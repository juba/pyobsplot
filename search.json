[
  {
    "objectID": "gallery_marks.html",
    "href": "gallery_marks.html",
    "title": "Marks",
    "section": "",
    "text": "Marks are the building blocks of Plot charts."
  },
  {
    "objectID": "gallery_marks.html#cell-mark",
    "href": "gallery_marks.html#cell-mark",
    "title": "Marks",
    "section": "Cell mark",
    "text": "Cell mark\nThe following chart, taken from the Cell Mark notebook, shows the rating of every episode of The Simpsons.\n\nimport polars as pl\nfrom pyobsplot import Plot, d3, Math, js\n\nsimpsons = pl.read_csv(\"data/simpsons.csv\")\n\nPlot.plot(\n    {\n        \"height\": 640,\n        \"padding\": 0.05,\n        \"grid\": True,\n        \"x\": {\"axis\": \"top\", \"label\": \"Season\"},\n        \"y\": {\"label\": \"Episode\"},\n        \"color\": {\"type\": \"linear\", \"scheme\": \"PiYG\"},\n        \"marks\": [\n            Plot.cell(\n                simpsons,\n                {\"x\": \"season\", \"y\": \"number_in_season\", \"fill\": \"imdb_rating\"},\n            ),\n            Plot.text(\n                simpsons,\n                {\n                    \"x\": \"season\",\n                    \"y\": \"number_in_season\",\n                    \"text\": \"imdb_rating\",\n                    \"title\": \"title\",\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "gallery_marks.html#faceting",
    "href": "gallery_marks.html#faceting",
    "title": "Marks",
    "section": "Faceting",
    "text": "Faceting\nFaceting allows to easily produce multiple plots by partitioning data. The following facet plot is taken from the Facets notebook.\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nPlot.plot(\n    {\n        \"height\": 600,\n        \"grid\": True,\n        \"facet\": {\"marginRight\": 80},\n        \"marks\": [\n            Plot.frame({\"facet\": False}),\n            Plot.dot(\n                penguins,\n                {\n                    \"x\": \"culmen_depth_mm\",\n                    \"y\": \"culmen_length_mm\",\n                    \"r\": 1.5,\n                    \"fill\": \"#ccc\",\n                    \"fx\": \"sex\",\n                    \"fy\": \"species\",\n                    \"facet\": \"exclude\",\n                },\n            ),\n            Plot.dot(\n                penguins,\n                {\n                    \"x\": \"culmen_depth_mm\",\n                    \"y\": \"culmen_length_mm\",\n                    \"fx\": \"sex\",\n                    \"fy\": \"species\",\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "gallery_marks.html#arrow-mark",
    "href": "gallery_marks.html#arrow-mark",
    "title": "Marks",
    "section": "Arrow mark",
    "text": "Arrow mark\nSome marks allow for nice representation of complex data. The following plot, taken from the Arrow mark notebook, shows the evolution of inequality and population in various U.S. cities.\n\nmetros = pl.read_csv(\"data/metros.csv\")\n\nPlot.plot(\n    {\n        \"height\": 600,\n        \"grid\": True,\n        \"inset\": 10,\n        \"x\": {\"type\": \"log\", \"label\": \"Population →\"},\n        \"y\": {\"label\": \"↑ Inequality\", \"ticks\": 4},\n        \"color\": {\n            \"type\": \"diverging\",\n            \"scheme\": \"burd\",\n            \"label\": \"Change in inequality from 1980 to 2015\",\n            \"legend\": True,\n            \"ticks\": 6,\n            \"tickFormat\": \"+f\",\n        },\n        \"marks\": [\n            Plot.arrow(\n                metros,\n                {\n                    \"x1\": \"POP_1980\",\n                    \"y1\": \"R90_10_1980\",\n                    \"x2\": \"POP_2015\",\n                    \"y2\": \"R90_10_2015\",\n                    \"bend\": True,\n                    \"stroke\": js(\"d =&gt; d.R90_10_2015 - d.R90_10_1980\"),\n                },\n            ),\n            Plot.text(\n                metros,\n                {\n                    \"x\": \"POP_2015\",\n                    \"y\": \"R90_10_2015\",\n                    \"filter\": \"highlight\",\n                    \"text\": \"nyt_display\",\n                    \"fill\": \"currentColor\",\n                    \"stroke\": \"white\",\n                    \"dy\": -6,\n                },\n            ),\n        ],\n    }\n)\n\n−3−2−1+0+1+2+3Change in inequality from 1980 to 201545678↑ Inequality200k300k1M2M3M10M20MPopulation →New YorkChicagoHoustonWashington, D.C.San FranciscoSan JoseFairfield, Conn.Binghamton, N.Y."
  },
  {
    "objectID": "gallery_marks.html#contour-mark",
    "href": "gallery_marks.html#contour-mark",
    "title": "Marks",
    "section": "Contour mark",
    "text": "Contour mark\nThe contour mark allows for nice representations of spatial data. The following example taken from the Contour mark notebook shows water vapor data from november 2022 (note that data processing and plot code are slightly modified to adapt to pyobsplot specificities).\n\nvapor = (\n    pl.read_csv(\"data/vapor.csv\", has_header=False, null_values=\"99999.0\")\n    .transpose()\n    .melt(variable_name=\"column\", value_name=\"values\")\n)\n\nPlot.plot(\n    {\n        \"width\": 850,\n        \"projection\": \"equal-earth\",\n        \"color\": {\n            \"scheme\": \"blues\",\n            \"legend\": True,\n            \"ticks\": 6,\n            \"nice\": True,\n            \"label\": \"Water vapor (cm)\",\n        },\n        \"marks\": [\n            Plot.contour(\n                vapor,\n                {\n                    \"fill\": \"values\",\n                    \"width\": 360,\n                    \"height\": 180,\n                    \"x1\": -180,\n                    \"y1\": 90,\n                    \"x2\": 180,\n                    \"y2\": -90,\n                    \"interval\": 0.25,\n                    \"blur\": 0.5,\n                    \"interpolate\": \"barycentric\",\n                    \"stroke\": \"currentColor\",\n                    \"strokeWidth\": 0.5,\n                    \"clip\": \"sphere\",\n                },\n            ),\n            Plot.sphere(),\n        ],\n    }\n)\n\n0123456Water vapor (cm)"
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Update Observable Plot to 0.6.7 (tooltips ! interactions !)\nUpdate apache-arrow to 12.0.0\nUpdate anywidget to 0.3.1"
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.5-dev",
    "href": "changelog.html#pyobsplot-0.3.5-dev",
    "title": "Changelog",
    "section": "",
    "text": "Update Observable Plot to 0.6.7 (tooltips ! interactions !)\nUpdate apache-arrow to 12.0.0\nUpdate anywidget to 0.3.1"
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.4",
    "href": "changelog.html#pyobsplot-0.3.4",
    "title": "Changelog",
    "section": "pyobsplot 0.3.4",
    "text": "pyobsplot 0.3.4\n\nAdd small padding around figure outputs for jsdom renderer to improve presentation over non-white backgrounds.\nUpdate Observable Plot to 0.6.6."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.3",
    "href": "changelog.html#pyobsplot-0.3.3",
    "title": "Changelog",
    "section": "pyobsplot 0.3.3",
    "text": "pyobsplot 0.3.3\n\njsdom renderer now uses a local http server instead of calling a script at each invocation, greatly improving rendering speed.\nAutocompletion of Plot methods should now be working in IDEs.\nEnsure that the needed version of the npm package is run if jsdom renderer is used.\nDebug mode also works with jsdom renderer.\nPlot generator objects now have correct __repr__ methods.\nUpdate anywidget to 0.2.3.\nFix: “Exception not rethrown” errors in pytest."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.2",
    "href": "changelog.html#pyobsplot-0.3.2",
    "title": "Changelog",
    "section": "pyobsplot 0.3.2",
    "text": "pyobsplot 0.3.2\n\nAdd ability to specify some default spec values to plot generator objects.\nrange objects are correctly serialized as lists for jsdom renderer.\nFix: don’t add styles to svg or html output if these styles are already present.\nFix: jsdom renderer not working on Windows."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.1",
    "href": "changelog.html#pyobsplot-0.3.1",
    "title": "Changelog",
    "section": "pyobsplot 0.3.1",
    "text": "pyobsplot 0.3.1\n\nIt is now possible to use Plot.plot() directly when creating a plot with default settings.Thanks to @fil for the idea.\nGeoJson data passed as string instead of dict is serialized correctly.\nAdd debug mode to output."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.3.0",
    "href": "changelog.html#pyobsplot-0.3.0",
    "title": "Changelog",
    "section": "pyobsplot 0.3.0",
    "text": "pyobsplot 0.3.0\n\nBreaking change: new API, plots are now generated with a plot generator object created by calling Obsplot(). Thanks to @fil for the idea.\nFix: wrong __version__ value."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.2.2",
    "href": "changelog.html#pyobsplot-0.2.2",
    "title": "Changelog",
    "section": "pyobsplot 0.2.2",
    "text": "pyobsplot 0.2.2\n\nFix: plot not recreated correctly on widget value change.\nFix: add watchfiles to dependencies to prevent error in Colab."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.2.1",
    "href": "changelog.html#pyobsplot-0.2.1",
    "title": "Changelog",
    "section": "pyobsplot 0.2.1",
    "text": "pyobsplot 0.2.1\n\nFix: mixing renderers in Jupyter lab moves all outputs to widgets.\nCompatibility with Python 3.8."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.2.0",
    "href": "changelog.html#pyobsplot-0.2.0",
    "title": "Changelog",
    "section": "pyobsplot 0.2.0",
    "text": "pyobsplot 0.2.0\n\nNew jsdom renderer which allows to generate plots as SVG or HTML instead of widgets.\nUpdate Observable Plot to 0.6.5."
  },
  {
    "objectID": "changelog.html#pyobsplot-0.1.3",
    "href": "changelog.html#pyobsplot-0.1.3",
    "title": "Changelog",
    "section": "pyobsplot 0.1.3",
    "text": "pyobsplot 0.1.3\n\nFirst released version."
  },
  {
    "objectID": "gallery_geo.html",
    "href": "gallery_geo.html",
    "title": "Mapping and spatial data",
    "section": "",
    "text": "The Geo mark allows to draw geographic features such as points, lines and polygons. These marks data are passed as GeoJSON.\nThis allows to create choropleth maps such as the following:\n\nfrom pyobsplot import Obsplot, Plot\nimport geopandas as gpd\nimport pandas as pd\n\n# Load US counties from TopoJson with geopandas\ncounties = gpd.read_file(\"data/us-counties-10m.json\", layer=\"counties\")\ncounties[\"id\"] = pd.to_numeric(counties[\"id\"])\n# Merge unemployment values\nunemployment = pd.read_csv(\"data/us-county-unemployment.csv\")\ncounties = pd.merge(counties, unemployment.loc[:, (\"id\", \"rate\")], on=\"id\", how=\"left\")\n\n# Convert geodataframe to GeoJson\ncounties = counties.to_json()\n\n# Map\nPlot.plot(\n    {\n        \"marks\": [Plot.geo(counties, {\"fill\": js(\"(d) =&gt; d.properties.rate\")})],\n        \"projection\": \"albers-usa\",\n        \"color\": {\n            \"type\": \"quantile\",\n            \"n\": 8,\n            \"scheme\": \"blues\",\n            \"label\": \"Unemployment (%)\",\n            \"legend\": True,\n        },\n    }\n)\n\n3.344.555.56.27.4Unemployment (%)\n\n\nOf course other marks can be used in conjunction with geo marks. This example represents the density of Walmarts supermarkets and is taken from the Mapping notebook.\n\n# Load US states from TopoJson with geopandas and convert to GeoJson\nstates = gpd.read_file(\"data/us-counties-10m.json\", layer=\"states\").to_json()\nnation = gpd.read_file(\"data/us-counties-10m.json\", layer=\"nation\").to_json()\n\nwalmarts = pd.read_csv(\"data/walmarts.tsv\", sep=\"\\t\")\n\nPlot.plot(\n    {\n        \"marks\": [\n            Plot.density(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"bandwidth\": 12, \"fill\": \"density\"},\n            ),\n            Plot.dot(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"r\": 1, \"fill\": \"currentColor\"},\n            ),\n            Plot.geo(states, {\"strokeOpacity\": 0.3}),\n            Plot.geo(nation),\n        ],\n        \"projection\": \"albers\",\n        \"color\": {\"scheme\": \"blues\"},\n    }\n)"
  },
  {
    "objectID": "gallery_geo.html#geo-mark",
    "href": "gallery_geo.html#geo-mark",
    "title": "Mapping and spatial data",
    "section": "",
    "text": "The Geo mark allows to draw geographic features such as points, lines and polygons. These marks data are passed as GeoJSON.\nThis allows to create choropleth maps such as the following:\n\nfrom pyobsplot import Obsplot, Plot\nimport geopandas as gpd\nimport pandas as pd\n\n# Load US counties from TopoJson with geopandas\ncounties = gpd.read_file(\"data/us-counties-10m.json\", layer=\"counties\")\ncounties[\"id\"] = pd.to_numeric(counties[\"id\"])\n# Merge unemployment values\nunemployment = pd.read_csv(\"data/us-county-unemployment.csv\")\ncounties = pd.merge(counties, unemployment.loc[:, (\"id\", \"rate\")], on=\"id\", how=\"left\")\n\n# Convert geodataframe to GeoJson\ncounties = counties.to_json()\n\n# Map\nPlot.plot(\n    {\n        \"marks\": [Plot.geo(counties, {\"fill\": js(\"(d) =&gt; d.properties.rate\")})],\n        \"projection\": \"albers-usa\",\n        \"color\": {\n            \"type\": \"quantile\",\n            \"n\": 8,\n            \"scheme\": \"blues\",\n            \"label\": \"Unemployment (%)\",\n            \"legend\": True,\n        },\n    }\n)\n\n3.344.555.56.27.4Unemployment (%)\n\n\nOf course other marks can be used in conjunction with geo marks. This example represents the density of Walmarts supermarkets and is taken from the Mapping notebook.\n\n# Load US states from TopoJson with geopandas and convert to GeoJson\nstates = gpd.read_file(\"data/us-counties-10m.json\", layer=\"states\").to_json()\nnation = gpd.read_file(\"data/us-counties-10m.json\", layer=\"nation\").to_json()\n\nwalmarts = pd.read_csv(\"data/walmarts.tsv\", sep=\"\\t\")\n\nPlot.plot(\n    {\n        \"marks\": [\n            Plot.density(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"bandwidth\": 12, \"fill\": \"density\"},\n            ),\n            Plot.dot(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"r\": 1, \"fill\": \"currentColor\"},\n            ),\n            Plot.geo(states, {\"strokeOpacity\": 0.3}),\n            Plot.geo(nation),\n        ],\n        \"projection\": \"albers\",\n        \"color\": {\"scheme\": \"blues\"},\n    }\n)"
  },
  {
    "objectID": "gallery_geo.html#raster-mark",
    "href": "gallery_geo.html#raster-mark",
    "title": "Mapping and spatial data",
    "section": "Raster mark",
    "text": "Raster mark\nThe Raster mark creates an image from spatial data.\nPlot allows to do different type of spatial interpolations, such as nearest, which draws voronoi cells around values:\n\nimport polars as pl\n\nca55 = pl.read_csv(\"data/ca55-south.csv\")\n\n\ndef flare_map(interpolation):\n    return Plot.plot(\n        {\n            \"x\": {\"axis\": None},\n            \"y\": {\"axis\": None},\n            \"inset\": 10,\n            \"marginBottom\": 2,\n            \"height\": 500,\n            \"color\": {\"type\": \"diverging\"},\n            \"marks\": [\n                Plot.raster(\n                    ca55,\n                    {\n                        \"x\": \"LONGITUDE\",\n                        \"y\": \"LATITUDE\",\n                        \"fill\": \"MAG_IGRF90\",\n                        \"interpolate\": interpolation,\n                    },\n                ),\n                Plot.frame(),\n            ],\n        }\n    )\n\n\nflare_map(\"nearest\")\n\n\n\n\nOr the more recent random walk interpolation:\n\nflare_map(\"random-walk\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyobsplot",
    "section": "",
    "text": "pyobsplot allows to use Observable Plot to create charts in Jupyter notebooks, VSCode notebooks, Google Colab and Quarto documents. Plots are created from Python code with a syntax as close as possible to the JavaScript one.\n\nimport polars as pl\nfrom pyobsplot import Plot\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nPlot.plot(\n    {\n        \"grid\": True,\n        \"marks\": [\n            Plot.dot(\n                penguins, {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"sex\"}\n            )\n        ],\n    }\n)\n\n\n\n\nOr, for a bit more complex example:\n\nPlot.plot(\n    {\n        \"marginLeft\": 75,\n        \"marginRight\": 70,\n        \"x\": {\"insetRight\": 10},\n        \"y\": {\"grid\": True},\n        \"facet\": {\"marginRight\": 70},\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.barX(\n                penguins,\n                Plot.groupY(\n                    {\"x\": \"count\"}, {\"fy\": \"island\", \"y\": \"species\", \"fill\": \"sex\"}\n                ),\n            ),\n            Plot.text(\n                [\"The Adelie species is the only one on Torgersen Island.\"],\n                {\n                    \"fy\": [\"Torgersen\"],\n                    \"frameAnchor\": \"right\",\n                    \"lineWidth\": 16,\n                    \"dx\": -4,\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "pyobsplot",
    "section": "",
    "text": "pyobsplot allows to use Observable Plot to create charts in Jupyter notebooks, VSCode notebooks, Google Colab and Quarto documents. Plots are created from Python code with a syntax as close as possible to the JavaScript one.\n\nimport polars as pl\nfrom pyobsplot import Plot\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nPlot.plot(\n    {\n        \"grid\": True,\n        \"marks\": [\n            Plot.dot(\n                penguins, {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"sex\"}\n            )\n        ],\n    }\n)\n\n\n\n\nOr, for a bit more complex example:\n\nPlot.plot(\n    {\n        \"marginLeft\": 75,\n        \"marginRight\": 70,\n        \"x\": {\"insetRight\": 10},\n        \"y\": {\"grid\": True},\n        \"facet\": {\"marginRight\": 70},\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.barX(\n                penguins,\n                Plot.groupY(\n                    {\"x\": \"count\"}, {\"fy\": \"island\", \"y\": \"species\", \"fill\": \"sex\"}\n                ),\n            ),\n            Plot.text(\n                [\"The Adelie species is the only one on Torgersen Island.\"],\n                {\n                    \"fy\": [\"Torgersen\"],\n                    \"frameAnchor\": \"right\",\n                    \"lineWidth\": 16,\n                    \"dx\": -4,\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "index.html#installation-and-usage",
    "href": "index.html#installation-and-usage",
    "title": "pyobsplot",
    "section": "Installation and usage",
    "text": "Installation and usage\n\n\n\n\n\n\nWarning\n\n\n\nThis project is at an early stage.\n\n\nGetting started gives installation instructions and a quick usage overview.\nUsage gives more detailed usage instructions.\nIf you just want to try this package without installing it on your computer, you can open an introduction notebook in Google Colab:"
  },
  {
    "objectID": "index.html#features-and-limitations",
    "href": "index.html#features-and-limitations",
    "title": "pyobsplot",
    "section": "Features and limitations",
    "text": "Features and limitations\nFeatures:\n\nSyntax as close as possible to the JavaScript one\nTwo renderers available: widget, which generates plots as Jupyter widgets, and jsdom, which generates SVG or HTML outputs\nPandas and polars DataFrame and Series objects are serialized using Arrow IPC format for improved speed and better data type conversions\nWorks offline, no iframe or dependency to Observable runtime\nCaching mechanism of data objects if they are used several times in the same plot\nCustom JavaScript code can be passed as strings with the js method\nPython date and datetime objects are automatically converted to JavaScript Date objects\nPlots can be defined with a dictionary, a call to a Plot mark function, or with kwargs. See alternative syntaxes.\nWorks with Jupyter notebooks and Quarto HTML documents. Plots without legends are also supported in PDF and docx outputs with the jsdom renderer.\n\nLimitations:\n\nPlots with legends don’t work in Quarto in formats other than HTML."
  },
  {
    "objectID": "index.html#credits",
    "href": "index.html#credits",
    "title": "pyobsplot",
    "section": "Credits",
    "text": "Credits\n\nObservable Plot, developed by Mike Bostock and Philippe Rivière among others.\nThe widget is developed thanks to the anywidget framework.\nSome code from the jsdom renderer has been adapted from altair_saver.\nThis documentation website is generated by Quarto."
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "pyobsplot can be installed with pip:\npip install pyobsplot\nIf you want to use the jsdom renderer, you must have a working installation of node.js and you must install pyobsplot npm package globally or locally:\n# Install locally\nnpm install pyobsplot\n# Install globally\nnpm install -g pyobsplot"
  },
  {
    "objectID": "getting_started.html#installation",
    "href": "getting_started.html#installation",
    "title": "Getting started",
    "section": "",
    "text": "pyobsplot can be installed with pip:\npip install pyobsplot\nIf you want to use the jsdom renderer, you must have a working installation of node.js and you must install pyobsplot npm package globally or locally:\n# Install locally\nnpm install pyobsplot\n# Install globally\nnpm install -g pyobsplot"
  },
  {
    "objectID": "getting_started.html#usage",
    "href": "getting_started.html#usage",
    "title": "Getting started",
    "section": "Usage",
    "text": "Usage\nTo use pyobsplot, you must import at least its Plot class with:\n\nfrom pyobsplot import Plot\n\nTo create a plot, call the Plot.plot method with a plot specification. The simplest specification form is a Python dictionary with a syntax nearly identical as the JavaScript one.\nSo, starting with a very simple DataFrame:\n\nimport polars as pl\n\ndata = pl.DataFrame(\n    {\n        \"x\": [1, 5, 2, 4, 6, 2, 4],\n        \"y\": [2, 1, 3, 4, 5, 1, 2],\n        \"type\": [\"T1\", \"T2\", \"T1\", \"T2\", \"T1\", \"T1\", \"T2\"],\n    }\n)\n\nIf your JavaScript plot function looks like this:\nPlot.plot(\n    {\n        grid: true,\n        marks: [Plot.dot(data, {x: \"x\", y: \"y\", fill: \"type\", r: 5})]\n    }\n)\nThen you can reproduce the plot with:\n\nPlot.plot(\n    {\n        \"grid\": True,\n        \"marks\": [Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\", \"r\": 5})],\n    }\n)\n\n\n\n\nThe syntax here is almost identical, except that dictionary keys must be quoted, and JavaScript true must be replaced by Python True.\nYou can use pandas and polars DataFrames as data sources, they are automatically serialized and passed to JavaScript via Arrow IPC format:\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nPlot.plot(\n    {\n        \"grid\": True,\n        \"color\": {\"legend\": True},\n        \"marks\": [\n            Plot.dot(\n                penguins,\n                {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"island\"},\n            )\n        ],\n    }\n)\n\nBiscoeDreamTorgersen3,0003,5004,0004,5005,0005,5006,000↑ body_mass_g180190200210220230flipper_length_mm →"
  },
  {
    "objectID": "getting_started.html#plot-generator-object",
    "href": "getting_started.html#plot-generator-object",
    "title": "Getting started",
    "section": "Plot generator object",
    "text": "Plot generator object\nCalling Plot.plot() is the fastest way to generate a plot with the default settings, but for further customization you can import the Obsplot class and create a plot generator object:\n\nfrom pyobsplot import Obsplot, Plot\n\nop = Obsplot()\n\nYou can then create plots by calling this generator object with your plot specification:\n\nop(\n    {\n        \"grid\": True,\n        \"marks\": [Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\", \"r\": 5})],\n    }\n)\n\nFor the simplest cases, you can also create your plot directly by passing a Plot mark method:\n\nop(Plot.auto(penguins, {\"x\": \"flipper_length_mm\"}))"
  },
  {
    "objectID": "getting_started.html#jsdom-renderer",
    "href": "getting_started.html#jsdom-renderer",
    "title": "Getting started",
    "section": "jsdom renderer",
    "text": "jsdom renderer\nBy default, plots will be created as Jupyter widgets. This allows for (very basic) interactivity, but also generates bigger files. An alternative is to use the jsdom renderer, which generates SVG or HTML outputs.\nThe renderer is configured by passing a renderer argument to Obsplot() when creating a generator object:\n\n# Switch to widget renderer (default one)\nopw = Obsplot(renderer=\"widget\")\n# Switch to jsdom renderer\nopj = Obsplot(renderer=\"jsdom\")"
  },
  {
    "objectID": "getting_started.html#learn-more",
    "href": "getting_started.html#learn-more",
    "title": "Getting started",
    "section": "Learn more",
    "text": "Learn more\nTo go further, see the usage page."
  },
  {
    "objectID": "development.html",
    "href": "development.html",
    "title": "Development",
    "section": "",
    "text": "“Debug mode” outputs the computed JavaScript plot structure (the one passed to Plot.plot).\nTo activate it, add debug=True when creating your plot generator object:\n\nop = Obsplot(render=\"widget\", debug=True)\n\nIf using the widget renderer, debug output will be displayed in JavaScript console. With the jsdom renderer, it will be displayed directly in the notebook."
  },
  {
    "objectID": "development.html#debug-mode",
    "href": "development.html#debug-mode",
    "title": "Development",
    "section": "",
    "text": "“Debug mode” outputs the computed JavaScript plot structure (the one passed to Plot.plot).\nTo activate it, add debug=True when creating your plot generator object:\n\nop = Obsplot(render=\"widget\", debug=True)\n\nIf using the widget renderer, debug output will be displayed in JavaScript console. With the jsdom renderer, it will be displayed directly in the notebook."
  },
  {
    "objectID": "development.html#install-from-git",
    "href": "development.html#install-from-git",
    "title": "Development",
    "section": "Install from git",
    "text": "Install from git\nTo install pyobsplot from git:\npip install git+https://github.com/juba/pyobsplot.git\nTo install pyobsplot npm package from git:\nnpm install 'https://gitpkg.now.sh/juba/pyobsplot/js/pyobsplot-js?main'"
  },
  {
    "objectID": "development.html#install-fom-source",
    "href": "development.html#install-fom-source",
    "title": "Development",
    "section": "Install fom source",
    "text": "Install fom source\nIf you want to build pyobsplot from source, you’ll have to follow these steps:\n\nInstall node.js\nInstall poetry dependency management system\nClone the repository\nInstall Python dependencies with : poetry install\nInstall main JavaScript dependencies with : npm install\nInstall pyobsplot-js dependencies with : cd js/pyobsplot-js && npm install\n\npyobsplot widget renderer uses the anywidget Jupyter widget framework. Python source code is in src/pyobsplot/widget.py. JavaScript and CSS source code is in js/widget.\npyobsplot jsdom renderer is provided by an npm package. Source code is in js/pyobsplot-js. Python source code is in src/pyobsplot/jsdom.py."
  },
  {
    "objectID": "development.html#widget-javascript-modification-and-bundling",
    "href": "development.html#widget-javascript-modification-and-bundling",
    "title": "Development",
    "section": "Widget JavaScript modification and bundling",
    "text": "Widget JavaScript modification and bundling\nEach time widget JavaScript or CSS code is modified in the js/widget directory, it must be bundled with one of the following scripts:\n# Bundle only once\nnpm run bundle\n# Bundle and watch for code change\nnpm run watch\nThe result is put into src/pyobsplot/static."
  },
  {
    "objectID": "development.html#tests",
    "href": "development.html#tests",
    "title": "Development",
    "section": "Tests",
    "text": "Tests\npyobsplot comes with three types of tests : Python test, JavaScript tests and Visual regression tests.\nTo run Python tests, use:\nnpm run pytest\nTo run JavaScript tests, use one of those:\n# From project root\nnpm run jstest\n# Equivalent to\ncd js/pyobsplot-js && npm run test\nVisual regression tests allow to test if generated plots stay the same. They use the galata framework. To run them you first have to start a specific Jupyter instance with:\nnpm run uistart\nIf you use visual regression tests for the first time, you have to generate reference images with:\n# Create / update reference images\nnpm run uitest:update\nAfter that, you can test that currently generated images are the same as the reference one with:\n# Compare with reference images\nnpm run uitest"
  },
  {
    "objectID": "development.html#maintenance-notes",
    "href": "development.html#maintenance-notes",
    "title": "Development",
    "section": "Maintenance notes",
    "text": "Maintenance notes\n\nReleases\n\nCheck that the min_npm_version value in .utils is correct\nRelease the Python package with poetry build and poetry publish\nIf necessary release the npm package with npm publish in its directory\n\n\n\nNew Plot versions\nWhen a new Plot version is released:\n\nupdate with npm install @observablehq/plot and npm install d3 for both pyobsplot and pyobsplot-js\nrun utils/get_plot_methods.js and update utils.py"
  },
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Usage",
    "section": "",
    "text": "For a quick usage introduction, see getting started.\nTo create a plot we can either use Plot.plot() to generate plots with the default settings, or create a plot generator object to be able to customize things further. This is the way we will use here.\nSo we start by importing the needed classes and create a plot generator object:\nfrom pyobsplot import Obsplot, Plot\n\nop = Obsplot()"
  },
  {
    "objectID": "usage.html#from-javascript-to-python",
    "href": "usage.html#from-javascript-to-python",
    "title": "Usage",
    "section": "From JavaScript to Python",
    "text": "From JavaScript to Python\nConverting a plot specification from JavaScript to Python should be straightforward most of the time:\n\nall dictionary keys must be quoted (so x: becomes \"x\":)\nJavaScript true and false must be replaced by True and False\nJavaScript null must be replaced by None\n\nSo the following JavaScript code:\nPlot.plot(\n    {\n        color: {legend: true},\n        grid: false,\n        marks: [Plot.dot(data, {x: \"x\", y: \"y\", fill: \"type\", r: 5})]\n    }\n)\nBecomes:\n\nop({\n    \"color\": {\"legend\": True},\n    \"grid\": False,\n    \"marks\": [Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\", \"r\": 5})],\n})\n\nIt is possible to replace JavaScript methods from the Plot, d3 and Math modules with Python methods, but you must first import the corresponding classes.\n\nfrom pyobsplot import Obsplot, Plot, d3\n\nop({\n    \"x\": {\n        \"axis\": None\n    },\n    \"marks\": [\n        Plot.ruleY([0], {\"stroke\": \"steelblue\"}),\n        Plot.lineY(d3.cumsum({ \"length\": 100 }, d3.randomNormal()))\n    ]\n})\n\n\n\n\nIf your specification includes JavaScript code (such as anonymous functions), you can pass it as a string by using the js method (after importing it):\n\nfrom pyobsplot import Obsplot, Plot, d3, js\nimport polars as pl\n\ndata = pl.DataFrame({\n    \"x\": [1, 5, 2, 4, 6, 2, 4],\n    \"y\": [2, 1, 3, 4, 5, 1, 2],\n    \"type\": [\"T1\", \"T2\", \"T1\", \"T2\", \"T1\", \"T1\", \"T2\"],\n})\n\nop({\n    \"grid\": True,\n    \"marks\": [\n        Plot.dot(data, {\n            \"x\": \"x\", \"y\": \"y\", \"r\": 5,\n            \"stroke\": \"black\", \"fill\": \"steelblue\",\n            \"fillOpacity\": js(\"d =&gt; d.type == 'T1' ? 0.7 : 0.1\")\n        })\n    ]\n})"
  },
  {
    "objectID": "usage.html#renderers",
    "href": "usage.html#renderers",
    "title": "Usage",
    "section": "Renderers",
    "text": "Renderers\npyobsplot provides two renderers : widget and jsdom. The widget renderer outputs plots as Jupyter widgets. The jsdom renderer uses an external npm package to generate plots as either SVG or HTML.\nThe following table lists the differences between the two renderers.\n\n\n\n\n\n\n\n\nwidget\n\n\njsdom\n\n\n\n\n\n\nOutput\n\n\nJupyter Widget\n\n\nSVG (plots without legend)HTML (plots with legend)\n\n\n\n\nAdditionalinstallation\n\n\nNone\n\n\nNeeds a working node.js installation and an additional npm package\n\n\n\n\nQuarto\n\n\nSupported only in HTML format\n\n\nSupported in HTML format, SVG output supported in other formats\n\n\n\n\nOutput size\n\n\nBig : includes the data and code needed to generate the plot\n\n\nModerate : size of the SVG or HTML output\n\n\n\n\nJupyterinteractivity\n\n\nBasic\n\n\nNone\n\n\n\n\nPersistencebetween sessions\n\n\nWidget state is not saved between session in VSCode\n\n\nOutput is saved between sessions\n\n\n\n\n\nTo use the jsdom renderer, you need a working node.js installation and you must install the npm pyobsplot package globally or locally:\n# Install locally\nnpm install pyobsplot\n# Install globally\nnpm install -g pyobsplot\nAfter that, you can select which renderer to use when creating a plot generator object:\n\n# Switch to widget renderer (the default one)\nopw = Obsplot(renderer=\"widget\")\n# Switch to jsdom renderer\nopj = Obsplot(renderer=\"jsdom\")"
  },
  {
    "objectID": "usage.html#alternative-syntaxes",
    "href": "usage.html#alternative-syntaxes",
    "title": "Usage",
    "section": "Alternative syntaxes",
    "text": "Alternative syntaxes\nAs we’ve already seen, the most common syntax for a plot specification is to pass it as a dictionary :\n\nop({\n    \"grid\": True,\n    \"color\": {\"legend\": True}\n    \"marks\": [\n        Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\"})\n    ],\n})\n\nBut it is also possible to pass top level arguments as kwargs to the generator object, which would give the following:\n\nop(\n    grid = True,\n    color = {\"legend\": True},\n    marks = [\n        Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\"})\n    ],\n)\n\nFinally, for the simplest cases, you can also pass a mark method directly. The JavaScript plot() method will be called automatically to display the plot:\n\nimport random\nop(\n    Plot.tickX(\n        [random.gauss(0,1) for i in range(1000)], \n        {\"stroke\": \"steelblue\", \"opacity\": 0.2}\n    )\n)"
  },
  {
    "objectID": "usage.html#default-specification-values",
    "href": "usage.html#default-specification-values",
    "title": "Usage",
    "section": "Default specification values",
    "text": "Default specification values\nWhen creating a plot generator objects, it is possible to specify default specification values that will be applied to every plot created with this generator.\nOnly the top-level layout options can be specified as defaults. This can be useful to specify a default width, colors, margins or even style.\nThe complete list of available default attributes is :\n\n\n['marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'margin', 'width', 'height', 'aspectRatio', 'style']\n\n\nSo to create a plot generator object that creates by default 400px wide plots with a 50px margin and white on blue colors, you could use :\n\nop_colors = Obsplot(default={\n    \"width\": 400, \n    \"margin\": 50,\n    \"style\": {\"color\": \"white\", \"background-color\": \"#004\"}\n})\n\n\nop_colors(\n    Plot.dot(data, {\"x\": \"x\", \"y\": \"y\"})\n)"
  },
  {
    "objectID": "usage.html#dataframes-and-series",
    "href": "usage.html#dataframes-and-series",
    "title": "Usage",
    "section": "DataFrames and Series",
    "text": "DataFrames and Series\nPandas and polars DataFrames can be passed directly in a plot specification. They will be converted to JavaScript objects via Arrow IPC serialization, to ensure speed and data types conversion.\n\nimport polars as pl\nfrom datetime import date\n\ndf = pl.DataFrame({\n    \"Date\": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3), date(2023, 1, 4)],\n    \"Value\": [4.2, 3.8, 4.5, 4.7]\n})\n\nop({\n    \"x\": {\"grid\": True},\n    \"y\": {\"domain\": [0, 5]},\n    \"marks\": [Plot.lineY(df, {\"x\": \"Date\", \"y\": \"Value\", \"stroke\": \"steelblue\"})]\n})\n\n\n\n\nIf you pass a pandas or polars Series object, it will be automatically converted to a DataFrame with one column:\n\nvalue = df.get_column(\"Value\")\n\nop(\n    Plot.tickX(value, {\"x\": \"Value\", \"stroke\": \"darkviolet\"})\n)\n\n\n\n\npyobsplot implements a simple caching mechanism for some data objects (it currently works for DataFrames and for GeoJson data). Sometimes the same data object is used several times in a plot specification:\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nop({\n  \"height\": 600,\n  \"grid\": True,\n  \"facet\": {\n    \"marginRight\": 80\n  },\n  \"marks\": [\n    Plot.frame({\"facet\": False}),\n    Plot.dot(penguins, {\n      \"x\": \"culmen_depth_mm\",\n      \"y\": \"culmen_length_mm\",\n      \"r\": 1.5,\n      \"fill\": \"#ccc\",\n      \"facet\": \"exclude\",\n      \"fx\": \"sex\",\n      \"fy\": \"species\",\n    }),\n    Plot.dot(penguins, {\n       \"x\": \"culmen_depth_mm\",\n       \"y\": \"culmen_length_mm\",\n       \"fx\": \"sex\",\n       \"fy\": \"species\",\n    })\n  ]\n})\n\n\n\n\nIn this case, caching ensures that the penguins DataFrame is only serialized and transmitted once instead of twice."
  },
  {
    "objectID": "usage.html#datetime-objects",
    "href": "usage.html#datetime-objects",
    "title": "Usage",
    "section": "datetime objects",
    "text": "datetime objects\ndatetime.date and datetime.datetime Python objects are automatically serialized and converted to JavaScript Date objects.\nThat makes the following two specifications equivalent:\n\nop({\n    \"x\": {\"domain\": [js(\"new Date('2021-01-01')\"), js(\"new Date('2022-01-01')\")]}, \n    \"grid\": True\n})\n\n\n\n\n\nfrom datetime import date\nop({\n    \"x\": {\"domain\": [date(2021,1,1), date(2022,1,1)]}, \n    \"grid\": True\n})\n\n\n\n\nAs well as the two following ones, using datetime:\n\nop({\n    \"x\": {\"domain\": [js(\"new Date('2021-01-01T07:00:00')\"), js(\"new Date('2021-01-01T08:00:00')\")]}, \n    \"grid\": True\n})\n\n\n\n\n\nfrom datetime import datetime\nop({\n    \"x\": {\"domain\": [datetime(2021,1,1,7,0,0), datetime(2021,1,1,8,0,0)]}, \n    \"grid\": True\n})"
  },
  {
    "objectID": "usage.html#quarto",
    "href": "usage.html#quarto",
    "title": "Usage",
    "section": "Quarto",
    "text": "Quarto\npyobsplot plots are compatible with quarto HTML formats. If you use the jsdom renderer, plots without legends are generated as SVG files and are also compatible with other formats such as PDF or docx.\nIf your source document is a jupyter notebook (and not a .qmd file), then you have to use the --execute argument to force plot computation and to make them visible in the output:\nquarto render test.ipynb --execute --to html"
  },
  {
    "objectID": "usage.html#interactivity",
    "href": "usage.html#interactivity",
    "title": "Usage",
    "section": "Interactivity",
    "text": "Interactivity\nWhen using the widget renderer, the fact that plots are generated as Jupyter widgets allow for basic interactivity. More specifically, you can set the spec attribute of an existing Obsplot to another plot specification and it will update it.\nThis allows to do things like the following, where a plot is updated depending on the value of a Jupyter IntSlider widget:\n\ndef generate_plot_spec(opacity):\n    return {\n      \"grid\": True,\n      \"marks\": [\n            Plot.rectY(penguins, Plot.binX({\"y\": \"count\"}, {\"x\": \"body_mass_g\", \"fill\": \"steelblue\", \"fillOpacity\": opacity})),\n            Plot.ruleY([0])\n        ]\n    }\n\nplot = op(generate_plot_spec(1))\n\ndef update_plot(change):\n    new = change['new']\n    plot.spec = generate_plot_spec(new / 100)\n\n\nw = IntSlider(value = 100, min = 0, max = 100)\nw.observe(update_plot, names='value')\n\ndisplay(w)\ndisplay(plot)\n\nYou can see a live version of this example in the following Colab notebook:"
  },
  {
    "objectID": "gallery_transforms.html",
    "href": "gallery_transforms.html",
    "title": "Transforms",
    "section": "",
    "text": "Transforms provide methods to manipulate and compute on data while plotting them."
  },
  {
    "objectID": "gallery_transforms.html#group-transform",
    "href": "gallery_transforms.html#group-transform",
    "title": "Transforms",
    "section": "Group transform",
    "text": "Group transform\nGroup transform allows to compute summary values before plotting them. It is often used to make bar charts.\n\nimport polars as pl\nfrom pyobsplot import Plot, d3, Math, js\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nPlot.plot(\n    {\n        \"y\": {\"grid\": True, \"percent\": True},\n        \"marks\": [\n            Plot.barY(\n                penguins,\n                Plot.groupZ(\n                    {\"y\": \"proportion-facet\"}, {\"fill\": \"sex\", \"fx\": \"species\"}\n                ),\n            ),\n            Plot.ruleY([0, 1]),\n        ],\n    }\n)"
  },
  {
    "objectID": "gallery_transforms.html#dodge-transform",
    "href": "gallery_transforms.html#dodge-transform",
    "title": "Transforms",
    "section": "Dodge transform",
    "text": "Dodge transform\nThe Dodge transform allows to pack marks without overlapping. The following chart shows data about IPO offerings in the US.\n\nfrom datetime import datetime\n\nipos = pl.read_csv(\"data/ipos.csv\", try_parse_dates=True).filter(\n    pl.col(\"date\") &gt; datetime(1991, 1, 1)\n)\n\n\nPlot.plot(\n    {\n        \"insetRight\": 10,\n        \"height\": 600,\n        \"width\": 600,\n        \"marks\": [\n            Plot.dot(\n                ipos, Plot.dodgeY({\"x\": \"date\", \"r\": \"rMVOP\", \"fill\": \"currentColor\"})\n            ),\n            Plot.text(\n                ipos,\n                Plot.dodgeY(\n                    {\n                        \"filter\": js(\"(d) =&gt; d.rMVOP &gt; 5e3\"),\n                        \"x\": \"date\",\n                        \"r\": \"rMVOP\",\n                        \"text\": js(\"d =&gt; (d.rMVOP / 1e3).toFixed()\"),\n                        \"fill\": \"white\",\n                        \"fontWeight\": \"bold\",\n                    }\n                ),\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "gallery_transforms.html#hexbin-transform",
    "href": "gallery_transforms.html#hexbin-transform",
    "title": "Transforms",
    "section": "Hexbin transform",
    "text": "Hexbin transform\nThe Hexbin transform aggregates two dimensional points into hexagonal bins.\n\nPlot.plot(\n    {\n        \"inset\": 10,\n        \"color\": {\"scheme\": \"ylgnbu\", \"legend\": True, \"label\": \"Count\"},\n        \"marks\": [\n            Plot.hexagon(\n                penguins,\n                Plot.hexbin(\n                    {\"r\": \"count\", \"fill\": \"count\"},\n                    {\n                        \"x\": \"culmen_length_mm\",\n                        \"y\": \"flipper_length_mm\",\n                        \"binWidth\": 50,\n                    },\n                ),\n            ),\n            Plot.text(\n                penguins,\n                Plot.hexbin(\n                    {\"text\": \"count\"},\n                    {\n                        \"x\": \"culmen_length_mm\",\n                        \"y\": \"flipper_length_mm\",\n                        \"fill\": \"black\",\n                        \"stroke\": \"white\",\n                        \"binWidth\": 50,\n                    },\n                ),\n            ),\n        ],\n    }\n)\n\n1020Count175180185190195200205210215220225230↑ flipper_length_mm3540455055culmen_length_mm →142611209111275101039322657181533115143211641752810189221734221"
  },
  {
    "objectID": "gallery_transforms.html#map-transform",
    "href": "gallery_transforms.html#map-transform",
    "title": "Transforms",
    "section": "Map transform",
    "text": "Map transform\nMap transform family can be used to normalize values.\n\nstocks = pl.read_csv(\"data/stocks.csv\", try_parse_dates=True)\n\nPlot.plot(\n    {\n        \"marginRight\": 40,\n        \"y\": {\n            \"type\": \"log\",\n            \"grid\": True,\n            \"label\": \"↑ Change in price (%)\",\n            \"tickFormat\": js('(f =&gt; x =&gt; f((x - 1) * 100))(d3.format(\"+d\"))'),\n        },\n        \"marks\": [\n            Plot.ruleY([1]),\n            Plot.line(\n                stocks, Plot.normalizeY({\"x\": \"Date\", \"y\": \"Close\", \"stroke\": \"Symbol\"})\n            ),\n            Plot.text(\n                stocks,\n                Plot.selectLast(\n                    Plot.normalizeY(\n                        {\n                            \"x\": \"Date\",\n                            \"y\": \"Close\",\n                            \"z\": \"Symbol\",\n                            \"text\": \"Symbol\",\n                            \"textAnchor\": \"start\",\n                            \"dx\": 3,\n                        }\n                    )\n                ),\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "gallery_transforms.html#transforms-composition",
    "href": "gallery_transforms.html#transforms-composition",
    "title": "Transforms",
    "section": "Transforms composition",
    "text": "Transforms composition\nSeveral group and map transforms can be applied and composed to create complex representations, such as this distribution of group ages by US states adapted from the Map transform notebook.\n\n# Load and prepare data\nstateage = (\n    pl.read_csv(\"data/us-population-state-age.csv\")\n    .melt(id_vars=\"name\", variable_name=\"age\", value_name=\"population\")\n    .rename({\"name\": \"state\"})\n)\n# Compute list of age groups\nages = stateage.get_column(\"age\").unique(maintain_order=True).to_list()\n# Compute list of states sorted by the proportion of age ≥80\nstates = (\n    stateage.with_columns(\n        (pl.col(\"population\") / pl.col(\"population\").sum().over(\"state\")).alias(\n            \"percent\"\n        )\n    )\n    .filter(pl.col(\"age\") == \"≥80\")\n    .sort(pl.col(\"percent\"), descending=True)\n    .get_column(\"state\")\n    .to_list()\n)\n\n# Plot.normalizeX default arguments\nxy = {\"basis\": \"sum\", \"z\": \"state\", \"x\": \"population\", \"y\": \"state\"}\n\n# Plot specification\nPlot.plot(\n    {\n        \"height\": 660,\n        \"grid\": True,\n        \"x\": {\"axis\": \"top\", \"label\": \"Percent (%) →\", \"transform\": js(\"d =&gt; d * 100\")},\n        \"y\": {\n            \"domain\": states,\n            \"axis\": None,\n        },\n        \"color\": {\n            \"scheme\": \"spectral\",\n            \"domain\": ages,\n            \"legend\": True,\n        },\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.ruleY(\n                stateage,\n                Plot.groupY({\"x1\": \"min\", \"x2\": \"max\"}, Plot.normalizeX(xy)),\n            ),\n            Plot.dot(\n                stateage,\n                Plot.normalizeX({**xy, \"fill\": \"age\"}),\n            ),\n            Plot.text(\n                stateage,\n                Plot.selectMinX(\n                    Plot.normalizeX(\n                        {\n                            **xy,\n                            \"textAnchor\": \"end\",\n                            \"dx\": -6,\n                            \"text\": \"state\",\n                        }\n                    )\n                ),\n            ),\n        ],\n    }\n)\n\n&lt;1010-1920-2930-3940-4950-5960-6970-79≥8002468101214161820Percent (%) →ALAKAZARCACOCTDEDCFLGAHIIDILINIAKSKYLAMEMDMAMIMNMSMOMTNENVNHNJNMNYNCNDOHOKORPARISCSDTNTXUTVTVAWAWVWIWYPR"
  }
]