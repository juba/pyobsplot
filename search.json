[
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Usage",
    "section": "",
    "text": "For a quick usage introduction, see getting started."
  },
  {
    "objectID": "usage.html#from-javascript-to-python",
    "href": "usage.html#from-javascript-to-python",
    "title": "Usage",
    "section": "From JavaScript to Python",
    "text": "From JavaScript to Python\nConverting a plot specification from JavaScript to Python should be straightforward most of the time:\n\nall dictionary keys must be quoted (so x: becomes \"x\":)\nJavaScript true and false must be replaced by True and False\nJavaScript null must be replaced by None\n\nSo for example, the following JavaScript code:\nPlot(\n    {\n        color: {legend: true}\n        grid: false,\n        marks: [Plot.dot(data, {x: \"x\", y: \"y\", fill: \"type\", r: 5})]\n    }\n)\nBecomes:\n\nObsplot(\n    {\n        \"color\": {\"legend\": True}\n        \"grid\": False,\n        \"marks\": [Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\", \"r\": 5})],\n    }\n)\n\nIt is possible to replace JavaScript methods from the Plot, d3 and Math modules with Python methods, but you must first import the corresponding classes.\n\nfrom pyobsplot import Obsplot, Plot, d3\n\nObsplot({\n        \"x\": {\n            \"axis\": None\n        },\n        \"marks\": [\n            Plot.lineY(d3.cumsum({ \"length\": 100 }, d3.randomNormal()))\n        ]\n})\n\n\n\n\nIf your specification includes JavaScript code (such as anonymous functions), you can pass it as a string by using the js method (after importing it):\n\nfrom pyobsplot import Obsplot, Plot, d3, js\nimport polars as pl\n\ndata = pl.DataFrame(\n    {\n        \"x\": [1, 5, 2, 4, 6, 2, 4],\n        \"y\": [2, 1, 3, 4, 5, 1, 2],\n        \"type\": [\"T1\", \"T2\", \"T1\", \"T2\", \"T1\", \"T1\", \"T2\"],\n    }\n)\n\nObsplot({\n    \"grid\": True,\n    \"marks\": [\n        Plot.dot(data, {\n            \"x\": \"x\", \"y\": \"y\", \"r\": 8,\n            \"stroke\": \"red\", \"fill\": \"red\",\n            \"fillOpacity\": js(\"d =&gt; d.type == 'T1' ? 1 : 0\")\n        })\n    ]\n})"
  },
  {
    "objectID": "usage.html#alternative-syntaxes",
    "href": "usage.html#alternative-syntaxes",
    "title": "Usage",
    "section": "Alternative syntaxes",
    "text": "Alternative syntaxes\nAs we’ve already seen, the most common syntax for a plot specification is to pass it as a dictionary :\n\nObsplot({\n    \"grid\": True,\n    \"color\": {\"legend\": True}\n    \"marks\": [\n        Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\"})\n    ],\n})\n\nBut it is also possible to pass top level arguments as kwargs to Obsplot, which would give the following:\n\nObsplot(\n    grid = True,\n    color = {\"legend\": True},\n    marks = [\n        Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\"})\n    ],\n)\n\nFinally, for the simplest cases, you can also pass a mark method directly to Obsplot. The JavaScript plot() method will be called automatically to display the plot:\n\nimport random\nObsplot(\n    Plot.tickX(\n        [random.gauss(0,1) for i in range(1000)], \n        {\"stroke\": \"red\", \"opacity\": 0.2}\n    )\n)"
  },
  {
    "objectID": "usage.html#dataframes-and-series",
    "href": "usage.html#dataframes-and-series",
    "title": "Usage",
    "section": "DataFrames and Series",
    "text": "DataFrames and Series\nPandas and polars DataFrames can be passed directly to Obsplot. They will be converted to JavaScript objects via Arrow IPC serialization, to ensure speed and data types conversion.\n\nimport polars as pl\nfrom datetime import date\n\ndf = pl.DataFrame({\n    \"Date\": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3), date(2023, 1, 4)],\n    \"Value\": [4.2, 3.8, 4.5, 4.7]\n})\n\nObsplot({\n    \"x\": {\"grid\": True},\n    \"y\": {\"domain\": [0, 5]},\n    \"marks\": [Plot.dot(df, {\"x\": \"Date\", \"y\": \"Value\"})]\n})\n\n\n\n\nIf you pass a pandas or polars Series object, it will be automatically converted to a DataFrame with one column:\n\nvalue = df.get_column(\"Value\")\n\nObsplot(\n    Plot.tickX(value, {\"x\": \"Value\"})\n)\n\n\n\n\npyobsplot implements a simple caching mechanism for some data objects: it currently works for DataFrames and for GeoJson objects.\nSometimes the same data object is used several times in a plot specification, such as:\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nObsplot({\n  \"height\": 600,\n  \"grid\": True,\n  \"facet\": {\n    \"data\": penguins,\n    \"x\": \"sex\",\n    \"y\": \"species\",\n    \"marginRight\": 80\n  },\n  \"marks\": [\n    Plot.frame({\"facet\": False}),\n    Plot.dot(penguins, {\n      \"x\": \"culmen_depth_mm\",\n      \"y\": \"culmen_length_mm\",\n      \"r\": 1.5,\n      \"fill\": \"#ccc\",\n      \"facet\": \"exclude\"\n    }),\n    Plot.dot(penguins, {\n       \"x\": \"culmen_depth_mm\",\n       \"y\": \"culmen_length_mm\",\n       \"facet\": True\n    })\n  ]\n})\n\n\n\n\nIn this case, caching ensures that the penguins DataFrame is only serialized and transmitted once instead of three times."
  },
  {
    "objectID": "usage.html#datetime-objects",
    "href": "usage.html#datetime-objects",
    "title": "Usage",
    "section": "datetime objects",
    "text": "datetime objects\ndatetime.date and datetime.datetime Python objects are automatically serialized and converted to JavaScript Date objects.\nThat makes the following two specifications equivalent:\n\nObsplot({\n    \"x\": {\"domain\": [js(\"new Date('2021-01-01')\"), js(\"new Date('2022-01-01')\")]}, \n    \"grid\": True\n})\n\n\n\n\n\nfrom datetime import date\nObsplot({\n    \"x\": {\"domain\": [date(2021,1,1), date(2022,1,1)]}, \n    \"grid\": True\n})\n\n\n\n\nAs well as the two following ones, using datetime:\n\nObsplot({\n    \"x\": {\"domain\": [js(\"new Date('2021-01-01T07:00:00')\"), js(\"new Date('2021-01-01T08:00:00')\")]}, \n    \"grid\": True\n})\n\n\n\n\n\nfrom datetime import datetime\nObsplot({\n    \"x\": {\"domain\": [datetime(2021,1,1,7,0,0), datetime(2021,1,1,8,0,0)]}, \n    \"grid\": True\n})"
  },
  {
    "objectID": "usage.html#interactivity",
    "href": "usage.html#interactivity",
    "title": "Usage",
    "section": "Interactivity",
    "text": "Interactivity\nThe fact that Obsplot are Jupyter widgets allow for basic interactivity. More specifically, you can set the spec attribute of an existing Obsplot to another plot specification and it will update it.\nThis allows to do things like the following, where a plot is updated depending on the value of a Jupyter IntSlider widget:\n\ndef generate_spec(length):\n    return {\n        \"x\": {\n            \"axis\": None\n        },\n        \"y\": {\n            \n        },\n        \"marks\": [\n            Plot.lineY(d3.cumsum({ \"length\": length }, d3.randomNormal()))\n        ]\n    }\n\n\ndef change_spec(change):\n    new_length = change['new']\n    p.spec = generate_spec(new_length)\n\n\nw = IntSlider(value = 100, min = 0, max = 1000)\np = Obsplot(generate_spec(w.value))\nw.observe(change_spec, names='value')\ndisplay(w)\np"
  },
  {
    "objectID": "usage.html#quarto",
    "href": "usage.html#quarto",
    "title": "Usage",
    "section": "Quarto",
    "text": "Quarto\nObsplot plots are compatible with quarto HTML formats: plots will be inserted as SVG or &lt;figure&gt; elements.\nIf your source document is a jupyter notebook (and not a .qmd file), then you have to use the --execute argument to force plot computation and to make them visible in the output:\nquarto render test.ipynb --execute --to html\nUnfortunately, as widgets, Obsplot plots are currently not available in any other quarto formats such as PDF."
  },
  {
    "objectID": "gallery_marks.html",
    "href": "gallery_marks.html",
    "title": "Marks",
    "section": "",
    "text": "Marks are the building blocks of Plot charts.\nThe following chart, taken from the Cell Mark notebook, shows the rating of every episode of The Simpsons.\n\nimport polars as pl\nfrom pyobsplot import Obsplot, Plot, d3, Math, js\n\nsimpsons = pl.read_csv(\"data/simpsons.csv\")\n\nObsplot(\n    {\n        \"height\": 640,\n        \"padding\": 0.05,\n        \"grid\": True,\n        \"x\": {\"axis\": \"top\", \"label\": \"Season\"},\n        \"y\": {\"label\": \"Episode\"},\n        \"color\": {\"type\": \"linear\", \"scheme\": \"PiYG\"},\n        \"marks\": [\n            Plot.cell(\n                simpsons,\n                {\"x\": \"season\", \"y\": \"number_in_season\", \"fill\": \"imdb_rating\"},\n            ),\n            Plot.text(\n                simpsons,\n                {\n                    \"x\": \"season\",\n                    \"y\": \"number_in_season\",\n                    \"text\": \"imdb_rating\",\n                    \"title\": \"title\",\n                },\n            ),\n        ],\n    }\n)\n\n\n\n\nFaceting allows to easily produce multiple plots by partitioning data. The following facet plot is taken from the Facets notebook.\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nObsplot(\n    {\n        \"height\": 600,\n        \"grid\": True,\n        \"facet\": {\"marginRight\": 80},\n        \"marks\": [\n            Plot.frame({\"facet\": False}),\n            Plot.dot(\n                penguins,\n                {\n                    \"x\": \"culmen_depth_mm\",\n                    \"y\": \"culmen_length_mm\",\n                    \"r\": 1.5,\n                    \"fill\": \"#ccc\",\n                    \"fx\": \"sex\",\n                    \"fy\": \"species\",\n                    \"facet\": \"exclude\",\n                },\n            ),\n            Plot.dot(\n                penguins,\n                {\n                    \"x\": \"culmen_depth_mm\",\n                    \"y\": \"culmen_length_mm\",\n                    \"fx\": \"sex\",\n                    \"fy\": \"species\",\n                },\n            ),\n        ],\n    }\n)\n\n\n\n\nSome marks allow for nice representation of complex data. The following plot, taken from the Arrow mark notebook, shows the evolution of inequality and population in various U.S. cities.\n\nmetros = pl.read_csv(\"data/metros.csv\")\n\nObsplot(\n    {\n        \"height\": 600,\n        \"grid\": True,\n        \"inset\": 10,\n        \"x\": {\"type\": \"log\", \"label\": \"Population →\"},\n        \"y\": {\"label\": \"↑ Inequality\", \"ticks\": 4},\n        \"color\": {\n            \"type\": \"diverging\",\n            \"scheme\": \"burd\",\n            \"label\": \"Change in inequality from 1980 to 2015\",\n            \"legend\": True,\n            \"ticks\": 6,\n            \"tickFormat\": \"+f\",\n        },\n        \"marks\": [\n            Plot.arrow(\n                metros,\n                {\n                    \"x1\": \"POP_1980\",\n                    \"y1\": \"R90_10_1980\",\n                    \"x2\": \"POP_2015\",\n                    \"y2\": \"R90_10_2015\",\n                    \"bend\": True,\n                    \"stroke\": js(\"d =&gt; d.R90_10_2015 - d.R90_10_1980\"),\n                },\n            ),\n            Plot.text(\n                metros,\n                {\n                    \"x\": \"POP_2015\",\n                    \"y\": \"R90_10_2015\",\n                    \"filter\": \"highlight\",\n                    \"text\": \"nyt_display\",\n                    \"fill\": \"currentColor\",\n                    \"stroke\": \"white\",\n                    \"dy\": -6,\n                },\n            ),\n        ],\n    }\n)\n\n−3−2−1+0+1+2+3Change in inequality from 1980 to 201545678↑ Inequality200k300k1M2M3M10M20MPopulation →New YorkChicagoHoustonWashington, D.C.San FranciscoSan JoseFairfield, Conn.Binghamton, N.Y.\n\n\nThe contour mark allows for nice representations of spatial data. The following example taken from the Contour mark notebook shows water vapor data from november 2022 (note that data processing and plot code are slightly modified to adapt to pyobsplot specificities).\n\nvapor = (\n    pl.read_csv(\"data/vapor.csv\", has_header=False, null_values=\"99999.0\")\n    .transpose()\n    .melt(variable_name=\"column\", value_name=\"values\")\n)\n\nObsplot(\n    {\n        \"projection\": \"equal-earth\",\n        \"color\": {\n            \"scheme\": \"blues\",\n            \"legend\": True,\n            \"ticks\": 6,\n            \"nice\": True,\n            \"label\": \"Water vapor (cm)\",\n        },\n        \"marks\": [\n            Plot.contour(\n                vapor,\n                {\n                    \"fill\": \"values\",\n                    \"width\": 360,\n                    \"height\": 180,\n                    \"x1\": -180,\n                    \"y1\": 90,\n                    \"x2\": 180,\n                    \"y2\": -90,\n                    \"interval\": 0.25,\n                    \"blur\": 0.5,\n                    \"interpolate\": \"barycentric\",\n                    \"stroke\": \"currentColor\",\n                    \"strokeWidth\": 0.5,\n                    \"clip\": \"sphere\",\n                },\n            ),\n            Plot.sphere(),\n        ],\n    }\n)\n\n0123456Water vapor (cm)"
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Update Observable Plot to 0.6.5"
  },
  {
    "objectID": "changelog.html#pyobsplot-development-version",
    "href": "changelog.html#pyobsplot-development-version",
    "title": "Changelog",
    "section": "",
    "text": "Update Observable Plot to 0.6.5"
  },
  {
    "objectID": "changelog.html#pyobsplot-0.1.3",
    "href": "changelog.html#pyobsplot-0.1.3",
    "title": "Changelog",
    "section": "pyobsplot 0.1.3",
    "text": "pyobsplot 0.1.3\n\nFirst released version"
  },
  {
    "objectID": "development.html",
    "href": "development.html",
    "title": "Development",
    "section": "",
    "text": "If you want to build pyobsplot from source, you’ll have to follow these steps:\n\nInstall node.js\nInstall poetry dependency management system\nClone the repository\nInstall Python dependencies with : poetry install\nInstall JavaScript dependencies with : npm install\n\npyobsplot uses the anywidget Jupyter widget framework. Python source code is in src/pyobsplot. JavaScript and CSS source code is in js/."
  },
  {
    "objectID": "development.html#install-fom-source",
    "href": "development.html#install-fom-source",
    "title": "Development",
    "section": "",
    "text": "If you want to build pyobsplot from source, you’ll have to follow these steps:\n\nInstall node.js\nInstall poetry dependency management system\nClone the repository\nInstall Python dependencies with : poetry install\nInstall JavaScript dependencies with : npm install\n\npyobsplot uses the anywidget Jupyter widget framework. Python source code is in src/pyobsplot. JavaScript and CSS source code is in js/."
  },
  {
    "objectID": "development.html#javascript-modification-and-bundling",
    "href": "development.html#javascript-modification-and-bundling",
    "title": "Development",
    "section": "JavaScript modification and bundling",
    "text": "JavaScript modification and bundling\nEach time JavaScript or CSS code is modified in the js/ directory, it must be bundled with one of the following scripts:\n# Bundle only once\nnpm run bundle\n# Bundle and watch for code change\nnpm run watch\nThe result is put into src/pyobsplot/static."
  },
  {
    "objectID": "development.html#tests",
    "href": "development.html#tests",
    "title": "Development",
    "section": "Tests",
    "text": "Tests\npyobsplot comes with three types of tests : Python test, JavaScript tests and Visual regression tests.\nTo run Python tests, use:\nnpm run pytest\nTo run JavaScript tests, use:\nnpm run jstest\nVisual regression tests allow to test if generated plots stay the same. They use the galata framework. To run them you first have to start a specific Jupyter instance with:\nnpm run uistart\nIf you use visual regression tests for the first time, you have to generate reference images with:\n# Create / update reference images\nnpm run uitest:update\nAfter that, you can test that currently generated images are the same as the reference one with:\n# Compare with reference images\nnpm run uitest"
  },
  {
    "objectID": "gallery_transforms.html",
    "href": "gallery_transforms.html",
    "title": "Transforms",
    "section": "",
    "text": "Transforms provide methods to manipulate and compute on data while plotting them.\nGroup transform allows to compute summary values before plotting them. It is often used to make bar charts.\n\nimport polars as pl\nfrom pyobsplot import Obsplot, Plot, d3, Math, js\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nObsplot(\n    {\n        \"y\": {\"grid\": True, \"percent\": True},\n        \"marks\": [\n            Plot.barY(\n                penguins,\n                Plot.groupZ(\n                    {\"y\": \"proportion-facet\"}, {\"fill\": \"sex\", \"fx\": \"species\"}\n                ),\n            ),\n            Plot.ruleY([0, 1]),\n        ],\n    }\n)\n\n\n\n\nThe Dodge transform allows to pack marks without overlapping. The following chart shows data about IPO offerings in the US.\n\nfrom datetime import datetime\n\nipos = pl.read_csv(\"data/ipos.csv\", try_parse_dates=True).filter(\n    pl.col(\"date\") &gt; datetime(1991, 1, 1)\n)\n\n\nObsplot(\n    {\n        \"insetRight\": 10,\n        \"height\": 600,\n        \"width\": 600,\n        \"marks\": [\n            Plot.dot(\n                ipos, Plot.dodgeY({\"x\": \"date\", \"r\": \"rMVOP\", \"fill\": \"currentColor\"})\n            ),\n            Plot.text(\n                ipos,\n                Plot.dodgeY(\n                    {\n                        \"filter\": js(\"(d) =&gt; d.rMVOP &gt; 5e3\"),\n                        \"x\": \"date\",\n                        \"r\": \"rMVOP\",\n                        \"text\": js(\"d =&gt; (d.rMVOP / 1e3).toFixed()\"),\n                        \"fill\": \"white\",\n                        \"fontWeight\": \"bold\",\n                    }\n                ),\n            ),\n        ],\n    }\n)\n\n\n\n\nThe Hexbin transform aggregates two dimensional points into hexagonal bins.\n\nObsplot(\n    {\n        \"inset\": 10,\n        \"color\": {\"scheme\": \"ylgnbu\", \"legend\": True, \"label\": \"Count\"},\n        \"marks\": [\n            Plot.hexagon(\n                penguins,\n                Plot.hexbin(\n                    {\"r\": \"count\", \"fill\": \"count\"},\n                    {\n                        \"x\": \"culmen_length_mm\",\n                        \"y\": \"flipper_length_mm\",\n                        \"binWidth\": 50,\n                    },\n                ),\n            ),\n            Plot.text(\n                penguins,\n                Plot.hexbin(\n                    {\"text\": \"count\"},\n                    {\n                        \"x\": \"culmen_length_mm\",\n                        \"y\": \"flipper_length_mm\",\n                        \"fill\": \"black\",\n                        \"stroke\": \"white\",\n                        \"binWidth\": 50,\n                    },\n                ),\n            ),\n        ],\n    }\n)\n\n1020Count175180185190195200205210215220225230↑ flipper_length_mm3540455055culmen_length_mm →142611209111275101039322657181533115143211641752810189221734221\n\n\nMap transform family can be used to normalize values.\n\nstocks = pl.read_csv(\"data/stocks.csv\", try_parse_dates=True)\n\nObsplot(\n    {\n        \"marginRight\": 40,\n        \"y\": {\n            \"type\": \"log\",\n            \"grid\": True,\n            \"label\": \"↑ Change in price (%)\",\n            \"tickFormat\": js('(f =&gt; x =&gt; f((x - 1) * 100))(d3.format(\"+d\"))'),\n        },\n        \"marks\": [\n            Plot.ruleY([1]),\n            Plot.line(\n                stocks, Plot.normalizeY({\"x\": \"Date\", \"y\": \"Close\", \"stroke\": \"Symbol\"})\n            ),\n            Plot.text(\n                stocks,\n                Plot.selectLast(\n                    Plot.normalizeY(\n                        {\n                            \"x\": \"Date\",\n                            \"y\": \"Close\",\n                            \"z\": \"Symbol\",\n                            \"text\": \"Symbol\",\n                            \"textAnchor\": \"start\",\n                            \"dx\": 3,\n                        }\n                    )\n                ),\n            ),\n        ],\n    }\n)\n\n\n\n\nSeveral group and map transforms can be applied and composed to create complex representations, such as this distribution of group ages by US states adapted from the Map transform notebook.\n\n# Load and prepare data\nstateage = (\n    pl.read_csv(\"data/us-population-state-age.csv\")\n    .melt(id_vars=\"name\", variable_name=\"age\", value_name=\"population\")\n    .rename({\"name\": \"state\"})\n)\n# Compute list of age groups\nages = stateage.get_column(\"age\").unique(maintain_order=True).to_list()\n# Compute list of states sorted by the proportion of age ≥80\nstates = (\n    stateage.with_columns(\n        (pl.col(\"population\") / pl.col(\"population\").sum().over(\"state\")).alias(\n            \"percent\"\n        )\n    )\n    .filter(pl.col(\"age\") == \"≥80\")\n    .sort(pl.col(\"percent\"), descending=True)\n    .get_column(\"state\")\n    .to_list()\n)\n\n# Plot.normalizeX default arguments\nxy = {\"basis\": \"sum\", \"z\": \"state\", \"x\": \"population\", \"y\": \"state\"}\n\n# Plot specification\nObsplot(\n    {\n        \"height\": 660,\n        \"grid\": True,\n        \"x\": {\"axis\": \"top\", \"label\": \"Percent (%) →\", \"transform\": js(\"d =&gt; d * 100\")},\n        \"y\": {\n            \"domain\": states,\n            \"axis\": None,\n        },\n        \"color\": {\n            \"scheme\": \"spectral\",\n            \"domain\": ages,\n            \"legend\": True,\n        },\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.ruleY(\n                stateage,\n                Plot.groupY({\"x1\": \"min\", \"x2\": \"max\"}, Plot.normalizeX(xy)),\n            ),\n            Plot.dot(\n                stateage,\n                Plot.normalizeX({**xy, \"fill\": \"age\"}),\n            ),\n            Plot.text(\n                stateage,\n                Plot.selectMinX(\n                    Plot.normalizeX(\n                        {\n                            **xy,\n                            \"textAnchor\": \"end\",\n                            \"dx\": -6,\n                            \"text\": \"state\",\n                        }\n                    )\n                ),\n            ),\n        ],\n    }\n)\n\n&lt;1010-1920-2930-3940-4950-5960-6970-79≥8002468101214161820Percent (%) →ALAKAZARCACOCTDEDCFLGAHIIDILINIAKSKYLAMEMDMAMIMNMSMOMTNENVNHNJNMNYNCNDOHOKORPARISCSDTNTXUTVTVAWAWVWIWYPR"
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "pyobsplot can be installed with pip:\npip install pyobsplot"
  },
  {
    "objectID": "getting_started.html#installation",
    "href": "getting_started.html#installation",
    "title": "Getting started",
    "section": "",
    "text": "pyobsplot can be installed with pip:\npip install pyobsplot"
  },
  {
    "objectID": "getting_started.html#usage",
    "href": "getting_started.html#usage",
    "title": "Getting started",
    "section": "Usage",
    "text": "Usage\nTo use pyobsplot, you must import at least its Obsplot and Plot classes with:\n\nfrom pyobsplot import Obsplot, Plot\n\nTo create a plot, you have to call Obsplot and pass a plot specification as argument. The simplest specification form is a Python dictionary with a syntax nearly identical as the JavaScript one.\nSo, starting with a very simple DataFrame:\n\nimport polars as pl\n\ndata = pl.DataFrame(\n    {\n        \"x\": [1, 5, 2, 4, 6, 2, 4],\n        \"y\": [2, 1, 3, 4, 5, 1, 2],\n        \"type\": [\"T1\", \"T2\", \"T1\", \"T2\", \"T1\", \"T1\", \"T2\"],\n    }\n)\n\nIf your JavaScript plot function looks like this:\nPlot(\n    {\n        grid: true,\n        marks: [Plot.dot(data, {x: \"x\", y: \"y\", fill: \"type\", r: 5})]\n    }\n)\nThen you can reproduce the plot with:\n\nObsplot(\n    {\n        \"grid\": True,\n        \"marks\": [Plot.dot(data, {\"x\": \"x\", \"y\": \"y\", \"fill\": \"type\", \"r\": 5})],\n    }\n)\n\n\n\n\nThe syntax is almost identical, except that dictionary keys must be quoted, and JavaScript true must be replaced by Python True.\nYou can use pandas and polars DataFrames as data sources, they are automatically serialized and passed to JavaScript via Arrow IPC format:\n\npenguins = pl.read_csv(\"data/penguins.csv\")\n\nObsplot(\n    {\n        \"grid\": True,\n        \"color\": {\"legend\": True},\n        \"marks\": [\n            Plot.dot(\n                penguins,\n                {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"island\"},\n            )\n        ],\n    }\n)\n\nBiscoeDreamTorgersen3,0003,5004,0004,5005,0005,5006,000↑ body_mass_g180190200210220230flipper_length_mm →\n\n\nFor the simplest cases, you can also create your plot directly by passing a Plot mark method to Obsplot:\n\nObsplot(Plot.auto(penguins, {\"x\": \"flipper_length_mm\"}))"
  },
  {
    "objectID": "gallery_geo.html",
    "href": "gallery_geo.html",
    "title": "Mapping and spatial data",
    "section": "",
    "text": "import polars as pl\nfrom pyobsplot import Obsplot, Plot, js\n\nThe Geo mark allows to draw geographic features such as points, lines and polygons. These marks data are passed as GeoJSON.\nThis allows to create choropleth maps such as the following:\n\nimport json\n\n# Load US counties from GeoJson\n# Source : https://eric.clst.org/tech/usgeojson/\nwith open(\"data/us_counties.geojson\", \"r\", encoding=\"windows-1252\") as f:\n    counties = json.load(f)\n\n# Merge unemployment values as GeoJson features property\nunemployment = pl.read_csv(\"data/us-county-unemployment.csv\")\nrates = {\n    id: unemp\n    for id, unemp in zip(unemployment.get_column(\"id\"), unemployment.get_column(\"rate\"))\n}\nfor county in counties[\"features\"]:\n    key = int(county[\"properties\"][\"GEO_ID\"][-5:])\n    if key in rates:\n        county[\"properties\"][\"unemployment\"] = rates[key]\n\n# Map\nObsplot(\n    {\n        \"marks\": [Plot.geo(counties, {\"fill\": js(\"(d) =&gt; d.properties.unemployment\")})],\n        # \"marks\": [Plot.geo(counties, {\"stroke\": \"red\"})],\n        \"projection\": \"albers-usa\",\n        \"color\": {\n            \"type\": \"quantile\",\n            \"n\": 8,\n            \"scheme\": \"blues\",\n            \"label\": \"Unemployment (%)\",\n            \"legend\": True,\n        },\n    }\n)\n\n3.344.555.56.27.4Unemployment (%)\n\n\nGeographic data in Observable notebooks are often stored in TopoJSON files. The topojson package can be useful for these kind of data.\n\nimport topojson as tp\n\n# Import TopoJSON data\nwith open(\"data/us-counties-10m.json\", \"r\") as f:\n    counties = json.load(f)\n\n# Extract \"nation\" objects and convert to GeoJSON\nnation = tp.Topology(counties, object_name=\"nation\").to_geojson(object_name=\"nation\")\nnation = json.loads(nation)\n# Extract \"states\" objects and convert to GeoJSON\nstates = tp.Topology(counties, object_name=\"states\").to_geojson(object_name=\"states\")\nstates = json.loads(states)\n\n# Plot map\nObsplot(\n    {\n        \"marks\": [\n            Plot.geo(states, {\"strokeOpacity\": 0.3}),\n            Plot.geo(nation),\n        ],\n        \"projection\": \"albers\",\n    }\n)\n\n\n\n\nOf course other marks can be used in conjunction with geo marks. This example represents the density of Walmarts supermarkets and is taken from the Mapping notebook.\n\nwalmarts = pl.read_csv(\"data/walmarts.tsv\", sep=\"\\t\")\n\nObsplot(\n    {\n        \"marks\": [\n            Plot.density(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"bandwidth\": 12, \"fill\": \"density\"},\n            ),\n            Plot.dot(\n                walmarts,\n                {\"x\": \"longitude\", \"y\": \"latitude\", \"r\": 1, \"fill\": \"currentColor\"},\n            ),\n            Plot.geo(states, {\"strokeOpacity\": 0.3, \"fill\": None}),\n            Plot.geo(nation),\n        ],\n        \"projection\": \"albers\",\n        \"color\": {\"scheme\": \"blues\"},\n    }\n)\n\n/tmp/ipykernel_2648/2759925357.py:1: DeprecationWarning: `sep` is deprecated as an argument to `read_csv`; use `separator` instead.\n  walmarts = pl.read_csv(\"data/walmarts.tsv\", sep=\"\\t\")\n\n\n\n\n\nThe Raster mark creates an image from spatial data.\nPlot allows to do different type of spatial interpolations, such as nearest, which draws voronoi cells around values:\n\nca55 = pl.read_csv(\"data/ca55-south.csv\")\n\n\ndef flare_map(interpolation):\n    return Obsplot(\n        {\n            \"x\": {\"axis\": None},\n            \"y\": {\"axis\": None},\n            \"inset\": 10,\n            \"marginBottom\": 2,\n            \"height\": 500,\n            \"color\": {\"type\": \"diverging\"},\n            \"marks\": [\n                Plot.raster(\n                    ca55,\n                    {\n                        \"x\": \"LONGITUDE\",\n                        \"y\": \"LATITUDE\",\n                        \"fill\": \"MAG_IGRF90\",\n                        \"interpolate\": interpolation,\n                    },\n                ),\n                Plot.frame(),\n            ],\n        }\n    )\n\n\nflare_map(\"nearest\")\n\n\n\n\nOr the more recent random walk interpolation:\n\nflare_map(\"random-walk\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyobsplot",
    "section": "",
    "text": "pyobsplot allows to use Observable Plot to create charts in Jupyter notebooks. Plots are produced as widgets from Python code with a syntax as close as possible to the JavaScript one.\n\nObsplot(\n    {\n        \"marks\": [\n            Plot.dot(\n                penguins, {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"sex\"}\n            )\n        ]\n    }\n)\n\n\n\n\nOr, for a bit more complex example:\n\nObsplot(\n    {\n        \"marginLeft\": 75,\n        \"marginRight\": 70,\n        \"x\": {\"insetRight\": 10},\n        \"y\": {\"grid\": True},\n        \"facet\": {\"marginRight\": 70},\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.barX(\n                penguins,\n                Plot.groupY(\n                    {\"x\": \"count\"}, {\"fy\": \"island\", \"y\": \"species\", \"fill\": \"sex\"}\n                ),\n            ),\n            Plot.text(\n                [\"The Adelie species is the only one on Torgersen Island.\"],\n                {\n                    \"fy\": [\"Torgersen\"],\n                    \"frameAnchor\": \"right\",\n                    \"lineWidth\": 16,\n                    \"dx\": -4,\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "pyobsplot",
    "section": "",
    "text": "pyobsplot allows to use Observable Plot to create charts in Jupyter notebooks. Plots are produced as widgets from Python code with a syntax as close as possible to the JavaScript one.\n\nObsplot(\n    {\n        \"marks\": [\n            Plot.dot(\n                penguins, {\"x\": \"flipper_length_mm\", \"y\": \"body_mass_g\", \"fill\": \"sex\"}\n            )\n        ]\n    }\n)\n\n\n\n\nOr, for a bit more complex example:\n\nObsplot(\n    {\n        \"marginLeft\": 75,\n        \"marginRight\": 70,\n        \"x\": {\"insetRight\": 10},\n        \"y\": {\"grid\": True},\n        \"facet\": {\"marginRight\": 70},\n        \"marks\": [\n            Plot.ruleX([0]),\n            Plot.barX(\n                penguins,\n                Plot.groupY(\n                    {\"x\": \"count\"}, {\"fy\": \"island\", \"y\": \"species\", \"fill\": \"sex\"}\n                ),\n            ),\n            Plot.text(\n                [\"The Adelie species is the only one on Torgersen Island.\"],\n                {\n                    \"fy\": [\"Torgersen\"],\n                    \"frameAnchor\": \"right\",\n                    \"lineWidth\": 16,\n                    \"dx\": -4,\n                },\n            ),\n        ],\n    }\n)"
  },
  {
    "objectID": "index.html#installation-and-usage",
    "href": "index.html#installation-and-usage",
    "title": "pyobsplot",
    "section": "Installation and usage",
    "text": "Installation and usage\n\n\n\n\n\n\nWarning\n\n\n\nThis project is at a very early stage. There will be bugs, and please take a look at the limitations listed below.\n\n\nGetting started gives installation instructions and a quick usage overview.\nUsage gives more detailed usage instructions."
  },
  {
    "objectID": "index.html#features-and-limitations",
    "href": "index.html#features-and-limitations",
    "title": "pyobsplot",
    "section": "Features and limitations",
    "text": "Features and limitations\nFeatures:\n\nSyntax as close as possible to the JavaScript one\nPandas and polars DataFrame and Series objects are serialized using Arrow IPC format for improved speed and data type conversions\nWorks offline, no iframe or dependency to Observable runtime\nCaching mechanism of data objects if they are used several times in the same plot\nCustom JavaScript code can be passed as strings with the js method\nPython date and datetime objects are automatically converted to JavaScript Date objects\nPlots can be defined with a dictionary, a call to a Plot mark function, or with kwargs. See alternative syntaxes\nWorks with Jupyter notebooks and Quarto HTML documents\n\nLimitations:\n\nWhen using notebooks inside VSCode, the cells output states are not saved between sessions. So when a notebook is closed and reopened, plots have to be recomputed to be displayed. This is currently a VSCode limitation.\nDoesn’t work in Quarto in formats other than HTML.\nWhen exporting to HTML, the resulting documents can be quite big as each plot is embedded as a widget, with the data and the code needed to generate it (there is currently no way to embed SVG or HTML directly).\nSome faceting operations produce warnings when used as top-level faceting (but the plots should be fine). This doesn’t happen when you using mark-level faceting (with the fx and fy channels)."
  },
  {
    "objectID": "index.html#credits",
    "href": "index.html#credits",
    "title": "pyobsplot",
    "section": "Credits",
    "text": "Credits\n\nObservable Plot, developed by Mike Bostock and Philippe Rivière among others.\nThe widget is developed thanks to the anywidget framework.\nThis documentation website is generated by Quarto and the bookup custom format."
  }
]