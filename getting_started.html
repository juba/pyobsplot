<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.294">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>pyobsplot - Getting started</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./favicon.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/quarto-contrib/bookup_fonts_gwf-0.0/fonts-embed.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./getting_started.html">Getting started</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">pyobsplot</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/juba/pyobsplot/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./getting_started.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Getting started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./usage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Usage</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Gallery</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gallery_marks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Marks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gallery_transforms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Transforms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./gallery_geo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Geo mark and mapping</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./contributing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Contributing</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#installation" id="toc-installation" class="nav-link active" data-scroll-target="#installation">Installation</a></li>
  <li><a href="#usage" id="toc-usage" class="nav-link" data-scroll-target="#usage">Usage</a></li>
  <li><a href="#learn-more" id="toc-learn-more" class="nav-link" data-scroll-target="#learn-more">Learn more</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/juba/pyobsplot/edit/main/doc/getting_started.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/juba/pyobsplot/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Getting started</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="installation" class="level2">
<h2 class="anchored" data-anchor-id="installation">Installation</h2>
<p><code>pyobsplot</code> can be installed with <code>pip</code>:</p>
<pre class="shell"><code>pip install pyobsplot</code></pre>
</section>
<section id="usage" class="level2">
<h2 class="anchored" data-anchor-id="usage">Usage</h2>
<p>To use <code>pyobsplot</code>, you must import at least its <code>Obsplot</code> and <code>Plot</code> classes with:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyobsplot <span class="im">import</span> Obsplot, Plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To create a plot, you have to call <code>Obsplot</code> and pass a plot specification as argument. The simplest specification form is a Python dictionary with a syntax nearly identical as the JavaScript one.</p>
<p>So, starting with a very simple DataFrame:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pl.DataFrame(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"x"</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>],</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"y"</span>: [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"type"</span>: [<span class="st">"T1"</span>, <span class="st">"T2"</span>, <span class="st">"T1"</span>, <span class="st">"T2"</span>, <span class="st">"T1"</span>, <span class="st">"T1"</span>, <span class="st">"T2"</span>],</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If your JavaScript plot function looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Plot</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">grid</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">marks</span><span class="op">:</span> [Plot<span class="op">.</span><span class="fu">dot</span>(data<span class="op">,</span> {<span class="dt">x</span><span class="op">:</span> <span class="st">"x"</span><span class="op">,</span> <span class="dt">y</span><span class="op">:</span> <span class="st">"y"</span><span class="op">,</span> <span class="dt">fill</span><span class="op">:</span> <span class="st">"type"</span><span class="op">,</span> <span class="dt">r</span><span class="op">:</span> <span class="dv">5</span>})]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then you can reproduce the plot with:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Obsplot(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"grid"</span>: <span class="va">True</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"marks"</span>: [Plot.dot(data, {<span class="st">"x"</span>: <span class="st">"x"</span>, <span class="st">"y"</span>: <span class="st">"y"</span>, <span class="st">"fill"</span>: <span class="st">"type"</span>, <span class="st">"r"</span>: <span class="dv">5</span>})],</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"9a570cdfc8094feda2530889b5fa6afa","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>The syntax is almost identical, except that dictionary keys must be quoted, and JavaScript <code>true</code> must be replaced by Python <code>True</code>.</p>
<p>You can use pandas and polars DataFrames as data sources, they are automatically serialized and passed to JavaScript via Arrow IPC format:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>penguins <span class="op">=</span> pl.read_csv(<span class="st">"data/penguins.csv"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Obsplot(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"grid"</span>: <span class="va">True</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"color"</span>: {<span class="st">"legend"</span>: <span class="va">True</span>},</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"marks"</span>: [</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            Plot.dot(</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                penguins,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"x"</span>: <span class="st">"flipper_length_mm"</span>, <span class="st">"y"</span>: <span class="st">"body_mass_g"</span>, <span class="st">"fill"</span>: <span class="st">"island"</span>},</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        ],</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"3eddd96661a541bba1e558c4a5f2001a","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>For the simplest cases, you can also create your plot directly by passing a <code>Plot</code> mark method to <code>Obsplot</code>:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Obsplot(Plot.auto(penguins, {<span class="st">"x"</span>: <span class="st">"flipper_length_mm"</span>}))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"2fbba5e881e04f09b7eb07829c58f6ce","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
</section>
<section id="learn-more" class="level1">
<h1>Learn more</h1>
<p>To go further, see the <a href="./usage.html">usage</a> page.</p>


</section>

</main> <!-- /main -->

<script type="application/vnd.jupyter.widget-state+json">
{"state":{"0d031d2d1d2b4bfca329f13640c78af3":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"2fbba5e881e04f09b7eb07829c58f6ce":{"buffers":[{"data":"QVJST1cxAAD/////sAEAABAAAAAAAAoADAAGAAUACAAKAAAAAAEEAAwAAAAIAAgAAAAEAAgAAAAEAAAABwAAAFABAAAUAQAA1AAAAJwAAABgAAAALAAAAAQAAADc/v//AAABBRAAAAAUAAAABAAAAAAAAAADAAAAc2V4AMj+//8A////AAABAxAAAAAcAAAABAAAAAAAAAALAAAAYm9keV9tYXNzX2cAXv///wAAAQAw////AAABAxAAAAAkAAAABAAAAAAAAAARAAAAZmxpcHBlcl9sZW5ndGhfbW0AAACW////AAABAGj///8AAAEDEAAAACAAAAAEAAAAAAAAAA8AAABjdWxtZW5fZGVwdGhfbW0Ayv///wAAAQCc////AAABAxAAAAAoAAAABAAAAAAAAAAQAAAAY3VsbWVuX2xlbmd0aF9tbQAABgAIAAYABgAAAAAAAQDY////AAABBRAAAAAYAAAABAAAAAAAAAAGAAAAaXNsYW5kAADI////EAAUAAgABgAHAAwAAAAQABAAAAAAAAEFEAAAABwAAAAEAAAAAAAAAAcAAABzcGVjaWVzAAQABAAEAAAAAAAAAP/////YAQAAFAAAAAAAAAAMABYABgAFAAgADAAMAAAAAAMEABgAAAB4PQAAAAAAAAAACgAYAAwABAAIAAoAAAAsAQAAEAAAAFgBAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkBQAAAAAAAGgFAAAAAAAA3AgAAAAAAABIDgAAAAAAAAAAAAAAAAAASA4AAAAAAABkBQAAAAAAALATAAAAAAAAMAgAAAAAAADgGwAAAAAAAAAAAAAAAAAA4BsAAAAAAABgBQAAAAAAAEAhAAAAAAAAAAAAAAAAAABAIQAAAAAAAGAFAAAAAAAAoCYAAAAAAAAAAAAAAAAAAKAmAAAAAAAAYAUAAAAAAAAALAAAAAAAAAAAAAAAAAAAACwAAAAAAABgBQAAAAAAAGAxAAAAAAAAKwAAAAAAAACQMQAAAAAAAGQFAAAAAAAA+DYAAAAAAAB+BgAAAAAAAAAAAAAHAAAAWAEAAAAAAAAAAAAAAAAAAFgBAAAAAAAAAAAAAAAAAABYAQAAAAAAAAAAAAAAAAAAWAEAAAAAAAAAAAAAAAAAAFgBAAAAAAAAAAAAAAAAAABYAQAAAAAAAAAAAAAAAAAAWAEAAAAAAAALAAAAAAAAAAAAAAAGAAAADAAAABIAAAAYAAAAHgAAACQAAAAqAAAAMAAAADYAAAA8AAAAQgAAAEgAAABOAAAAVAAAAFoAAABgAAAAZgAAAGwAAAByAAAAeAAAAH4AAACEAAAAigAAAJAAAACWAAAAnAAAAKIAAACoAAAArgAAALQAAAC6AAAAwAAAAMYAAADMAAAA0gAAANgAAADeAAAA5AAAAOoAAADwAAAA9gAAAPwAAAACAQAACAEAAA4BAAAUAQAAGgEAACABAAAmAQAALAEAADIBAAA4AQAAPgEAAEQBAABKAQAAUAEAAFYBAABcAQAAYgEAAGgBAABuAQAAdAEAAHoBAACAAQAAhgEAAIwBAACSAQAAmAEAAJ4BAACkAQAAqgEAALABAAC2AQAAvAEAAMIBAADIAQAAzgEAANQBAADaAQAA4AEAAOYBAADsAQAA8gEAAPgBAAD+AQAABAIAAAoCAAAQAgAAFgIAABwCAAAiAgAAKAIAAC4CAAA0AgAAOgIAAEACAABGAgAATAIAAFICAABYAgAAXgIAAGQCAABqAgAAcAIAAHYCAAB8AgAAggIAAIgCAACOAgAAlAIAAJoCAACgAgAApgIAAKwCAACyAgAAuAIAAL4CAADEAgAAygIAANACAADWAgAA3AIAAOICAADoAgAA7gIAAPQCAAD6AgAAAAMAAAYDAAAMAwAAEgMAABgDAAAeAwAAJAMAACoDAAAwAwAANgMAADwDAABCAwAASAMAAE4DAABUAwAAWgMAAGADAABmAwAAbAMAAHIDAAB4AwAAfgMAAIQDAACKAwAAkAMAAJkDAACiAwAAqwMAALQDAAC9AwAAxgMAAM8DAADYAwAA4QMAAOoDAADzAwAA/AMAAAUEAAAOBAAAFwQAACAEAAApBAAAMgQAADsEAABEBAAATQQAAFYEAABfBAAAaAQAAHEEAAB6BAAAgwQAAIwEAACVBAAAngQAAKcEAACwBAAAuQQAAMIEAADLBAAA1AQAAN0EAADmBAAA7wQAAPgEAAABBQAACgUAABMFAAAcBQAAJQUAAC4FAAA3BQAAQAUAAEkFAABSBQAAWwUAAGQFAABtBQAAdgUAAH8FAACIBQAAkQUAAJoFAACjBQAArAUAALUFAAC+BQAAxwUAANAFAADZBQAA4gUAAOsFAAD0BQAA+gUAAAAGAAAGBgAADAYAABIGAAAYBgAAHgYAACQGAAAqBgAAMAYAADYGAAA8BgAAQgYAAEgGAABOBgAAVAYAAFoGAABgBgAAZgYAAGwGAAByBgAAeAYAAH4GAACEBgAAigYAAJAGAACWBgAAnAYAAKIGAACoBgAArgYAALQGAAC6BgAAwAYAAMYGAADMBgAA0gYAANgGAADeBgAA5AYAAOoGAADwBgAA9gYAAPwGAAACBwAACAcAAA4HAAAUBwAAGgcAACAHAAAmBwAALAcAADIHAAA4BwAAPgcAAEQHAABKBwAAUAcAAFYHAABcBwAAYgcAAGgHAABuBwAAdAcAAHoHAACABwAAhgcAAIwHAACSBwAAmAcAAJ4HAACkBwAAqgcAALAHAAC2BwAAvAcAAMIHAADIBwAAzgcAANQHAADaBwAA4AcAAOYHAADsBwAA8gcAAPgHAAD+BwAABAgAAAoIAAAQCAAAFggAABwIAAAiCAAAKAgAAC4IAAA0CAAAOggAAEAIAABGCAAATAgAAFIIAABYCAAAXggAAGQIAABqCAAAcAgAAHYIAAB8CAAAgggAAIgIAACOCAAAlAgAAJoIAACgCAAApggAAKwIAACyCAAAuAgAAL4IAADECAAAyggAANAIAADWCAAA3AgAAAAAAABBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBHZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b28AAAAAAAAAAAkAAAASAAAAGwAAACQAAAAtAAAANgAAAD8AAABIAAAAUQAAAFoAAABjAAAAbAAAAHUAAAB+AAAAhwAAAJAAAACZAAAAogAAAKsAAAC0AAAAugAAAMAAAADGAAAAzAAAANIAAADYAAAA3gAAAOQAAADqAAAA8AAAAPUAAAD6AAAA/wAAAAQBAAAJAQAADgEAABMBAAAYAQAAHQEAACIBAAAnAQAALAEAADEBAAA2AQAAOwEAAEABAABFAQAASgEAAE8BAABUAQAAWgEAAGABAABmAQAAbAEAAHIBAAB4AQAAfgEAAIQBAACKAQAAkAEAAJYBAACcAQAAogEAAKgBAACuAQAAtAEAALoBAADAAQAAyQEAANIBAADbAQAA5AEAAO0BAAD2AQAA/wEAAAgCAAARAgAAGgIAACMCAAAsAgAANQIAAD4CAABHAgAAUAIAAFUCAABaAgAAXwIAAGQCAABpAgAAbgIAAHMCAAB4AgAAfQIAAIICAACHAgAAjAIAAJECAACWAgAAmwIAAKACAACmAgAArAIAALICAAC4AgAAvgIAAMQCAADKAgAA0AIAANYCAADcAgAA4gIAAOgCAADuAgAA9AIAAPoCAAAAAwAACQMAABIDAAAbAwAAJAMAAC0DAAA2AwAAPwMAAEgDAABRAwAAWgMAAGMDAABsAwAAdQMAAH4DAACHAwAAkAMAAJUDAACaAwAAnwMAAKQDAACpAwAArgMAALMDAAC4AwAAvQMAAMIDAADHAwAAzAMAANEDAADWAwAA2wMAAOADAADlAwAA6gMAAO8DAAD0AwAA+QMAAP4DAAADBAAACAQAAA0EAAASBAAAFwQAABwEAAAhBAAAJgQAACsEAAAwBAAANQQAADoEAAA/BAAARAQAAEkEAABOBAAAUwQAAFgEAABdBAAAYgQAAGcEAABsBAAAcQQAAHYEAAB7BAAAgAQAAIUEAACKBAAAjwQAAJQEAACZBAAAngQAAKMEAACoBAAArQQAALIEAAC3BAAAvAQAAMEEAADGBAAAywQAANAEAADVBAAA2gQAAN8EAADkBAAA6QQAAO4EAADzBAAA+AQAAP0EAAACBQAABwUAAAwFAAARBQAAFgUAABsFAAAgBQAAJQUAACoFAAAvBQAANAUAADkFAAA+BQAAQwUAAEgFAABOBQAAVAUAAFoFAABgBQAAZgUAAGwFAAByBQAAeAUAAH4FAACEBQAAigUAAJAFAACWBQAAnAUAAKIFAACoBQAArgUAALQFAAC6BQAAwAUAAMYFAADMBQAA0gUAANgFAADeBQAA5AUAAOoFAADwBQAA9gUAAPwFAAACBgAACAYAAA4GAAAUBgAAGgYAACAGAAAmBgAALAYAADIGAAA4BgAAPgYAAEQGAABKBgAAUAYAAFYGAABcBgAAYgYAAGgGAABuBgAAdAYAAHoGAACABgAAhgYAAIwGAACSBgAAmAYAAJ4GAACkBgAAqgYAALAGAAC2BgAAvAYAAMIGAADIBgAAzgYAANQGAADaBgAA4AYAAOYGAADsBgAA8gYAAPgGAAD+BgAABAcAAAoHAAAQBwAAFgcAABwHAAAiBwAAKAcAAC4HAAA0BwAAOgcAAEAHAABGBwAATAcAAFIHAABYBwAAXgcAAGQHAABqBwAAcAcAAHYHAAB8BwAAggcAAIgHAACOBwAAlAcAAJoHAACgBwAApgcAAKwHAACyBwAAuAcAAL4HAADEBwAAygcAANAHAADWBwAA3AcAAOIHAADoBwAA7gcAAPQHAAD6BwAAAAgAAAYIAAAMCAAAEggAABgIAAAeCAAAJAgAACoIAAAwCAAAAAAAAFRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlbkJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1CaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VUb3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZVRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlbkRyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lZmYcQgAAHkIzMyFCAADAf83MEkIzMx1CmpkbQs3MHEJmZghCAAAoQjMzF0IzMxdCZmYkQmZmGkJmZgpCZmYSQs3MGkIAACpCmpkJQgAAOEIzMxdCzcwWQpqZD0LNzBhCMzMbQjMzDUJmZiJCAAAiQpqZF0IAACJCAAAeQs3MFEIAAB5CmpkjQpqZEULNzBxCMzMbQs3MKEJmZhZCMzMfQgAAEkIzMyNCAAAQQmZmMEIAABRCZmYeQmZmJEIAABZCAAAQQjMzKUJmZh5CZmYgQgAADEIAAChCAAAKQpqZJUIAABxCZmYiQgAAEkJmZhZCzcwOQjMzJUJmZhZCZmYkQpqZEUJmZiZCAAAOQmZmJEKamQ9CMzMnQgAABkLNzB5CZmYeQjMzN0IAAA5CMzMrQpqZI0LNzBRCzcwQQmZmKEJmZgpCmpkrQs3MEkJmZgxCMzMVQjMzJUIzMxFCmpkTQjMzGUKamRtCzcwOQmZmJEIAAAhCZmYeQs3MEEIzMyNCZmYYQjMzIUJmZgRCzcwsQgAADEIAACRCzcwWQjMzF0KamRdCzcweQmZmGkLNzBhCZmYYQs3MLEJmZhhCZmY2Qs3MHkLNzChCZmYeQs3MKkJmZhpCMzMVQs3MDkJmZiRCzcwQQs3MFkLNzCBCmpklQs3MDEJmZiJCMzMbQgAAJkIAABxCZmYwQgAAGkJmZixCMzMTQgAAFkJmZhhCZmYkQmZmDkLNzCBCAAAUQs3MHkLNzCBCZmYiQmZmAELNzCJCMzMVQgAAHELNzBxCZmYSQgAAEEIzMxdCAAAQQgAAJkIAADpCAABIQjMzTUKamTVCzcxSQs3MNEJmZjhCMzNNQgAAOEIzM01CZmY6Qs3MTkIAADxCAABQQpqZN0IAAEpCMzNJQgAAaEKamTlCzcxEQpqZKUIAAEJCzcwsQmZmSkLNzDpCAABQQgAASkIAAEZCmpk5QjMzU0KamSNCzcxYQgAAKkIAAExCzcxGQgAAPkJmZj5CAABQQpqZO0IAAFZCAABEQs3MOEKamUtCAAA2QpqZS0IzM0tCZmZIQgAAREIAAE5CMzNHQmZmQEKamU1Czcw2Qs3MSkIAACpCzcxQQs3MNEIzM0VCzcxIQmZmNkKamU9CMzM7Qs3MNkIzM19CAAAuQmZmRkIzM0tCzcxIQmZmOEIAAEhCzcxCQgAASEJmZj5CAAA6QpqZNULNzDpCMzMtQjMzO0KamSNCAABEQgAANkKamUFCMzM3QjMzRUIAAChCzcxEQs3MOELNzEJCzcxIQmZmNEIAADpCMzM5QpqZK0JmZjhCAAAyQjMzP0LNzEBCAABIQjMzPUIzMytCZmY0QmZmbkJmZkRCmplBQmZmKkKamTFCAAAwQs3MQkLNzCpCZmZGQjMzNUJmZkZCAABKQmZmLkIAADZCAABKQpqZM0LNzDRCZmY6QgAAQkJmZjRCZmZIQgAAOkIAADRCMzMvQgAANkLNzCxCmplJQjMzNULNzDhCzcw2QjMzWUIzMzdCMzNHQs3MOEIAAEZCAAAuQs3MSkLNzD5Cmpk5Qs3MQEIAADpCmpk5QmZmQkIAAD5CZmZMQs3MNELNzDRCZmZEQgAAUkKamT1CAABIQpqZM0IzM0tCmpktQjMzTUIAAD5CZmZQQgAAPkLNzFBCAAA2QgAARkIAADJCMzNLQpqZRUKamTtCmplBQmZmTEIAAEJCmplfQs3MPEJmZkRCMzM9QjMzO0LNzCZCmplVQjMzLUJmZkBCAABKQjMzR0IAAC5CAABOQs3MOEJmZlxCAAAyQjMzQ0LNzDxCAADAfzMzO0KamUlCzcw0QpqZR0KamZVBMzOLQQAAkEEAAMB/ZmaaQc3MpEFmZo5BzcycQc3MkEGamaFBzcyIQWZmikHNzIxBmpmpQc3MqEFmZo5BAACYQZqZpUEzM5NBAACsQWZmkkGamZVBmpmZQc3MkEGamYlBMzOXQc3MlEEzM49BzcyUQTMzl0GamYVBzcyQQWZmjkEzM5dBAACIQc3MqEEAAKBBAACUQWZmmkHNzJhBAACQQTMzk0EAAJRBmpmdQTMzh0FmZpZBAACYQTMzl0EzM49BmpmpQZqZjUEzM5dBMzOPQQAAnEHNzJBBzcyUQQAAjEFmZpZBzcyEQc3MmEEzM4dBzcyoQQAAiEGamZFBzcyIQQAAkEGamYFBzcyYQc3MhEEzM5tBAACYQTMzk0GamYlBMzOXQQAAjEEAAJRBZmaGQTMzm0HNzIBBzcyYQZqZiUHNzIxBZmaWQTMzm0FmZo5BZmaiQQAAnEHNzJRBmpmZQWZmlkEAAJBBzcyQQc3MiEHNzJBBZmaKQTMzl0HNzJRBAACUQc3MgEEAAJRBMzOPQQAAoEEAAIBBAACgQc3MlEEzM5dBmpmJQQAAoEEAAIhBAACYQQAAhEFmZqJBmpmNQQAAnEGamaVBZmaSQQAAiEEAAKRBAACIQc3MlEGamYlBZmaeQQAAiEEAAJRBZmZ+QQAAmEHNzIxBZmaSQc3MiEEAAJBBMzOPQZqZmUEAAJRBAACUQc3MjEEAAIxBAACMQc3MoEEAAIRBMzOPQc3MiEGamYlBAAB4QQAAiEFmZoZBmpmVQc3MlEEzM5NBZmaOQc3MkEHNzIhBAACUQTMzj0EAAJxBmpmZQZqZlUFmZp5BZmaOQZqZkUGamZFBMzOXQTMzn0FmZo5BZmaiQWZmikHNzJBBzcyIQc3MnEEAAKBBZmaOQc3MlEGamZFBZmaKQQAAjEHNzIRBMzObQTMzj0EAAJhBMzOTQQAAmEFmZo5BAACgQc3MhEFmZqZBmpmFQWZmlkHNzJRBZmaGQWZmkkGamaVBzcyEQTMzn0EAAJxBAACMQc3MmEEAAIhBMzOPQQAAlEEzM49BzcycQZqZlUFmZopBMzODQQAAmEFmZopBmpmdQWZmikFmZpZBzcyEQTMzn0FmZpZBMzObQQAAnEEAAIRBAACIQWZmnkHNzJBBmpmRQQAAmEGamZVBMzNTQWZmgkGamWFBMzNzQQAAaEEAAFhBmplpQc3MdEFmZlZBZmZ2QTMzW0HNzIBBMzNbQZqZaUGamWlBMzN7QQAAWEEzM3NBAABoQZqZcUHNzGRBAABoQQAAaEHNzHxBmplRQZqZcUHNzGRBAABwQc3MZEHNzHRBzcx0QTMzY0EAAGhBAACIQc3MbEFmZoJBMzNbQWZmikGamVlBMzN7QTMzW0EAAIBBMzNbQQAAcEFmZn5BZmZeQWZmXkFmZn5BzcxUQc3MfEEzM2NBmplhQWZmZkEAAHBBZmZmQWZmdkFmZl5BAABwQQAAaEHNzHRBzcxcQWZmbkFmZl5BMzN7QTMzY0FmZoZBZmZmQZqZgUEzM2NBAABwQQAAcEGamXlBmpl5Qc3MbEEAAHBBAACAQTMzY0FmZoJBzcxcQTMzg0EAAGhBmpl5QZqZaUFmZn5BzcxcQWZmikFmZmZBMzNjQQAAYEEAAIhBAABwQc3MiEEAAGhBzcyAQTMza0EzM3tBzcx8QZqZaUFmZmZBAACEQQAAcEEAAIhBAAB4QQAAcEHNzFxBzcyAQTMza0HNzHxBAABgQZqZcUEzM3NBZmZ+QTMzc0FmZoJBmplhQQAAgEEzM3tBmpmBQTMzW0EAAMB/zcxkQTMze0HNzGxBzcyAQQAANUMAADpDAABDQwAAwH8AAEFDAAA+QwAANUMAAENDAABBQwAAPkMAADpDAAA0QwAANkMAAD9DAABGQwAAOUMAAENDAABFQwAAOEMAAEJDAAAuQwAANEMAAD1DAAA5QwAANEMAADtDAAA3QwAAO0MAACxDAAA0QwAAMkMAADJDAAA8QwAAOEMAAENDAABEQwAAPkMAADRDAAA1QwAAOEMAADZDAABDQwAAOkMAAERDAAA5QwAAPkMAADZDAAAzQwAAPkMAAD9DAAA6QwAAPEMAAD5DAABIQwAAO0MAAD9DAAA6QwAAQUMAADVDAABCQwAAOUMAAENDAAA5QwAAQEMAADhDAABAQwAAQ0MAADxDAAA+QwAARkMAAD5DAAA+QwAAREMAAEVDAAA+QwAAQ0MAAD9DAAA4QwAAO0MAAENDAAA9QwAAREMAADtDAABBQwAAP0MAAEJDAAA+QwAAPUMAAD1DAAA+QwAASkMAAE1DAAA5QwAAOkMAADtDAABQQwAAPkMAAERDAAAyQwAAQEMAAEBDAABLQwAAN0MAAD5DAABBQwAAOEMAAEdDAAA+QwAANUMAAEVDAABGQwAAP0MAAEFDAABFQwAAP0MAAERDAAA8QwAAR0MAAD1DAAA9QwAAO0MAAEZDAAAwQwAASkMAADpDAABHQwAAP0MAAENDAAA/QwAAUkMAAD5DAABFQwAAQUMAAEdDAAA7QwAAPkMAAD9DAABIQwAAOUMAAEFDAABBQwAAO0MAADxDAAA+QwAAQEMAADlDAAA+QwAAOEMAAENDAABBQwAAO0MAAElDAABAQwAAREMAAEFDAAA8QwAARUMAAEZDAAAyQwAARUMAAENDAABGQwAAQUMAAEJDAAA5QwAASUMAAD5DAABJQwAARUMAADVDAAA+QwAAQ0MAADVDAAA/QwAAO0MAAEFDAABDQwAARUMAAEhDAABIQwAAP0MAAE1DAAA7QwAASUMAADtDAABLQwAAQ0MAAEdDAABDQwAAUkMAAEBDAABNQwAAUkMAADtDAABEQwAAREMAAERDAABJQwAAPkMAAFRDAAA7QwAARkMAAEdDAABJQwAAQUMAAEtDAAA7QwAARUMAAD9DAABLQwAASkMAAEJDAABOQwAAPUMAAENDAABPQwAASkMAAEFDAABSQwAARkMAAFNDAABmQwAAUkMAAFpDAABXQwAAUkMAAFNDAABbQwAAUUMAAFdDAABWQwAAWEMAAFZDAABVQwAAUkMAAFlDAABSQwAAXUMAAFFDAABeQwAAWkMAAFdDAABVQwAAV0MAAFdDAABXQwAAWEMAAFdDAABSQwAAXEMAAF5DAABRQwAAT0MAAGZDAABcQwAAXEMAAFVDAABbQwAAUEMAAFBDAABQQwAAYUMAAFJDAABYQwAAXkMAAFlDAABSQwAAYUMAAFVDAABXQwAAUkMAAFxDAABSQwAAYUMAAFlDAABcQwAAUEMAAFxDAABQQwAAYEMAAFBDAABdQwAAVkMAAGdDAABbQwAAZkMAAFZDAABlQwAAXEMAAF9DAABYQwAAXUMAAF1DAABZQwAAWEMAAGZDAABRQwAAXEMAAFdDAABfQwAAVEMAAF1DAABUQwAAYEMAAFRDAABkQwAAWkMAAFpDAABUQwAAZkMAAFpDAABkQwAAVEMAAGBDAABWQwAAYkMAAFhDAABeQwAAS0MAAGFDAABbQwAAZEMAAFdDAABkQwAAWEMAAFdDAABSQwAAW0MAAFBDAABRQwAAWEMAAGVDAABVQwAAZkMAAFlDAABmQwAAWUMAAF5DAABWQwAAwH8AAFdDAABeQwAAVEMAAFVDAGBqRQCAbUUAIEtFAADAfwCgV0UAIGRFAJBiRQAYkkUAMFlFANCERQBATkUAQGdFAABIRQCAbUUAgIlFAEBnRQCgV0UAoIxFANBPRQBAg0UAgFRFAABhRQCAbUUA4HZFAIBtRQCAbUUA4F1FAABIRQDgREUA4HZFACBLRQDAc0UAQE5FAMBzRQDQT0UAsIFFAOB2RQDgXUUAQE5FAFCRRQDgREUAwHNFAMBBRQCAiUUAgDtFAMCPRQAQVkUA8DlFAKBXRQCwgUUAwFpFAGCGRQCgV0UAIH1FAEA1RQBAZ0UA4F1FAIBtRQAgMkUAYGpFAOBERQCAiUUAAGFFACB9RQAgMkUA4HZFAGBRRQAggEUAoD5FABCLRQAAYUUAwHNFAOBdRQCwgUUAQGdFANCERQBAZ0UAwHNFAOBdRQAAekUAAEhFAOCSRQCAbUUAQINFAGBRRQDgXUUAgG1FAMBaRQDgdkUAAGFFAOBdRQBghkUAgFRFABCLRQBATkUAYIZFAEBnRQDwh0UAQDVFACCARQDQaEUAqJNFADBARQDQhEUA0DZFAOBdRQBgakUAwHNFAHBGRQA4lUUAEG9FAMCPRQAASEUAmIVFAMBzRQCwfkUAQDVFAPBrRQBgUUUA0E9FAOBERQDAWkUAoFdFADByRQCgPkUAAHpFALBMRQBghkUAoD5FAAB6RQDQT0UAwFpFAMBaRQDYi0UAEFZFAMBzRQBwRkUAcHhFAIBURQDQhEUAgFRFADBZRQCgPkUA0GhFAIA7RQAgZEUA0IRFADBZRQCgV0UAYGpFAEBnRQAAekUAwFpFAMBzRQAgZEUAUFxFANBoRQDgdkUAIEtFAGBqRQCwgUUAQGdFAIBtRQDwa0UAQGdFACB9RQBwX0UAIH1FAEBORQBAZ0UAoFdFAICJRQAAYUUAgFRFAEA1RQCAbUUAQE5FALCBRQCAVEUAgG1FAEBnRQAwjkUAAEhFAGCGRQBgUUUAIIBFAABhRQDAc0UAoHBFAACWRQDAKEUAoIxFAOB2RQAgZEUA4F1FAMBaRQCwZUUAEItFAIBURQBghkUAIEtFALBlRQDQT0UA4HZFAABhRQAgfUUAYFFFAKBXRQAgS0UAIH1FAIBtRQBQXEUA4HZFACBkRQAgZEUAAHpFAIBURQDwa0UAIIBFAPBrRQCgjEUAILJFABCLRQAgskUAwKhFADCORQAAlkUAgKJFAICJRQDwoEUAUJFFAHCtRQBQkUUA0LZFAECDRQDQtkUAsIFFAODERQAAlkUAMKdFACCyRQBAnEUAgIlFANCdRQBAnEUAYJ9FACCARQCQsEUAwI9FAHCtRQAQpEUA4JJFANCdRQAQvUUA8KBFAMCoRQCwmkUAEKRFAPCHRQAwp0UA4HZFACCyRQBghkUAcJRFAHCtRQAgmUUAQINFAMCoRQBgn0UAoKVFAJCXRQCgpUUAgIlFAECcRQAgmUUA0J1FAGCGRQBAnEUAEItFAHCtRQBAg0UAoKVFAICJRQCQsEUA4JJFACCyRQBQkUUAQLVFAOCSRQBwrUUAcJRFAECcRQBgn0UAgKJFAOCSRQBAtUUAwI9FAIC7RQBwlEUA8LlFAIiQRQBQqkUAqJNFADCnRQBwlEUAAK9FAMCPRQCgpUUAWJhFAHCtRQCwmkUAwKhFAHCURQCQsEUAkJdFAICiRQDomUUAWJhFAIiQRQAQpEUAkJdFAACvRQB4m0UA4KtFAKiTRQDgq0UA4JJFAOCrRQD4jkUA4KtFAECcRQDwuUUAUJFFAOCrRQC4iEUA0LZFAFiYRQCAu0UA6JlFAADAfwCQl0UAsLNFAICiRQDAqEX38P///3////////////////////////////////+//////7//////7//2AAAAAAAAAAAABAAAAAoAAAAQAAAAEAAAABYAAAAaAAAAIAAAACQAAAAkAAAAJAAAACQAAAAkAAAAKgAAAC4AAAAyAAAAOAAAAD4AAABCAAAASAAAAEwAAABSAAAAVgAAAFwAAABgAAAAZAAAAGoAAABuAAAAdAAAAHoAAAB+AAAAhAAAAIgAAACOAAAAkgAAAJgAAACcAAAAoAAAAKYAAACsAAAAsAAAALYAAAC6AAAAwAAAAMQAAADKAAAAzgAAANIAAADSAAAA2AAAANwAAADiAAAA5gAAAOwAAADwAAAA9gAAAPoAAAAAAQAABAEAAAoBAAAOAQAAFAEAABgBAAAeAQAAIgEAACgBAAAsAQAAMgEAADYBAAA8AQAAQAEAAEYBAABKAQAAUAEAAFQBAABaAQAAXgEAAGQBAABoAQAAbgEAAHIBAAB4AQAAfAEAAIIBAACGAQAAjAEAAJABAACUAQAAmgEAAJ4BAACkAQAAqgEAAK4BAAC0AQAAuAEAAL4BAADCAQAAyAEAAMwBAADSAQAA1gEAANwBAADgAQAA5gEAAOoBAADwAQAA9AEAAPoBAAD+AQAABAIAAAgCAAAOAgAAEgIAABgCAAAcAgAAIgIAACYCAAAsAgAAMAIAADYCAAA6AgAAQAIAAEQCAABKAgAATgIAAFQCAABYAgAAXgIAAGICAABoAgAAbAIAAHICAAB2AgAAfAIAAIACAACGAgAAigIAAJACAACUAgAAmgIAAJ4CAACkAgAAqAIAAK4CAACyAgAAuAIAALwCAADAAgAAxgIAAMwCAADQAgAA1gIAANoCAADgAgAA5AIAAOgCAADuAgAA8gIAAPgCAAD+AgAAAgMAAAgDAAAMAwAAEgMAABYDAAAcAwAAIAMAACYDAAAqAwAALgMAADQDAAA6AwAAPgMAAEQDAABIAwAATgMAAFIDAABYAwAAXAMAAGIDAABmAwAAbAMAAHADAAB2AwAAegMAAIADAACEAwAAiAMAAI4DAACUAwAAmAMAAJ4DAACiAwAApgMAAKwDAACwAwAAtgMAALwDAADAAwAAxgMAAMoDAADOAwAA1AMAANoDAADeAwAA5AMAAOgDAADuAwAA8gMAAPgDAAD8AwAAAAQAAAYEAAAKBAAAEAQAABYEAAAaBAAAIAQAACQEAAAoBAAALgQAADQEAAA4BAAAPgQAAEIEAABGBAAATAQAAFIEAABWBAAAXAQAAGAEAABmBAAAagQAAHAEAAB0BAAAegQAAH4EAACEBAAAiAQAAI4EAACSBAAAlgQAAJwEAACiBAAApgQAAKwEAACwBAAAsAQAALQEAAC6BAAAvgQAAMIEAADIBAAAzgQAANIEAADYBAAA3AQAAOIEAADmBAAA7AQAAPAEAAD2BAAA+gQAAAAFAAAEBQAACAUAAA4FAAAUBQAAGAUAAB4FAAAiBQAAKAUAACwFAAAyBQAANgUAADwFAABABQAARgUAAEoFAABQBQAAVAUAAFoFAABeBQAAZAUAAGgFAABuBQAAcgUAAHIFAAB2BQAAfAUAAIAFAACGBQAAigUAAI4FAACUBQAAmgUAAJ4FAACkBQAAqAUAAK4FAACyBQAAuAUAALwFAADCBQAAxgUAAMwFAADQBQAA1gUAANoFAADgBQAA5AUAAOoFAADuBQAA9AUAAPgFAAD+BQAAAgYAAAYGAAAMBgAAEgYAABYGAAAcBgAAIAYAACYGAAAqBgAAKgYAAC4GAAA0BgAAOAYAAD4GAABCBgAASAYAAEwGAABSBgAAVgYAAFwGAABgBgAAYAYAAGQGAABqBgAAagYAAHAGAAB0BgAAegYAAH4GAAAAAAAATUFMRUZFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFAAD/////AAAAABAAAAAMABQABgAIAAwAEAAMAAAAAAAEADgAAAAoAAAABAAAAAEAAADAAQAAAAAAAOABAAAAAAAAeD0AAAAAAAAAAAAAAAAAAAgACAAAAAQACAAAAAQAAAAHAAAAUAEAABQBAADUAAAAnAAAAGAAAAAsAAAABAAAANz+//8AAAEFEAAAABQAAAAEAAAAAAAAAAMAAABzZXgAyP7//wD///8AAAEDEAAAABwAAAAEAAAAAAAAAAsAAABib2R5X21hc3NfZwBe////AAABADD///8AAAEDEAAAACQAAAAEAAAAAAAAABEAAABmbGlwcGVyX2xlbmd0aF9tbQAAAJb///8AAAEAaP///wAAAQMQAAAAIAAAAAQAAAAAAAAADwAAAGN1bG1lbl9kZXB0aF9tbQDK////AAABAJz///8AAAEDEAAAACgAAAAEAAAAAAAAABAAAABjdWxtZW5fbGVuZ3RoX21tAAAGAAgABgAGAAAAAAABANj///8AAAEFEAAAABgAAAAEAAAAAAAAAAYAAABpc2xhbmQAAMj///8QABQACAAGAAcADAAAABAAEAAAAAAAAQUQAAAAHAAAAAQAAAAAAAAABwAAAHNwZWNpZXMABAAEAAQAAADYAQAAQVJST1cx","encoding":"base64","path":["spec","data",0]}],"model_module":"anywidget","model_module_version":"0.2.0","model_name":"AnyModel","state":{"_anywidget_id":"pyobsplot.widget.Obsplot","_css":"/* js/styles.css */\n.counter-button {\n  background-color: #ea580c;\n}\n.counter-button:hover {\n  background-color: #0000FF;\n}\n.pyobsplot-plot {\n  color: #000;\n  background-color: white;\n}\n.pyobsplot-error {\n  color: #CC0000;\n  padding-left: 1em;\n}\n.pyobsplot-error::before {\n  content: \"\\26a0  \";\n}\n","_dom_classes":[],"_esm":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/binary-search-bounds/search-bounds.js\nvar require_search_bounds = __commonJS({\n  \"node_modules/binary-search-bounds/search-bounds.js\"(exports, module) {\n    \"use strict\";\n    function ge(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p >= 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function gt(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p > 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function lt(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p < 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function le(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p <= 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function eq(a4, y4, c6, l, h) {\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p === 0) {\n          return m3;\n        }\n        if (p <= 0) {\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return -1;\n    }\n    function norm(a4, y4, c6, l, h, f) {\n      if (typeof c6 === \"function\") {\n        return f(a4, y4, c6, l === void 0 ? 0 : l | 0, h === void 0 ? a4.length - 1 : h | 0);\n      }\n      return f(a4, y4, void 0, c6 === void 0 ? 0 : c6 | 0, l === void 0 ? a4.length - 1 : l | 0);\n    }\n    module.exports = {\n      ge: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, ge);\n      },\n      gt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, gt);\n      },\n      lt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, lt);\n      },\n      le: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, le);\n      },\n      eq: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, eq);\n      }\n    };\n  }\n});\n\n// node_modules/interval-tree-1d/interval-tree.js\nvar require_interval_tree = __commonJS({\n  \"node_modules/interval-tree-1d/interval-tree.js\"(exports, module) {\n    \"use strict\";\n    var bounds = require_search_bounds();\n    var NOT_FOUND = 0;\n    var SUCCESS = 1;\n    var EMPTY = 2;\n    module.exports = createWrapper;\n    function IntervalTreeNode(mid3, left2, right2, leftPoints, rightPoints) {\n      this.mid = mid3;\n      this.left = left2;\n      this.right = right2;\n      this.leftPoints = leftPoints;\n      this.rightPoints = rightPoints;\n      this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;\n    }\n    var proto = IntervalTreeNode.prototype;\n    function copy3(a4, b) {\n      a4.mid = b.mid;\n      a4.left = b.left;\n      a4.right = b.right;\n      a4.leftPoints = b.leftPoints;\n      a4.rightPoints = b.rightPoints;\n      a4.count = b.count;\n    }\n    function rebuild(node, intervals) {\n      var ntree = createIntervalTree(intervals);\n      node.mid = ntree.mid;\n      node.left = ntree.left;\n      node.right = ntree.right;\n      node.leftPoints = ntree.leftPoints;\n      node.rightPoints = ntree.rightPoints;\n      node.count = ntree.count;\n    }\n    function rebuildWithInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      intervals.push(interval2);\n      rebuild(node, intervals);\n    }\n    function rebuildWithoutInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      var idx = intervals.indexOf(interval2);\n      if (idx < 0) {\n        return NOT_FOUND;\n      }\n      intervals.splice(idx, 1);\n      rebuild(node, intervals);\n      return SUCCESS;\n    }\n    proto.intervals = function(result) {\n      result.push.apply(result, this.leftPoints);\n      if (this.left) {\n        this.left.intervals(result);\n      }\n      if (this.right) {\n        this.right.intervals(result);\n      }\n      return result;\n    };\n    proto.insert = function(interval2) {\n      var weight = this.count - this.leftPoints.length;\n      this.count += 1;\n      if (interval2[1] < this.mid) {\n        if (this.left) {\n          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.left.insert(interval2);\n          }\n        } else {\n          this.left = createIntervalTree([interval2]);\n        }\n      } else if (interval2[0] > this.mid) {\n        if (this.right) {\n          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.right.insert(interval2);\n          }\n        } else {\n          this.right = createIntervalTree([interval2]);\n        }\n      } else {\n        var l = bounds.ge(this.leftPoints, interval2, compareBegin);\n        var r = bounds.ge(this.rightPoints, interval2, compareEnd);\n        this.leftPoints.splice(l, 0, interval2);\n        this.rightPoints.splice(r, 0, interval2);\n      }\n    };\n    proto.remove = function(interval2) {\n      var weight = this.count - this.leftPoints;\n      if (interval2[1] < this.mid) {\n        if (!this.left) {\n          return NOT_FOUND;\n        }\n        var rw = this.right ? this.right.count : 0;\n        if (4 * rw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.left.remove(interval2);\n        if (r === EMPTY) {\n          this.left = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else if (interval2[0] > this.mid) {\n        if (!this.right) {\n          return NOT_FOUND;\n        }\n        var lw = this.left ? this.left.count : 0;\n        if (4 * lw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.right.remove(interval2);\n        if (r === EMPTY) {\n          this.right = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else {\n        if (this.count === 1) {\n          if (this.leftPoints[0] === interval2) {\n            return EMPTY;\n          } else {\n            return NOT_FOUND;\n          }\n        }\n        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {\n          if (this.left && this.right) {\n            var p = this;\n            var n = this.left;\n            while (n.right) {\n              p = n;\n              n = n.right;\n            }\n            if (p === this) {\n              n.right = this.right;\n            } else {\n              var l = this.left;\n              var r = this.right;\n              p.count -= n.count;\n              p.right = n.left;\n              n.left = l;\n              n.right = r;\n            }\n            copy3(this, n);\n            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\n          } else if (this.left) {\n            copy3(this, this.left);\n          } else {\n            copy3(this, this.right);\n          }\n          return SUCCESS;\n        }\n        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {\n          if (this.leftPoints[l][0] !== interval2[0]) {\n            break;\n          }\n          if (this.leftPoints[l] === interval2) {\n            this.count -= 1;\n            this.leftPoints.splice(l, 1);\n            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {\n              if (this.rightPoints[r][1] !== interval2[1]) {\n                break;\n              } else if (this.rightPoints[r] === interval2) {\n                this.rightPoints.splice(r, 1);\n                return SUCCESS;\n              }\n            }\n          }\n        }\n        return NOT_FOUND;\n      }\n    };\n    function reportLeftRange(arr, hi, cb) {\n      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRightRange(arr, lo, cb) {\n      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRange(arr, cb) {\n      for (var i = 0; i < arr.length; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    proto.queryPoint = function(x4, cb) {\n      if (x4 < this.mid) {\n        if (this.left) {\n          var r = this.left.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportLeftRange(this.leftPoints, x4, cb);\n      } else if (x4 > this.mid) {\n        if (this.right) {\n          var r = this.right.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportRightRange(this.rightPoints, x4, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    proto.queryInterval = function(lo, hi, cb) {\n      if (lo < this.mid && this.left) {\n        var r = this.left.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi > this.mid && this.right) {\n        var r = this.right.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi < this.mid) {\n        return reportLeftRange(this.leftPoints, hi, cb);\n      } else if (lo > this.mid) {\n        return reportRightRange(this.rightPoints, lo, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    function compareNumbers(a4, b) {\n      return a4 - b;\n    }\n    function compareBegin(a4, b) {\n      var d = a4[0] - b[0];\n      if (d) {\n        return d;\n      }\n      return a4[1] - b[1];\n    }\n    function compareEnd(a4, b) {\n      var d = a4[1] - b[1];\n      if (d) {\n        return d;\n      }\n      return a4[0] - b[0];\n    }\n    function createIntervalTree(intervals) {\n      if (intervals.length === 0) {\n        return null;\n      }\n      var pts = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        pts.push(intervals[i][0], intervals[i][1]);\n      }\n      pts.sort(compareNumbers);\n      var mid3 = pts[pts.length >> 1];\n      var leftIntervals = [];\n      var rightIntervals = [];\n      var centerIntervals = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        var s2 = intervals[i];\n        if (s2[1] < mid3) {\n          leftIntervals.push(s2);\n        } else if (mid3 < s2[0]) {\n          rightIntervals.push(s2);\n        } else {\n          centerIntervals.push(s2);\n        }\n      }\n      var leftPoints = centerIntervals;\n      var rightPoints = centerIntervals.slice();\n      leftPoints.sort(compareBegin);\n      rightPoints.sort(compareEnd);\n      return new IntervalTreeNode(\n        mid3,\n        createIntervalTree(leftIntervals),\n        createIntervalTree(rightIntervals),\n        leftPoints,\n        rightPoints\n      );\n    }\n    function IntervalTree2(root3) {\n      this.root = root3;\n    }\n    var tproto = IntervalTree2.prototype;\n    tproto.insert = function(interval2) {\n      if (this.root) {\n        this.root.insert(interval2);\n      } else {\n        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);\n      }\n    };\n    tproto.remove = function(interval2) {\n      if (this.root) {\n        var r = this.root.remove(interval2);\n        if (r === EMPTY) {\n          this.root = null;\n        }\n        return r !== NOT_FOUND;\n      }\n      return false;\n    };\n    tproto.queryPoint = function(p, cb) {\n      if (this.root) {\n        return this.root.queryPoint(p, cb);\n      }\n    };\n    tproto.queryInterval = function(lo, hi, cb) {\n      if (lo <= hi && this.root) {\n        return this.root.queryInterval(lo, hi, cb);\n      }\n    };\n    Object.defineProperty(tproto, \"count\", {\n      get: function() {\n        if (this.root) {\n          return this.root.count;\n        }\n        return 0;\n      }\n    });\n    Object.defineProperty(tproto, \"intervals\", {\n      get: function() {\n        if (this.root) {\n          return this.root.intervals([]);\n        }\n        return [];\n      }\n    });\n    function createWrapper(intervals) {\n      if (!intervals || intervals.length === 0) {\n        return new IntervalTree2(null);\n      }\n      return new IntervalTree2(createIntervalTree(intervals));\n    }\n  }\n});\n\n// node_modules/@observablehq/plot/dist/index.js\nvar dist_exports = {};\n__export(dist_exports, {\n  Area: () => Area,\n  Arrow: () => Arrow,\n  BarX: () => BarX,\n  BarY: () => BarY,\n  Cell: () => Cell,\n  Contour: () => Contour,\n  Density: () => Density,\n  Dot: () => Dot,\n  Frame: () => Frame,\n  Geo: () => Geo,\n  Hexgrid: () => Hexgrid,\n  Image: () => Image2,\n  Line: () => Line,\n  Link: () => Link,\n  Mark: () => Mark,\n  Raster: () => Raster,\n  Rect: () => Rect,\n  RuleX: () => RuleX,\n  RuleY: () => RuleY,\n  Text: () => Text,\n  TickX: () => TickX,\n  TickY: () => TickY,\n  Vector: () => Vector,\n  area: () => area,\n  areaX: () => areaX,\n  areaY: () => areaY,\n  arrow: () => arrow,\n  auto: () => auto,\n  autoSpec: () => autoSpec,\n  axisFx: () => axisFx,\n  axisFy: () => axisFy,\n  axisX: () => axisX,\n  axisY: () => axisY,\n  barX: () => barX,\n  barY: () => barY,\n  bin: () => bin2,\n  binX: () => binX,\n  binY: () => binY,\n  boxX: () => boxX,\n  boxY: () => boxY,\n  cell: () => cell,\n  cellX: () => cellX,\n  cellY: () => cellY,\n  centroid: () => centroid,\n  circle: () => circle,\n  cluster: () => cluster,\n  column: () => column,\n  contour: () => contour,\n  delaunayLink: () => delaunayLink,\n  delaunayMesh: () => delaunayMesh,\n  density: () => density,\n  dodgeX: () => dodgeX,\n  dodgeY: () => dodgeY,\n  dot: () => dot,\n  dotX: () => dotX,\n  dotY: () => dotY,\n  filter: () => filter3,\n  formatIsoDate: () => formatIsoDate,\n  formatMonth: () => formatMonth,\n  formatWeekday: () => formatWeekday,\n  frame: () => frame2,\n  geo: () => geo,\n  geoCentroid: () => geoCentroid,\n  graticule: () => graticule2,\n  gridFx: () => gridFx,\n  gridFy: () => gridFy,\n  gridX: () => gridX,\n  gridY: () => gridY,\n  group: () => group2,\n  groupX: () => groupX,\n  groupY: () => groupY,\n  groupZ: () => groupZ,\n  hexagon: () => hexagon,\n  hexbin: () => hexbin,\n  hexgrid: () => hexgrid,\n  hull: () => hull,\n  identity: () => identity6,\n  image: () => image,\n  initializer: () => initializer,\n  interpolateNearest: () => interpolateNearest,\n  interpolateNone: () => interpolateNone,\n  interpolatorBarycentric: () => interpolatorBarycentric,\n  interpolatorRandomWalk: () => interpolatorRandomWalk,\n  legend: () => legend,\n  line: () => line,\n  lineX: () => lineX,\n  lineY: () => lineY,\n  linearRegressionX: () => linearRegressionX,\n  linearRegressionY: () => linearRegressionY,\n  link: () => link3,\n  map: () => map5,\n  mapX: () => mapX,\n  mapY: () => mapY,\n  marks: () => marks,\n  normalize: () => normalize3,\n  normalizeX: () => normalizeX,\n  normalizeY: () => normalizeY,\n  plot: () => plot,\n  raster: () => raster,\n  rect: () => rect,\n  rectX: () => rectX,\n  rectY: () => rectY,\n  reverse: () => reverse2,\n  ruleX: () => ruleX,\n  ruleY: () => ruleY,\n  scale: () => scale2,\n  select: () => select,\n  selectFirst: () => selectFirst,\n  selectLast: () => selectLast,\n  selectMaxX: () => selectMaxX,\n  selectMaxY: () => selectMaxY,\n  selectMinX: () => selectMinX,\n  selectMinY: () => selectMinY,\n  shuffle: () => shuffle2,\n  sort: () => sort2,\n  sphere: () => sphere,\n  spike: () => spike,\n  stackX: () => stackX,\n  stackX1: () => stackX1,\n  stackX2: () => stackX2,\n  stackY: () => stackY,\n  stackY1: () => stackY1,\n  stackY2: () => stackY2,\n  text: () => text,\n  textX: () => textX,\n  textY: () => textY,\n  tickX: () => tickX,\n  tickY: () => tickY,\n  transform: () => basic,\n  tree: () => tree,\n  treeLink: () => treeLink,\n  treeNode: () => treeNode,\n  valueof: () => valueof,\n  vector: () => vector,\n  vectorX: () => vectorX,\n  vectorY: () => vectorY,\n  voronoi: () => voronoi,\n  voronoiMesh: () => voronoiMesh,\n  window: () => window2,\n  windowX: () => windowX,\n  windowY: () => windowY\n});\n\n// node_modules/d3/src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  Adder: () => Adder,\n  Delaunay: () => Delaunay,\n  FormatSpecifier: () => FormatSpecifier,\n  InternMap: () => InternMap,\n  InternSet: () => InternSet,\n  Node: () => Node2,\n  Path: () => Path,\n  Voronoi: () => Voronoi,\n  ZoomTransform: () => Transform,\n  active: () => active_default,\n  arc: () => arc_default,\n  area: () => area_default5,\n  areaRadial: () => areaRadial_default,\n  ascending: () => ascending,\n  autoType: () => autoType,\n  axisBottom: () => axisBottom,\n  axisLeft: () => axisLeft,\n  axisRight: () => axisRight,\n  axisTop: () => axisTop,\n  bin: () => bin,\n  bisect: () => bisect_default,\n  bisectCenter: () => bisectCenter,\n  bisectLeft: () => bisectLeft,\n  bisectRight: () => bisectRight,\n  bisector: () => bisector,\n  blob: () => blob_default,\n  blur: () => blur,\n  blur2: () => blur2,\n  blurImage: () => blurImage,\n  brush: () => brush_default,\n  brushSelection: () => brushSelection,\n  brushX: () => brushX,\n  brushY: () => brushY,\n  buffer: () => buffer_default,\n  chord: () => chord_default,\n  chordDirected: () => chordDirected,\n  chordTranspose: () => chordTranspose,\n  cluster: () => cluster_default,\n  color: () => color,\n  contourDensity: () => density_default,\n  contours: () => contours_default,\n  count: () => count,\n  create: () => create_default,\n  creator: () => creator_default,\n  cross: () => cross,\n  csv: () => csv2,\n  csvFormat: () => csvFormat,\n  csvFormatBody: () => csvFormatBody,\n  csvFormatRow: () => csvFormatRow,\n  csvFormatRows: () => csvFormatRows,\n  csvFormatValue: () => csvFormatValue,\n  csvParse: () => csvParse,\n  csvParseRows: () => csvParseRows,\n  cubehelix: () => cubehelix,\n  cumsum: () => cumsum,\n  curveBasis: () => basis_default2,\n  curveBasisClosed: () => basisClosed_default2,\n  curveBasisOpen: () => basisOpen_default,\n  curveBumpX: () => bumpX,\n  curveBumpY: () => bumpY,\n  curveBundle: () => bundle_default,\n  curveCardinal: () => cardinal_default,\n  curveCardinalClosed: () => cardinalClosed_default,\n  curveCardinalOpen: () => cardinalOpen_default,\n  curveCatmullRom: () => catmullRom_default,\n  curveCatmullRomClosed: () => catmullRomClosed_default,\n  curveCatmullRomOpen: () => catmullRomOpen_default,\n  curveLinear: () => linear_default,\n  curveLinearClosed: () => linearClosed_default,\n  curveMonotoneX: () => monotoneX,\n  curveMonotoneY: () => monotoneY,\n  curveNatural: () => natural_default,\n  curveStep: () => step_default,\n  curveStepAfter: () => stepAfter,\n  curveStepBefore: () => stepBefore,\n  descending: () => descending,\n  deviation: () => deviation,\n  difference: () => difference,\n  disjoint: () => disjoint,\n  dispatch: () => dispatch_default,\n  drag: () => drag_default,\n  dragDisable: () => nodrag_default,\n  dragEnable: () => yesdrag,\n  dsv: () => dsv,\n  dsvFormat: () => dsv_default,\n  easeBack: () => backInOut,\n  easeBackIn: () => backIn,\n  easeBackInOut: () => backInOut,\n  easeBackOut: () => backOut,\n  easeBounce: () => bounceOut,\n  easeBounceIn: () => bounceIn,\n  easeBounceInOut: () => bounceInOut,\n  easeBounceOut: () => bounceOut,\n  easeCircle: () => circleInOut,\n  easeCircleIn: () => circleIn,\n  easeCircleInOut: () => circleInOut,\n  easeCircleOut: () => circleOut,\n  easeCubic: () => cubicInOut,\n  easeCubicIn: () => cubicIn,\n  easeCubicInOut: () => cubicInOut,\n  easeCubicOut: () => cubicOut,\n  easeElastic: () => elasticOut,\n  easeElasticIn: () => elasticIn,\n  easeElasticInOut: () => elasticInOut,\n  easeElasticOut: () => elasticOut,\n  easeExp: () => expInOut,\n  easeExpIn: () => expIn,\n  easeExpInOut: () => expInOut,\n  easeExpOut: () => expOut,\n  easeLinear: () => linear2,\n  easePoly: () => polyInOut,\n  easePolyIn: () => polyIn,\n  easePolyInOut: () => polyInOut,\n  easePolyOut: () => polyOut,\n  easeQuad: () => quadInOut,\n  easeQuadIn: () => quadIn,\n  easeQuadInOut: () => quadInOut,\n  easeQuadOut: () => quadOut,\n  easeSin: () => sinInOut,\n  easeSinIn: () => sinIn,\n  easeSinInOut: () => sinInOut,\n  easeSinOut: () => sinOut,\n  every: () => every,\n  extent: () => extent,\n  fcumsum: () => fcumsum,\n  filter: () => filter,\n  flatGroup: () => flatGroup,\n  flatRollup: () => flatRollup,\n  forceCenter: () => center_default,\n  forceCollide: () => collide_default,\n  forceLink: () => link_default,\n  forceManyBody: () => manyBody_default,\n  forceRadial: () => radial_default,\n  forceSimulation: () => simulation_default,\n  forceX: () => x_default2,\n  forceY: () => y_default2,\n  format: () => format,\n  formatDefaultLocale: () => defaultLocale,\n  formatLocale: () => locale_default,\n  formatPrefix: () => formatPrefix,\n  formatSpecifier: () => formatSpecifier,\n  fsum: () => fsum,\n  geoAlbers: () => albers_default,\n  geoAlbersUsa: () => albersUsa_default,\n  geoArea: () => area_default2,\n  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,\n  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,\n  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,\n  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,\n  geoBounds: () => bounds_default,\n  geoCentroid: () => centroid_default,\n  geoCircle: () => circle_default,\n  geoClipAntimeridian: () => antimeridian_default,\n  geoClipCircle: () => circle_default2,\n  geoClipExtent: () => extent_default2,\n  geoClipRectangle: () => clipRectangle,\n  geoConicConformal: () => conicConformal_default,\n  geoConicConformalRaw: () => conicConformalRaw,\n  geoConicEqualArea: () => conicEqualArea_default,\n  geoConicEqualAreaRaw: () => conicEqualAreaRaw,\n  geoConicEquidistant: () => conicEquidistant_default,\n  geoConicEquidistantRaw: () => conicEquidistantRaw,\n  geoContains: () => contains_default2,\n  geoDistance: () => distance_default,\n  geoEqualEarth: () => equalEarth_default,\n  geoEqualEarthRaw: () => equalEarthRaw,\n  geoEquirectangular: () => equirectangular_default,\n  geoEquirectangularRaw: () => equirectangularRaw,\n  geoGnomonic: () => gnomonic_default,\n  geoGnomonicRaw: () => gnomonicRaw,\n  geoGraticule: () => graticule,\n  geoGraticule10: () => graticule10,\n  geoIdentity: () => identity_default4,\n  geoInterpolate: () => interpolate_default2,\n  geoLength: () => length_default,\n  geoMercator: () => mercator_default,\n  geoMercatorRaw: () => mercatorRaw,\n  geoNaturalEarth1: () => naturalEarth1_default,\n  geoNaturalEarth1Raw: () => naturalEarth1Raw,\n  geoOrthographic: () => orthographic_default,\n  geoOrthographicRaw: () => orthographicRaw,\n  geoPath: () => path_default,\n  geoProjection: () => projection,\n  geoProjectionMutator: () => projectionMutator,\n  geoRotation: () => rotation_default,\n  geoStereographic: () => stereographic_default,\n  geoStereographicRaw: () => stereographicRaw,\n  geoStream: () => stream_default,\n  geoTransform: () => transform_default,\n  geoTransverseMercator: () => transverseMercator_default,\n  geoTransverseMercatorRaw: () => transverseMercatorRaw,\n  gray: () => gray,\n  greatest: () => greatest,\n  greatestIndex: () => greatestIndex,\n  group: () => group,\n  groupSort: () => groupSort,\n  groups: () => groups,\n  hcl: () => hcl,\n  hierarchy: () => hierarchy,\n  histogram: () => bin,\n  hsl: () => hsl,\n  html: () => html,\n  image: () => image_default,\n  index: () => index,\n  indexes: () => indexes,\n  interpolate: () => value_default,\n  interpolateArray: () => array_default,\n  interpolateBasis: () => basis_default,\n  interpolateBasisClosed: () => basisClosed_default,\n  interpolateBlues: () => Blues_default,\n  interpolateBrBG: () => BrBG_default,\n  interpolateBuGn: () => BuGn_default,\n  interpolateBuPu: () => BuPu_default,\n  interpolateCividis: () => cividis_default,\n  interpolateCool: () => cool,\n  interpolateCubehelix: () => cubehelix_default,\n  interpolateCubehelixDefault: () => cubehelix_default2,\n  interpolateCubehelixLong: () => cubehelixLong,\n  interpolateDate: () => date_default,\n  interpolateDiscrete: () => discrete_default,\n  interpolateGnBu: () => GnBu_default,\n  interpolateGreens: () => Greens_default,\n  interpolateGreys: () => Greys_default,\n  interpolateHcl: () => hcl_default,\n  interpolateHclLong: () => hclLong,\n  interpolateHsl: () => hsl_default,\n  interpolateHslLong: () => hslLong,\n  interpolateHue: () => hue_default,\n  interpolateInferno: () => inferno,\n  interpolateLab: () => lab2,\n  interpolateMagma: () => magma,\n  interpolateNumber: () => number_default,\n  interpolateNumberArray: () => numberArray_default,\n  interpolateObject: () => object_default,\n  interpolateOrRd: () => OrRd_default,\n  interpolateOranges: () => Oranges_default,\n  interpolatePRGn: () => PRGn_default,\n  interpolatePiYG: () => PiYG_default,\n  interpolatePlasma: () => plasma,\n  interpolatePuBu: () => PuBu_default,\n  interpolatePuBuGn: () => PuBuGn_default,\n  interpolatePuOr: () => PuOr_default,\n  interpolatePuRd: () => PuRd_default,\n  interpolatePurples: () => Purples_default,\n  interpolateRainbow: () => rainbow_default,\n  interpolateRdBu: () => RdBu_default,\n  interpolateRdGy: () => RdGy_default,\n  interpolateRdPu: () => RdPu_default,\n  interpolateRdYlBu: () => RdYlBu_default,\n  interpolateRdYlGn: () => RdYlGn_default,\n  interpolateReds: () => Reds_default,\n  interpolateRgb: () => rgb_default,\n  interpolateRgbBasis: () => rgbBasis,\n  interpolateRgbBasisClosed: () => rgbBasisClosed,\n  interpolateRound: () => round_default,\n  interpolateSinebow: () => sinebow_default,\n  interpolateSpectral: () => Spectral_default,\n  interpolateString: () => string_default,\n  interpolateTransformCss: () => interpolateTransformCss,\n  interpolateTransformSvg: () => interpolateTransformSvg,\n  interpolateTurbo: () => turbo_default,\n  interpolateViridis: () => viridis_default,\n  interpolateWarm: () => warm,\n  interpolateYlGn: () => YlGn_default,\n  interpolateYlGnBu: () => YlGnBu_default,\n  interpolateYlOrBr: () => YlOrBr_default,\n  interpolateYlOrRd: () => YlOrRd_default,\n  interpolateZoom: () => zoom_default,\n  interrupt: () => interrupt_default,\n  intersection: () => intersection,\n  interval: () => interval_default,\n  isoFormat: () => isoFormat_default,\n  isoParse: () => isoParse_default,\n  json: () => json_default,\n  lab: () => lab,\n  lch: () => lch,\n  least: () => least,\n  leastIndex: () => leastIndex,\n  line: () => line_default2,\n  lineRadial: () => lineRadial_default,\n  link: () => link2,\n  linkHorizontal: () => linkHorizontal,\n  linkRadial: () => linkRadial,\n  linkVertical: () => linkVertical,\n  local: () => local,\n  map: () => map2,\n  matcher: () => matcher_default,\n  max: () => max,\n  maxIndex: () => maxIndex,\n  mean: () => mean,\n  median: () => median,\n  medianIndex: () => medianIndex,\n  merge: () => merge,\n  min: () => min,\n  minIndex: () => minIndex,\n  mode: () => mode,\n  namespace: () => namespace_default,\n  namespaces: () => namespaces_default,\n  nice: () => nice,\n  now: () => now,\n  pack: () => pack_default,\n  packEnclose: () => enclose_default,\n  packSiblings: () => siblings_default,\n  pairs: () => pairs,\n  partition: () => partition_default,\n  path: () => path,\n  pathRound: () => pathRound,\n  permute: () => permute,\n  pie: () => pie_default,\n  piecewise: () => piecewise,\n  pointRadial: () => pointRadial_default,\n  pointer: () => pointer_default,\n  pointers: () => pointers_default,\n  polygonArea: () => area_default4,\n  polygonCentroid: () => centroid_default3,\n  polygonContains: () => contains_default3,\n  polygonHull: () => hull_default,\n  polygonLength: () => length_default2,\n  precisionFixed: () => precisionFixed_default,\n  precisionPrefix: () => precisionPrefix_default,\n  precisionRound: () => precisionRound_default,\n  quadtree: () => quadtree,\n  quantile: () => quantile,\n  quantileIndex: () => quantileIndex,\n  quantileSorted: () => quantileSorted,\n  quantize: () => quantize_default,\n  quickselect: () => quickselect,\n  radialArea: () => areaRadial_default,\n  radialLine: () => lineRadial_default,\n  randomBates: () => bates_default,\n  randomBernoulli: () => bernoulli_default,\n  randomBeta: () => beta_default,\n  randomBinomial: () => binomial_default,\n  randomCauchy: () => cauchy_default,\n  randomExponential: () => exponential_default,\n  randomGamma: () => gamma_default,\n  randomGeometric: () => geometric_default,\n  randomInt: () => int_default,\n  randomIrwinHall: () => irwinHall_default,\n  randomLcg: () => lcg,\n  randomLogNormal: () => logNormal_default,\n  randomLogistic: () => logistic_default,\n  randomNormal: () => normal_default,\n  randomPareto: () => pareto_default,\n  randomPoisson: () => poisson_default,\n  randomUniform: () => uniform_default,\n  randomWeibull: () => weibull_default,\n  range: () => range,\n  rank: () => rank,\n  reduce: () => reduce,\n  reverse: () => reverse,\n  rgb: () => rgb,\n  ribbon: () => ribbon_default,\n  ribbonArrow: () => ribbonArrow,\n  rollup: () => rollup,\n  rollups: () => rollups,\n  scaleBand: () => band,\n  scaleDiverging: () => diverging,\n  scaleDivergingLog: () => divergingLog,\n  scaleDivergingPow: () => divergingPow,\n  scaleDivergingSqrt: () => divergingSqrt,\n  scaleDivergingSymlog: () => divergingSymlog,\n  scaleIdentity: () => identity4,\n  scaleImplicit: () => implicit,\n  scaleLinear: () => linear3,\n  scaleLog: () => log2,\n  scaleOrdinal: () => ordinal,\n  scalePoint: () => point,\n  scalePow: () => pow3,\n  scaleQuantile: () => quantile2,\n  scaleQuantize: () => quantize,\n  scaleRadial: () => radial,\n  scaleSequential: () => sequential,\n  scaleSequentialLog: () => sequentialLog,\n  scaleSequentialPow: () => sequentialPow,\n  scaleSequentialQuantile: () => sequentialQuantile,\n  scaleSequentialSqrt: () => sequentialSqrt,\n  scaleSequentialSymlog: () => sequentialSymlog,\n  scaleSqrt: () => sqrt2,\n  scaleSymlog: () => symlog,\n  scaleThreshold: () => threshold,\n  scaleTime: () => time,\n  scaleUtc: () => utcTime,\n  scan: () => scan,\n  schemeAccent: () => Accent_default,\n  schemeBlues: () => scheme22,\n  schemeBrBG: () => scheme,\n  schemeBuGn: () => scheme10,\n  schemeBuPu: () => scheme11,\n  schemeCategory10: () => category10_default,\n  schemeDark2: () => Dark2_default,\n  schemeGnBu: () => scheme12,\n  schemeGreens: () => scheme23,\n  schemeGreys: () => scheme24,\n  schemeOrRd: () => scheme13,\n  schemeOranges: () => scheme27,\n  schemePRGn: () => scheme2,\n  schemePaired: () => Paired_default,\n  schemePastel1: () => Pastel1_default,\n  schemePastel2: () => Pastel2_default,\n  schemePiYG: () => scheme3,\n  schemePuBu: () => scheme15,\n  schemePuBuGn: () => scheme14,\n  schemePuOr: () => scheme4,\n  schemePuRd: () => scheme16,\n  schemePurples: () => scheme25,\n  schemeRdBu: () => scheme5,\n  schemeRdGy: () => scheme6,\n  schemeRdPu: () => scheme17,\n  schemeRdYlBu: () => scheme7,\n  schemeRdYlGn: () => scheme8,\n  schemeReds: () => scheme26,\n  schemeSet1: () => Set1_default,\n  schemeSet2: () => Set2_default,\n  schemeSet3: () => Set3_default,\n  schemeSpectral: () => scheme9,\n  schemeTableau10: () => Tableau10_default,\n  schemeYlGn: () => scheme19,\n  schemeYlGnBu: () => scheme18,\n  schemeYlOrBr: () => scheme20,\n  schemeYlOrRd: () => scheme21,\n  select: () => select_default2,\n  selectAll: () => selectAll_default2,\n  selection: () => selection_default,\n  selector: () => selector_default,\n  selectorAll: () => selectorAll_default,\n  shuffle: () => shuffle_default,\n  shuffler: () => shuffler,\n  some: () => some,\n  sort: () => sort,\n  stack: () => stack_default,\n  stackOffsetDiverging: () => diverging_default,\n  stackOffsetExpand: () => expand_default,\n  stackOffsetNone: () => none_default,\n  stackOffsetSilhouette: () => silhouette_default,\n  stackOffsetWiggle: () => wiggle_default,\n  stackOrderAppearance: () => appearance_default,\n  stackOrderAscending: () => ascending_default2,\n  stackOrderDescending: () => descending_default2,\n  stackOrderInsideOut: () => insideOut_default,\n  stackOrderNone: () => none_default2,\n  stackOrderReverse: () => reverse_default,\n  stratify: () => stratify_default,\n  style: () => styleValue,\n  subset: () => subset,\n  sum: () => sum,\n  superset: () => superset,\n  svg: () => svg,\n  symbol: () => Symbol2,\n  symbolAsterisk: () => asterisk_default,\n  symbolCircle: () => circle_default3,\n  symbolCross: () => cross_default2,\n  symbolDiamond: () => diamond_default,\n  symbolDiamond2: () => diamond2_default,\n  symbolPlus: () => plus_default,\n  symbolSquare: () => square_default,\n  symbolSquare2: () => square2_default,\n  symbolStar: () => star_default,\n  symbolTimes: () => times_default,\n  symbolTriangle: () => triangle_default,\n  symbolTriangle2: () => triangle2_default,\n  symbolWye: () => wye_default,\n  symbolX: () => times_default,\n  symbols: () => symbolsFill,\n  symbolsFill: () => symbolsFill,\n  symbolsStroke: () => symbolsStroke,\n  text: () => text_default3,\n  thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,\n  thresholdScott: () => thresholdScott,\n  thresholdSturges: () => thresholdSturges,\n  tickFormat: () => tickFormat,\n  tickIncrement: () => tickIncrement,\n  tickStep: () => tickStep,\n  ticks: () => ticks,\n  timeDay: () => timeDay,\n  timeDays: () => timeDays,\n  timeFormat: () => timeFormat,\n  timeFormatDefaultLocale: () => defaultLocale2,\n  timeFormatLocale: () => formatLocale,\n  timeFriday: () => timeFriday,\n  timeFridays: () => timeFridays,\n  timeHour: () => timeHour,\n  timeHours: () => timeHours,\n  timeInterval: () => timeInterval,\n  timeMillisecond: () => millisecond,\n  timeMilliseconds: () => milliseconds,\n  timeMinute: () => timeMinute,\n  timeMinutes: () => timeMinutes,\n  timeMonday: () => timeMonday,\n  timeMondays: () => timeMondays,\n  timeMonth: () => timeMonth,\n  timeMonths: () => timeMonths,\n  timeParse: () => timeParse,\n  timeSaturday: () => timeSaturday,\n  timeSaturdays: () => timeSaturdays,\n  timeSecond: () => second,\n  timeSeconds: () => seconds,\n  timeSunday: () => timeSunday,\n  timeSundays: () => timeSundays,\n  timeThursday: () => timeThursday,\n  timeThursdays: () => timeThursdays,\n  timeTickInterval: () => timeTickInterval,\n  timeTicks: () => timeTicks,\n  timeTuesday: () => timeTuesday,\n  timeTuesdays: () => timeTuesdays,\n  timeWednesday: () => timeWednesday,\n  timeWednesdays: () => timeWednesdays,\n  timeWeek: () => timeSunday,\n  timeWeeks: () => timeSundays,\n  timeYear: () => timeYear,\n  timeYears: () => timeYears,\n  timeout: () => timeout_default,\n  timer: () => timer,\n  timerFlush: () => timerFlush,\n  transition: () => transition,\n  transpose: () => transpose,\n  tree: () => tree_default,\n  treemap: () => treemap_default,\n  treemapBinary: () => binary_default,\n  treemapDice: () => dice_default,\n  treemapResquarify: () => resquarify_default,\n  treemapSlice: () => slice_default,\n  treemapSliceDice: () => sliceDice_default,\n  treemapSquarify: () => squarify_default,\n  tsv: () => tsv2,\n  tsvFormat: () => tsvFormat,\n  tsvFormatBody: () => tsvFormatBody,\n  tsvFormatRow: () => tsvFormatRow,\n  tsvFormatRows: () => tsvFormatRows,\n  tsvFormatValue: () => tsvFormatValue,\n  tsvParse: () => tsvParse,\n  tsvParseRows: () => tsvParseRows,\n  union: () => union,\n  unixDay: () => unixDay,\n  unixDays: () => unixDays,\n  utcDay: () => utcDay,\n  utcDays: () => utcDays,\n  utcFormat: () => utcFormat,\n  utcFriday: () => utcFriday,\n  utcFridays: () => utcFridays,\n  utcHour: () => utcHour,\n  utcHours: () => utcHours,\n  utcMillisecond: () => millisecond,\n  utcMilliseconds: () => milliseconds,\n  utcMinute: () => utcMinute,\n  utcMinutes: () => utcMinutes,\n  utcMonday: () => utcMonday,\n  utcMondays: () => utcMondays,\n  utcMonth: () => utcMonth,\n  utcMonths: () => utcMonths,\n  utcParse: () => utcParse,\n  utcSaturday: () => utcSaturday,\n  utcSaturdays: () => utcSaturdays,\n  utcSecond: () => second,\n  utcSeconds: () => seconds,\n  utcSunday: () => utcSunday,\n  utcSundays: () => utcSundays,\n  utcThursday: () => utcThursday,\n  utcThursdays: () => utcThursdays,\n  utcTickInterval: () => utcTickInterval,\n  utcTicks: () => utcTicks,\n  utcTuesday: () => utcTuesday,\n  utcTuesdays: () => utcTuesdays,\n  utcWednesday: () => utcWednesday,\n  utcWednesdays: () => utcWednesdays,\n  utcWeek: () => utcSunday,\n  utcWeeks: () => utcSundays,\n  utcYear: () => utcYear,\n  utcYears: () => utcYears,\n  variance: () => variance,\n  window: () => window_default,\n  xml: () => xml_default,\n  zip: () => zip,\n  zoom: () => zoom_default2,\n  zoomIdentity: () => identity5,\n  zoomTransform: () => transform\n});\n\n// node_modules/d3-array/src/ascending.js\nfunction ascending(a4, b) {\n  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/descending.js\nfunction descending(a4, b) {\n  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/bisector.js\nfunction bisector(f) {\n  let compare1, compare2, delta;\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x4) => ascending(f(d), x4);\n    delta = (d, x4) => f(d) - x4;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n  function left2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) < 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function right2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) <= 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function center2(a4, x4, lo = 0, hi = a4.length) {\n    const i = left2(a4, x4, lo, hi - 1);\n    return i > lo && delta(a4[i - 1], x4) > -delta(a4[i], x4) ? i - 1 : i;\n  }\n  return { left: left2, center: center2, right: right2 };\n}\nfunction zero() {\n  return 0;\n}\n\n// node_modules/d3-array/src/number.js\nfunction number(x4) {\n  return x4 === null ? NaN : +x4;\n}\nfunction* numbers(values2, valueof2) {\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n\n// node_modules/d3-array/src/bisect.js\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\nvar bisectCenter = bisector(number).center;\nvar bisect_default = bisectRight;\n\n// node_modules/d3-array/src/blur.js\nfunction blur(values2, r) {\n  if (!((r = +r) >= 0))\n    throw new RangeError(\"invalid r\");\n  let length4 = values2.length;\n  if (!((length4 = Math.floor(length4)) >= 0))\n    throw new RangeError(\"invalid length\");\n  if (!length4 || !r)\n    return values2;\n  const blur3 = blurf(r);\n  const temp = values2.slice();\n  blur3(values2, temp, 0, length4, 1);\n  blur3(temp, values2, 0, length4, 1);\n  blur3(values2, temp, 0, length4, 1);\n  return values2;\n}\nvar blur2 = Blur2(blurf);\nvar blurImage = Blur2(blurfImage);\nfunction Blur2(blur3) {\n  return function(data, rx, ry = rx) {\n    if (!((rx = +rx) >= 0))\n      throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0))\n      throw new RangeError(\"invalid ry\");\n    let { data: values2, width, height } = data;\n    if (!((width = Math.floor(width)) >= 0))\n      throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0))\n      throw new RangeError(\"invalid height\");\n    if (!width || !height || !rx && !ry)\n      return data;\n    const blurx = rx && blur3(rx);\n    const blury = ry && blur3(ry);\n    const temp = values2.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    }\n    return data;\n  };\n}\nfunction blurh(blur3, T, S, w, h) {\n  for (let y4 = 0, n = w * h; y4 < n; ) {\n    blur3(T, S, y4, y4 += w, 1);\n  }\n}\nfunction blurv(blur3, T, S, w, h) {\n  for (let x4 = 0, n = w * h; x4 < w; ++x4) {\n    blur3(T, S, x4, x4 + n, w);\n  }\n}\nfunction blurfImage(radius2) {\n  const blur3 = blurf(radius2);\n  return (T, S, start2, stop, step) => {\n    start2 <<= 2, stop <<= 2, step <<= 2;\n    blur3(T, S, start2 + 0, stop + 0, step);\n    blur3(T, S, start2 + 1, stop + 1, step);\n    blur3(T, S, start2 + 2, stop + 2, step);\n    blur3(T, S, start2 + 3, stop + 3, step);\n  };\n}\nfunction blurf(radius2) {\n  const radius0 = Math.floor(radius2);\n  if (radius0 === radius2)\n    return bluri(radius2);\n  const t = radius2 - radius0;\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius0 * S[start2];\n    const s0 = step * radius0;\n    const s1 = s0 + step;\n    for (let i = start2, j = start2 + s0; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s0)];\n      T[i] = (sum5 + t * (S[Math.max(start2, i - s1)] + S[Math.min(stop, i + s1)])) / w;\n      sum5 -= S[Math.max(start2, i - s0)];\n    }\n  };\n}\nfunction bluri(radius2) {\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius2 * S[start2];\n    const s2 = step * radius2;\n    for (let i = start2, j = start2 + s2; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s2)];\n      T[i] = sum5 / w;\n      sum5 -= S[Math.max(start2, i - s2)];\n    }\n  };\n}\n\n// node_modules/d3-array/src/count.js\nfunction count(values2, valueof2) {\n  let count3 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  }\n  return count3;\n}\n\n// node_modules/d3-array/src/cross.js\nfunction length(array4) {\n  return array4.length | 0;\n}\nfunction empty(length4) {\n  return !(length4 > 0);\n}\nfunction arrayify(values2) {\n  return typeof values2 !== \"object\" || \"length\" in values2 ? values2 : Array.from(values2);\n}\nfunction reducer(reduce2) {\n  return (values2) => reduce2(...values2);\n}\nfunction cross(...values2) {\n  const reduce2 = typeof values2[values2.length - 1] === \"function\" && reducer(values2.pop());\n  values2 = values2.map(arrayify);\n  const lengths = values2.map(length);\n  const j = values2.length - 1;\n  const index3 = new Array(j + 1).fill(0);\n  const product = [];\n  if (j < 0 || lengths.some(empty))\n    return product;\n  while (true) {\n    product.push(index3.map((j2, i2) => values2[i2][j2]));\n    let i = j;\n    while (++index3[i] === lengths[i]) {\n      if (i === 0)\n        return reduce2 ? product.map(reduce2) : product;\n      index3[i--] = 0;\n    }\n  }\n}\n\n// node_modules/d3-array/src/cumsum.js\nfunction cumsum(values2, valueof2) {\n  var sum5 = 0, index3 = 0;\n  return Float64Array.from(values2, valueof2 === void 0 ? (v2) => sum5 += +v2 || 0 : (v2) => sum5 += +valueof2(v2, index3++, values2) || 0);\n}\n\n// node_modules/d3-array/src/variance.js\nfunction variance(values2, valueof2) {\n  let count3 = 0;\n  let delta;\n  let mean2 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  }\n  if (count3 > 1)\n    return sum5 / (count3 - 1);\n}\n\n// node_modules/d3-array/src/deviation.js\nfunction deviation(values2, valueof2) {\n  const v2 = variance(values2, valueof2);\n  return v2 ? Math.sqrt(v2) : v2;\n}\n\n// node_modules/d3-array/src/extent.js\nfunction extent(values2, valueof2) {\n  let min4;\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  }\n  return [min4, max5];\n}\n\n// node_modules/d3-array/src/fsum.js\nvar Adder = class {\n  constructor() {\n    this._partials = new Float64Array(32);\n    this._n = 0;\n  }\n  add(x4) {\n    const p = this._partials;\n    let i = 0;\n    for (let j = 0; j < this._n && j < 32; j++) {\n      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);\n      if (lo)\n        p[i++] = lo;\n      x4 = hi;\n    }\n    p[i] = x4;\n    this._n = i + 1;\n    return this;\n  }\n  valueOf() {\n    const p = this._partials;\n    let n = this._n, x4, y4, lo, hi = 0;\n    if (n > 0) {\n      hi = p[--n];\n      while (n > 0) {\n        x4 = hi;\n        y4 = p[--n];\n        hi = x4 + y4;\n        lo = y4 - (hi - x4);\n        if (lo)\n          break;\n      }\n      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {\n        y4 = lo * 2;\n        x4 = hi + y4;\n        if (y4 == x4 - hi)\n          hi = x4;\n      }\n    }\n    return hi;\n  }\n};\nfunction fsum(values2, valueof2) {\n  const adder = new Adder();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        adder.add(value);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        adder.add(value);\n      }\n    }\n  }\n  return +adder;\n}\nfunction fcumsum(values2, valueof2) {\n  const adder = new Adder();\n  let index3 = -1;\n  return Float64Array.from(\n    values2,\n    valueof2 === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof2(v2, ++index3, values2) || 0)\n  );\n}\n\n// node_modules/internmap/src/index.js\nvar InternMap = class extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (entries != null)\n      for (const [key2, value] of entries)\n        this.set(key2, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n};\nvar InternSet = class extends Set {\n  constructor(values2, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (values2 != null)\n      for (const value of values2)\n        this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n};\nfunction intern_get({ _intern, _key }, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\nfunction intern_set({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key))\n    return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\nfunction intern_delete({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/identity.js\nfunction identity(x4) {\n  return x4;\n}\n\n// node_modules/d3-array/src/group.js\nfunction group(values2, ...keys) {\n  return nest(values2, identity, identity, keys);\n}\nfunction groups(values2, ...keys) {\n  return nest(values2, Array.from, identity, keys);\n}\nfunction flatten(groups2, keys) {\n  for (let i = 1, n = keys.length; i < n; ++i) {\n    groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));\n  }\n  return groups2;\n}\nfunction flatGroup(values2, ...keys) {\n  return flatten(groups(values2, ...keys), keys);\n}\nfunction flatRollup(values2, reduce2, ...keys) {\n  return flatten(rollups(values2, reduce2, ...keys), keys);\n}\nfunction rollup(values2, reduce2, ...keys) {\n  return nest(values2, identity, reduce2, keys);\n}\nfunction rollups(values2, reduce2, ...keys) {\n  return nest(values2, Array.from, reduce2, keys);\n}\nfunction index(values2, ...keys) {\n  return nest(values2, identity, unique, keys);\n}\nfunction indexes(values2, ...keys) {\n  return nest(values2, Array.from, unique, keys);\n}\nfunction unique(values2) {\n  if (values2.length !== 1)\n    throw new Error(\"duplicate key\");\n  return values2[0];\n}\nfunction nest(values2, map6, reduce2, keys) {\n  return function regroup(values3, i) {\n    if (i >= keys.length)\n      return reduce2(values3);\n    const groups2 = new InternMap();\n    const keyof3 = keys[i++];\n    let index3 = -1;\n    for (const value of values3) {\n      const key = keyof3(value, ++index3, values3);\n      const group3 = groups2.get(key);\n      if (group3)\n        group3.push(value);\n      else\n        groups2.set(key, [value]);\n    }\n    for (const [key, values4] of groups2) {\n      groups2.set(key, regroup(values4, i));\n    }\n    return map6(groups2);\n  }(values2, 0);\n}\n\n// node_modules/d3-array/src/permute.js\nfunction permute(source, keys) {\n  return Array.from(keys, (key) => source[key]);\n}\n\n// node_modules/d3-array/src/sort.js\nfunction sort(values2, ...F) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  values2 = Array.from(values2);\n  let [f] = F;\n  if (f && f.length !== 2 || F.length > 1) {\n    const index3 = Uint32Array.from(values2, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map((f2) => values2.map(f2));\n      index3.sort((i, j) => {\n        for (const f2 of F) {\n          const c6 = ascendingDefined(f2[i], f2[j]);\n          if (c6)\n            return c6;\n        }\n      });\n    } else {\n      f = values2.map(f);\n      index3.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values2, index3);\n  }\n  return values2.sort(compareDefined(f));\n}\nfunction compareDefined(compare = ascending) {\n  if (compare === ascending)\n    return ascendingDefined;\n  if (typeof compare !== \"function\")\n    throw new TypeError(\"compare is not a function\");\n  return (a4, b) => {\n    const x4 = compare(a4, b);\n    if (x4 || x4 === 0)\n      return x4;\n    return (compare(b, b) === 0) - (compare(a4, a4) === 0);\n  };\n}\nfunction ascendingDefined(a4, b) {\n  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);\n}\n\n// node_modules/d3-array/src/groupSort.js\nfunction groupSort(values2, reduce2, key) {\n  return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);\n}\n\n// node_modules/d3-array/src/array.js\nvar array = Array.prototype;\nvar slice = array.slice;\nvar map = array.map;\n\n// node_modules/d3-array/src/constant.js\nfunction constant(x4) {\n  return () => x4;\n}\n\n// node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\nfunction tickSpec(start2, stop, count3) {\n  const step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;\n  let i1, i2, inc2;\n  if (power < 0) {\n    inc2 = Math.pow(10, -power) / factor;\n    i1 = Math.round(start2 * inc2);\n    i2 = Math.round(stop * inc2);\n    if (i1 / inc2 < start2)\n      ++i1;\n    if (i2 / inc2 > stop)\n      --i2;\n    inc2 = -inc2;\n  } else {\n    inc2 = Math.pow(10, power) * factor;\n    i1 = Math.round(start2 / inc2);\n    i2 = Math.round(stop / inc2);\n    if (i1 * inc2 < start2)\n      ++i1;\n    if (i2 * inc2 > stop)\n      --i2;\n  }\n  if (i2 < i1 && 0.5 <= count3 && count3 < 2)\n    return tickSpec(start2, stop, count3 * 2);\n  return [i1, i2, inc2];\n}\nfunction ticks(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  if (!(count3 > 0))\n    return [];\n  if (start2 === stop)\n    return [start2];\n  const reverse3 = stop < start2, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);\n  if (!(i2 >= i1))\n    return [];\n  const n = i2 - i1 + 1, ticks2 = new Array(n);\n  if (reverse3) {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) * inc2;\n  } else {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) * inc2;\n  }\n  return ticks2;\n}\nfunction tickIncrement(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  return tickSpec(start2, stop, count3)[2];\n}\nfunction tickStep(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  const reverse3 = stop < start2, inc2 = reverse3 ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);\n  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);\n}\n\n// node_modules/d3-array/src/nice.js\nfunction nice(start2, stop, count3) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start2, stop, count3);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start2, stop];\n    } else if (step > 0) {\n      start2 = Math.floor(start2 / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start2 = Math.ceil(start2 * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n\n// node_modules/d3-array/src/threshold/sturges.js\nfunction thresholdSturges(values2) {\n  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);\n}\n\n// node_modules/d3-array/src/bin.js\nfunction bin() {\n  var value = identity, domain = extent, threshold2 = thresholdSturges;\n  function histogram(data) {\n    if (!Array.isArray(data))\n      data = Array.from(data);\n    var i, n = data.length, x4, step, values2 = new Array(n);\n    for (i = 0; i < n; ++i) {\n      values2[i] = value(data[i], i, data);\n    }\n    var xz = domain(values2), x06 = xz[0], x12 = xz[1], tz = threshold2(values2, x06, x12);\n    if (!Array.isArray(tz)) {\n      const max5 = x12, tn = +tz;\n      if (domain === extent)\n        [x06, x12] = nice(x06, x12, tn);\n      tz = ticks(x06, x12, tn);\n      if (tz[0] <= x06)\n        step = tickIncrement(x06, x12, tn);\n      if (tz[tz.length - 1] >= x12) {\n        if (max5 >= x12 && domain === extent) {\n          const step2 = tickIncrement(x06, x12, tn);\n          if (isFinite(step2)) {\n            if (step2 > 0) {\n              x12 = (Math.floor(x12 / step2) + 1) * step2;\n            } else if (step2 < 0) {\n              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n    var m3 = tz.length, a4 = 0, b = m3;\n    while (tz[a4] <= x06)\n      ++a4;\n    while (tz[b - 1] > x12)\n      --b;\n    if (a4 || b < m3)\n      tz = tz.slice(a4, b), m3 = b - a4;\n    var bins = new Array(m3 + 1), bin3;\n    for (i = 0; i <= m3; ++i) {\n      bin3 = bins[i] = [];\n      bin3.x0 = i > 0 ? tz[i - 1] : x06;\n      bin3.x1 = i < m3 ? tz[i] : x12;\n    }\n    if (isFinite(step)) {\n      if (step > 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            bins[Math.min(m3, Math.floor((x4 - x06) / step))].push(data[i]);\n          }\n        }\n      } else if (step < 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            const j = Math.floor((x06 - x4) * step);\n            bins[Math.min(m3, j + (tz[j] <= x4))].push(data[i]);\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n          bins[bisect_default(tz, x4, 0, m3)].push(data[i]);\n        }\n      }\n    }\n    return bins;\n  }\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;\n  };\n  return histogram;\n}\n\n// node_modules/d3-array/src/max.js\nfunction max(values2, valueof2) {\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/maxIndex.js\nfunction maxIndex(values2, valueof2) {\n  let max5;\n  let maxIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  }\n  return maxIndex2;\n}\n\n// node_modules/d3-array/src/min.js\nfunction min(values2, valueof2) {\n  let min4;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/minIndex.js\nfunction minIndex(values2, valueof2) {\n  let min4;\n  let minIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  }\n  return minIndex2;\n}\n\n// node_modules/d3-array/src/quickselect.js\nfunction quickselect(array4, k2, left2 = 0, right2 = Infinity, compare) {\n  k2 = Math.floor(k2);\n  left2 = Math.floor(Math.max(0, left2));\n  right2 = Math.floor(Math.min(array4.length - 1, right2));\n  if (!(left2 <= k2 && k2 <= right2))\n    return array4;\n  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);\n  while (right2 > left2) {\n    if (right2 - left2 > 600) {\n      const n = right2 - left2 + 1;\n      const m3 = k2 - left2 + 1;\n      const z = Math.log(n);\n      const s2 = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));\n      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));\n      quickselect(array4, k2, newLeft, newRight, compare);\n    }\n    const t = array4[k2];\n    let i = left2;\n    let j = right2;\n    swap(array4, left2, k2);\n    if (compare(array4[right2], t) > 0)\n      swap(array4, left2, right2);\n    while (i < j) {\n      swap(array4, i, j), ++i, --j;\n      while (compare(array4[i], t) < 0)\n        ++i;\n      while (compare(array4[j], t) > 0)\n        --j;\n    }\n    if (compare(array4[left2], t) === 0)\n      swap(array4, left2, j);\n    else\n      ++j, swap(array4, j, right2);\n    if (j <= k2)\n      left2 = j + 1;\n    if (k2 <= j)\n      right2 = j - 1;\n  }\n  return array4;\n}\nfunction swap(array4, i, j) {\n  const t = array4[i];\n  array4[i] = array4[j];\n  array4[j] = t;\n}\n\n// node_modules/d3-array/src/greatest.js\nfunction greatest(values2, compare = ascending) {\n  let max5;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let maxValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {\n        max5 = element;\n        maxValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, max5) > 0 : compare(value, value) === 0) {\n        max5 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/quantile.js\nfunction quantile(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return min(values2);\n  if (p >= 1)\n    return max(values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileSorted(values2, p, valueof2 = number) {\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return +valueof2(values2[0], 0, values2);\n  if (p >= 1)\n    return +valueof2(values2[n - 1], n - 1, values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileIndex(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return minIndex(values2);\n  if (p >= 1)\n    return maxIndex(values2);\n  var n, i = Math.floor((n - 1) * p), order = (i2, j) => ascendingDefined(values2[i2], values2[j]), index3 = quickselect(Uint32Array.from(values2, (_, i2) => i2), i, 0, n - 1, order);\n  return greatest(index3.subarray(0, i + 1), (i2) => values2[i2]);\n}\n\n// node_modules/d3-array/src/threshold/freedmanDiaconis.js\nfunction thresholdFreedmanDiaconis(values2, min4, max5) {\n  const c6 = count(values2), d = quantile(values2, 0.75) - quantile(values2, 0.25);\n  return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;\n}\n\n// node_modules/d3-array/src/threshold/scott.js\nfunction thresholdScott(values2, min4, max5) {\n  const c6 = count(values2), d = deviation(values2);\n  return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;\n}\n\n// node_modules/d3-array/src/mean.js\nfunction mean(values2, valueof2) {\n  let count3 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  }\n  if (count3)\n    return sum5 / count3;\n}\n\n// node_modules/d3-array/src/median.js\nfunction median(values2, valueof2) {\n  return quantile(values2, 0.5, valueof2);\n}\nfunction medianIndex(values2, valueof2) {\n  return quantileIndex(values2, 0.5, valueof2);\n}\n\n// node_modules/d3-array/src/merge.js\nfunction* flatten2(arrays) {\n  for (const array4 of arrays) {\n    yield* array4;\n  }\n}\nfunction merge(arrays) {\n  return Array.from(flatten2(arrays));\n}\n\n// node_modules/d3-array/src/mode.js\nfunction mode(values2, valueof2) {\n  const counts = new InternMap();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  }\n  let modeValue;\n  let modeCount = 0;\n  for (const [value, count3] of counts) {\n    if (count3 > modeCount) {\n      modeCount = count3;\n      modeValue = value;\n    }\n  }\n  return modeValue;\n}\n\n// node_modules/d3-array/src/pairs.js\nfunction pairs(values2, pairof = pair) {\n  const pairs2 = [];\n  let previous;\n  let first2 = false;\n  for (const value of values2) {\n    if (first2)\n      pairs2.push(pairof(previous, value));\n    previous = value;\n    first2 = true;\n  }\n  return pairs2;\n}\nfunction pair(a4, b) {\n  return [a4, b];\n}\n\n// node_modules/d3-array/src/range.js\nfunction range(start2, stop, step) {\n  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;\n  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range5 = new Array(n);\n  while (++i < n) {\n    range5[i] = start2 + i * step;\n  }\n  return range5;\n}\n\n// node_modules/d3-array/src/rank.js\nfunction rank(values2, valueof2 = ascending) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  let V = Array.from(values2);\n  const R = new Float64Array(V.length);\n  if (valueof2.length !== 2)\n    V = V.map(valueof2), valueof2 = ascending;\n  const compareIndex = (i, j) => valueof2(V[i], V[j]);\n  let k2, r;\n  values2 = Uint32Array.from(V, (_, i) => i);\n  values2.sort(valueof2 === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));\n  values2.forEach((j, i) => {\n    const c6 = compareIndex(j, k2 === void 0 ? j : k2);\n    if (c6 >= 0) {\n      if (k2 === void 0 || c6 > 0)\n        k2 = j, r = i;\n      R[j] = r;\n    } else {\n      R[j] = NaN;\n    }\n  });\n  return R;\n}\n\n// node_modules/d3-array/src/least.js\nfunction least(values2, compare = ascending) {\n  let min4;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let minValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {\n        min4 = element;\n        minValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, min4) < 0 : compare(value, value) === 0) {\n        min4 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/leastIndex.js\nfunction leastIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return minIndex(values2, compare);\n  let minValue;\n  let min4 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n      minValue = value;\n      min4 = index3;\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/greatestIndex.js\nfunction greatestIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return maxIndex(values2, compare);\n  let maxValue;\n  let max5 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {\n      maxValue = value;\n      max5 = index3;\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/scan.js\nfunction scan(values2, compare) {\n  const index3 = leastIndex(values2, compare);\n  return index3 < 0 ? void 0 : index3;\n}\n\n// node_modules/d3-array/src/shuffle.js\nvar shuffle_default = shuffler(Math.random);\nfunction shuffler(random) {\n  return function shuffle3(array4, i0 = 0, i1 = array4.length) {\n    let m3 = i1 - (i0 = +i0);\n    while (m3) {\n      const i = random() * m3-- | 0, t = array4[m3 + i0];\n      array4[m3 + i0] = array4[i + i0];\n      array4[i + i0] = t;\n    }\n    return array4;\n  };\n}\n\n// node_modules/d3-array/src/sum.js\nfunction sum(values2, valueof2) {\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        sum5 += value;\n      }\n    }\n  }\n  return sum5;\n}\n\n// node_modules/d3-array/src/transpose.js\nfunction transpose(matrix) {\n  if (!(n = matrix.length))\n    return [];\n  for (var i = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i < m3; ) {\n    for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose2;\n}\nfunction length2(d) {\n  return d.length;\n}\n\n// node_modules/d3-array/src/zip.js\nfunction zip() {\n  return transpose(arguments);\n}\n\n// node_modules/d3-array/src/every.js\nfunction every(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (!test(value, ++index3, values2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/some.js\nfunction some(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// node_modules/d3-array/src/filter.js\nfunction filter(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  const array4 = [];\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      array4.push(value);\n    }\n  }\n  return array4;\n}\n\n// node_modules/d3-array/src/map.js\nfunction map2(values2, mapper) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  if (typeof mapper !== \"function\")\n    throw new TypeError(\"mapper is not a function\");\n  return Array.from(values2, (value, index3) => mapper(value, index3, values2));\n}\n\n// node_modules/d3-array/src/reduce.js\nfunction reduce(values2, reducer2, value) {\n  if (typeof reducer2 !== \"function\")\n    throw new TypeError(\"reducer is not a function\");\n  const iterator = values2[Symbol.iterator]();\n  let done, next, index3 = -1;\n  if (arguments.length < 3) {\n    ({ done, value } = iterator.next());\n    if (done)\n      return;\n    ++index3;\n  }\n  while ({ done, value: next } = iterator.next(), !done) {\n    value = reducer2(value, next, ++index3, values2);\n  }\n  return value;\n}\n\n// node_modules/d3-array/src/reverse.js\nfunction reverse(values2) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  return Array.from(values2).reverse();\n}\n\n// node_modules/d3-array/src/difference.js\nfunction difference(values2, ...others) {\n  values2 = new InternSet(values2);\n  for (const other of others) {\n    for (const value of other) {\n      values2.delete(value);\n    }\n  }\n  return values2;\n}\n\n// node_modules/d3-array/src/disjoint.js\nfunction disjoint(values2, other) {\n  const iterator = other[Symbol.iterator](), set4 = new InternSet();\n  for (const v2 of values2) {\n    if (set4.has(v2))\n      return false;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        break;\n      if (Object.is(v2, value))\n        return false;\n      set4.add(value);\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/intersection.js\nfunction intersection(values2, ...others) {\n  values2 = new InternSet(values2);\n  others = others.map(set);\n  out:\n    for (const value of values2) {\n      for (const other of others) {\n        if (!other.has(value)) {\n          values2.delete(value);\n          continue out;\n        }\n      }\n    }\n  return values2;\n}\nfunction set(values2) {\n  return values2 instanceof InternSet ? values2 : new InternSet(values2);\n}\n\n// node_modules/d3-array/src/superset.js\nfunction superset(values2, other) {\n  const iterator = values2[Symbol.iterator](), set4 = /* @__PURE__ */ new Set();\n  for (const o of other) {\n    const io = intern(o);\n    if (set4.has(io))\n      continue;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        return false;\n      const ivalue = intern(value);\n      set4.add(ivalue);\n      if (Object.is(io, ivalue))\n        break;\n    }\n  }\n  return true;\n}\nfunction intern(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/subset.js\nfunction subset(values2, other) {\n  return superset(other, values2);\n}\n\n// node_modules/d3-array/src/union.js\nfunction union(...others) {\n  const set4 = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set4.add(o);\n    }\n  }\n  return set4;\n}\n\n// node_modules/d3-axis/src/identity.js\nfunction identity_default(x4) {\n  return x4;\n}\n\n// node_modules/d3-axis/src/axis.js\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon = 1e-6;\nfunction translateX(x4) {\n  return \"translate(\" + x4 + \",0)\";\n}\nfunction translateY(y4) {\n  return \"translate(0,\" + y4 + \")\";\n}\nfunction number2(scale3) {\n  return (d) => +scale3(d);\n}\nfunction center(scale3, offset2) {\n  offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;\n  if (scale3.round())\n    offset2 = Math.round(offset2);\n  return (d) => +scale3(d) + offset2;\n}\nfunction entering() {\n  return !this.__axis;\n}\nfunction axis(orient, scale3) {\n  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x4 = orient === left || orient === right ? \"x\" : \"y\", transform2 = orient === top || orient === bottom ? translateX : translateY;\n  function axis2(context) {\n    var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues, format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range5 = scale3.range(), range0 = +range5[0] + offset2, range1 = +range5[range5.length - 1] + offset2, position2 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(\".domain\").data([null]), tick = selection2.selectAll(\".tick\").data(values2, scale3).order(), tickExit = tick.exit(), tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"), line2 = tick.select(\"line\"), text2 = tick.select(\"text\");\n    path2 = path2.merge(path2.enter().insert(\"path\", \".tick\").attr(\"class\", \"domain\").attr(\"stroke\", \"currentColor\"));\n    tick = tick.merge(tickEnter);\n    line2 = line2.merge(tickEnter.append(\"line\").attr(\"stroke\", \"currentColor\").attr(x4 + \"2\", k2 * tickSizeInner));\n    text2 = text2.merge(tickEnter.append(\"text\").attr(\"fill\", \"currentColor\").attr(x4, k2 * spacing).attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n    if (context !== selection2) {\n      path2 = path2.transition(context);\n      tick = tick.transition(context);\n      line2 = line2.transition(context);\n      text2 = text2.transition(context);\n      tickExit = tickExit.transition(context).attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute(\"transform\");\n      });\n      tickEnter.attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        var p = this.parentNode.__axis;\n        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);\n      });\n    }\n    tickExit.remove();\n    path2.attr(\"d\", orient === left || orient === right ? tickSizeOuter ? \"M\" + k2 * tickSizeOuter + \",\" + range0 + \"H\" + offset2 + \"V\" + range1 + \"H\" + k2 * tickSizeOuter : \"M\" + offset2 + \",\" + range0 + \"V\" + range1 : tickSizeOuter ? \"M\" + range0 + \",\" + k2 * tickSizeOuter + \"V\" + offset2 + \"H\" + range1 + \"V\" + k2 * tickSizeOuter : \"M\" + range0 + \",\" + offset2 + \"H\" + range1);\n    tick.attr(\"opacity\", 1).attr(\"transform\", function(d) {\n      return transform2(position2(d) + offset2);\n    });\n    line2.attr(x4 + \"2\", k2 * tickSizeInner);\n    text2.attr(x4, k2 * spacing).text(format3);\n    selection2.filter(entering).attr(\"fill\", \"none\").attr(\"font-size\", 10).attr(\"font-family\", \"sans-serif\").attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n    selection2.each(function() {\n      this.__axis = position2;\n    });\n  }\n  axis2.scale = function(_) {\n    return arguments.length ? (scale3 = _, axis2) : scale3;\n  };\n  axis2.ticks = function() {\n    return tickArguments = Array.from(arguments), axis2;\n  };\n  axis2.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();\n  };\n  axis2.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();\n  };\n  axis2.tickFormat = function(_) {\n    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;\n  };\n  axis2.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;\n  };\n  axis2.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;\n  };\n  axis2.offset = function(_) {\n    return arguments.length ? (offset2 = +_, axis2) : offset2;\n  };\n  return axis2;\n}\nfunction axisTop(scale3) {\n  return axis(top, scale3);\n}\nfunction axisRight(scale3) {\n  return axis(right, scale3);\n}\nfunction axisBottom(scale3) {\n  return axis(bottom, scale3);\n}\nfunction axisLeft(scale3) {\n  return axis(left, scale3);\n}\n\n// node_modules/d3-dispatch/src/dispatch.js\nvar noop = { value: () => {\n} };\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || t in _ || /[\\s.]/.test(t))\n      throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\nfunction Dispatch(_) {\n  this._ = _;\n}\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t))\n      throw new Error(\"unknown type: \" + t);\n    return { type: t, name };\n  });\n}\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._, T = parseTypenames(typename + \"\", _), t, i = -1, n = T.length;\n    if (arguments.length < 2) {\n      while (++i < n)\n        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))\n          return t;\n      return;\n    }\n    if (callback != null && typeof callback !== \"function\")\n      throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type)\n        _[t] = set2(_[t], typename.name, callback);\n      else if (callback == null)\n        for (t in _)\n          _[t] = set2(_[t], typename.name, null);\n    }\n    return this;\n  },\n  copy: function() {\n    var copy3 = {}, _ = this._;\n    for (var t in _)\n      copy3[t] = _[t].slice();\n    return new Dispatch(copy3);\n  },\n  call: function(type2, that) {\n    if ((n = arguments.length - 2) > 0)\n      for (var args = new Array(n), i = 0, n, t; i < n; ++i)\n        args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  },\n  apply: function(type2, that, args) {\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  }\n};\nfunction get(type2, name) {\n  for (var i = 0, n = type2.length, c6; i < n; ++i) {\n    if ((c6 = type2[i]).name === name) {\n      return c6.value;\n    }\n  }\n}\nfunction set2(type2, name, callback) {\n  for (var i = 0, n = type2.length; i < n; ++i) {\n    if (type2[i].name === name) {\n      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null)\n    type2.push({ name, value: callback });\n  return type2;\n}\nvar dispatch_default = dispatch;\n\n// node_modules/d3-selection/src/namespaces.js\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\nvar namespaces_default = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\n// node_modules/d3-selection/src/namespace.js\nfunction namespace_default(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\")\n    name = name.slice(i + 1);\n  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;\n}\n\n// node_modules/d3-selection/src/creator.js\nfunction creatorInherit(name) {\n  return function() {\n    var document2 = this.ownerDocument, uri = this.namespaceURI;\n    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);\n  };\n}\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\nfunction creator_default(name) {\n  var fullname = namespace_default(name);\n  return (fullname.local ? creatorFixed : creatorInherit)(fullname);\n}\n\n// node_modules/d3-selection/src/selector.js\nfunction none() {\n}\nfunction selector_default(selector) {\n  return selector == null ? none : function() {\n    return this.querySelector(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/select.js\nfunction select_default(select2) {\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/array.js\nfunction array2(x4) {\n  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-selection/src/selectorAll.js\nfunction empty2() {\n  return [];\n}\nfunction selectorAll_default(selector) {\n  return selector == null ? empty2 : function() {\n    return this.querySelectorAll(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectAll.js\nfunction arrayAll(select2) {\n  return function() {\n    return array2(select2.apply(this, arguments));\n  };\n}\nfunction selectAll_default(select2) {\n  if (typeof select2 === \"function\")\n    select2 = arrayAll(select2);\n  else\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        subgroups.push(select2.call(node, node.__data__, i, group3));\n        parents.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, parents);\n}\n\n// node_modules/d3-selection/src/matcher.js\nfunction matcher_default(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n}\nfunction childMatcher(selector) {\n  return function(node) {\n    return node.matches(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectChild.js\nvar find = Array.prototype.find;\nfunction childFind(match) {\n  return function() {\n    return find.call(this.children, match);\n  };\n}\nfunction childFirst() {\n  return this.firstElementChild;\n}\nfunction selectChild_default(match) {\n  return this.select(match == null ? childFirst : childFind(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/selectChildren.js\nvar filter2 = Array.prototype.filter;\nfunction children() {\n  return Array.from(this.children);\n}\nfunction childrenFilter(match) {\n  return function() {\n    return filter2.call(this.children, match);\n  };\n}\nfunction selectChildren_default(match) {\n  return this.selectAll(match == null ? children : childrenFilter(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/filter.js\nfunction filter_default(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/sparse.js\nfunction sparse_default(update) {\n  return new Array(update.length);\n}\n\n// node_modules/d3-selection/src/selection/enter.js\nfunction enter_default() {\n  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);\n}\nfunction EnterNode(parent, datum2) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum2;\n}\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) {\n    return this._parent.insertBefore(child, this._next);\n  },\n  insertBefore: function(child, next) {\n    return this._parent.insertBefore(child, next);\n  },\n  querySelector: function(selector) {\n    return this._parent.querySelector(selector);\n  },\n  querySelectorAll: function(selector) {\n    return this._parent.querySelectorAll(selector);\n  }\n};\n\n// node_modules/d3-selection/src/constant.js\nfunction constant_default(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-selection/src/selection/data.js\nfunction bindIndex(parent, group3, enter, update, exit, data) {\n  var i = 0, node, groupLength = group3.length, dataLength = data.length;\n  for (; i < dataLength; ++i) {\n    if (node = group3[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      exit[i] = node;\n    }\n  }\n}\nfunction bindKey(parent, group3, enter, update, exit, data, key) {\n  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\nfunction datum(node) {\n  return node.__data__;\n}\nfunction data_default(value, key) {\n  if (!arguments.length)\n    return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;\n  if (typeof value !== \"function\")\n    value = constant_default(value);\n  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {\n    var parent = parents[j], group3 = groups2[j], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1)\n          i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength)\n          ;\n        previous._next = next || null;\n      }\n    }\n  }\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data ? data : Array.from(data);\n}\n\n// node_modules/d3-selection/src/selection/exit.js\nfunction exit_default() {\n  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);\n}\n\n// node_modules/d3-selection/src/selection/join.js\nfunction join_default(onenter, onupdate, onexit) {\n  var enter = this.enter(), update = this, exit = this.exit();\n  if (typeof onenter === \"function\") {\n    enter = onenter(enter);\n    if (enter)\n      enter = enter.selection();\n  } else {\n    enter = enter.append(onenter + \"\");\n  }\n  if (onupdate != null) {\n    update = onupdate(update);\n    if (update)\n      update = update.selection();\n  }\n  if (onexit == null)\n    exit.remove();\n  else\n    onexit(exit);\n  return enter && update ? enter.merge(update).order() : update;\n}\n\n// node_modules/d3-selection/src/selection/merge.js\nfunction merge_default(context) {\n  var selection2 = context.selection ? context.selection() : context;\n  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Selection(merges, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/order.js\nfunction order_default() {\n  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {\n    for (var group3 = groups2[j], i = group3.length - 1, next = group3[i], node; --i >= 0; ) {\n      if (node = group3[i]) {\n        if (next && node.compareDocumentPosition(next) ^ 4)\n          next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/sort.js\nfunction sort_default(compare) {\n  if (!compare)\n    compare = ascending2;\n  function compareNode(a4, b) {\n    return a4 && b ? compare(a4.__data__, b.__data__) : !a4 - !b;\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n  return new Selection(sortgroups, this._parents).order();\n}\nfunction ascending2(a4, b) {\n  return a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-selection/src/selection/call.js\nfunction call_default() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/nodes.js\nfunction nodes_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-selection/src/selection/node.js\nfunction node_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length; i < n; ++i) {\n      var node = group3[i];\n      if (node)\n        return node;\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-selection/src/selection/size.js\nfunction size_default() {\n  let size = 0;\n  for (const node of this)\n    ++size;\n  return size;\n}\n\n// node_modules/d3-selection/src/selection/empty.js\nfunction empty_default() {\n  return !this.node();\n}\n\n// node_modules/d3-selection/src/selection/each.js\nfunction each_default(callback) {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        callback.call(node, node.__data__, i, group3);\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/attr.js\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\nfunction attrFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttribute(name);\n    else\n      this.setAttribute(name, v2);\n  };\n}\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttributeNS(fullname.space, fullname.local);\n    else\n      this.setAttributeNS(fullname.space, fullname.local, v2);\n  };\n}\nfunction attr_default(name, value) {\n  var fullname = namespace_default(name);\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);\n  }\n  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === \"function\" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));\n}\n\n// node_modules/d3-selection/src/window.js\nfunction window_default(node) {\n  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;\n}\n\n// node_modules/d3-selection/src/selection/style.js\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.style.removeProperty(name);\n    else\n      this.style.setProperty(name, v2, priority);\n  };\n}\nfunction style_default(name, value, priority) {\n  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === \"function\" ? styleFunction : styleConstant)(name, value, priority == null ? \"\" : priority)) : styleValue(this.node(), name);\n}\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\n// node_modules/d3-selection/src/selection/property.js\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\nfunction propertyFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      delete this[name];\n    else\n      this[name] = v2;\n  };\n}\nfunction property_default(name, value) {\n  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === \"function\" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];\n}\n\n// node_modules/d3-selection/src/selection/classed.js\nfunction classArray(string2) {\n  return string2.trim().split(/^|\\s+/);\n}\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.add(names[i]);\n}\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.remove(names[i]);\n}\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\nfunction classed_default(name, value) {\n  var names = classArray(name + \"\");\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n)\n      if (!list.contains(names[i]))\n        return false;\n    return true;\n  }\n  return this.each((typeof value === \"function\" ? classedFunction : value ? classedTrue : classedFalse)(names, value));\n}\n\n// node_modules/d3-selection/src/selection/text.js\nfunction textRemove() {\n  this.textContent = \"\";\n}\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.textContent = v2 == null ? \"\" : v2;\n  };\n}\nfunction text_default(value) {\n  return arguments.length ? this.each(value == null ? textRemove : (typeof value === \"function\" ? textFunction : textConstant)(value)) : this.node().textContent;\n}\n\n// node_modules/d3-selection/src/selection/html.js\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\nfunction htmlFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.innerHTML = v2 == null ? \"\" : v2;\n  };\n}\nfunction html_default(value) {\n  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === \"function\" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;\n}\n\n// node_modules/d3-selection/src/selection/raise.js\nfunction raise() {\n  if (this.nextSibling)\n    this.parentNode.appendChild(this);\n}\nfunction raise_default() {\n  return this.each(raise);\n}\n\n// node_modules/d3-selection/src/selection/lower.js\nfunction lower() {\n  if (this.previousSibling)\n    this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\nfunction lower_default() {\n  return this.each(lower);\n}\n\n// node_modules/d3-selection/src/selection/append.js\nfunction append_default(name) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name);\n  return this.select(function() {\n    return this.appendChild(create3.apply(this, arguments));\n  });\n}\n\n// node_modules/d3-selection/src/selection/insert.js\nfunction constantNull() {\n  return null;\n}\nfunction insert_default(name, before) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name), select2 = before == null ? constantNull : typeof before === \"function\" ? before : selector_default(before);\n  return this.select(function() {\n    return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);\n  });\n}\n\n// node_modules/d3-selection/src/selection/remove.js\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent)\n    parent.removeChild(this);\n}\nfunction remove_default() {\n  return this.each(remove);\n}\n\n// node_modules/d3-selection/src/selection/clone.js\nfunction selection_cloneShallow() {\n  var clone = this.cloneNode(false), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction selection_cloneDeep() {\n  var clone = this.cloneNode(true), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction clone_default(deep) {\n  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);\n}\n\n// node_modules/d3-selection/src/selection/datum.js\nfunction datum_default(value) {\n  return arguments.length ? this.property(\"__data__\", value) : this.node().__data__;\n}\n\n// node_modules/d3-selection/src/selection/on.js\nfunction contextListener(listener) {\n  return function(event) {\n    listener.call(this, event, this.__data__);\n  };\n}\nfunction parseTypenames2(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    return { type: t, name };\n  });\n}\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on)\n      return;\n    for (var j = 0, i = -1, m3 = on.length, o; j < m3; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.options);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i)\n      on.length = i;\n    else\n      delete this.__on;\n  };\n}\nfunction onAdd(typename, value, options) {\n  return function() {\n    var on = this.__on, o, listener = contextListener(value);\n    if (on)\n      for (var j = 0, m3 = on.length; j < m3; ++j) {\n        if ((o = on[j]).type === typename.type && o.name === typename.name) {\n          this.removeEventListener(o.type, o.listener, o.options);\n          this.addEventListener(o.type, o.listener = listener, o.options = options);\n          o.value = value;\n          return;\n        }\n      }\n    this.addEventListener(typename.type, listener, options);\n    o = { type: typename.type, name: typename.name, value, listener, options };\n    if (!on)\n      this.__on = [o];\n    else\n      on.push(o);\n  };\n}\nfunction on_default(typename, value, options) {\n  var typenames = parseTypenames2(typename + \"\"), i, n = typenames.length, t;\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on)\n      for (var j = 0, m3 = on.length, o; j < m3; ++j) {\n        for (i = 0, o = on[j]; i < n; ++i) {\n          if ((t = typenames[i]).type === o.type && t.name === o.name) {\n            return o.value;\n          }\n        }\n      }\n    return;\n  }\n  on = value ? onAdd : onRemove;\n  for (i = 0; i < n; ++i)\n    this.each(on(typenames[i], value, options));\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/dispatch.js\nfunction dispatchEvent(node, type2, params) {\n  var window3 = window_default(node), event = window3.CustomEvent;\n  if (typeof event === \"function\") {\n    event = new event(type2, params);\n  } else {\n    event = window3.document.createEvent(\"Event\");\n    if (params)\n      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;\n    else\n      event.initEvent(type2, false, false);\n  }\n  node.dispatchEvent(event);\n}\nfunction dispatchConstant(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params);\n  };\n}\nfunction dispatchFunction(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params.apply(this, arguments));\n  };\n}\nfunction dispatch_default2(type2, params) {\n  return this.each((typeof params === \"function\" ? dispatchFunction : dispatchConstant)(type2, params));\n}\n\n// node_modules/d3-selection/src/selection/iterator.js\nfunction* iterator_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        yield node;\n    }\n  }\n}\n\n// node_modules/d3-selection/src/selection/index.js\nvar root = [null];\nfunction Selection(groups2, parents) {\n  this._groups = groups2;\n  this._parents = parents;\n}\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\nfunction selection_selection() {\n  return this;\n}\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: select_default,\n  selectAll: selectAll_default,\n  selectChild: selectChild_default,\n  selectChildren: selectChildren_default,\n  filter: filter_default,\n  data: data_default,\n  enter: enter_default,\n  exit: exit_default,\n  join: join_default,\n  merge: merge_default,\n  selection: selection_selection,\n  order: order_default,\n  sort: sort_default,\n  call: call_default,\n  nodes: nodes_default,\n  node: node_default,\n  size: size_default,\n  empty: empty_default,\n  each: each_default,\n  attr: attr_default,\n  style: style_default,\n  property: property_default,\n  classed: classed_default,\n  text: text_default,\n  html: html_default,\n  raise: raise_default,\n  lower: lower_default,\n  append: append_default,\n  insert: insert_default,\n  remove: remove_default,\n  clone: clone_default,\n  datum: datum_default,\n  on: on_default,\n  dispatch: dispatch_default2,\n  [Symbol.iterator]: iterator_default\n};\nvar selection_default = selection;\n\n// node_modules/d3-selection/src/select.js\nfunction select_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);\n}\n\n// node_modules/d3-selection/src/create.js\nfunction create_default(name) {\n  return select_default2(creator_default(name).call(document.documentElement));\n}\n\n// node_modules/d3-selection/src/local.js\nvar nextId = 0;\nfunction local() {\n  return new Local();\n}\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id2 = this._;\n    while (!(id2 in node))\n      if (!(node = node.parentNode))\n        return;\n    return node[id2];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\n// node_modules/d3-selection/src/sourceEvent.js\nfunction sourceEvent_default(event) {\n  let sourceEvent;\n  while (sourceEvent = event.sourceEvent)\n    event = sourceEvent;\n  return event;\n}\n\n// node_modules/d3-selection/src/pointer.js\nfunction pointer_default(event, node) {\n  event = sourceEvent_default(event);\n  if (node === void 0)\n    node = event.currentTarget;\n  if (node) {\n    var svg2 = node.ownerSVGElement || node;\n    if (svg2.createSVGPoint) {\n      var point6 = svg2.createSVGPoint();\n      point6.x = event.clientX, point6.y = event.clientY;\n      point6 = point6.matrixTransform(node.getScreenCTM().inverse());\n      return [point6.x, point6.y];\n    }\n    if (node.getBoundingClientRect) {\n      var rect2 = node.getBoundingClientRect();\n      return [event.clientX - rect2.left - node.clientLeft, event.clientY - rect2.top - node.clientTop];\n    }\n  }\n  return [event.pageX, event.pageY];\n}\n\n// node_modules/d3-selection/src/pointers.js\nfunction pointers_default(events, node) {\n  if (events.target) {\n    events = sourceEvent_default(events);\n    if (node === void 0)\n      node = events.currentTarget;\n    events = events.touches || [events];\n  }\n  return Array.from(events, (event) => pointer_default(event, node));\n}\n\n// node_modules/d3-selection/src/selectAll.js\nfunction selectAll_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array2(selector)], root);\n}\n\n// node_modules/d3-drag/src/noevent.js\nvar nonpassive = { passive: false };\nvar nonpassivecapture = { capture: true, passive: false };\nfunction nopropagation(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-drag/src/nodrag.js\nfunction nodrag_default(view) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", noevent_default, nonpassivecapture);\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", noevent_default, nonpassivecapture);\n  } else {\n    root3.__noselect = root3.style.MozUserSelect;\n    root3.style.MozUserSelect = \"none\";\n  }\n}\nfunction yesdrag(view, noclick) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection2.on(\"click.drag\", noevent_default, nonpassivecapture);\n    setTimeout(function() {\n      selection2.on(\"click.drag\", null);\n    }, 0);\n  }\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", null);\n  } else {\n    root3.style.MozUserSelect = root3.__noselect;\n    delete root3.__noselect;\n  }\n}\n\n// node_modules/d3-drag/src/constant.js\nvar constant_default2 = (x4) => () => x4;\n\n// node_modules/d3-drag/src/event.js\nfunction DragEvent(type2, {\n  sourceEvent,\n  subject,\n  target,\n  identifier,\n  active,\n  x: x4,\n  y: y4,\n  dx,\n  dy,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    subject: { value: subject, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    identifier: { value: identifier, enumerable: true, configurable: true },\n    active: { value: active, enumerable: true, configurable: true },\n    x: { value: x4, enumerable: true, configurable: true },\n    y: { value: y4, enumerable: true, configurable: true },\n    dx: { value: dx, enumerable: true, configurable: true },\n    dy: { value: dy, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// node_modules/d3-drag/src/drag.js\nfunction defaultFilter(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultContainer() {\n  return this.parentNode;\n}\nfunction defaultSubject(event, d) {\n  return d == null ? { x: event.x, y: event.y } : d;\n}\nfunction defaultTouchable() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction drag_default() {\n  var filter4 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default(\"start\", \"drag\", \"end\"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;\n  function drag(selection2) {\n    selection2.on(\"mousedown.drag\", mousedowned).filter(touchable).on(\"touchstart.drag\", touchstarted).on(\"touchmove.drag\", touchmoved, nonpassive).on(\"touchend.drag touchcancel.drag\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  function mousedowned(event, d) {\n    if (touchending || !filter4.call(this, event, d))\n      return;\n    var gesture = beforestart(this, container.call(this, event, d), event, d, \"mouse\");\n    if (!gesture)\n      return;\n    select_default2(event.view).on(\"mousemove.drag\", mousemoved, nonpassivecapture).on(\"mouseup.drag\", mouseupped, nonpassivecapture);\n    nodrag_default(event.view);\n    nopropagation(event);\n    mousemoving = false;\n    mousedownx = event.clientX;\n    mousedowny = event.clientY;\n    gesture(\"start\", event);\n  }\n  function mousemoved(event) {\n    noevent_default(event);\n    if (!mousemoving) {\n      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\", event);\n  }\n  function mouseupped(event) {\n    select_default2(event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(event.view, mousemoving);\n    noevent_default(event);\n    gestures.mouse(\"end\", event);\n  }\n  function touchstarted(event, d) {\n    if (!filter4.call(this, event, d))\n      return;\n    var touches = event.changedTouches, c6 = container.call(this, event, d), n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(this, c6, event, d, touches[i].identifier, touches[i])) {\n        nopropagation(event);\n        gesture(\"start\", event, touches[i]);\n      }\n    }\n  }\n  function touchmoved(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        noevent_default(event);\n        gesture(\"drag\", event, touches[i]);\n      }\n    }\n  }\n  function touchended(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, 500);\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        nopropagation(event);\n        gesture(\"end\", event, touches[i]);\n      }\n    }\n  }\n  function beforestart(that, container2, event, d, identifier, touch) {\n    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s2;\n    if ((s2 = subject.call(that, new DragEvent(\"beforestart\", {\n      sourceEvent: event,\n      target: drag,\n      identifier,\n      active,\n      x: p[0],\n      y: p[1],\n      dx: 0,\n      dy: 0,\n      dispatch: dispatch2\n    }), d)) == null)\n      return;\n    dx = s2.x - p[0] || 0;\n    dy = s2.y - p[1] || 0;\n    return function gesture(type2, event2, touch2) {\n      var p02 = p, n;\n      switch (type2) {\n        case \"start\":\n          gestures[identifier] = gesture, n = active++;\n          break;\n        case \"end\":\n          delete gestures[identifier], --active;\n        case \"drag\":\n          p = pointer_default(touch2 || event2, container2), n = active;\n          break;\n      }\n      dispatch2.call(\n        type2,\n        that,\n        new DragEvent(type2, {\n          sourceEvent: event2,\n          subject: s2,\n          target: drag,\n          identifier,\n          active: n,\n          x: p[0] + dx,\n          y: p[1] + dy,\n          dx: p[0] - p02[0],\n          dy: p[1] - p02[1],\n          dispatch: dispatch2\n        }),\n        d\n      );\n    };\n  }\n  drag.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : filter4;\n  };\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant_default2(_), drag) : container;\n  };\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant_default2(_), drag) : subject;\n  };\n  drag.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : touchable;\n  };\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n  return drag;\n}\n\n// node_modules/d3-color/src/define.js\nfunction define_default(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition)\n    prototype[key] = definition[key];\n  return prototype;\n}\n\n// node_modules/d3-color/src/color.js\nfunction Color() {\n}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\";\nvar reN = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\";\nvar reP = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\";\nvar reHex = /^#([0-9a-f]{3,8})$/;\nvar reRgbInteger = new RegExp(`^rgb\\\\(${reI},${reI},${reI}\\\\)$`);\nvar reRgbPercent = new RegExp(`^rgb\\\\(${reP},${reP},${reP}\\\\)$`);\nvar reRgbaInteger = new RegExp(`^rgba\\\\(${reI},${reI},${reI},${reN}\\\\)$`);\nvar reRgbaPercent = new RegExp(`^rgba\\\\(${reP},${reP},${reP},${reN}\\\\)$`);\nvar reHslPercent = new RegExp(`^hsl\\\\(${reN},${reP},${reP}\\\\)$`);\nvar reHslaPercent = new RegExp(`^hsla\\\\(${reN},${reP},${reP},${reN}\\\\)$`);\nvar named = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\ndefine_default(Color, color, {\n  copy(channels) {\n    return Object.assign(new this.constructor(), this, channels);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: color_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: color_formatHex,\n  formatHex8: color_formatHex8,\n  formatHsl: color_formatHsl,\n  formatRgb: color_formatRgb,\n  toString: color_formatRgb\n});\nfunction color_formatHex() {\n  return this.rgb().formatHex();\n}\nfunction color_formatHex8() {\n  return this.rgb().formatHex8();\n}\nfunction color_formatHsl() {\n  return hslConvert(this).formatHsl();\n}\nfunction color_formatRgb() {\n  return this.rgb().formatRgb();\n}\nfunction color(format3) {\n  var m3, l;\n  format3 = (format3 + \"\").trim().toLowerCase();\n  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);\n}\nfunction rgba(r, g, b, a4) {\n  if (a4 <= 0)\n    r = g = b = NaN;\n  return new Rgb(r, g, b, a4);\n}\nfunction rgbConvert(o) {\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Rgb();\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity2) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Rgb(r, g, b, opacity2) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Rgb, rgb, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: rgb_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: rgb_formatHex,\n  formatHex8: rgb_formatHex8,\n  formatRgb: rgb_formatRgb,\n  toString: rgb_formatRgb\n}));\nfunction rgb_formatHex() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;\n}\nfunction rgb_formatHex8() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction rgb_formatRgb() {\n  const a4 = clampa(this.opacity);\n  return `${a4 === 1 ? \"rgb(\" : \"rgba(\"}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? \")\" : `, ${a4})`}`;\n}\nfunction clampa(opacity2) {\n  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));\n}\nfunction clampi(value) {\n  return Math.max(0, Math.min(255, Math.round(value) || 0));\n}\nfunction hex(value) {\n  value = clampi(value);\n  return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\nfunction hsla(h, s2, l, a4) {\n  if (a4 <= 0)\n    h = s2 = l = NaN;\n  else if (l <= 0 || l >= 1)\n    h = s2 = NaN;\n  else if (s2 <= 0)\n    h = NaN;\n  return new Hsl(h, s2, l, a4);\n}\nfunction hslConvert(o) {\n  if (o instanceof Hsl)\n    return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Hsl();\n  if (o instanceof Hsl)\n    return o;\n  o = o.rgb();\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s2 = max5 - min4, l = (max5 + min4) / 2;\n  if (s2) {\n    if (r === max5)\n      h = (g - b) / s2 + (g < b) * 6;\n    else if (g === max5)\n      h = (b - r) / s2 + 2;\n    else\n      h = (r - g) / s2 + 4;\n    s2 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;\n    h *= 60;\n  } else {\n    s2 = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s2, l, o.opacity);\n}\nfunction hsl(h, s2, l, opacity2) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hsl(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Hsl, hsl, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),\n      hsl2rgb(h, m1, m22),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  formatHsl() {\n    const a4 = clampa(this.opacity);\n    return `${a4 === 1 ? \"hsl(\" : \"hsla(\"}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? \")\" : `, ${a4})`}`;\n  }\n}));\nfunction clamph(value) {\n  value = (value || 0) % 360;\n  return value < 0 ? value + 360 : value;\n}\nfunction clampt(value) {\n  return Math.max(0, Math.min(1, value || 0));\n}\nfunction hsl2rgb(h, m1, m22) {\n  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;\n}\n\n// node_modules/d3-color/src/math.js\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\n\n// node_modules/d3-color/src/lab.js\nvar K = 18;\nvar Xn = 0.96422;\nvar Yn = 1;\nvar Zn = 0.82521;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\nfunction labConvert(o) {\n  if (o instanceof Lab)\n    return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl)\n    return hcl2lab(o);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x4, z;\n  if (r === g && g === b)\n    x4 = z = y4;\n  else {\n    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n  }\n  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);\n}\nfunction gray(l, opacity2) {\n  return new Lab(l, 0, 0, opacity2 == null ? 1 : opacity2);\n}\nfunction lab(l, a4, b, opacity2) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Lab(l, a4, b, opacity2) {\n  this.l = +l;\n  this.a = +a4;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Lab, lab, extend(Color, {\n  brighter(k2) {\n    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  darker(k2) {\n    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  rgb() {\n    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;\n    x4 = Xn * lab2xyz(x4);\n    y4 = Yn * lab2xyz(y4);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),\n      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),\n      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),\n      this.opacity\n    );\n  }\n}));\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\nfunction lrgb2rgb(x4) {\n  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);\n}\nfunction rgb2lrgb(x4) {\n  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);\n}\nfunction hclConvert(o) {\n  if (o instanceof Hcl)\n    return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab))\n    o = labConvert(o);\n  if (o.a === 0 && o.b === 0)\n    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);\n  var h = Math.atan2(o.b, o.a) * degrees;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\nfunction lch(l, c6, h, opacity2) {\n  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction hcl(h, c6, l, opacity2) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hcl(h, c6, l, opacity2) {\n  this.h = +h;\n  this.c = +c6;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\nfunction hcl2lab(o) {\n  if (isNaN(o.h))\n    return new Lab(o.l, 0, 0, o.opacity);\n  var h = o.h * radians;\n  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n}\ndefine_default(Hcl, hcl, extend(Color, {\n  brighter(k2) {\n    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  darker(k2) {\n    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  rgb() {\n    return hcl2lab(this).rgb();\n  }\n}));\n\n// node_modules/d3-color/src/cubehelix.js\nvar A = -0.14861;\nvar B = 1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = 1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix)\n    return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);\n}\nfunction cubehelix(h, s2, l, opacity2) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Cubehelix(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Cubehelix, cubehelix, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);\n    return new Rgb(\n      255 * (l + a4 * (A * cosh2 + B * sinh2)),\n      255 * (l + a4 * (C * cosh2 + D * sinh2)),\n      255 * (l + a4 * (E * cosh2)),\n      this.opacity\n    );\n  }\n}));\n\n// node_modules/d3-interpolate/src/basis.js\nfunction basis(t13, v0, v1, v2, v3) {\n  var t22 = t13 * t13, t32 = t22 * t13;\n  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;\n}\nfunction basis_default(values2) {\n  var n = values2.length - 1;\n  return function(t) {\n    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/basisClosed.js\nfunction basisClosed_default(values2) {\n  var n = values2.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/constant.js\nvar constant_default3 = (x4) => () => x4;\n\n// node_modules/d3-interpolate/src/color.js\nfunction linear(a4, d) {\n  return function(t) {\n    return a4 + t * d;\n  };\n}\nfunction exponential(a4, b, y4) {\n  return a4 = Math.pow(a4, y4), b = Math.pow(b, y4) - a4, y4 = 1 / y4, function(t) {\n    return Math.pow(a4 + t * b, y4);\n  };\n}\nfunction hue(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b : a4);\n}\nfunction gamma(y4) {\n  return (y4 = +y4) === 1 ? nogamma : function(a4, b) {\n    return b - a4 ? exponential(a4, b, y4) : constant_default3(isNaN(a4) ? b : a4);\n  };\n}\nfunction nogamma(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b : a4);\n}\n\n// node_modules/d3-interpolate/src/rgb.js\nvar rgb_default = function rgbGamma(y4) {\n  var color3 = gamma(y4);\n  function rgb2(start2, end) {\n    var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.r = r(t);\n      start2.g = g(t);\n      start2.b = b(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  }\n  rgb2.gamma = rgbGamma;\n  return rgb2;\n}(1);\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;\n    for (i = 0; i < n; ++i) {\n      color3 = rgb(colors[i]);\n      r[i] = color3.r || 0;\n      g[i] = color3.g || 0;\n      b[i] = color3.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color3.opacity = 1;\n    return function(t) {\n      color3.r = r(t);\n      color3.g = g(t);\n      color3.b = b(t);\n      return color3 + \"\";\n    };\n  };\n}\nvar rgbBasis = rgbSpline(basis_default);\nvar rgbBasisClosed = rgbSpline(basisClosed_default);\n\n// node_modules/d3-interpolate/src/numberArray.js\nfunction numberArray_default(a4, b) {\n  if (!b)\n    b = [];\n  var n = a4 ? Math.min(b.length, a4.length) : 0, c6 = b.slice(), i;\n  return function(t) {\n    for (i = 0; i < n; ++i)\n      c6[i] = a4[i] * (1 - t) + b[i] * t;\n    return c6;\n  };\n}\nfunction isNumberArray(x4) {\n  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);\n}\n\n// node_modules/d3-interpolate/src/array.js\nfunction array_default(a4, b) {\n  return (isNumberArray(b) ? numberArray_default : genericArray)(a4, b);\n}\nfunction genericArray(a4, b) {\n  var nb = b ? b.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x4 = new Array(na), c6 = new Array(nb), i;\n  for (i = 0; i < na; ++i)\n    x4[i] = value_default(a4[i], b[i]);\n  for (; i < nb; ++i)\n    c6[i] = b[i];\n  return function(t) {\n    for (i = 0; i < na; ++i)\n      c6[i] = x4[i](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/date.js\nfunction date_default(a4, b) {\n  var d = /* @__PURE__ */ new Date();\n  return a4 = +a4, b = +b, function(t) {\n    return d.setTime(a4 * (1 - t) + b * t), d;\n  };\n}\n\n// node_modules/d3-interpolate/src/number.js\nfunction number_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return a4 * (1 - t) + b * t;\n  };\n}\n\n// node_modules/d3-interpolate/src/object.js\nfunction object_default(a4, b) {\n  var i = {}, c6 = {}, k2;\n  if (a4 === null || typeof a4 !== \"object\")\n    a4 = {};\n  if (b === null || typeof b !== \"object\")\n    b = {};\n  for (k2 in b) {\n    if (k2 in a4) {\n      i[k2] = value_default(a4[k2], b[k2]);\n    } else {\n      c6[k2] = b[k2];\n    }\n  }\n  return function(t) {\n    for (k2 in i)\n      c6[k2] = i[k2](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/string.js\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\nfunction zero2(b) {\n  return function() {\n    return b;\n  };\n}\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\nfunction string_default(a4, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];\n  a4 = a4 + \"\", b = b + \"\";\n  while ((am = reA.exec(a4)) && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) {\n      bs = b.slice(bi, bs);\n      if (s2[i])\n        s2[i] += bs;\n      else\n        s2[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) {\n      if (s2[i])\n        s2[i] += bm;\n      else\n        s2[++i] = bm;\n    } else {\n      s2[++i] = null;\n      q.push({ i, x: number_default(am, bm) });\n    }\n    bi = reB.lastIndex;\n  }\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s2[i])\n      s2[i] += bs;\n    else\n      s2[++i] = bs;\n  }\n  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {\n    for (var i2 = 0, o; i2 < b; ++i2)\n      s2[(o = q[i2]).i] = o.x(t);\n    return s2.join(\"\");\n  });\n}\n\n// node_modules/d3-interpolate/src/value.js\nfunction value_default(a4, b) {\n  var t = typeof b, c6;\n  return b == null || t === \"boolean\" ? constant_default3(b) : (t === \"number\" ? number_default : t === \"string\" ? (c6 = color(b)) ? (b = c6, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object_default : number_default)(a4, b);\n}\n\n// node_modules/d3-interpolate/src/discrete.js\nfunction discrete_default(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\n// node_modules/d3-interpolate/src/hue.js\nfunction hue_default(a4, b) {\n  var i = hue(+a4, +b);\n  return function(t) {\n    var x4 = i(t);\n    return x4 - 360 * Math.floor(x4 / 360);\n  };\n}\n\n// node_modules/d3-interpolate/src/round.js\nfunction round_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return Math.round(a4 * (1 - t) + b * t);\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/decompose.js\nvar degrees2 = 180 / Math.PI;\nvar identity2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\nfunction decompose_default(a4, b, c6, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a4 * a4 + b * b))\n    a4 /= scaleX, b /= scaleX;\n  if (skewX = a4 * c6 + b * d)\n    c6 -= a4 * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c6 * c6 + d * d))\n    c6 /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a4 * d < b * c6)\n    a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a4) * degrees2,\n    skewX: Math.atan(skewX) * degrees2,\n    scaleX,\n    scaleY\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/parse.js\nvar svgNode;\nfunction parseCss(value) {\n  const m3 = new (typeof DOMMatrix === \"function\" ? DOMMatrix : WebKitCSSMatrix)(value + \"\");\n  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);\n}\nfunction parseSvg(value) {\n  if (value == null)\n    return identity2;\n  if (!svgNode)\n    svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate()))\n    return identity2;\n  value = value.matrix;\n  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\n// node_modules/d3-interpolate/src/transform/index.js\nfunction interpolateTransform(parse2, pxComma, pxParen, degParen) {\n  function pop(s2) {\n    return s2.length ? s2.pop() + \" \" : \"\";\n  }\n  function translate(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb || yb) {\n      s2.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n  function rotate(a4, b, s2, q) {\n    if (a4 !== b) {\n      if (a4 - b > 180)\n        b += 360;\n      else if (b - a4 > 180)\n        a4 += 360;\n      q.push({ i: s2.push(pop(s2) + \"rotate(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"rotate(\" + b + degParen);\n    }\n  }\n  function skewX(a4, b, s2, q) {\n    if (a4 !== b) {\n      q.push({ i: s2.push(pop(s2) + \"skewX(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"skewX(\" + b + degParen);\n    }\n  }\n  function scale3(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(pop(s2) + \"scale(\", null, \",\", null, \")\");\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb !== 1 || yb !== 1) {\n      s2.push(pop(s2) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n  return function(a4, b) {\n    var s2 = [], q = [];\n    a4 = parse2(a4), b = parse2(b);\n    translate(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);\n    rotate(a4.rotate, b.rotate, s2, q);\n    skewX(a4.skewX, b.skewX, s2, q);\n    scale3(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);\n    a4 = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n)\n        s2[(o = q[i]).i] = o.x(t);\n      return s2.join(\"\");\n    };\n  };\n}\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\n// node_modules/d3-interpolate/src/zoom.js\nvar epsilon2 = 1e-12;\nfunction cosh(x4) {\n  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;\n}\nfunction sinh(x4) {\n  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;\n}\nfunction tanh(x4) {\n  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);\n}\nvar zoom_default = function zoomRho(rho, rho2, rho4) {\n  function zoom(p02, p1) {\n    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < epsilon2) {\n      S = Math.log(w1 / w0) / rho;\n      i = function(t) {\n        return [\n          ux0 + t * dx,\n          uy0 + t * dy,\n          w0 * Math.exp(rho * t * S)\n        ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);\n      S = (r1 - r0) / rho;\n      i = function(t) {\n        var s2 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));\n        return [\n          ux0 + u4 * dx,\n          uy0 + u4 * dy,\n          w0 * coshr0 / cosh(rho * s2 + r0)\n        ];\n      };\n    }\n    i.duration = S * 1e3 * rho / Math.SQRT2;\n    return i;\n  }\n  zoom.rho = function(_) {\n    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;\n    return zoomRho(_1, _2, _4);\n  };\n  return zoom;\n}(Math.SQRT2, 2, 4);\n\n// node_modules/d3-interpolate/src/hsl.js\nfunction hsl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.s = s2(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hsl_default = hsl2(hue);\nvar hslLong = hsl2(nogamma);\n\n// node_modules/d3-interpolate/src/lab.js\nfunction lab2(start2, end) {\n  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n  return function(t) {\n    start2.l = l(t);\n    start2.a = a4(t);\n    start2.b = b(t);\n    start2.opacity = opacity2(t);\n    return start2 + \"\";\n  };\n}\n\n// node_modules/d3-interpolate/src/hcl.js\nfunction hcl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.c = c6(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hcl_default = hcl2(hue);\nvar hclLong = hcl2(nogamma);\n\n// node_modules/d3-interpolate/src/cubehelix.js\nfunction cubehelix2(hue2) {\n  return function cubehelixGamma(y4) {\n    y4 = +y4;\n    function cubehelix3(start2, end) {\n      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n      return function(t) {\n        start2.h = h(t);\n        start2.s = s2(t);\n        start2.l = l(Math.pow(t, y4));\n        start2.opacity = opacity2(t);\n        return start2 + \"\";\n      };\n    }\n    cubehelix3.gamma = cubehelixGamma;\n    return cubehelix3;\n  }(1);\n}\nvar cubehelix_default = cubehelix2(hue);\nvar cubehelixLong = cubehelix2(nogamma);\n\n// node_modules/d3-interpolate/src/piecewise.js\nfunction piecewise(interpolate, values2) {\n  if (values2 === void 0)\n    values2 = interpolate, interpolate = value_default;\n  var i = 0, n = values2.length - 1, v2 = values2[0], I = new Array(n < 0 ? 0 : n);\n  while (i < n)\n    I[i] = interpolate(v2, v2 = values2[++i]);\n  return function(t) {\n    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));\n    return I[i2](t - i2);\n  };\n}\n\n// node_modules/d3-interpolate/src/quantize.js\nfunction quantize_default(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i)\n    samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n\n// node_modules/d3-timer/src/timer.js\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1e3;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {\n  setTimeout(f, 17);\n};\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\nfunction clearNow() {\n  clockNow = 0;\n}\nfunction Timer() {\n  this._call = this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time2) {\n    if (typeof callback !== \"function\")\n      throw new TypeError(\"callback is not a function\");\n    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail)\n        taskTail._next = this;\n      else\n        taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time2;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction timer(callback, delay, time2) {\n  var t = new Timer();\n  t.restart(callback, delay, time2);\n  return t;\n}\nfunction timerFlush() {\n  now();\n  ++frame;\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0)\n      t._call.call(void 0, e);\n    t = t._next;\n  }\n  --frame;\n}\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\nfunction poke() {\n  var now2 = clock.now(), delay = now2 - clockLast;\n  if (delay > pokeDelay)\n    clockSkew -= delay, clockLast = now2;\n}\nfunction nap() {\n  var t03, t13 = taskHead, t22, time2 = Infinity;\n  while (t13) {\n    if (t13._call) {\n      if (time2 > t13._time)\n        time2 = t13._time;\n      t03 = t13, t13 = t13._next;\n    } else {\n      t22 = t13._next, t13._next = null;\n      t13 = t03 ? t03._next = t22 : taskHead = t22;\n    }\n  }\n  taskTail = t03;\n  sleep(time2);\n}\nfunction sleep(time2) {\n  if (frame)\n    return;\n  if (timeout)\n    timeout = clearTimeout(timeout);\n  var delay = time2 - clockNow;\n  if (delay > 24) {\n    if (time2 < Infinity)\n      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);\n    if (interval)\n      interval = clearInterval(interval);\n  } else {\n    if (!interval)\n      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\n// node_modules/d3-timer/src/timeout.js\nfunction timeout_default(callback, delay, time2) {\n  var t = new Timer();\n  delay = delay == null ? 0 : +delay;\n  t.restart((elapsed) => {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time2);\n  return t;\n}\n\n// node_modules/d3-timer/src/interval.js\nfunction interval_default(callback, delay, time2) {\n  var t = new Timer(), total = delay;\n  if (delay == null)\n    return t.restart(callback, delay, time2), t;\n  t._restart = t.restart;\n  t.restart = function(callback2, delay2, time3) {\n    delay2 = +delay2, time3 = time3 == null ? now() : +time3;\n    t._restart(function tick(elapsed) {\n      elapsed += total;\n      t._restart(tick, total += delay2, time3);\n      callback2(elapsed);\n    }, delay2, time3);\n  };\n  t.restart(callback, delay, time2);\n  return t;\n}\n\n// node_modules/d3-transition/src/transition/schedule.js\nvar emptyOn = dispatch_default(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\nfunction schedule_default(node, name, id2, index3, group3, timing) {\n  var schedules = node.__transition;\n  if (!schedules)\n    node.__transition = {};\n  else if (id2 in schedules)\n    return;\n  create(node, id2, {\n    name,\n    index: index3,\n    // For context during callback.\n    group: group3,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nfunction init(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > CREATED)\n    throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nfunction set3(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > STARTED)\n    throw new Error(\"too late; already running\");\n  return schedule;\n}\nfunction get2(node, id2) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id2]))\n    throw new Error(\"transition not found\");\n  return schedule;\n}\nfunction create(node, id2, self) {\n  var schedules = node.__transition, tween;\n  schedules[id2] = self;\n  self.timer = timer(schedule, 0, self.time);\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start2, self.delay, self.time);\n    if (self.delay <= elapsed)\n      start2(elapsed - self.delay);\n  }\n  function start2(elapsed) {\n    var i, j, n, o;\n    if (self.state !== SCHEDULED)\n      return stop();\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name)\n        continue;\n      if (o.state === STARTED)\n        return timeout_default(start2);\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } else if (+i < id2) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n    timeout_default(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING)\n      return;\n    self.state = STARTED;\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id2];\n    for (var i in schedules)\n      return;\n    delete node.__transition;\n  }\n}\n\n// node_modules/d3-transition/src/interrupt.js\nfunction interrupt_default(node, name) {\n  var schedules = node.__transition, schedule, active, empty4 = true, i;\n  if (!schedules)\n    return;\n  name = name == null ? null : name + \"\";\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) {\n      empty4 = false;\n      continue;\n    }\n    active = schedule.state > STARTING && schedule.state < ENDING;\n    schedule.state = ENDED;\n    schedule.timer.stop();\n    schedule.on.call(active ? \"interrupt\" : \"cancel\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n  if (empty4)\n    delete node.__transition;\n}\n\n// node_modules/d3-transition/src/selection/interrupt.js\nfunction interrupt_default2(name) {\n  return this.each(function() {\n    interrupt_default(this, name);\n  });\n}\n\n// node_modules/d3-transition/src/transition/tween.js\nfunction tweenRemove(id2, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tweenFunction(id2, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n)\n        tween1.push(t);\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tween_default(name, value) {\n  var id2 = this._id;\n  name += \"\";\n  if (arguments.length < 2) {\n    var tween = get2(this.node(), id2).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));\n}\nfunction tweenValue(transition2, name, value) {\n  var id2 = transition2._id;\n  transition2.each(function() {\n    var schedule = set3(this, id2);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n  return function(node) {\n    return get2(node, id2).value[name];\n  };\n}\n\n// node_modules/d3-transition/src/transition/interpolate.js\nfunction interpolate_default(a4, b) {\n  var c6;\n  return (typeof b === \"number\" ? number_default : b instanceof color ? rgb_default : (c6 = color(b)) ? (b = c6, rgb_default) : string_default)(a4, b);\n}\n\n// node_modules/d3-transition/src/transition/attr.js\nfunction attrRemove2(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS2(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttribute(name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrConstantNS2(fullname, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttributeNS(fullname.space, fullname.local);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttribute(name);\n    string0 = this.getAttribute(name);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attrFunctionNS2(fullname, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttributeNS(fullname.space, fullname.local);\n    string0 = this.getAttributeNS(fullname.space, fullname.local);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attr_default2(name, value) {\n  var fullname = namespace_default(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate_default;\n  return this.attrTween(name, typeof value === \"function\" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, \"attr.\" + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));\n}\n\n// node_modules/d3-transition/src/transition/attrTween.js\nfunction attrInterpolate(name, i) {\n  return function(t) {\n    this.setAttribute(name, i.call(this, t));\n  };\n}\nfunction attrInterpolateNS(fullname, i) {\n  return function(t) {\n    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));\n  };\n}\nfunction attrTweenNS(fullname, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolateNS(fullname, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween(name, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolate(name, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween_default(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  var fullname = namespace_default(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n}\n\n// node_modules/d3-transition/src/transition/delay.js\nfunction delayFunction(id2, value) {\n  return function() {\n    init(this, id2).delay = +value.apply(this, arguments);\n  };\n}\nfunction delayConstant(id2, value) {\n  return value = +value, function() {\n    init(this, id2).delay = value;\n  };\n}\nfunction delay_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;\n}\n\n// node_modules/d3-transition/src/transition/duration.js\nfunction durationFunction(id2, value) {\n  return function() {\n    set3(this, id2).duration = +value.apply(this, arguments);\n  };\n}\nfunction durationConstant(id2, value) {\n  return value = +value, function() {\n    set3(this, id2).duration = value;\n  };\n}\nfunction duration_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;\n}\n\n// node_modules/d3-transition/src/transition/ease.js\nfunction easeConstant(id2, value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    set3(this, id2).ease = value;\n  };\n}\nfunction ease_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;\n}\n\n// node_modules/d3-transition/src/transition/easeVarying.js\nfunction easeVarying(id2, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (typeof v2 !== \"function\")\n      throw new Error();\n    set3(this, id2).ease = v2;\n  };\n}\nfunction easeVarying_default(value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.each(easeVarying(this._id, value));\n}\n\n// node_modules/d3-transition/src/transition/filter.js\nfunction filter_default2(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/merge.js\nfunction merge_default2(transition2) {\n  if (transition2._id !== this._id)\n    throw new Error();\n  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Transition(merges, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/on.js\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0)\n      t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\nfunction onFunction(id2, name, listener) {\n  var on0, on1, sit = start(name) ? init : set3;\n  return function() {\n    var schedule = sit(this, id2), on = schedule.on;\n    if (on !== on0)\n      (on1 = (on0 = on).copy()).on(name, listener);\n    schedule.on = on1;\n  };\n}\nfunction on_default2(name, listener) {\n  var id2 = this._id;\n  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));\n}\n\n// node_modules/d3-transition/src/transition/remove.js\nfunction removeFunction(id2) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition)\n      if (+i !== id2)\n        return;\n    if (parent)\n      parent.removeChild(this);\n  };\n}\nfunction remove_default2() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n}\n\n// node_modules/d3-transition/src/transition/select.js\nfunction select_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selectAll.js\nfunction selectAll_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {\n          if (child = children2[k2]) {\n            schedule_default(child, name, id2, k2, children2, inherit3);\n          }\n        }\n        subgroups.push(children2);\n        parents.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selection.js\nvar Selection2 = selection_default.prototype.constructor;\nfunction selection_default2() {\n  return new Selection2(this._groups, this._parents);\n}\n\n// node_modules/d3-transition/src/transition/style.js\nfunction styleNull(name, interpolate) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);\n  };\n}\nfunction styleRemove2(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = styleValue(this, name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction styleFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + \"\";\n    if (value1 == null)\n      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction styleMaybeRemove(id2, name) {\n  var on0, on1, listener0, key = \"style.\" + name, event = \"end.\" + key, remove2;\n  return function() {\n    var schedule = set3(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;\n    if (on !== on0 || listener0 !== listener)\n      (on1 = (on0 = on).copy()).on(event, listener0 = listener);\n    schedule.on = on1;\n  };\n}\nfunction style_default2(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate_default;\n  return value == null ? this.styleTween(name, styleNull(name, i)).on(\"end.style.\" + name, styleRemove2(name)) : typeof value === \"function\" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, \"style.\" + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on(\"end.style.\" + name, null);\n}\n\n// node_modules/d3-transition/src/transition/styleTween.js\nfunction styleInterpolate(name, i, priority) {\n  return function(t) {\n    this.style.setProperty(name, i.call(this, t), priority);\n  };\n}\nfunction styleTween(name, value, priority) {\n  var t, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t = (i0 = i) && styleInterpolate(name, i, priority);\n    return t;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction styleTween_default(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n}\n\n// node_modules/d3-transition/src/transition/text.js\nfunction textConstant2(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction2(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\nfunction text_default2(value) {\n  return this.tween(\"text\", typeof value === \"function\" ? textFunction2(tweenValue(this, \"text\", value)) : textConstant2(value == null ? \"\" : value + \"\"));\n}\n\n// node_modules/d3-transition/src/transition/textTween.js\nfunction textInterpolate(i) {\n  return function(t) {\n    this.textContent = i.call(this, t);\n  };\n}\nfunction textTween(value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && textInterpolate(i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction textTween_default(value) {\n  var key = \"text\";\n  if (arguments.length < 1)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, textTween(value));\n}\n\n// node_modules/d3-transition/src/transition/transition.js\nfunction transition_default() {\n  var name = this._name, id0 = this._id, id1 = newId();\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        var inherit3 = get2(node, id0);\n        schedule_default(node, name, id1, i, group3, {\n          time: inherit3.time + inherit3.delay + inherit3.duration,\n          delay: 0,\n          duration: inherit3.duration,\n          ease: inherit3.ease\n        });\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id1);\n}\n\n// node_modules/d3-transition/src/transition/end.js\nfunction end_default() {\n  var on0, on1, that = this, id2 = that._id, size = that.size();\n  return new Promise(function(resolve, reject) {\n    var cancel = { value: reject }, end = { value: function() {\n      if (--size === 0)\n        resolve();\n    } };\n    that.each(function() {\n      var schedule = set3(this, id2), on = schedule.on;\n      if (on !== on0) {\n        on1 = (on0 = on).copy();\n        on1._.cancel.push(cancel);\n        on1._.interrupt.push(cancel);\n        on1._.end.push(end);\n      }\n      schedule.on = on1;\n    });\n    if (size === 0)\n      resolve();\n  });\n}\n\n// node_modules/d3-transition/src/transition/index.js\nvar id = 0;\nfunction Transition(groups2, parents, name, id2) {\n  this._groups = groups2;\n  this._parents = parents;\n  this._name = name;\n  this._id = id2;\n}\nfunction transition(name) {\n  return selection_default().transition(name);\n}\nfunction newId() {\n  return ++id;\n}\nvar selection_prototype = selection_default.prototype;\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: select_default3,\n  selectAll: selectAll_default3,\n  selectChild: selection_prototype.selectChild,\n  selectChildren: selection_prototype.selectChildren,\n  filter: filter_default2,\n  merge: merge_default2,\n  selection: selection_default2,\n  transition: transition_default,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: on_default2,\n  attr: attr_default2,\n  attrTween: attrTween_default,\n  style: style_default2,\n  styleTween: styleTween_default,\n  text: text_default2,\n  textTween: textTween_default,\n  remove: remove_default2,\n  tween: tween_default,\n  delay: delay_default,\n  duration: duration_default,\n  ease: ease_default,\n  easeVarying: easeVarying_default,\n  end: end_default,\n  [Symbol.iterator]: selection_prototype[Symbol.iterator]\n};\n\n// node_modules/d3-ease/src/linear.js\nvar linear2 = (t) => +t;\n\n// node_modules/d3-ease/src/quad.js\nfunction quadIn(t) {\n  return t * t;\n}\nfunction quadOut(t) {\n  return t * (2 - t);\n}\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\n// node_modules/d3-ease/src/poly.js\nvar exponent = 3;\nvar polyIn = function custom(e) {\n  e = +e;\n  function polyIn2(t) {\n    return Math.pow(t, e);\n  }\n  polyIn2.exponent = custom;\n  return polyIn2;\n}(exponent);\nvar polyOut = function custom2(e) {\n  e = +e;\n  function polyOut2(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n  polyOut2.exponent = custom2;\n  return polyOut2;\n}(exponent);\nvar polyInOut = function custom3(e) {\n  e = +e;\n  function polyInOut2(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n  polyInOut2.exponent = custom3;\n  return polyInOut2;\n}(exponent);\n\n// node_modules/d3-ease/src/sin.js\nvar pi = Math.PI;\nvar halfPi = pi / 2;\nfunction sinIn(t) {\n  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);\n}\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\n// node_modules/d3-ease/src/math.js\nfunction tpmt(x4) {\n  return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;\n}\n\n// node_modules/d3-ease/src/exp.js\nfunction expIn(t) {\n  return tpmt(1 - +t);\n}\nfunction expOut(t) {\n  return 1 - tpmt(t);\n}\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;\n}\n\n// node_modules/d3-ease/src/circle.js\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/bounce.js\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/back.js\nvar overshoot = 1.70158;\nvar backIn = function custom4(s2) {\n  s2 = +s2;\n  function backIn2(t) {\n    return (t = +t) * t * (s2 * (t - 1) + t);\n  }\n  backIn2.overshoot = custom4;\n  return backIn2;\n}(overshoot);\nvar backOut = function custom5(s2) {\n  s2 = +s2;\n  function backOut2(t) {\n    return --t * t * ((t + 1) * s2 + t) + 1;\n  }\n  backOut2.overshoot = custom5;\n  return backOut2;\n}(overshoot);\nvar backInOut = function custom6(s2) {\n  s2 = +s2;\n  function backInOut2(t) {\n    return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;\n  }\n  backInOut2.overshoot = custom6;\n  return backInOut2;\n}(overshoot);\n\n// node_modules/d3-ease/src/elastic.js\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\nvar elasticIn = function custom7(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticIn2(t) {\n    return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);\n  }\n  elasticIn2.amplitude = function(a5) {\n    return custom7(a5, p * tau);\n  };\n  elasticIn2.period = function(p2) {\n    return custom7(a4, p2);\n  };\n  return elasticIn2;\n}(amplitude, period);\nvar elasticOut = function custom8(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticOut2(t) {\n    return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);\n  }\n  elasticOut2.amplitude = function(a5) {\n    return custom8(a5, p * tau);\n  };\n  elasticOut2.period = function(p2) {\n    return custom8(a4, p2);\n  };\n  return elasticOut2;\n}(amplitude, period);\nvar elasticInOut = function custom9(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticInOut2(t) {\n    return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;\n  }\n  elasticInOut2.amplitude = function(a5) {\n    return custom9(a5, p * tau);\n  };\n  elasticInOut2.period = function(p2) {\n    return custom9(a4, p2);\n  };\n  return elasticInOut2;\n}(amplitude, period);\n\n// node_modules/d3-transition/src/selection/transition.js\nvar defaultTiming = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\nfunction inherit(node, id2) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id2])) {\n    if (!(node = node.parentNode)) {\n      throw new Error(`transition ${id2} not found`);\n    }\n  }\n  return timing;\n}\nfunction transition_default2(name) {\n  var id2, timing;\n  if (name instanceof Transition) {\n    id2 = name._id, name = name._name;\n  } else {\n    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        schedule_default(node, name, id2, i, group3, timing || inherit(node, id2));\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/selection/index.js\nselection_default.prototype.interrupt = interrupt_default2;\nselection_default.prototype.transition = transition_default2;\n\n// node_modules/d3-transition/src/active.js\nvar root2 = [null];\nfunction active_default(node, name) {\n  var schedules = node.__transition, schedule, i;\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n        return new Transition([[node]], root2, name, +i);\n      }\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-brush/src/constant.js\nvar constant_default4 = (x4) => () => x4;\n\n// node_modules/d3-brush/src/event.js\nfunction BrushEvent(type2, {\n  sourceEvent,\n  target,\n  selection: selection2,\n  mode: mode2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    selection: { value: selection2, enumerable: true, configurable: true },\n    mode: { value: mode2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-brush/src/noevent.js\nfunction nopropagation2(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default2(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-brush/src/brush.js\nvar MODE_DRAG = { name: \"drag\" };\nvar MODE_SPACE = { name: \"space\" };\nvar MODE_HANDLE = { name: \"handle\" };\nvar MODE_CENTER = { name: \"center\" };\nvar { abs, max: max2, min: min2 } = Math;\nfunction number1(e) {\n  return [+e[0], +e[1]];\n}\nfunction number22(e) {\n  return [number1(e[0]), number1(e[1])];\n}\nvar X = {\n  name: \"x\",\n  handles: [\"w\", \"e\"].map(type),\n  input: function(x4, e) {\n    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][0], xy[1][0]];\n  }\n};\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y4, e) {\n    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][1], xy[1][1]];\n  }\n};\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"w\", \"e\", \"s\", \"nw\", \"ne\", \"sw\", \"se\"].map(type),\n  input: function(xy) {\n    return xy == null ? null : number22(xy);\n  },\n  output: function(xy) {\n    return xy;\n  }\n};\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\nvar signsX = {\n  overlay: 1,\n  selection: 1,\n  n: null,\n  e: 1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: 1,\n  se: 1,\n  sw: -1\n};\nvar signsY = {\n  overlay: 1,\n  selection: 1,\n  n: -1,\n  e: null,\n  s: 1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: 1,\n  sw: 1\n};\nfunction type(t) {\n  return { type: t };\n}\nfunction defaultFilter2(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultExtent() {\n  var svg2 = this.ownerSVGElement || this;\n  if (svg2.hasAttribute(\"viewBox\")) {\n    svg2 = svg2.viewBox.baseVal;\n    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];\n  }\n  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];\n}\nfunction defaultTouchable2() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction local2(node) {\n  while (!node.__brush)\n    if (!(node = node.parentNode))\n      return;\n  return node.__brush;\n}\nfunction empty3(extent3) {\n  return extent3[0][0] === extent3[1][0] || extent3[0][1] === extent3[1][1];\n}\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\nfunction brushX() {\n  return brush(X);\n}\nfunction brushY() {\n  return brush(Y);\n}\nfunction brush_default() {\n  return brush(XY);\n}\nfunction brush(dim) {\n  var extent3 = defaultExtent, filter4 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default(\"start\", \"brush\", \"end\"), handleSize = 6, touchending;\n  function brush2(group3) {\n    var overlay = group3.property(\"__brush\", initialize).selectAll(\".overlay\").data([type(\"overlay\")]);\n    overlay.enter().append(\"rect\").attr(\"class\", \"overlay\").attr(\"pointer-events\", \"all\").attr(\"cursor\", cursors.overlay).merge(overlay).each(function() {\n      var extent4 = local2(this).extent;\n      select_default2(this).attr(\"x\", extent4[0][0]).attr(\"y\", extent4[0][1]).attr(\"width\", extent4[1][0] - extent4[0][0]).attr(\"height\", extent4[1][1] - extent4[0][1]);\n    });\n    group3.selectAll(\".selection\").data([type(\"selection\")]).enter().append(\"rect\").attr(\"class\", \"selection\").attr(\"cursor\", cursors.selection).attr(\"fill\", \"#777\").attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"#fff\").attr(\"shape-rendering\", \"crispEdges\");\n    var handle = group3.selectAll(\".handle\").data(dim.handles, function(d) {\n      return d.type;\n    });\n    handle.exit().remove();\n    handle.enter().append(\"rect\").attr(\"class\", function(d) {\n      return \"handle handle--\" + d.type;\n    }).attr(\"cursor\", function(d) {\n      return cursors[d.type];\n    });\n    group3.each(redraw).attr(\"fill\", \"none\").attr(\"pointer-events\", \"all\").on(\"mousedown.brush\", started).filter(touchable).on(\"touchstart.brush\", started).on(\"touchmove.brush\", touchmoved).on(\"touchend.brush touchcancel.brush\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  brush2.move = function(group3, selection2, event) {\n    if (group3.tween) {\n      group3.on(\"start.brush\", function(event2) {\n        emitter(this, arguments).beforestart().start(event2);\n      }).on(\"interrupt.brush end.brush\", function(event2) {\n        emitter(this, arguments).end(event2);\n      }).tween(\"brush\", function() {\n        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(this, arguments) : selection2, state.extent), i = value_default(selection0, selection1);\n        function tween(t) {\n          state.selection = t === 1 && selection1 === null ? null : i(t);\n          redraw.call(that);\n          emit.brush();\n        }\n        return selection0 !== null && selection1 !== null ? tween : tween(1);\n      });\n    } else {\n      group3.each(function() {\n        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();\n        interrupt_default(that);\n        state.selection = selection1 === null ? null : selection1;\n        redraw.call(that);\n        emit.start(event).brush(event).end(event);\n      });\n    }\n  };\n  brush2.clear = function(group3, event) {\n    brush2.move(group3, null, event);\n  };\n  function redraw() {\n    var group3 = select_default2(this), selection2 = local2(this).selection;\n    if (selection2) {\n      group3.selectAll(\".selection\").style(\"display\", null).attr(\"x\", selection2[0][0]).attr(\"y\", selection2[0][1]).attr(\"width\", selection2[1][0] - selection2[0][0]).attr(\"height\", selection2[1][1] - selection2[0][1]);\n      group3.selectAll(\".handle\").style(\"display\", null).attr(\"x\", function(d) {\n        return d.type[d.type.length - 1] === \"e\" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;\n      }).attr(\"y\", function(d) {\n        return d.type[0] === \"s\" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;\n      }).attr(\"width\", function(d) {\n        return d.type === \"n\" || d.type === \"s\" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;\n      }).attr(\"height\", function(d) {\n        return d.type === \"e\" || d.type === \"w\" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;\n      });\n    } else {\n      group3.selectAll(\".selection,.handle\").style(\"display\", \"none\").attr(\"x\", null).attr(\"y\", null).attr(\"width\", null).attr(\"height\", null);\n    }\n  }\n  function emitter(that, args, clean) {\n    var emit = that.__brush.emitter;\n    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);\n  }\n  function Emitter(that, args, clean) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n    this.clean = clean;\n  }\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1)\n        this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function(event, mode2) {\n      if (this.starting)\n        this.starting = false, this.emit(\"start\", event, mode2);\n      else\n        this.emit(\"brush\", event);\n      return this;\n    },\n    brush: function(event, mode2) {\n      this.emit(\"brush\", event, mode2);\n      return this;\n    },\n    end: function(event, mode2) {\n      if (--this.active === 0)\n        delete this.state.emitter, this.emit(\"end\", event, mode2);\n      return this;\n    },\n    emit: function(type2, event, mode2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new BrushEvent(type2, {\n          sourceEvent: event,\n          target: brush2,\n          selection: dim.output(this.state.selection),\n          mode: mode2,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function started(event) {\n    if (touchending && !event.touches)\n      return;\n    if (!filter4.apply(this, arguments))\n      return;\n    var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = \"overlay\" : type2) === \"selection\" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local2(that), extent4 = state.extent, selection2 = state.selection, W = extent4[0][0], w0, w1, N = extent4[0][1], n0, n1, E2 = extent4[1][0], e0, e1, S = extent4[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {\n      const i = t.identifier;\n      t = pointer_default(t, that);\n      t.point0 = t.slice();\n      t.identifier = i;\n      return t;\n    });\n    interrupt_default(that);\n    var emit = emitter(that, arguments, true).beforestart();\n    if (type2 === \"overlay\") {\n      if (selection2)\n        moving = true;\n      const pts = [points[0], points[1] || points[0]];\n      state.selection = selection2 = [[\n        w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),\n        n0 = dim === X ? N : min2(pts[0][1], pts[1][1])\n      ], [\n        e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),\n        s0 = dim === X ? S : max2(pts[0][1], pts[1][1])\n      ]];\n      if (points.length > 1)\n        move(event);\n    } else {\n      w0 = selection2[0][0];\n      n0 = selection2[0][1];\n      e0 = selection2[1][0];\n      s0 = selection2[1][1];\n    }\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n    var group3 = select_default2(that).attr(\"pointer-events\", \"none\");\n    var overlay = group3.selectAll(\".overlay\").attr(\"cursor\", cursors[type2]);\n    if (event.touches) {\n      emit.moved = moved;\n      emit.ended = ended;\n    } else {\n      var view = select_default2(event.view).on(\"mousemove.brush\", moved, true).on(\"mouseup.brush\", ended, true);\n      if (keys)\n        view.on(\"keydown.brush\", keydowned, true).on(\"keyup.brush\", keyupped, true);\n      nodrag_default(event.view);\n    }\n    redraw.call(that);\n    emit.start(event, mode2.name);\n    function moved(event2) {\n      for (const p of event2.changedTouches || [event2]) {\n        for (const d of points)\n          if (d.identifier === p.identifier)\n            d.cur = pointer_default(p, that);\n      }\n      if (shifting && !lockX && !lockY && points.length === 1) {\n        const point6 = points[0];\n        if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))\n          lockY = true;\n        else\n          lockX = true;\n      }\n      for (const point6 of points)\n        if (point6.cur)\n          point6[0] = point6.cur[0], point6[1] = point6.cur[1];\n      moving = true;\n      noevent_default2(event2);\n      move(event2);\n    }\n    function move(event2) {\n      const point6 = points[0], point0 = point6.point0;\n      var t;\n      dx = point6[0] - point0[0];\n      dy = point6[1] - point0[1];\n      switch (mode2) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX)\n            dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY)\n            dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (points[1]) {\n            if (signX)\n              w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;\n            if (signY)\n              n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;\n          } else {\n            if (signX < 0)\n              dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;\n            else if (signX > 0)\n              dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;\n            if (signY < 0)\n              dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n            else if (signY > 0)\n              dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          }\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX)\n            w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));\n          if (signY)\n            n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));\n          break;\n        }\n      }\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type2 in flipX)\n          overlay.attr(\"cursor\", cursors[type2 = flipX[type2]]);\n      }\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type2 in flipY)\n          overlay.attr(\"cursor\", cursors[type2 = flipY[type2]]);\n      }\n      if (state.selection)\n        selection2 = state.selection;\n      if (lockX)\n        w1 = selection2[0][0], e1 = selection2[1][0];\n      if (lockY)\n        n1 = selection2[0][1], s1 = selection2[1][1];\n      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush(event2, mode2.name);\n      }\n    }\n    function ended(event2) {\n      nopropagation2(event2);\n      if (event2.touches) {\n        if (event2.touches.length)\n          return;\n        if (touchending)\n          clearTimeout(touchending);\n        touchending = setTimeout(function() {\n          touchending = null;\n        }, 500);\n      } else {\n        yesdrag(event2.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group3.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection)\n        selection2 = state.selection;\n      if (empty3(selection2))\n        state.selection = null, redraw.call(that);\n      emit.end(event2, mode2.name);\n    }\n    function keydowned(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          shifting = signX && signY;\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_HANDLE) {\n            if (signX)\n              e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY)\n              s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode2 = MODE_CENTER;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1 - dx;\n            else if (signX > 0)\n              w0 = w1 - dx;\n            if (signY < 0)\n              s0 = s1 - dy;\n            else if (signY > 0)\n              n0 = n1 - dy;\n            mode2 = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n    function keyupped(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move(event2);\n          }\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1;\n            else if (signX > 0)\n              w0 = w1;\n            if (signY < 0)\n              s0 = s1;\n            else if (signY > 0)\n              n0 = n1;\n            mode2 = MODE_HANDLE;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_SPACE) {\n            if (event2.altKey) {\n              if (signX)\n                e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY)\n                s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode2 = MODE_CENTER;\n            } else {\n              if (signX < 0)\n                e0 = e1;\n              else if (signX > 0)\n                w0 = w1;\n              if (signY < 0)\n                s0 = s1;\n              else if (signY > 0)\n                n0 = n1;\n              mode2 = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type2]);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n  }\n  function touchmoved(event) {\n    emitter(this, arguments).moved(event);\n  }\n  function touchended(event) {\n    emitter(this, arguments).ended(event);\n  }\n  function initialize() {\n    var state = this.__brush || { selection: null };\n    state.extent = number22(extent3.apply(this, arguments));\n    state.dim = dim;\n    return state;\n  }\n  brush2.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default4(number22(_)), brush2) : extent3;\n  };\n  brush2.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : filter4;\n  };\n  brush2.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : touchable;\n  };\n  brush2.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush2) : handleSize;\n  };\n  brush2.keyModifiers = function(_) {\n    return arguments.length ? (keys = !!_, brush2) : keys;\n  };\n  brush2.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush2 : value;\n  };\n  return brush2;\n}\n\n// node_modules/d3-chord/src/math.js\nvar abs2 = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi2 = Math.PI;\nvar halfPi2 = pi2 / 2;\nvar tau2 = pi2 * 2;\nvar max3 = Math.max;\nvar epsilon3 = 1e-12;\n\n// node_modules/d3-chord/src/chord.js\nfunction range2(i, j) {\n  return Array.from({ length: j - i }, (_, k2) => i + k2);\n}\nfunction compareValue(compare) {\n  return function(a4, b) {\n    return compare(\n      a4.source.value + a4.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\nfunction chord_default() {\n  return chord(false, false);\n}\nfunction chordTranspose() {\n  return chord(false, true);\n}\nfunction chordDirected() {\n  return chord(true, false);\n}\nfunction chord(directed, transpose2) {\n  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;\n  function chord2(matrix) {\n    var n = matrix.length, groupSums = new Array(n), groupIndex2 = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;\n    matrix = Float64Array.from({ length: n * n }, transpose2 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);\n    for (let i = 0; i < n; ++i) {\n      let x4 = 0;\n      for (let j = 0; j < n; ++j)\n        x4 += matrix[i * n + j] + directed * matrix[j * n + i];\n      k2 += groupSums[i] = x4;\n    }\n    k2 = max3(0, tau2 - padAngle * n) / k2;\n    dx = k2 ? padAngle : tau2 / n;\n    {\n      let x4 = 0;\n      if (sortGroups)\n        groupIndex2.sort((a4, b) => sortGroups(groupSums[a4], groupSums[b]));\n      for (const i of groupIndex2) {\n        const x06 = x4;\n        if (directed) {\n          const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(a4 < 0 ? -matrix[~a4 * n + i] : matrix[i * n + a4], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            if (j < 0) {\n              const chord3 = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[~j * n + i] * k2, value: matrix[~j * n + i] };\n            } else {\n              const chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        } else {\n          const subgroupIndex = range2(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(matrix[i * n + a4], matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            let chord3;\n            if (i < j) {\n              chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            } else {\n              chord3 = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n              if (i === j)\n                chord3.source = chord3.target;\n            }\n            if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {\n              const source = chord3.source;\n              chord3.source = chord3.target;\n              chord3.target = source;\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        }\n        x4 += dx;\n      }\n    }\n    chords = Object.values(chords);\n    chords.groups = groups2;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n  chord2.padAngle = function(_) {\n    return arguments.length ? (padAngle = max3(0, _), chord2) : padAngle;\n  };\n  chord2.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord2) : sortGroups;\n  };\n  chord2.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;\n  };\n  chord2.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;\n  };\n  return chord2;\n}\n\n// node_modules/d3-path/src/path.js\nvar pi3 = Math.PI;\nvar tau3 = 2 * pi3;\nvar epsilon4 = 1e-6;\nvar tauEpsilon = tau3 - epsilon4;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new Error(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append;\n  const k2 = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n    }\n  };\n}\nvar Path = class {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x4, y4) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x4, y4) {\n    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  quadraticCurveTo(x12, y12, x4, y4) {\n    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  bezierCurveTo(x12, y12, x22, y22, x4, y4) {\n    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arcTo(x12, y12, x22, y22, r) {\n    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x12},${this._y1 = y12}`;\n    } else if (!(l01_2 > epsilon4))\n      ;\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {\n      this._append`L${this._x1 = x12},${this._y1 = y12}`;\n    } else {\n      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;\n      if (Math.abs(t01 - 1) > epsilon4) {\n        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;\n      }\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;\n    }\n  }\n  arc(x4, y4, r, a0, a1, ccw) {\n    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;\n    if (this._x1 === null) {\n      this._append`M${x06},${y06}`;\n    } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {\n      this._append`L${x06},${y06}`;\n    }\n    if (!r)\n      return;\n    if (da2 < 0)\n      da2 = da2 % tau3 + tau3;\n    if (da2 > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;\n    } else if (da2 > epsilon4) {\n      this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x4, y4, w, h) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n};\nfunction path() {\n  return new Path();\n}\npath.prototype = Path.prototype;\nfunction pathRound(digits = 3) {\n  return new Path(+digits);\n}\n\n// node_modules/d3-chord/src/array.js\nvar slice2 = Array.prototype.slice;\n\n// node_modules/d3-chord/src/constant.js\nfunction constant_default5(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-chord/src/ribbon.js\nfunction defaultSource(d) {\n  return d.source;\n}\nfunction defaultTarget(d) {\n  return d.target;\n}\nfunction defaultRadius(d) {\n  return d.radius;\n}\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\nfunction defaultPadAngle() {\n  return 0;\n}\nfunction defaultArrowheadRadius() {\n  return 10;\n}\nfunction ribbon(headRadius) {\n  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;\n  function ribbon2() {\n    var buffer, s2 = source.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;\n    if (!context)\n      context = buffer = path();\n    if (ap > epsilon3) {\n      if (abs2(sa1 - sa0) > ap * 2 + epsilon3)\n        sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);\n      else\n        sa0 = sa1 = (sa0 + sa1) / 2;\n      if (abs2(ta1 - ta0) > ap * 2 + epsilon3)\n        ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);\n      else\n        ta0 = ta1 = (ta0 + ta1) / 2;\n    }\n    context.moveTo(sr * cos(sa0), sr * sin(sa0));\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) {\n      if (headRadius) {\n        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;\n        context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));\n        context.lineTo(tr * cos(ta2), tr * sin(ta2));\n        context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));\n      } else {\n        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n        context.arc(0, 0, tr, ta0, ta1);\n      }\n    }\n    context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  if (headRadius)\n    ribbon2.headRadius = function(_) {\n      return arguments.length ? (headRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : headRadius;\n    };\n  ribbon2.radius = function(_) {\n    return arguments.length ? (sourceRadius = targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.sourceRadius = function(_) {\n    return arguments.length ? (sourceRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.targetRadius = function(_) {\n    return arguments.length ? (targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : targetRadius;\n  };\n  ribbon2.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : startAngle;\n  };\n  ribbon2.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : endAngle;\n  };\n  ribbon2.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : padAngle;\n  };\n  ribbon2.source = function(_) {\n    return arguments.length ? (source = _, ribbon2) : source;\n  };\n  ribbon2.target = function(_) {\n    return arguments.length ? (target = _, ribbon2) : target;\n  };\n  ribbon2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;\n  };\n  return ribbon2;\n}\nfunction ribbon_default() {\n  return ribbon();\n}\nfunction ribbonArrow() {\n  return ribbon(defaultArrowheadRadius);\n}\n\n// node_modules/d3-contour/src/array.js\nvar array3 = Array.prototype;\nvar slice3 = array3.slice;\n\n// node_modules/d3-contour/src/ascending.js\nfunction ascending_default(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/d3-contour/src/area.js\nfunction area_default(ring) {\n  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n)\n    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area2;\n}\n\n// node_modules/d3-contour/src/constant.js\nvar constant_default6 = (x4) => () => x4;\n\n// node_modules/d3-contour/src/contains.js\nfunction contains_default(ring, hole) {\n  var i = -1, n = hole.length, c6;\n  while (++i < n)\n    if (c6 = ringContains(ring, hole[i]))\n      return c6;\n  return 0;\n}\nfunction ringContains(ring, point6) {\n  var x4 = point6[0], y4 = point6[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi7 = ring[i], xi = pi7[0], yi = pi7[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi7, pj, point6))\n      return 0;\n    if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)\n      contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a4, b, c6) {\n  var i;\n  return collinear(a4, b, c6) && within(a4[i = +(a4[0] === b[0])], c6[i], b[i]);\n}\nfunction collinear(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b[1] - a4[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\n// node_modules/d3-contour/src/noop.js\nfunction noop_default() {\n}\n\n// node_modules/d3-contour/src/contours.js\nvar cases = [\n  [],\n  [[[1, 1.5], [0.5, 1]]],\n  [[[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [0.5, 1]]],\n  [[[1, 0.5], [1.5, 1]]],\n  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],\n  [[[1, 0.5], [1, 1.5]]],\n  [[[1, 0.5], [0.5, 1]]],\n  [[[0.5, 1], [1, 0.5]]],\n  [[[1, 1.5], [1, 0.5]]],\n  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [1, 0.5]]],\n  [[[0.5, 1], [1.5, 1]]],\n  [[[1, 1.5], [1.5, 1]]],\n  [[[0.5, 1], [1, 1.5]]],\n  []\n];\nfunction contours_default() {\n  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;\n  function contours(values2) {\n    var tz = threshold2(values2);\n    if (!Array.isArray(tz)) {\n      const e = extent(values2, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1])\n        tz.pop();\n      while (tz[1] < e[0])\n        tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending_default);\n    }\n    return tz.map((value) => contour2(values2, value));\n  }\n  function contour2(values2, value) {\n    const v2 = value == null ? NaN : +value;\n    if (isNaN(v2))\n      throw new Error(`invalid value: ${value}`);\n    var polygons = [], holes = [];\n    isorings(values2, v2, function(ring) {\n      smooth(ring, values2, v2);\n      if (area_default(ring) > 0)\n        polygons.push([ring]);\n      else\n        holes.push(ring);\n    });\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: \"MultiPolygon\",\n      value,\n      coordinates: polygons\n    };\n  }\n  function isorings(values2, value, callback) {\n    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x4, y4, t03, t13, t22, t32;\n    x4 = y4 = -1;\n    t13 = above(values2[0], value);\n    cases[t13 << 1].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t03 = t13, t13 = above(values2[x4 + 1], value);\n      cases[t03 | t13 << 1].forEach(stitch);\n    }\n    cases[t13 << 0].forEach(stitch);\n    while (++y4 < dy - 1) {\n      x4 = -1;\n      t13 = above(values2[y4 * dx + dx], value);\n      t22 = above(values2[y4 * dx], value);\n      cases[t13 << 1 | t22 << 2].forEach(stitch);\n      while (++x4 < dx - 1) {\n        t03 = t13, t13 = above(values2[y4 * dx + dx + x4 + 1], value);\n        t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);\n      }\n      cases[t13 | t22 << 3].forEach(stitch);\n    }\n    x4 = -1;\n    t22 = values2[y4 * dx] >= value;\n    cases[t22 << 2].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n      cases[t22 << 2 | t32 << 3].forEach(stitch);\n    }\n    cases[t22 << 3].forEach(stitch);\n    function stitch(line2) {\n      var start2 = [line2[0][0] + x4, line2[0][1] + y4], end = [line2[1][0] + x4, line2[1][1] + y4], startIndex = index3(start2), endIndex = index3(end), f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start2);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };\n      }\n    }\n  }\n  function index3(point6) {\n    return point6[0] * 2 + point6[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values2, value) {\n    ring.forEach(function(point6) {\n      var x4 = point6[0], y4 = point6[1], xt = x4 | 0, yt = y4 | 0, v1 = valid(values2[yt * dx + xt]);\n      if (x4 > 0 && x4 < dx && xt === x4) {\n        point6[0] = smooth1(x4, valid(values2[yt * dx + xt - 1]), v1, value);\n      }\n      if (y4 > 0 && y4 < dy && yt === y4) {\n        point6[1] = smooth1(y4, valid(values2[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n  contours.contour = contour2;\n  contours.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold2;\n  };\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction finite(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction above(x4, value) {\n  return x4 == null ? false : +x4 >= value;\n}\nfunction valid(v2) {\n  return v2 == null || isNaN(v2 = +v2) ? -Infinity : v2;\n}\nfunction smooth1(x4, v0, v1, value) {\n  const a4 = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a4) || isFinite(b) ? a4 / b : Math.sign(a4) / Math.sign(b);\n  return isNaN(d) ? x4 : x4 + d - 0.5;\n}\n\n// node_modules/d3-contour/src/density.js\nfunction defaultX(d) {\n  return d[0];\n}\nfunction defaultY(d) {\n  return d[1];\n}\nfunction defaultWeight() {\n  return 1;\n}\nfunction density_default() {\n  var x4 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m3 = dy + o * 2 >> k2, threshold2 = constant_default6(20);\n  function grid(data) {\n    var values2 = new Float32Array(n * m3), pow2k = Math.pow(2, -k2), i = -1;\n    for (const d of data) {\n      var xi = (x4(d, ++i, data) + o) * pow2k, yi = (y4(d, i, data) + o) * pow2k, wi = +weight(d, i, data);\n      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m3) {\n        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;\n        values2[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;\n        values2[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;\n        values2[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;\n        values2[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;\n      }\n    }\n    blur2({ data: values2, width: n, height: m3 }, r * pow2k);\n    return values2;\n  }\n  function density2(data) {\n    var values2 = grid(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k2);\n    if (!Array.isArray(tz)) {\n      tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);\n    }\n    return contours_default().size([n, m3]).thresholds(tz.map((d) => d * pow4k))(values2).map((c6, i) => (c6.value = +tz[i], transform2(c6)));\n  }\n  density2.contours = function(data) {\n    var values2 = grid(data), contours = contours_default().size([n, m3]), pow4k = Math.pow(2, 2 * k2), contour2 = (value) => {\n      value = +value;\n      var c6 = transform2(contours.contour(values2, value * pow4k));\n      c6.value = value;\n      return c6;\n    };\n    Object.defineProperty(contour2, \"max\", { get: () => max(values2) / pow4k });\n    return contour2;\n  };\n  function transform2(geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  }\n  function transformPolygon(coordinates2) {\n    coordinates2.forEach(transformRing);\n  }\n  function transformRing(coordinates2) {\n    coordinates2.forEach(transformPoint);\n  }\n  function transformPoint(coordinates2) {\n    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;\n    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;\n  }\n  function resize() {\n    o = r * 3;\n    n = dx + o * 2 >> k2;\n    m3 = dy + o * 2 >> k2;\n    return density2;\n  }\n  density2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : x4;\n  };\n  density2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : y4;\n  };\n  density2.weight = function(_) {\n    return arguments.length ? (weight = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : weight;\n  };\n  density2.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = +_[0], _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, resize();\n  };\n  density2.cellSize = function(_) {\n    if (!arguments.length)\n      return 1 << k2;\n    if (!((_ = +_) >= 1))\n      throw new Error(\"invalid cell size\");\n    return k2 = Math.floor(Math.log(_) / Math.LN2), resize();\n  };\n  density2.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density2) : threshold2;\n  };\n  density2.bandwidth = function(_) {\n    if (!arguments.length)\n      return Math.sqrt(r * (r + 1));\n    if (!((_ = +_) >= 0))\n      throw new Error(\"invalid bandwidth\");\n    return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();\n  };\n  return density2;\n}\n\n// node_modules/robust-predicates/esm/util.js\nvar epsilon5 = 11102230246251565e-32;\nvar splitter = 134217729;\nvar resulterrbound = (3 + 8 * epsilon5) * epsilon5;\nfunction sum2(elen, e, flen, f, h) {\n  let Q, Qnew, hh, bvirt;\n  let enow = e[0];\n  let fnow = f[0];\n  let eindex = 0;\n  let findex = 0;\n  if (fnow > enow === fnow > -enow) {\n    Q = enow;\n    enow = e[++eindex];\n  } else {\n    Q = fnow;\n    fnow = f[++findex];\n  }\n  let hindex = 0;\n  if (eindex < elen && findex < flen) {\n    if (fnow > enow === fnow > -enow) {\n      Qnew = enow + Q;\n      hh = Q - (Qnew - enow);\n      enow = e[++eindex];\n    } else {\n      Qnew = fnow + Q;\n      hh = Q - (Qnew - fnow);\n      fnow = f[++findex];\n    }\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n    while (eindex < elen && findex < flen) {\n      if (fnow > enow === fnow > -enow) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n      } else {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n      }\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n    }\n  }\n  while (eindex < elen) {\n    Qnew = Q + enow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (enow - bvirt);\n    enow = e[++eindex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  while (findex < flen) {\n    Qnew = Q + fnow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n    fnow = f[++findex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  if (Q !== 0 || hindex === 0) {\n    h[hindex++] = Q;\n  }\n  return hindex;\n}\nfunction estimate(elen, e) {\n  let Q = e[0];\n  for (let i = 1; i < elen; i++)\n    Q += e[i];\n  return Q;\n}\nfunction vec(n) {\n  return new Float64Array(n);\n}\n\n// node_modules/robust-predicates/esm/orient2d.js\nvar ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;\nvar ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;\nvar ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;\nvar B2 = vec(4);\nvar C1 = vec(8);\nvar C2 = vec(12);\nvar D2 = vec(16);\nvar u = vec(4);\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n  let acxtail, acytail, bcxtail, bcytail;\n  let bvirt, c6, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t13, t03, u33;\n  const acx = ax - cx;\n  const bcx = bx - cx;\n  const acy = ay - cy;\n  const bcy = by - cy;\n  s1 = acx * bcy;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcx;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  B2[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  B2[3] = u33;\n  let det = estimate(4, B2);\n  let errbound = ccwerrboundB * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return det;\n  }\n  bvirt = ax - acx;\n  acxtail = ax - (acx + bvirt) + (bvirt - cx);\n  bvirt = bx - bcx;\n  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n  bvirt = ay - acy;\n  acytail = ay - (acy + bvirt) + (bvirt - cy);\n  bvirt = by - bcy;\n  bcytail = by - (bcy + bvirt) + (bvirt - cy);\n  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n    return det;\n  }\n  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n  if (det >= errbound || -det >= errbound)\n    return det;\n  s1 = acxtail * bcy;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcx;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C1len = sum2(4, B2, 4, u, C1);\n  s1 = acx * bcytail;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcxtail;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C2len = sum2(C1len, C1, 4, u, C2);\n  s1 = acxtail * bcytail;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcxtail;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const Dlen = sum2(C2len, C2, 4, u, D2);\n  return D2[Dlen - 1];\n}\nfunction orient2d(ax, ay, bx, by, cx, cy) {\n  const detleft = (ay - cy) * (bx - cx);\n  const detright = (ax - cx) * (by - cy);\n  const det = detleft - detright;\n  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)\n    return det;\n  const detsum = Math.abs(detleft + detright);\n  if (Math.abs(det) >= ccwerrboundA * detsum)\n    return det;\n  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\n// node_modules/robust-predicates/esm/orient3d.js\nvar o3derrboundA = (7 + 56 * epsilon5) * epsilon5;\nvar o3derrboundB = (3 + 28 * epsilon5) * epsilon5;\nvar o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;\nvar bc = vec(4);\nvar ca = vec(4);\nvar ab = vec(4);\nvar at_b = vec(4);\nvar at_c = vec(4);\nvar bt_c = vec(4);\nvar bt_a = vec(4);\nvar ct_a = vec(4);\nvar ct_b = vec(4);\nvar bct = vec(8);\nvar cat = vec(8);\nvar abt = vec(8);\nvar u2 = vec(4);\nvar _8 = vec(8);\nvar _8b = vec(8);\nvar _16 = vec(8);\nvar _12 = vec(12);\nvar fin = vec(192);\nvar fin2 = vec(192);\n\n// node_modules/robust-predicates/esm/incircle.js\nvar iccerrboundA = (10 + 96 * epsilon5) * epsilon5;\nvar iccerrboundB = (4 + 48 * epsilon5) * epsilon5;\nvar iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;\nvar bc2 = vec(4);\nvar ca2 = vec(4);\nvar ab2 = vec(4);\nvar aa = vec(4);\nvar bb = vec(4);\nvar cc = vec(4);\nvar u3 = vec(4);\nvar v = vec(4);\nvar axtbc = vec(8);\nvar aytbc = vec(8);\nvar bxtca = vec(8);\nvar bytca = vec(8);\nvar cxtab = vec(8);\nvar cytab = vec(8);\nvar abt2 = vec(8);\nvar bct2 = vec(8);\nvar cat2 = vec(8);\nvar abtt = vec(4);\nvar bctt = vec(4);\nvar catt = vec(4);\nvar _82 = vec(8);\nvar _162 = vec(16);\nvar _16b = vec(16);\nvar _16c = vec(16);\nvar _32 = vec(32);\nvar _32b = vec(32);\nvar _48 = vec(48);\nvar _64 = vec(64);\nvar fin3 = vec(1152);\nvar fin22 = vec(1152);\n\n// node_modules/robust-predicates/esm/insphere.js\nvar isperrboundA = (16 + 224 * epsilon5) * epsilon5;\nvar isperrboundB = (5 + 72 * epsilon5) * epsilon5;\nvar isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;\nvar ab3 = vec(4);\nvar bc3 = vec(4);\nvar cd = vec(4);\nvar de = vec(4);\nvar ea = vec(4);\nvar ac = vec(4);\nvar bd = vec(4);\nvar ce = vec(4);\nvar da = vec(4);\nvar eb = vec(4);\nvar abc = vec(24);\nvar bcd = vec(24);\nvar cde = vec(24);\nvar dea = vec(24);\nvar eab = vec(24);\nvar abd = vec(24);\nvar bce = vec(24);\nvar cda = vec(24);\nvar deb = vec(24);\nvar eac = vec(24);\nvar adet = vec(1152);\nvar bdet = vec(1152);\nvar cdet = vec(1152);\nvar ddet = vec(1152);\nvar edet = vec(1152);\nvar abdet = vec(2304);\nvar cddet = vec(2304);\nvar cdedet = vec(3456);\nvar deter = vec(5760);\nvar _83 = vec(8);\nvar _8b2 = vec(8);\nvar _8c = vec(8);\nvar _163 = vec(16);\nvar _24 = vec(24);\nvar _482 = vec(48);\nvar _48b = vec(48);\nvar _96 = vec(96);\nvar _192 = vec(192);\nvar _384x = vec(384);\nvar _384y = vec(384);\nvar _384z = vec(384);\nvar _768 = vec(768);\nvar xdet = vec(96);\nvar ydet = vec(96);\nvar zdet = vec(96);\nvar fin4 = vec(1152);\n\n// node_modules/delaunator/index.js\nvar EPSILON = Math.pow(2, -52);\nvar EDGE_STACK = new Uint32Array(512);\nvar Delaunator = class {\n  static from(points, getX = defaultGetX, getY = defaultGetY) {\n    const n = points.length;\n    const coords = new Float64Array(n * 2);\n    for (let i = 0; i < n; i++) {\n      const p = points[i];\n      coords[2 * i] = getX(p);\n      coords[2 * i + 1] = getY(p);\n    }\n    return new Delaunator(coords);\n  }\n  constructor(coords) {\n    const n = coords.length >> 1;\n    if (n > 0 && typeof coords[0] !== \"number\")\n      throw new Error(\"Expected coords to contain numbers.\");\n    this.coords = coords;\n    const maxTriangles = Math.max(2 * n - 5, 0);\n    this._triangles = new Uint32Array(maxTriangles * 3);\n    this._halfedges = new Int32Array(maxTriangles * 3);\n    this._hashSize = Math.ceil(Math.sqrt(n));\n    this._hullPrev = new Uint32Array(n);\n    this._hullNext = new Uint32Array(n);\n    this._hullTri = new Uint32Array(n);\n    this._hullHash = new Int32Array(this._hashSize).fill(-1);\n    this._ids = new Uint32Array(n);\n    this._dists = new Float64Array(n);\n    this.update();\n  }\n  update() {\n    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;\n    const n = coords.length >> 1;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY2 = -Infinity;\n    for (let i = 0; i < n; i++) {\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (x4 < minX)\n        minX = x4;\n      if (y4 < minY)\n        minY = y4;\n      if (x4 > maxX)\n        maxX = x4;\n      if (y4 > maxY2)\n        maxY2 = y4;\n      this._ids[i] = i;\n    }\n    const cx = (minX + maxX) / 2;\n    const cy = (minY + maxY2) / 2;\n    let minDist = Infinity;\n    let i0, i1, i2;\n    for (let i = 0; i < n; i++) {\n      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist) {\n        i0 = i;\n        minDist = d;\n      }\n    }\n    const i0x = coords[2 * i0];\n    const i0y = coords[2 * i0 + 1];\n    minDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0)\n        continue;\n      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist && d > 0) {\n        i1 = i;\n        minDist = d;\n      }\n    }\n    let i1x = coords[2 * i1];\n    let i1y = coords[2 * i1 + 1];\n    let minRadius = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0 || i === i1)\n        continue;\n      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n      if (r < minRadius) {\n        i2 = i;\n        minRadius = r;\n      }\n    }\n    let i2x = coords[2 * i2];\n    let i2y = coords[2 * i2 + 1];\n    if (minRadius === Infinity) {\n      for (let i = 0; i < n; i++) {\n        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];\n      }\n      quicksort(this._ids, this._dists, 0, n - 1);\n      const hull2 = new Uint32Array(n);\n      let j = 0;\n      for (let i = 0, d0 = -Infinity; i < n; i++) {\n        const id2 = this._ids[i];\n        if (this._dists[id2] > d0) {\n          hull2[j++] = id2;\n          d0 = this._dists[id2];\n        }\n      }\n      this.hull = hull2.subarray(0, j);\n      this.triangles = new Uint32Array(0);\n      this.halfedges = new Uint32Array(0);\n      return;\n    }\n    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n      const i = i1;\n      const x4 = i1x;\n      const y4 = i1y;\n      i1 = i2;\n      i1x = i2x;\n      i1y = i2y;\n      i2 = i;\n      i2x = x4;\n      i2y = y4;\n    }\n    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n    this._cx = center2.x;\n    this._cy = center2.y;\n    for (let i = 0; i < n; i++) {\n      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);\n    }\n    quicksort(this._ids, this._dists, 0, n - 1);\n    this._hullStart = i0;\n    let hullSize = 3;\n    hullNext[i0] = hullPrev[i2] = i1;\n    hullNext[i1] = hullPrev[i0] = i2;\n    hullNext[i2] = hullPrev[i1] = i0;\n    hullTri[i0] = 0;\n    hullTri[i1] = 1;\n    hullTri[i2] = 2;\n    hullHash.fill(-1);\n    hullHash[this._hashKey(i0x, i0y)] = i0;\n    hullHash[this._hashKey(i1x, i1y)] = i1;\n    hullHash[this._hashKey(i2x, i2y)] = i2;\n    this.trianglesLen = 0;\n    this._addTriangle(i0, i1, i2, -1, -1, -1);\n    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {\n      const i = this._ids[k2];\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (k2 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)\n        continue;\n      xp = x4;\n      yp = y4;\n      if (i === i0 || i === i1 || i === i2)\n        continue;\n      let start2 = 0;\n      for (let j = 0, key = this._hashKey(x4, y4); j < this._hashSize; j++) {\n        start2 = hullHash[(key + j) % this._hashSize];\n        if (start2 !== -1 && start2 !== hullNext[start2])\n          break;\n      }\n      start2 = hullPrev[start2];\n      let e = start2, q;\n      while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n        e = q;\n        if (e === start2) {\n          e = -1;\n          break;\n        }\n      }\n      if (e === -1)\n        continue;\n      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n      hullTri[i] = this._legalize(t + 2);\n      hullTri[e] = t;\n      hullSize++;\n      let n2 = hullNext[e];\n      while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);\n        hullTri[i] = this._legalize(t + 2);\n        hullNext[n2] = n2;\n        hullSize--;\n        n2 = q;\n      }\n      if (e === start2) {\n        while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n          this._legalize(t + 2);\n          hullTri[q] = t;\n          hullNext[e] = e;\n          hullSize--;\n          e = q;\n        }\n      }\n      this._hullStart = hullPrev[i] = e;\n      hullNext[e] = hullPrev[n2] = i;\n      hullNext[i] = n2;\n      hullHash[this._hashKey(x4, y4)] = i;\n      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n    }\n    this.hull = new Uint32Array(hullSize);\n    for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n      this.hull[i] = e;\n      e = hullNext[e];\n    }\n    this.triangles = this._triangles.subarray(0, this.trianglesLen);\n    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n  }\n  _hashKey(x4, y4) {\n    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;\n  }\n  _legalize(a4) {\n    const { _triangles: triangles, _halfedges: halfedges, coords } = this;\n    let i = 0;\n    let ar = 0;\n    while (true) {\n      const b = halfedges[a4];\n      const a0 = a4 - a4 % 3;\n      ar = a0 + (a4 + 2) % 3;\n      if (b === -1) {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n        continue;\n      }\n      const b02 = b - b % 3;\n      const al = a0 + (a4 + 1) % 3;\n      const bl = b02 + (b + 2) % 3;\n      const p02 = triangles[ar];\n      const pr = triangles[a4];\n      const pl = triangles[al];\n      const p1 = triangles[bl];\n      const illegal = inCircle(\n        coords[2 * p02],\n        coords[2 * p02 + 1],\n        coords[2 * pr],\n        coords[2 * pr + 1],\n        coords[2 * pl],\n        coords[2 * pl + 1],\n        coords[2 * p1],\n        coords[2 * p1 + 1]\n      );\n      if (illegal) {\n        triangles[a4] = p1;\n        triangles[b] = p02;\n        const hbl = halfedges[bl];\n        if (hbl === -1) {\n          let e = this._hullStart;\n          do {\n            if (this._hullTri[e] === bl) {\n              this._hullTri[e] = a4;\n              break;\n            }\n            e = this._hullPrev[e];\n          } while (e !== this._hullStart);\n        }\n        this._link(a4, hbl);\n        this._link(b, halfedges[ar]);\n        this._link(ar, bl);\n        const br = b02 + (b + 1) % 3;\n        if (i < EDGE_STACK.length) {\n          EDGE_STACK[i++] = br;\n        }\n      } else {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n      }\n    }\n    return ar;\n  }\n  _link(a4, b) {\n    this._halfedges[a4] = b;\n    if (b !== -1)\n      this._halfedges[b] = a4;\n  }\n  // add a new triangle given vertex indices and adjacent half-edge ids\n  _addTriangle(i0, i1, i2, a4, b, c6) {\n    const t = this.trianglesLen;\n    this._triangles[t] = i0;\n    this._triangles[t + 1] = i1;\n    this._triangles[t + 2] = i2;\n    this._link(t, a4);\n    this._link(t + 1, b);\n    this._link(t + 2, c6);\n    this.trianglesLen += 3;\n    return t;\n  }\n};\nfunction pseudoAngle(dx, dy) {\n  const p = dx / (Math.abs(dx) + Math.abs(dy));\n  return (dy > 0 ? 3 - p : 1 + p) / 4;\n}\nfunction dist(ax, ay, bx, by) {\n  const dx = ax - bx;\n  const dy = ay - by;\n  return dx * dx + dy * dy;\n}\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n  const dx = ax - px;\n  const dy = ay - py;\n  const ex = bx - px;\n  const ey = by - py;\n  const fx = cx - px;\n  const fy = cy - py;\n  const ap = dx * dx + dy * dy;\n  const bp = ex * ex + ey * ey;\n  const cp = fx * fx + fy * fy;\n  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n}\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = (ey * bl - dy * cl) * d;\n  const y4 = (dx * cl - ex * bl) * d;\n  return x4 * x4 + y4 * y4;\n}\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = ax + (ey * bl - dy * cl) * d;\n  const y4 = ay + (dx * cl - ex * bl) * d;\n  return { x: x4, y: y4 };\n}\nfunction quicksort(ids, dists, left2, right2) {\n  if (right2 - left2 <= 20) {\n    for (let i = left2 + 1; i <= right2; i++) {\n      const temp = ids[i];\n      const tempDist = dists[temp];\n      let j = i - 1;\n      while (j >= left2 && dists[ids[j]] > tempDist)\n        ids[j + 1] = ids[j--];\n      ids[j + 1] = temp;\n    }\n  } else {\n    const median2 = left2 + right2 >> 1;\n    let i = left2 + 1;\n    let j = right2;\n    swap2(ids, median2, i);\n    if (dists[ids[left2]] > dists[ids[right2]])\n      swap2(ids, left2, right2);\n    if (dists[ids[i]] > dists[ids[right2]])\n      swap2(ids, i, right2);\n    if (dists[ids[left2]] > dists[ids[i]])\n      swap2(ids, left2, i);\n    const temp = ids[i];\n    const tempDist = dists[temp];\n    while (true) {\n      do\n        i++;\n      while (dists[ids[i]] < tempDist);\n      do\n        j--;\n      while (dists[ids[j]] > tempDist);\n      if (j < i)\n        break;\n      swap2(ids, i, j);\n    }\n    ids[left2 + 1] = ids[j];\n    ids[j] = temp;\n    if (right2 - i + 1 >= j - left2) {\n      quicksort(ids, dists, i, right2);\n      quicksort(ids, dists, left2, j - 1);\n    } else {\n      quicksort(ids, dists, left2, j - 1);\n      quicksort(ids, dists, i, right2);\n    }\n  }\n}\nfunction swap2(arr, i, j) {\n  const tmp2 = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp2;\n}\nfunction defaultGetX(p) {\n  return p[0];\n}\nfunction defaultGetY(p) {\n  return p[1];\n}\n\n// node_modules/d3-delaunay/src/path.js\nvar epsilon6 = 1e-6;\nvar Path2 = class {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n  }\n  moveTo(x4, y4) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x4, y4) {\n    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arc(x4, y4, r) {\n    x4 = +x4, y4 = +y4, r = +r;\n    const x06 = x4 + r;\n    const y06 = y4;\n    if (r < 0)\n      throw new Error(\"negative radius\");\n    if (this._x1 === null)\n      this._ += `M${x06},${y06}`;\n    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)\n      this._ += \"L\" + x06 + \",\" + y06;\n    if (!r)\n      return;\n    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;\n  }\n  rect(x4, y4, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n};\n\n// node_modules/d3-delaunay/src/polygon.js\nvar Polygon = class {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n};\n\n// node_modules/d3-delaunay/src/voronoi.js\nvar Voronoi = class {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))\n      throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const { delaunay: { points, hull: hull2, triangles }, vectors } = this;\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {\n      const t13 = triangles[i] * 2;\n      const t22 = triangles[i + 1] * 2;\n      const t32 = triangles[i + 2] * 2;\n      const x13 = points[t13];\n      const y13 = points[t13 + 1];\n      const x22 = points[t22];\n      const y22 = points[t22 + 1];\n      const x32 = points[t32];\n      const y32 = points[t32 + 1];\n      const dx = x22 - x13;\n      const dy = y22 - y13;\n      const ex = x32 - x13;\n      const ey = y32 - y13;\n      const ab4 = (dx * ey - dy * ex) * 2;\n      if (Math.abs(ab4) < 1e-9) {\n        let a4 = 1e9;\n        const r = triangles[0] * 2;\n        a4 *= Math.sign((points[r] - x13) * ey - (points[r + 1] - y13) * ex);\n        x4 = (x13 + x32) / 2 - a4 * ey;\n        y4 = (y13 + y32) / 2 + a4 * ex;\n      } else {\n        const d = 1 / ab4;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x4 = x13 + (ey * bl - dy * cl) * d;\n        y4 = y13 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x4;\n      circumcenters[j + 1] = y4;\n    }\n    let h = hull2[hull2.length - 1];\n    let p02, p1 = h * 4;\n    let x06, x12 = points[2 * h];\n    let y06, y12 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull2.length; ++i) {\n      h = hull2[i];\n      p02 = p1, x06 = x12, y06 = y12;\n      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];\n      vectors[p02 + 2] = vectors[p1] = y06 - y12;\n      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { delaunay: { halfedges, inedges, hull: hull2 }, circumcenters, vectors } = this;\n    if (hull2.length <= 1)\n      return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull2[hull2.length - 1];\n    for (let i = 0; i < hull2.length; ++i) {\n      h0 = h1, h1 = hull2[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x4 = circumcenters[t];\n      const y4 = circumcenters[t + 1];\n      const v2 = h0 * 4;\n      const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);\n      if (p)\n        this._renderSegment(x4, y4, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const points = this._clip(i);\n    if (points === null || !points.length)\n      return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)\n      n -= 2;\n    for (let i2 = 2; i2 < n; i2 += 2) {\n      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])\n        context.lineTo(points[i2], points[i2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const { delaunay: { points } } = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell2 = this.cellPolygon(i);\n      if (cell2)\n        cell2.index = i, yield cell2;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon();\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x06, y06, x12, y12, context) {\n    let S;\n    const c0 = this._regioncode(x06, y06);\n    const c1 = this._regioncode(x12, y12);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x06, y06);\n      context.lineTo(x12, y12);\n    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x4, y4) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return false;\n    return this.delaunay._step(i, x4, y4) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci)\n      for (const j of this.delaunay.neighbors(i)) {\n        const cj = this._clip(j);\n        if (cj)\n          loop:\n            for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {\n                  yield j;\n                  break loop;\n                }\n              }\n            }\n      }\n  }\n  _cell(i) {\n    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return null;\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null)\n      return null;\n    const { vectors: V } = this;\n    const v2 = i * 4;\n    return V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points);\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x06, y06, x12 = points[n - 2], y12 = points[n - 1];\n    let c0, c1 = this._regioncode(x12, y12);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x12, y12);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P)\n          P.push(x12, y12);\n        else\n          P = [x12, y12];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)\n            continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)\n            continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1)\n            this._edge(i, e0, e1, P, P.length);\n          if (P)\n            P.push(sx0, sy0);\n          else\n            P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1)\n          this._edge(i, e0, e1, P, P.length);\n        if (P)\n          P.push(sx1, sy1);\n        else\n          P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1)\n        this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x06, y06, x12, y12, c0, c1) {\n    while (true) {\n      if (c0 === 0 && c1 === 0)\n        return [x06, y06, x12, y12];\n      if (c0 & c1)\n        return null;\n      let x4, y4, c6 = c0 || c1;\n      if (c6 & 8)\n        x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;\n      else if (c6 & 4)\n        x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;\n      else if (c6 & 2)\n        y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;\n      else\n        y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;\n      if (c0)\n        x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);\n      else\n        x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0))\n      P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))\n      P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1)\n          j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x4, y4;\n      switch (e0) {\n        case 5:\n          e0 = 4;\n          continue;\n        case 4:\n          e0 = 6, x4 = this.xmax, y4 = this.ymin;\n          break;\n        case 6:\n          e0 = 2;\n          continue;\n        case 2:\n          e0 = 10, x4 = this.xmax, y4 = this.ymax;\n          break;\n        case 10:\n          e0 = 8;\n          continue;\n        case 8:\n          e0 = 9, x4 = this.xmin, y4 = this.ymax;\n          break;\n        case 9:\n          e0 = 1;\n          continue;\n        case 1:\n          e0 = 5, x4 = this.xmin, y4 = this.ymin;\n          break;\n      }\n      if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {\n        P.splice(j, 0, x4, y4), j += 2;\n      }\n    }\n    if (P.length > 4) {\n      for (let i2 = 0; i2 < P.length; i2 += 2) {\n        const j2 = (i2 + 2) % P.length, k2 = (i2 + 4) % P.length;\n        if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])\n          P.splice(j2, 2), i2 -= 2;\n      }\n    }\n    return j;\n  }\n  _project(x06, y06, vx, vy) {\n    let t = Infinity, c6, x4, y4;\n    if (vy < 0) {\n      if (y06 <= this.ymin)\n        return null;\n      if ((c6 = (this.ymin - y06) / vy) < t)\n        y4 = this.ymin, x4 = x06 + (t = c6) * vx;\n    } else if (vy > 0) {\n      if (y06 >= this.ymax)\n        return null;\n      if ((c6 = (this.ymax - y06) / vy) < t)\n        y4 = this.ymax, x4 = x06 + (t = c6) * vx;\n    }\n    if (vx > 0) {\n      if (x06 >= this.xmax)\n        return null;\n      if ((c6 = (this.xmax - x06) / vx) < t)\n        x4 = this.xmax, y4 = y06 + (t = c6) * vy;\n    } else if (vx < 0) {\n      if (x06 <= this.xmin)\n        return null;\n      if ((c6 = (this.xmin - x06) / vx) < t)\n        x4 = this.xmin, y4 = y06 + (t = c6) * vy;\n    }\n    return [x4, y4];\n  }\n  _edgecode(x4, y4) {\n    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);\n  }\n  _regioncode(x4, y4) {\n    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);\n  }\n};\n\n// node_modules/d3-delaunay/src/delaunay.js\nvar tau4 = 2 * Math.PI;\nvar pow = Math.pow;\nfunction pointX(p) {\n  return p[0];\n}\nfunction pointY(p) {\n  return p[1];\n}\nfunction collinear2(d) {\n  const { triangles, coords } = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a4 = 2 * triangles[i], b = 2 * triangles[i + 1], c6 = 2 * triangles[i + 2], cross2 = (coords[c6] - coords[a4]) * (coords[b + 1] - coords[a4 + 1]) - (coords[b] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);\n    if (cross2 > 1e-10)\n      return false;\n  }\n  return true;\n}\nfunction jitter(x4, y4, r) {\n  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];\n}\nvar Delaunay = class {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n    if (d.hull && d.hull.length > 2 && collinear2(d)) {\n      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull2 = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1)\n        inedges[p] = e;\n    }\n    for (let i = 0, n = hull2.length; i < n; ++i) {\n      hullIndex[hull2[i]] = i;\n    }\n    if (hull2.length <= 2 && hull2.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull2[0];\n      inedges[hull2[0]] = 1;\n      if (hull2.length === 2) {\n        inedges[hull2[1]] = 0;\n        this.triangles[1] = hull2[1];\n        this.triangles[2] = hull2[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;\n    if (collinear3) {\n      const l = collinear3.indexOf(i);\n      if (l > 0)\n        yield collinear3[l - 1];\n      if (l < collinear3.length - 1)\n        yield collinear3[l + 1];\n      return;\n    }\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return;\n    let e = e0, p02 = -1;\n    do {\n      yield p02 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        return;\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (p !== p02)\n          yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x4, y4, i = 0) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return -1;\n    const i0 = i;\n    let c6;\n    while ((c6 = this._step(i, x4, y4)) >= 0 && c6 !== i && c6 !== i0)\n      i = c6;\n    return c6;\n  }\n  _step(i, x4, y4) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, points } = this;\n    if (inedges[i] === -1 || !points.length)\n      return (i + 1) % (points.length >> 1);\n    let c6 = i;\n    let dc = pow(x4 - points[i * 2], 2) + pow(y4 - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x4 - points[t * 2], 2) + pow(y4 - points[t * 2 + 1], 2);\n      if (dt < dc)\n        dc = dt, c6 = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (e !== t) {\n          if (pow(x4 - points[e * 2], 2) + pow(y4 - points[e * 2 + 1], 2) < dc)\n            return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c6;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, halfedges, triangles } = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === void 0 && (!context || typeof context.moveTo !== \"function\"))\n      r = context, context = null;\n    r = r == void 0 ? 2 : +r;\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points } = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x4 = points[i], y4 = points[i + 1];\n      context.moveTo(x4 + r, y4);\n      context.arc(x4, y4, r, 0, tau4);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { hull: hull2, points } = this;\n    const h = hull2[0] * 2, n = hull2.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h2 = 2 * hull2[i];\n      context.lineTo(points[h2], points[h2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon();\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, triangles } = this;\n    const t03 = triangles[i *= 3] * 2;\n    const t13 = triangles[i + 1] * 2;\n    const t22 = triangles[i + 2] * 2;\n    context.moveTo(points[t03], points[t03 + 1]);\n    context.lineTo(points[t13], points[t13 + 1]);\n    context.lineTo(points[t22], points[t22 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const { triangles } = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon();\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n};\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array4 = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array4[i * 2] = fx.call(that, p, i, points);\n    array4[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array4;\n}\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n\n// node_modules/d3-dsv/src/dsv.js\nvar EOL = {};\nvar EOF = {};\nvar QUOTE = 34;\nvar NEWLINE = 10;\nvar RETURN = 13;\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + '] || \"\"';\n  }).join(\",\") + \"}\");\n}\nfunction customConverter(columns, f) {\n  var object2 = objectConverter(columns);\n  return function(row, i) {\n    return f(object2(row), i, columns);\n  };\n}\nfunction inferColumns(rows) {\n  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];\n  rows.forEach(function(row) {\n    for (var column2 in row) {\n      if (!(column2 in columnSet)) {\n        columns.push(columnSet[column2] = column2);\n      }\n    }\n  });\n  return columns;\n}\nfunction pad(value, width) {\n  var s2 = value + \"\", length4 = s2.length;\n  return length4 < width ? new Array(width - length4 + 1).join(0) + s2 : s2;\n}\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6) : year > 9999 ? \"+\" + pad(year, 6) : pad(year, 4);\n}\nfunction formatDate(date2) {\n  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();\n  return isNaN(date2) ? \"Invalid Date\" : formatYear(date2.getUTCFullYear(), 4) + \"-\" + pad(date2.getUTCMonth() + 1, 2) + \"-\" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \".\" + pad(milliseconds2, 3) + \"Z\" : seconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \"Z\" : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\" : \"\");\n}\nfunction dsv_default(delimiter) {\n  var reFormat = new RegExp('[\"' + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0);\n  function parse2(text2, f) {\n    var convert, columns, rows = parseRows(text2, function(row, i) {\n      if (convert)\n        return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n  function parseRows(text2, f) {\n    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;\n    if (text2.charCodeAt(N - 1) === NEWLINE)\n      --N;\n    if (text2.charCodeAt(N - 1) === RETURN)\n      --N;\n    function token() {\n      if (eof)\n        return EOF;\n      if (eol)\n        return eol = false, EOL;\n      var i, j = I, c6;\n      if (text2.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)\n          ;\n        if ((i = I) >= N)\n          eof = true;\n        else if ((c6 = text2.charCodeAt(I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        }\n        return text2.slice(j + 1, i - 1).replace(/\"\"/g, '\"');\n      }\n      while (I < N) {\n        if ((c6 = text2.charCodeAt(i = I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        } else if (c6 !== DELIMITER)\n          continue;\n        return text2.slice(j, i);\n      }\n      return eof = true, text2.slice(j, N);\n    }\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF)\n        row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null)\n        continue;\n      rows.push(row);\n    }\n    return rows;\n  }\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column2) {\n        return formatValue(row[column2]);\n      }).join(delimiter);\n    });\n  }\n  function format3(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n  function formatBody(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n  function formatValue(value) {\n    return value == null ? \"\" : value instanceof Date ? formatDate(value) : reFormat.test(value += \"\") ? '\"' + value.replace(/\"/g, '\"\"') + '\"' : value;\n  }\n  return {\n    parse: parse2,\n    parseRows,\n    format: format3,\n    formatBody,\n    formatRows,\n    formatRow,\n    formatValue\n  };\n}\n\n// node_modules/d3-dsv/src/csv.js\nvar csv = dsv_default(\",\");\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatBody = csv.formatBody;\nvar csvFormatRows = csv.formatRows;\nvar csvFormatRow = csv.formatRow;\nvar csvFormatValue = csv.formatValue;\n\n// node_modules/d3-dsv/src/tsv.js\nvar tsv = dsv_default(\"\t\");\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatBody = tsv.formatBody;\nvar tsvFormatRows = tsv.formatRows;\nvar tsvFormatRow = tsv.formatRow;\nvar tsvFormatValue = tsv.formatValue;\n\n// node_modules/d3-dsv/src/autoType.js\nfunction autoType(object2) {\n  for (var key in object2) {\n    var value = object2[key].trim(), number7, m3;\n    if (!value)\n      value = null;\n    else if (value === \"true\")\n      value = true;\n    else if (value === \"false\")\n      value = false;\n    else if (value === \"NaN\")\n      value = NaN;\n    else if (!isNaN(number7 = +value))\n      value = number7;\n    else if (m3 = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n      if (fixtz && !!m3[4] && !m3[7])\n        value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n      value = new Date(value);\n    } else\n      continue;\n    object2[key] = value;\n  }\n  return object2;\n}\nvar fixtz = (/* @__PURE__ */ new Date(\"2019-01-01T00:00\")).getHours() || (/* @__PURE__ */ new Date(\"2019-07-01T00:00\")).getHours();\n\n// node_modules/d3-fetch/src/blob.js\nfunction responseBlob(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.blob();\n}\nfunction blob_default(input, init2) {\n  return fetch(input, init2).then(responseBlob);\n}\n\n// node_modules/d3-fetch/src/buffer.js\nfunction responseArrayBuffer(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.arrayBuffer();\n}\nfunction buffer_default(input, init2) {\n  return fetch(input, init2).then(responseArrayBuffer);\n}\n\n// node_modules/d3-fetch/src/text.js\nfunction responseText(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.text();\n}\nfunction text_default3(input, init2) {\n  return fetch(input, init2).then(responseText);\n}\n\n// node_modules/d3-fetch/src/dsv.js\nfunction dsvParse(parse2) {\n  return function(input, init2, row) {\n    if (arguments.length === 2 && typeof init2 === \"function\")\n      row = init2, init2 = void 0;\n    return text_default3(input, init2).then(function(response) {\n      return parse2(response, row);\n    });\n  };\n}\nfunction dsv(delimiter, input, init2, row) {\n  if (arguments.length === 3 && typeof init2 === \"function\")\n    row = init2, init2 = void 0;\n  var format3 = dsv_default(delimiter);\n  return text_default3(input, init2).then(function(response) {\n    return format3.parse(response, row);\n  });\n}\nvar csv2 = dsvParse(csvParse);\nvar tsv2 = dsvParse(tsvParse);\n\n// node_modules/d3-fetch/src/image.js\nfunction image_default(input, init2) {\n  return new Promise(function(resolve, reject) {\n    var image2 = new Image();\n    for (var key in init2)\n      image2[key] = init2[key];\n    image2.onerror = reject;\n    image2.onload = function() {\n      resolve(image2);\n    };\n    image2.src = input;\n  });\n}\n\n// node_modules/d3-fetch/src/json.js\nfunction responseJson(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  if (response.status === 204 || response.status === 205)\n    return;\n  return response.json();\n}\nfunction json_default(input, init2) {\n  return fetch(input, init2).then(responseJson);\n}\n\n// node_modules/d3-fetch/src/xml.js\nfunction parser(type2) {\n  return (input, init2) => text_default3(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));\n}\nvar xml_default = parser(\"application/xml\");\nvar html = parser(\"text/html\");\nvar svg = parser(\"image/svg+xml\");\n\n// node_modules/d3-force/src/center.js\nfunction center_default(x4, y4) {\n  var nodes, strength = 1;\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force() {\n    var i, n = nodes.length, node, sx = 0, sy = 0;\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n    for (sx = (sx / n - x4) * strength, sy = (sy / n - y4) * strength, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  return force;\n}\n\n// node_modules/d3-quadtree/src/add.js\nfunction add_default(d) {\n  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);\n  return add(this.cover(x4, y4), x4, y4, d);\n}\nfunction add(tree2, x4, y4, d) {\n  if (isNaN(x4) || isNaN(y4))\n    return tree2;\n  var parent, node = tree2._root, leaf = { data: d }, x06 = tree2._x0, y06 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;\n  if (!node)\n    return tree2._root = leaf, tree2;\n  while (node.length) {\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n    if (parent = node, !(node = node[i = bottom2 << 1 | right2]))\n      return parent[i] = leaf, tree2;\n  }\n  xp = +tree2._x.call(null, node.data);\n  yp = +tree2._y.call(null, node.data);\n  if (x4 === xp && y4 === yp)\n    return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));\n  return parent[j] = node, parent[i] = leaf, tree2;\n}\nfunction addAll(data) {\n  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))\n      continue;\n    xz[i] = x4;\n    yz[i] = y4;\n    if (x4 < x06)\n      x06 = x4;\n    if (x4 > x12)\n      x12 = x4;\n    if (y4 < y06)\n      y06 = y4;\n    if (y4 > y12)\n      y12 = y4;\n  }\n  if (x06 > x12 || y06 > y12)\n    return this;\n  this.cover(x06, y06).cover(x12, y12);\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/cover.js\nfunction cover_default(x4, y4) {\n  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))\n    return this;\n  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;\n  if (isNaN(x06)) {\n    x12 = (x06 = Math.floor(x4)) + 1;\n    y12 = (y06 = Math.floor(y4)) + 1;\n  } else {\n    var z = x12 - x06 || 1, node = this._root, parent, i;\n    while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {\n      i = (y4 < y06) << 1 | x4 < x06;\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0:\n          x12 = x06 + z, y12 = y06 + z;\n          break;\n        case 1:\n          x06 = x12 - z, y12 = y06 + z;\n          break;\n        case 2:\n          x12 = x06 + z, y06 = y12 - z;\n          break;\n        case 3:\n          x06 = x12 - z, y06 = y12 - z;\n          break;\n      }\n    }\n    if (this._root && this._root.length)\n      this._root = node;\n  }\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  return this;\n}\n\n// node_modules/d3-quadtree/src/data.js\nfunction data_default2() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        data.push(node.data);\n      while (node = node.next);\n  });\n  return data;\n}\n\n// node_modules/d3-quadtree/src/extent.js\nfunction extent_default(_) {\n  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n\n// node_modules/d3-quadtree/src/quad.js\nfunction quad_default(node, x06, y06, x12, y12) {\n  this.node = node;\n  this.x0 = x06;\n  this.y0 = y06;\n  this.x1 = x12;\n  this.y1 = y12;\n}\n\n// node_modules/d3-quadtree/src/find.js\nfunction find_default(x4, y4, radius2) {\n  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;\n  if (node)\n    quads.push(new quad_default(node, x06, y06, x32, y32));\n  if (radius2 == null)\n    radius2 = Infinity;\n  else {\n    x06 = x4 - radius2, y06 = y4 - radius2;\n    x32 = x4 + radius2, y32 = y4 + radius2;\n    radius2 *= radius2;\n  }\n  while (q = quads.pop()) {\n    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)\n      continue;\n    if (node.length) {\n      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;\n      quads.push(\n        new quad_default(node[3], xm, ym, x22, y22),\n        new quad_default(node[2], x12, ym, xm, y22),\n        new quad_default(node[1], xm, y12, x22, ym),\n        new quad_default(node[0], x12, y12, xm, ym)\n      );\n      if (i = (y4 >= ym) << 1 | x4 >= xm) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    } else {\n      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;\n      if (d2 < radius2) {\n        var d = Math.sqrt(radius2 = d2);\n        x06 = x4 - d, y06 = y4 - d;\n        x32 = x4 + d, y32 = y4 + d;\n        data = node.data;\n      }\n    }\n  }\n  return data;\n}\n\n// node_modules/d3-quadtree/src/remove.js\nfunction remove_default3(d) {\n  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))\n    return this;\n  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x4, y4, xm, ym, right2, bottom2, i, j;\n  if (!node)\n    return this;\n  if (node.length)\n    while (true) {\n      if (right2 = x4 >= (xm = (x06 + x12) / 2))\n        x06 = xm;\n      else\n        x12 = xm;\n      if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n        y06 = ym;\n      else\n        y12 = ym;\n      if (!(parent = node, node = node[i = bottom2 << 1 | right2]))\n        return this;\n      if (!node.length)\n        break;\n      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])\n        retainer = parent, j = i;\n    }\n  while (node.data !== d)\n    if (!(previous = node, node = node.next))\n      return this;\n  if (next = node.next)\n    delete node.next;\n  if (previous)\n    return next ? previous.next = next : delete previous.next, this;\n  if (!parent)\n    return this._root = next, this;\n  next ? parent[i] = next : delete parent[i];\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {\n    if (retainer)\n      retainer[j] = node;\n    else\n      this._root = node;\n  }\n  return this;\n}\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i)\n    this.remove(data[i]);\n  return this;\n}\n\n// node_modules/d3-quadtree/src/root.js\nfunction root_default() {\n  return this._root;\n}\n\n// node_modules/d3-quadtree/src/size.js\nfunction size_default2() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        ++size;\n      while (node = node.next);\n  });\n  return size;\n}\n\n// node_modules/d3-quadtree/src/visit.js\nfunction visit_default(callback) {\n  var quads = [], q, node = this._root, child, x06, y06, x12, y12;\n  if (node)\n    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {\n      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/visitAfter.js\nfunction visitAfter_default(callback) {\n  var quads = [], next = [], q;\n  if (this._root)\n    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/x.js\nfunction defaultX2(d) {\n  return d[0];\n}\nfunction x_default(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n\n// node_modules/d3-quadtree/src/y.js\nfunction defaultY2(d) {\n  return d[1];\n}\nfunction y_default(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n\n// node_modules/d3-quadtree/src/quadtree.js\nfunction quadtree(nodes, x4, y4) {\n  var tree2 = new Quadtree(x4 == null ? defaultX2 : x4, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree2 : tree2.addAll(nodes);\n}\nfunction Quadtree(x4, y4, x06, y06, x12, y12) {\n  this._x = x4;\n  this._y = y4;\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  this._root = void 0;\n}\nfunction leaf_copy(leaf) {\n  var copy3 = { data: leaf.data }, next = copy3;\n  while (leaf = leaf.next)\n    next = next.next = { data: leaf.data };\n  return copy3;\n}\nvar treeProto = quadtree.prototype = Quadtree.prototype;\ntreeProto.copy = function() {\n  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;\n  if (!node)\n    return copy3;\n  if (!node.length)\n    return copy3._root = leaf_copy(node), copy3;\n  nodes = [{ source: node, target: copy3._root = new Array(4) }];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length)\n          nodes.push({ source: child, target: node.target[i] = new Array(4) });\n        else\n          node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n  return copy3;\n};\ntreeProto.add = add_default;\ntreeProto.addAll = addAll;\ntreeProto.cover = cover_default;\ntreeProto.data = data_default2;\ntreeProto.extent = extent_default;\ntreeProto.find = find_default;\ntreeProto.remove = remove_default3;\ntreeProto.removeAll = removeAll;\ntreeProto.root = root_default;\ntreeProto.size = size_default2;\ntreeProto.visit = visit_default;\ntreeProto.visitAfter = visitAfter_default;\ntreeProto.x = x_default;\ntreeProto.y = y_default;\n\n// node_modules/d3-force/src/constant.js\nfunction constant_default7(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-force/src/jiggle.js\nfunction jiggle_default(random) {\n  return (random() - 0.5) * 1e-6;\n}\n\n// node_modules/d3-force/src/collide.js\nfunction x(d) {\n  return d.x + d.vx;\n}\nfunction y(d) {\n  return d.y + d.vy;\n}\nfunction collide_default(radius2) {\n  var nodes, radii, random, strength = 1, iterations2 = 1;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(radius2 == null ? 1 : +radius2);\n  function force() {\n    var i, n = nodes.length, tree2, node, xi, yi, ri, ri2;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      tree2 = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree2.visit(apply2);\n      }\n    }\n    function apply2(quad, x06, y06, x12, y12) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x4 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l = x4 * x4 + y4 * y4;\n          if (l < r * r) {\n            if (x4 === 0)\n              x4 = jiggle_default(random), l += x4 * x4;\n            if (y4 === 0)\n              y4 = jiggle_default(random), l += y4 * y4;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x4 *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y4 *= l) * r;\n            data.vx -= x4 * (r = 1 - r);\n            data.vy -= y4 * r;\n          }\n        }\n        return;\n      }\n      return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;\n    }\n  }\n  function prepare(quad) {\n    if (quad.data)\n      return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i)\n      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/link.js\nfunction index2(d) {\n  return d.index;\n}\nfunction find2(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node)\n    throw new Error(\"node not found: \" + nodeId);\n  return node;\n}\nfunction link_default(links) {\n  var id2 = index2, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;\n  if (links == null)\n    links = [];\n  function defaultStrength(link4) {\n    return 1 / Math.min(count3[link4.source.index], count3[link4.target.index]);\n  }\n  function force(alpha) {\n    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {\n      for (var i = 0, link4, source, target, x4, y4, l, b; i < n; ++i) {\n        link4 = links[i], source = link4.source, target = link4.target;\n        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);\n        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);\n        l = Math.sqrt(x4 * x4 + y4 * y4);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x4 *= l, y4 *= l;\n        target.vx -= x4 * (b = bias[i]);\n        target.vy -= y4 * b;\n        source.vx += x4 * (b = 1 - b);\n        source.vy += y4 * b;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link4;\n    for (i = 0, count3 = new Array(n); i < m3; ++i) {\n      link4 = links[i], link4.index = i;\n      if (typeof link4.source !== \"object\")\n        link4.source = find2(nodeById, link4.source);\n      if (typeof link4.target !== \"object\")\n        link4.target = find2(nodeById, link4.target);\n      count3[link4.source.index] = (count3[link4.source.index] || 0) + 1;\n      count3[link4.target.index] = (count3[link4.target.index] || 0) + 1;\n    }\n    for (i = 0, bias = new Array(m3); i < m3; ++i) {\n      link4 = links[i], bias[i] = count3[link4.source.index] / (count3[link4.source.index] + count3[link4.target.index]);\n    }\n    strengths = new Array(m3), initializeStrength();\n    distances = new Array(m3), initializeDistance();\n  }\n  function initializeStrength() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n  function initializeDistance() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n  force.id = function(_) {\n    return arguments.length ? (id2 = _, force) : id2;\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initializeStrength(), force) : strength;\n  };\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant_default7(+_), initializeDistance(), force) : distance;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/lcg.js\nvar a = 1664525;\nvar c = 1013904223;\nvar m = 4294967296;\nfunction lcg_default() {\n  let s2 = 1;\n  return () => (s2 = (a * s2 + c) % m) / m;\n}\n\n// node_modules/d3-force/src/simulation.js\nfunction x2(d) {\n  return d.x;\n}\nfunction y2(d) {\n  return d.y;\n}\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\nfunction simulation_default(nodes) {\n  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default(\"tick\", \"end\"), random = lcg_default();\n  if (nodes == null)\n    nodes = [];\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n  function tick(iterations2) {\n    var i, n = nodes.length, node;\n    if (iterations2 === void 0)\n      iterations2 = 1;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n      forces.forEach(function(force) {\n        force(alpha);\n      });\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null)\n          node.x += node.vx *= velocityDecay;\n        else\n          node.x = node.fx, node.vx = 0;\n        if (node.fy == null)\n          node.y += node.vy *= velocityDecay;\n        else\n          node.y = node.fy, node.vy = 0;\n      }\n    }\n    return simulation;\n  }\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null)\n        node.x = node.fx;\n      if (node.fy != null)\n        node.y = node.fy;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;\n        node.x = radius2 * Math.cos(angle2);\n        node.y = radius2 * Math.sin(angle2);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n  function initializeForce(force) {\n    if (force.initialize)\n      force.initialize(nodes, random);\n    return force;\n  }\n  initializeNodes();\n  return simulation = {\n    tick,\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n    force: function(name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function(x4, y4, radius2) {\n      var i = 0, n = nodes.length, dx, dy, d2, node, closest;\n      if (radius2 == null)\n        radius2 = Infinity;\n      else\n        radius2 *= radius2;\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x4 - node.x;\n        dy = y4 - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius2)\n          closest = node, radius2 = d2;\n      }\n      return closest;\n    },\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n\n// node_modules/d3-force/src/manyBody.js\nfunction manyBody_default() {\n  var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;\n  function force(_) {\n    var i, n = nodes.length, tree2 = quadtree(nodes, x2, y2).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i)\n      node = nodes[i], tree2.visit(apply2);\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node2;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i)\n      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);\n  }\n  function accumulate(quad) {\n    var strength2 = 0, q, c6, weight = 0, x4, y4, i;\n    if (quad.length) {\n      for (x4 = y4 = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c6 = Math.abs(q.value))) {\n          strength2 += q.value, weight += c6, x4 += c6 * q.x, y4 += c6 * q.y;\n        }\n      }\n      quad.x = x4 / weight;\n      quad.y = y4 / weight;\n    } else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do\n        strength2 += strengths[q.data.index];\n      while (q = q.next);\n    }\n    quad.value = strength2;\n  }\n  function apply2(quad, x12, _, x22) {\n    if (!quad.value)\n      return true;\n    var x4 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x12, l = x4 * x4 + y4 * y4;\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x4 === 0)\n          x4 = jiggle_default(random), l += x4 * x4;\n        if (y4 === 0)\n          y4 = jiggle_default(random), l += y4 * y4;\n        if (l < distanceMin2)\n          l = Math.sqrt(distanceMin2 * l);\n        node.vx += x4 * quad.value * alpha / l;\n        node.vy += y4 * quad.value * alpha / l;\n      }\n      return true;\n    } else if (quad.length || l >= distanceMax2)\n      return;\n    if (quad.data !== node || quad.next) {\n      if (x4 === 0)\n        x4 = jiggle_default(random), l += x4 * x4;\n      if (y4 === 0)\n        y4 = jiggle_default(random), l += y4 * y4;\n      if (l < distanceMin2)\n        l = Math.sqrt(distanceMin2 * l);\n    }\n    do\n      if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x4 * w;\n        node.vy += y4 * w;\n      }\n    while (quad = quad.next);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/radial.js\nfunction radial_default(radius2, x4, y4) {\n  var nodes, strength = constant_default7(0.1), strengths, radiuses;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(+radius2);\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force(alpha) {\n    for (var i = 0, n = nodes.length; i < n; ++i) {\n      var node = nodes[i], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;\n      node.vx += dx * k2;\n      node.vy += dy * k2;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    radiuses = new Array(n);\n    for (i = 0; i < n; ++i) {\n      radiuses[i] = +radius2(nodes[i], i, nodes);\n      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _, initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/x.js\nfunction x_default2(x4) {\n  var strength = constant_default7(0.1), nodes, strengths, xz;\n  if (typeof x4 !== \"function\")\n    x4 = constant_default7(x4 == null ? 0 : +x4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : x4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/y.js\nfunction y_default2(y4) {\n  var strength = constant_default7(0.1), nodes, strengths, yz;\n  if (typeof y4 !== \"function\")\n    y4 = constant_default7(y4 == null ? 0 : +y4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-format/src/formatDecimal.js\nfunction formatDecimal_default(x4) {\n  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString(\"en\").replace(/,/g, \"\") : x4.toString(10);\n}\nfunction formatDecimalParts(x4, p) {\n  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf(\"e\")) < 0)\n    return null;\n  var i, coefficient = x4.slice(0, i);\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x4.slice(i + 1)\n  ];\n}\n\n// node_modules/d3-format/src/exponent.js\nfunction exponent_default(x4) {\n  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;\n}\n\n// node_modules/d3-format/src/formatGroup.js\nfunction formatGroup_default(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length, t = [], j = 0, g = grouping[0], length4 = 0;\n    while (i > 0 && g > 0) {\n      if (length4 + g + 1 > width)\n        g = Math.max(1, width - length4);\n      t.push(value.substring(i -= g, i + g));\n      if ((length4 += g + 1) > width)\n        break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n    return t.reverse().join(thousands);\n  };\n}\n\n// node_modules/d3-format/src/formatNumerals.js\nfunction formatNumerals_default(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n\n// node_modules/d3-format/src/formatSpecifier.js\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nfunction formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier)))\n    throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\nformatSpecifier.prototype = FormatSpecifier.prototype;\nfunction FormatSpecifier(specifier) {\n  this.fill = specifier.fill === void 0 ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === void 0 ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === void 0 ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === void 0 ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === void 0 ? void 0 : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === void 0 ? \"\" : specifier.type + \"\";\n}\nFormatSpecifier.prototype.toString = function() {\n  return this.fill + this.align + this.sign + this.symbol + (this.zero ? \"0\" : \"\") + (this.width === void 0 ? \"\" : Math.max(1, this.width | 0)) + (this.comma ? \",\" : \"\") + (this.precision === void 0 ? \"\" : \".\" + Math.max(0, this.precision | 0)) + (this.trim ? \"~\" : \"\") + this.type;\n};\n\n// node_modules/d3-format/src/formatTrim.js\nfunction formatTrim_default(s2) {\n  out:\n    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (s2[i]) {\n        case \".\":\n          i0 = i1 = i;\n          break;\n        case \"0\":\n          if (i0 === 0)\n            i0 = i;\n          i1 = i;\n          break;\n        default:\n          if (!+s2[i])\n            break out;\n          if (i0 > 0)\n            i0 = 0;\n          break;\n      }\n    }\n  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;\n}\n\n// node_modules/d3-format/src/formatPrefixAuto.js\nvar prefixExponent;\nfunction formatPrefixAuto_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;\n  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join(\"0\") : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i) : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];\n}\n\n// node_modules/d3-format/src/formatRounded.js\nfunction formatRounded_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1];\n  return exponent2 < 0 ? \"0.\" + new Array(-exponent2).join(\"0\") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + \".\" + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join(\"0\");\n}\n\n// node_modules/d3-format/src/formatTypes.js\nvar formatTypes_default = {\n  \"%\": (x4, p) => (x4 * 100).toFixed(p),\n  \"b\": (x4) => Math.round(x4).toString(2),\n  \"c\": (x4) => x4 + \"\",\n  \"d\": formatDecimal_default,\n  \"e\": (x4, p) => x4.toExponential(p),\n  \"f\": (x4, p) => x4.toFixed(p),\n  \"g\": (x4, p) => x4.toPrecision(p),\n  \"o\": (x4) => Math.round(x4).toString(8),\n  \"p\": (x4, p) => formatRounded_default(x4 * 100, p),\n  \"r\": formatRounded_default,\n  \"s\": formatPrefixAuto_default,\n  \"X\": (x4) => Math.round(x4).toString(16).toUpperCase(),\n  \"x\": (x4) => Math.round(x4).toString(16)\n};\n\n// node_modules/d3-format/src/identity.js\nfunction identity_default2(x4) {\n  return x4;\n}\n\n// node_modules/d3-format/src/locale.js\nvar map3 = Array.prototype.map;\nvar prefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\\xB5\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\nfunction locale_default(locale3) {\n  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + \"\"), currencyPrefix = locale3.currency === void 0 ? \"\" : locale3.currency[0] + \"\", currencySuffix = locale3.currency === void 0 ? \"\" : locale3.currency[1] + \"\", decimal = locale3.decimal === void 0 ? \".\" : locale3.decimal + \"\", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? \"%\" : locale3.percent + \"\", minus = locale3.minus === void 0 ? \"\\u2212\" : locale3.minus + \"\", nan = locale3.nan === void 0 ? \"NaN\" : locale3.nan + \"\";\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;\n    if (type2 === \"n\")\n      comma = true, type2 = \"g\";\n    else if (!formatTypes_default[type2])\n      precision === void 0 && (precision = 12), trim = true, type2 = \"g\";\n    if (zero3 || fill === \"0\" && align === \"=\")\n      zero3 = true, fill = \"0\", align = \"=\";\n    var prefix = symbol2 === \"$\" ? currencyPrefix : symbol2 === \"#\" && /[boxX]/.test(type2) ? \"0\" + type2.toLowerCase() : \"\", suffix = symbol2 === \"$\" ? currencySuffix : /[%p]/.test(type2) ? percent : \"\";\n    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);\n    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));\n    function format3(value) {\n      var valuePrefix = prefix, valueSuffix = suffix, i, n, c6;\n      if (type2 === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n        var valueNegative = value < 0 || 1 / value < 0;\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n        if (trim)\n          value = formatTrim_default(value);\n        if (valueNegative && +value === 0 && sign3 !== \"+\")\n          valueNegative = false;\n        valuePrefix = (valueNegative ? sign3 === \"(\" ? sign3 : minus : sign3 === \"-\" || sign3 === \"(\" ? \"\" : sign3) + valuePrefix;\n        valueSuffix = (type2 === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign3 === \"(\" ? \")\" : \"\");\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {\n              valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n      if (comma && !zero3)\n        value = group3(value, Infinity);\n      var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : \"\";\n      if (comma && zero3)\n        value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n      switch (align) {\n        case \"<\":\n          value = valuePrefix + value + valueSuffix + padding;\n          break;\n        case \"=\":\n          value = valuePrefix + padding + value + valueSuffix;\n          break;\n        case \"^\":\n          value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);\n          break;\n        default:\n          value = padding + valuePrefix + value + valueSuffix;\n          break;\n      }\n      return numerals(value);\n    }\n    format3.toString = function() {\n      return specifier + \"\";\n    };\n    return format3;\n  }\n  function formatPrefix2(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];\n    return function(value2) {\n      return f(k2 * value2) + prefix;\n    };\n  }\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix2\n  };\n}\n\n// node_modules/d3-format/src/defaultLocale.js\nvar locale;\nvar format;\nvar formatPrefix;\ndefaultLocale({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\nfunction defaultLocale(definition) {\n  locale = locale_default(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n\n// node_modules/d3-format/src/precisionFixed.js\nfunction precisionFixed_default(step) {\n  return Math.max(0, -exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionPrefix.js\nfunction precisionPrefix_default(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionRound.js\nfunction precisionRound_default(step, max5) {\n  step = Math.abs(step), max5 = Math.abs(max5) - step;\n  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;\n}\n\n// node_modules/d3-geo/src/math.js\nvar epsilon7 = 1e-6;\nvar epsilon22 = 1e-12;\nvar pi4 = Math.PI;\nvar halfPi3 = pi4 / 2;\nvar quarterPi = pi4 / 4;\nvar tau5 = pi4 * 2;\nvar degrees3 = 180 / pi4;\nvar radians2 = pi4 / 180;\nvar abs3 = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos2 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\nvar hypot = Math.hypot;\nvar log = Math.log;\nvar pow2 = Math.pow;\nvar sin2 = Math.sin;\nvar sign = Math.sign || function(x4) {\n  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;\n};\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\nfunction acos(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);\n}\nfunction asin(x4) {\n  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);\n}\nfunction haversin(x4) {\n  return (x4 = sin2(x4 / 2)) * x4;\n}\n\n// node_modules/d3-geo/src/noop.js\nfunction noop2() {\n}\n\n// node_modules/d3-geo/src/stream.js\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\nvar streamObjectType = {\n  Feature: function(object2, stream) {\n    streamGeometry(object2.geometry, stream);\n  },\n  FeatureCollection: function(object2, stream) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      streamGeometry(features[i].geometry, stream);\n  }\n};\nvar streamGeometryType = {\n  Sphere: function(object2, stream) {\n    stream.sphere();\n  },\n  Point: function(object2, stream) {\n    object2 = object2.coordinates;\n    stream.point(object2[0], object2[1], object2[2]);\n  },\n  MultiPoint: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);\n  },\n  LineString: function(object2, stream) {\n    streamLine(object2.coordinates, stream, 0);\n  },\n  MultiLineString: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamLine(coordinates2[i], stream, 0);\n  },\n  Polygon: function(object2, stream) {\n    streamPolygon(object2.coordinates, stream);\n  },\n  MultiPolygon: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamPolygon(coordinates2[i], stream);\n  },\n  GeometryCollection: function(object2, stream) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      streamGeometry(geometries[i], stream);\n  }\n};\nfunction streamLine(coordinates2, stream, closed) {\n  var i = -1, n = coordinates2.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n)\n    coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\nfunction streamPolygon(coordinates2, stream) {\n  var i = -1, n = coordinates2.length;\n  stream.polygonStart();\n  while (++i < n)\n    streamLine(coordinates2[i], stream, 1);\n  stream.polygonEnd();\n}\nfunction stream_default(object2, stream) {\n  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {\n    streamObjectType[object2.type](object2, stream);\n  } else {\n    streamGeometry(object2, stream);\n  }\n}\n\n// node_modules/d3-geo/src/area.js\nvar areaRingSum = new Adder();\nvar areaSum = new Adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\nvar areaStream = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaRingSum = new Adder();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop2;\n  },\n  sphere: function() {\n    areaSum.add(tau5);\n  }\n};\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\nfunction areaPointFirst(lambda, phi2) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);\n}\nfunction areaPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  phi2 = phi2 / 2 + quarterPi;\n  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k2 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda), v2 = k2 * sdLambda * sin2(adLambda);\n  areaRingSum.add(atan2(v2, u4));\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\nfunction area_default2(object2) {\n  areaSum = new Adder();\n  stream_default(object2, areaStream);\n  return areaSum * 2;\n}\n\n// node_modules/d3-geo/src/cartesian.js\nfunction spherical(cartesian2) {\n  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];\n}\nfunction cartesian(spherical2) {\n  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);\n  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];\n}\nfunction cartesianDot(a4, b) {\n  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];\n}\nfunction cartesianCross(a4, b) {\n  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];\n}\nfunction cartesianAddInPlace(a4, b) {\n  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];\n}\nfunction cartesianScale(vector2, k2) {\n  return [vector2[0] * k2, vector2[1] * k2, vector2[2] * k2];\n}\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\n// node_modules/d3-geo/src/bounds.js\nvar lambda02;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda002;\nvar phi002;\nvar p0;\nvar deltaSum;\nvar ranges;\nvar range3;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0)\n      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon7)\n      phi1 = 90;\n    else if (deltaSum < -epsilon7)\n      phi0 = -90;\n    range3[0] = lambda02, range3[1] = lambda1;\n  },\n  sphere: function() {\n    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\nfunction boundsPoint(lambda, phi2) {\n  ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n}\nfunction linePoint(lambda, phi2) {\n  var p = cartesian([lambda * radians2, phi2 * radians2]);\n  if (p0) {\n    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;\n    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = inflection[1] * degrees3;\n      if (phii > phi1)\n        phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = -inflection[1] * degrees3;\n      if (phii < phi0)\n        phi0 = phii;\n    } else {\n      if (phi2 < phi0)\n        phi0 = phi2;\n      if (phi2 > phi1)\n        phi1 = phi2;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n          lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n          lambda02 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda02) {\n        if (lambda < lambda02)\n          lambda02 = lambda;\n        if (lambda > lambda1)\n          lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n            lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n            lambda02 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  }\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n  p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n  range3[0] = lambda02, range3[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\nfunction boundsRingPoint(lambda, phi2) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda002 = lambda, phi002 = phi2;\n  }\n  areaStream.point(lambda, phi2);\n  linePoint(lambda, phi2);\n}\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda002, phi002);\n  areaStream.lineEnd();\n  if (abs3(deltaSum) > epsilon7)\n    lambda02 = -(lambda1 = 180);\n  range3[0] = lambda02, range3[1] = lambda1;\n  p0 = null;\n}\nfunction angle(lambda04, lambda12) {\n  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;\n}\nfunction rangeCompare(a4, b) {\n  return a4[0] - b[0];\n}\nfunction rangeContains(range5, x4) {\n  return range5[0] <= range5[1] ? range5[0] <= x4 && x4 <= range5[1] : x4 < range5[0] || range5[1] < x4;\n}\nfunction bounds_default(feature) {\n  var i, n, a4, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);\n  ranges = [];\n  stream_default(feature, boundsStream);\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a4, b[0]) || rangeContains(a4, b[1])) {\n        if (angle(a4[0], b[1]) > angle(a4[0], a4[1]))\n          a4[1] = b[1];\n        if (angle(b[0], a4[1]) > angle(a4[0], a4[1]))\n          a4[0] = b[0];\n      } else {\n        merged.push(a4 = b);\n      }\n    }\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a4[1], b[0])) > deltaMax)\n        deltaMax = delta, lambda02 = b[0], lambda1 = a4[1];\n    }\n  }\n  ranges = range3 = null;\n  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];\n}\n\n// node_modules/d3-geo/src/centroid.js\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda003;\nvar phi003;\nvar x0;\nvar y0;\nvar z0;\nvar centroidStream = {\n  sphere: noop2,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\nfunction centroidPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));\n}\nfunction centroidPointCartesian(x4, y4, z) {\n  ++W0;\n  X0 += (x4 - X0) / W0;\n  Y0 += (y4 - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\nfunction centroidLinePointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLinePoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda003, phi003);\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingPointFirst(lambda, phi2) {\n  lambda003 = lambda, phi003 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidRingPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x4 - x0 * z, cz = x0 * y4 - y0 * x4, m3 = hypot(cx, cy, cz), w = asin(m3), v2 = m3 && -w / m3;\n  X2.add(v2 * cx);\n  Y2.add(v2 * cy);\n  Z2.add(v2 * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroid_default(object2) {\n  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream_default(object2, centroidStream);\n  var x4 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x4, y4, z);\n  if (m3 < epsilon22) {\n    x4 = X1, y4 = Y1, z = Z1;\n    if (W1 < epsilon7)\n      x4 = X0, y4 = Y0, z = Z0;\n    m3 = hypot(x4, y4, z);\n    if (m3 < epsilon22)\n      return [NaN, NaN];\n  }\n  return [atan2(y4, x4) * degrees3, asin(z / m3) * degrees3];\n}\n\n// node_modules/d3-geo/src/constant.js\nfunction constant_default8(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-geo/src/compose.js\nfunction compose_default(a4, b) {\n  function compose(x4, y4) {\n    return x4 = a4(x4, y4), b(x4[0], x4[1]);\n  }\n  if (a4.invert && b.invert)\n    compose.invert = function(x4, y4) {\n      return x4 = b.invert(x4, y4), x4 && a4.invert(x4[0], x4[1]);\n    };\n  return compose;\n}\n\n// node_modules/d3-geo/src/rotation.js\nfunction rotationIdentity(lambda, phi2) {\n  if (abs3(lambda) > pi4)\n    lambda -= Math.round(lambda / tau5) * tau5;\n  return [lambda, phi2];\n}\nrotationIdentity.invert = rotationIdentity;\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n}\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi2) {\n    lambda += deltaLambda;\n    if (abs3(lambda) > pi4)\n      lambda -= Math.round(lambda / tau5) * tau5;\n    return [lambda, phi2];\n  };\n}\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);\n  function rotation(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x4 * sinDeltaPhi;\n    return [\n      atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)\n    ];\n  }\n  rotation.invert = function(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;\n    return [\n      atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k2 * sinDeltaPhi),\n      asin(k2 * cosDeltaPhi - x4 * sinDeltaPhi)\n    ];\n  };\n  return rotation;\n}\nfunction rotation_default(rotate) {\n  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);\n  function forward(coordinates2) {\n    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  }\n  forward.invert = function(coordinates2) {\n    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/circle.js\nfunction circleStream(stream, radius2, delta, direction, t03, t13) {\n  if (!delta)\n    return;\n  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;\n  if (t03 == null) {\n    t03 = radius2 + direction * tau5;\n    t13 = radius2 - step / 2;\n  } else {\n    t03 = circleRadius(cosRadius, t03);\n    t13 = circleRadius(cosRadius, t13);\n    if (direction > 0 ? t03 < t13 : t03 > t13)\n      t03 += direction * tau5;\n  }\n  for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {\n    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);\n    stream.point(point6[0], point6[1]);\n  }\n}\nfunction circleRadius(cosRadius, point6) {\n  point6 = cartesian(point6), point6[0] -= cosRadius;\n  cartesianNormalizeInPlace(point6);\n  var radius2 = acos(-point6[1]);\n  return ((-point6[2] < 0 ? -radius2 : radius2) + tau5 - epsilon7) % tau5;\n}\nfunction circle_default() {\n  var center2 = constant_default8([0, 0]), radius2 = constant_default8(90), precision = constant_default8(6), ring, rotate, stream = { point: point6 };\n  function point6(x4, y4) {\n    ring.push(x4 = rotate(x4, y4));\n    x4[0] *= degrees3, x4[1] *= degrees3;\n  }\n  function circle2() {\n    var c6 = center2.apply(this, arguments), r = radius2.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;\n    ring = [];\n    rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;\n    circleStream(stream, r, p, 1);\n    c6 = { type: \"Polygon\", coordinates: [ring] };\n    ring = rotate = null;\n    return c6;\n  }\n  circle2.center = function(_) {\n    return arguments.length ? (center2 = typeof _ === \"function\" ? _ : constant_default8([+_[0], +_[1]]), circle2) : center2;\n  };\n  circle2.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : radius2;\n  };\n  circle2.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : precision;\n  };\n  return circle2;\n}\n\n// node_modules/d3-geo/src/clip/buffer.js\nfunction buffer_default2() {\n  var lines = [], line2;\n  return {\n    point: function(x4, y4, m3) {\n      line2.push([x4, y4, m3]);\n    },\n    lineStart: function() {\n      lines.push(line2 = []);\n    },\n    lineEnd: noop2,\n    rejoin: function() {\n      if (lines.length > 1)\n        lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line2 = null;\n      return result;\n    }\n  };\n}\n\n// node_modules/d3-geo/src/pointEqual.js\nfunction pointEqual_default(a4, b) {\n  return abs3(a4[0] - b[0]) < epsilon7 && abs3(a4[1] - b[1]) < epsilon7;\n}\n\n// node_modules/d3-geo/src/clip/rejoin.js\nfunction Intersection(point6, points, other, entry) {\n  this.x = point6;\n  this.z = points;\n  this.o = other;\n  this.e = entry;\n  this.v = false;\n  this.n = this.p = null;\n}\nfunction rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {\n  var subject = [], clip = [], i, n;\n  segments.forEach(function(segment) {\n    if ((n2 = segment.length - 1) <= 0)\n      return;\n    var n2, p02 = segment[0], p1 = segment[n2], x4;\n    if (pointEqual_default(p02, p1)) {\n      if (!p02[2] && !p1[2]) {\n        stream.lineStart();\n        for (i = 0; i < n2; ++i)\n          stream.point((p02 = segment[i])[0], p02[1]);\n        stream.lineEnd();\n        return;\n      }\n      p1[0] += 2 * epsilon7;\n    }\n    subject.push(x4 = new Intersection(p02, segment, null, true));\n    clip.push(x4.o = new Intersection(p02, null, x4, false));\n    subject.push(x4 = new Intersection(p1, segment, null, false));\n    clip.push(x4.o = new Intersection(p1, null, x4, true));\n  });\n  if (!subject.length)\n    return;\n  clip.sort(compareIntersection2);\n  link(subject);\n  link(clip);\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n  var start2 = subject[0], points, point6;\n  while (1) {\n    var current = start2, isSubject = true;\n    while (current.v)\n      if ((current = current.n) === start2)\n        return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\nfunction link(array4) {\n  if (!(n = array4.length))\n    return;\n  var n, i = 0, a4 = array4[0], b;\n  while (++i < n) {\n    a4.n = b = array4[i];\n    b.p = a4;\n    a4 = b;\n  }\n  a4.n = b = array4[0];\n  b.p = a4;\n}\n\n// node_modules/d3-geo/src/polygonContains.js\nfunction longitude(point6) {\n  return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);\n}\nfunction polygonContains_default(polygon, point6) {\n  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;\n  var sum5 = new Adder();\n  if (sinPhi === 1)\n    phi2 = halfPi3 + epsilon7;\n  else if (sinPhi === -1)\n    phi2 = -halfPi3 - epsilon7;\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m3 = (ring = polygon[i]).length))\n      continue;\n    var ring, m3, point0 = ring[m3 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);\n    for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {\n      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k2 = sinPhi03 * sinPhi1;\n      sum5.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));\n      angle2 += antimeridian ? delta + sign3 * tau5 : delta;\n      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection2 = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection2);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);\n        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n  return (angle2 < -epsilon7 || angle2 < epsilon7 && sum5 < -epsilon22) ^ winding & 1;\n}\n\n// node_modules/d3-geo/src/clip/index.js\nfunction clip_default(pointVisible, clipLine, interpolate, start2) {\n  return function(sink) {\n    var line2 = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n    var clip = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point6;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains_default(polygon, start2);\n        if (segments.length) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted)\n          sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n    function point6(lambda, phi2) {\n      if (pointVisible(lambda, phi2))\n        sink.point(lambda, phi2);\n    }\n    function pointLine(lambda, phi2) {\n      line2.point(lambda, phi2);\n    }\n    function lineStart() {\n      clip.point = pointLine;\n      line2.lineStart();\n    }\n    function lineEnd() {\n      clip.point = point6;\n      line2.lineEnd();\n    }\n    function pointRing(lambda, phi2) {\n      ring.push([lambda, phi2]);\n      ringSink.point(lambda, phi2);\n    }\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point7;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n)\n        return;\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m3 = segment.length - 1) > 0) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m3; ++i)\n            sink.point((point7 = segment[i])[0], point7[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n      if (n > 1 && clean & 2)\n        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n    return clip;\n  };\n}\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\nfunction compareIntersection(a4, b) {\n  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);\n}\n\n// node_modules/d3-geo/src/clip/antimeridian.js\nvar antimeridian_default = clip_default(\n  function() {\n    return true;\n  },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi4, -halfPi3]\n);\nfunction clipAntimeridianLine(stream) {\n  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda12, phi12) {\n      var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);\n      if (abs3(delta - pi4) < epsilon7) {\n        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        stream.point(lambda12, phi02);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi4) {\n        if (abs3(lambda04 - sign0) < epsilon7)\n          lambda04 -= sign0 * epsilon7;\n        if (abs3(lambda12 - sign1) < epsilon7)\n          lambda12 -= sign1 * epsilon7;\n        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        clean = 0;\n      }\n      stream.point(lambda04 = lambda12, phi02 = phi12);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda04 = phi02 = NaN;\n    },\n    clean: function() {\n      return 2 - clean;\n    }\n  };\n}\nfunction clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {\n  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);\n  return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;\n}\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi2;\n  if (from == null) {\n    phi2 = direction * halfPi3;\n    stream.point(-pi4, phi2);\n    stream.point(0, phi2);\n    stream.point(pi4, phi2);\n    stream.point(pi4, 0);\n    stream.point(pi4, -phi2);\n    stream.point(0, -phi2);\n    stream.point(-pi4, -phi2);\n    stream.point(-pi4, 0);\n    stream.point(-pi4, phi2);\n  } else if (abs3(from[0] - to[0]) > epsilon7) {\n    var lambda = from[0] < to[0] ? pi4 : -pi4;\n    phi2 = direction * lambda / 2;\n    stream.point(-lambda, phi2);\n    stream.point(0, phi2);\n    stream.point(lambda, phi2);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\n// node_modules/d3-geo/src/clip/circle.js\nfunction circle_default2(radius2) {\n  var cr = cos2(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius2, delta, direction, from, to);\n  }\n  function visible(lambda, phi2) {\n    return cos2(lambda) * cos2(phi2) > cr;\n  }\n  function clipLine(stream) {\n    var point0, c0, v0, v00, clean;\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi2) {\n        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c6 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;\n        if (!point0 && (v00 = v0 = v2))\n          stream.lineStart();\n        if (v2 !== v0) {\n          point22 = intersect2(point0, point1);\n          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))\n            point1[2] = 1;\n        }\n        if (v2 !== v0) {\n          clean = 0;\n          if (v2) {\n            stream.lineStart();\n            point22 = intersect2(point1, point0);\n            stream.point(point22[0], point22[1]);\n          } else {\n            point22 = intersect2(point0, point1);\n            stream.point(point22[0], point22[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point22;\n        } else if (notHemisphere && point0 && smallRadius ^ v2) {\n          var t;\n          if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v2, c0 = c6;\n      },\n      lineEnd: function() {\n        if (v0)\n          stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  }\n  function intersect2(a4, b, two) {\n    var pa = cartesian(a4), pb = cartesian(b);\n    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n    if (!determinant)\n      return !two && a4;\n    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);\n    cartesianAddInPlace(A5, B3);\n    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);\n    if (t22 < 0)\n      return;\n    var t = sqrt(t22), q = cartesianScale(u4, (-w - t) / uu);\n    cartesianAddInPlace(q, A5);\n    q = spherical(q);\n    if (!two)\n      return q;\n    var lambda04 = a4[0], lambda12 = b[0], phi02 = a4[1], phi12 = b[1], z;\n    if (lambda12 < lambda04)\n      z = lambda04, lambda04 = lambda12, lambda12 = z;\n    var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;\n    if (!polar && phi12 < phi02)\n      z = phi02, phi02 = phi12, phi12 = z;\n    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {\n      var q1 = cartesianScale(u4, (-w + t) / uu);\n      cartesianAddInPlace(q1, A5);\n      return [q, spherical(q1)];\n    }\n  }\n  function code(lambda, phi2) {\n    var r = smallRadius ? radius2 : pi4 - radius2, code2 = 0;\n    if (lambda < -r)\n      code2 |= 1;\n    else if (lambda > r)\n      code2 |= 2;\n    if (phi2 < -r)\n      code2 |= 4;\n    else if (phi2 > r)\n      code2 |= 8;\n    return code2;\n  }\n  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi4, radius2 - pi4]);\n}\n\n// node_modules/d3-geo/src/clip/line.js\nfunction line_default(a4, b, x06, y06, x12, y12) {\n  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;\n  r = x06 - ax;\n  if (!dx && r > 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dx > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = x12 - ax;\n  if (!dx && r < 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dx > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  r = y06 - ay;\n  if (!dy && r > 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dy > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = y12 - ay;\n  if (!dy && r < 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dy > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  if (t03 > 0)\n    a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;\n  if (t13 < 1)\n    b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;\n  return true;\n}\n\n// node_modules/d3-geo/src/clip/rectangle.js\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\nfunction clipRectangle(x06, y06, x12, y12) {\n  function visible(x4, y4) {\n    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;\n  }\n  function interpolate(from, to, direction, stream) {\n    var a4 = 0, a1 = 0;\n    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do\n        stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);\n      while ((a4 = (a4 + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n  function corner(p, direction) {\n    return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n  }\n  function compareIntersection2(a4, b) {\n    return comparePoint(a4.x, b.x);\n  }\n  function comparePoint(a4, b) {\n    var ca3 = corner(a4, 1), cb = corner(b, 1);\n    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a4[1] : ca3 === 1 ? a4[0] - b[0] : ca3 === 2 ? a4[1] - b[1] : b[0] - a4[0];\n  }\n  return function(stream) {\n    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;\n    var clipStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart,\n      polygonEnd\n    };\n    function point6(x4, y4) {\n      if (visible(x4, y4))\n        activeStream.point(x4, y4);\n    }\n    function polygonInside() {\n      var winding = 0;\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j < m3; ++j) {\n          a0 = b02, a1 = b12, point7 = ring2[j], b02 = point7[0], b12 = point7[1];\n          if (a1 <= y12) {\n            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0))\n              ++winding;\n          } else {\n            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0))\n              --winding;\n          }\n        }\n      }\n      return winding;\n    }\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n    function polygonEnd() {\n      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;\n      if (cleanInside || visible2) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible2) {\n          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n    function lineStart() {\n      clipStream.point = linePoint2;\n      if (polygon)\n        polygon.push(ring = []);\n      first2 = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n    function lineEnd() {\n      if (segments) {\n        linePoint2(x__, y__);\n        if (v__ && v_)\n          bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point6;\n      if (v_)\n        activeStream.lineEnd();\n    }\n    function linePoint2(x4, y4) {\n      var v2 = visible(x4, y4);\n      if (polygon)\n        ring.push([x4, y4]);\n      if (first2) {\n        x__ = x4, y__ = y4, v__ = v2;\n        first2 = false;\n        if (v2) {\n          activeStream.lineStart();\n          activeStream.point(x4, y4);\n        }\n      } else {\n        if (v2 && v_)\n          activeStream.point(x4, y4);\n        else {\n          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];\n          if (line_default(a4, b, x06, y06, x12, y12)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a4[0], a4[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v2)\n              activeStream.lineEnd();\n            clean = false;\n          } else if (v2) {\n            activeStream.lineStart();\n            activeStream.point(x4, y4);\n            clean = false;\n          }\n        }\n      }\n      x_ = x4, y_ = y4, v_ = v2;\n    }\n    return clipStream;\n  };\n}\n\n// node_modules/d3-geo/src/clip/extent.js\nfunction extent_default2() {\n  var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip;\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip) : [[x06, y06], [x12, y12]];\n    }\n  };\n}\n\n// node_modules/d3-geo/src/length.js\nvar lengthSum;\nvar lambda03;\nvar sinPhi02;\nvar cosPhi02;\nvar lengthStream = {\n  sphere: noop2,\n  point: noop2,\n  lineStart: lengthLineStart,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2\n};\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop2;\n}\nfunction lengthPointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);\n  lengthStream.point = lengthPoint;\n}\nfunction lengthPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x4 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z));\n  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;\n}\nfunction length_default(object2) {\n  lengthSum = new Adder();\n  stream_default(object2, lengthStream);\n  return +lengthSum;\n}\n\n// node_modules/d3-geo/src/distance.js\nvar coordinates = [null, null];\nvar object = { type: \"LineString\", coordinates };\nfunction distance_default(a4, b) {\n  coordinates[0] = a4;\n  coordinates[1] = b;\n  return length_default(object);\n}\n\n// node_modules/d3-geo/src/contains.js\nvar containsObjectType = {\n  Feature: function(object2, point6) {\n    return containsGeometry(object2.geometry, point6);\n  },\n  FeatureCollection: function(object2, point6) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      if (containsGeometry(features[i].geometry, point6))\n        return true;\n    return false;\n  }\n};\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object2, point6) {\n    return containsPoint(object2.coordinates, point6);\n  },\n  MultiPoint: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPoint(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  LineString: function(object2, point6) {\n    return containsLine(object2.coordinates, point6);\n  },\n  MultiLineString: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsLine(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  Polygon: function(object2, point6) {\n    return containsPolygon(object2.coordinates, point6);\n  },\n  MultiPolygon: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPolygon(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  GeometryCollection: function(object2, point6) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      if (containsGeometry(geometries[i], point6))\n        return true;\n    return false;\n  }\n};\nfunction containsGeometry(geometry, point6) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;\n}\nfunction containsPoint(coordinates2, point6) {\n  return distance_default(coordinates2, point6) === 0;\n}\nfunction containsLine(coordinates2, point6) {\n  var ao, bo, ab4;\n  for (var i = 0, n = coordinates2.length; i < n; i++) {\n    bo = distance_default(coordinates2[i], point6);\n    if (bo === 0)\n      return true;\n    if (i > 0) {\n      ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);\n      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)\n        return true;\n    }\n    ao = bo;\n  }\n  return false;\n}\nfunction containsPolygon(coordinates2, point6) {\n  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));\n}\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\nfunction pointRadians(point6) {\n  return [point6[0] * radians2, point6[1] * radians2];\n}\nfunction contains_default2(object2, point6) {\n  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);\n}\n\n// node_modules/d3-geo/src/graticule.js\nfunction graticuleX(y06, y12, dy) {\n  var y4 = range(y06, y12 - epsilon7, dy).concat(y12);\n  return function(x4) {\n    return y4.map(function(y5) {\n      return [x4, y5];\n    });\n  };\n}\nfunction graticuleY(x06, x12, dx) {\n  var x4 = range(x06, x12 - epsilon7, dx).concat(x12);\n  return function(y4) {\n    return x4.map(function(x5) {\n      return [x5, y4];\n    });\n  };\n}\nfunction graticule() {\n  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;\n  function graticule3() {\n    return { type: \"MultiLineString\", coordinates: lines() };\n  }\n  function lines() {\n    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {\n      return abs3(x5 % DX) > epsilon7;\n    }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {\n      return abs3(y5 % DY) > epsilon7;\n    }).map(y4));\n  }\n  graticule3.lines = function() {\n    return lines().map(function(coordinates2) {\n      return { type: \"LineString\", coordinates: coordinates2 };\n    });\n  };\n  graticule3.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X3(X03).concat(\n          Y3(Y13).slice(1),\n          X3(X13).reverse().slice(1),\n          Y3(Y03).reverse().slice(1)\n        )\n      ]\n    };\n  };\n  graticule3.extent = function(_) {\n    if (!arguments.length)\n      return graticule3.extentMinor();\n    return graticule3.extentMajor(_).extentMinor(_);\n  };\n  graticule3.extentMajor = function(_) {\n    if (!arguments.length)\n      return [[X03, Y03], [X13, Y13]];\n    X03 = +_[0][0], X13 = +_[1][0];\n    Y03 = +_[0][1], Y13 = +_[1][1];\n    if (X03 > X13)\n      _ = X03, X03 = X13, X13 = _;\n    if (Y03 > Y13)\n      _ = Y03, Y03 = Y13, Y13 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.extentMinor = function(_) {\n    if (!arguments.length)\n      return [[x06, y06], [x12, y12]];\n    x06 = +_[0][0], x12 = +_[1][0];\n    y06 = +_[0][1], y12 = +_[1][1];\n    if (x06 > x12)\n      _ = x06, x06 = x12, x12 = _;\n    if (y06 > y12)\n      _ = y06, y06 = y12, y12 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.step = function(_) {\n    if (!arguments.length)\n      return graticule3.stepMinor();\n    return graticule3.stepMajor(_).stepMinor(_);\n  };\n  graticule3.stepMajor = function(_) {\n    if (!arguments.length)\n      return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule3;\n  };\n  graticule3.stepMinor = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule3;\n  };\n  graticule3.precision = function(_) {\n    if (!arguments.length)\n      return precision;\n    precision = +_;\n    x4 = graticuleX(y06, y12, 90);\n    y4 = graticuleY(x06, x12, precision);\n    X3 = graticuleX(Y03, Y13, 90);\n    Y3 = graticuleY(X03, X13, precision);\n    return graticule3;\n  };\n  return graticule3.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);\n}\nfunction graticule10() {\n  return graticule()();\n}\n\n// node_modules/d3-geo/src/interpolate.js\nfunction interpolate_default2(a4, b) {\n  var x06 = a4[0] * radians2, y06 = a4[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k2 = sin2(d);\n  var interpolate = d ? function(t) {\n    var B3 = sin2(t *= d) / k2, A5 = sin2(d - t) / k2, x4 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;\n    return [\n      atan2(y4, x4) * degrees3,\n      atan2(z, sqrt(x4 * x4 + y4 * y4)) * degrees3\n    ];\n  } : function() {\n    return [x06 * degrees3, y06 * degrees3];\n  };\n  interpolate.distance = d;\n  return interpolate;\n}\n\n// node_modules/d3-geo/src/identity.js\nvar identity_default3 = (x4) => x4;\n\n// node_modules/d3-geo/src/path/area.js\nvar areaSum2 = new Adder();\nvar areaRingSum2 = new Adder();\nvar x00;\nvar y00;\nvar x02;\nvar y02;\nvar areaStream2 = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaStream2.lineStart = areaRingStart2;\n    areaStream2.lineEnd = areaRingEnd2;\n  },\n  polygonEnd: function() {\n    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;\n    areaSum2.add(abs3(areaRingSum2));\n    areaRingSum2 = new Adder();\n  },\n  result: function() {\n    var area2 = areaSum2 / 2;\n    areaSum2 = new Adder();\n    return area2;\n  }\n};\nfunction areaRingStart2() {\n  areaStream2.point = areaPointFirst2;\n}\nfunction areaPointFirst2(x4, y4) {\n  areaStream2.point = areaPoint2;\n  x00 = x02 = x4, y00 = y02 = y4;\n}\nfunction areaPoint2(x4, y4) {\n  areaRingSum2.add(y02 * x4 - x02 * y4);\n  x02 = x4, y02 = y4;\n}\nfunction areaRingEnd2() {\n  areaPoint2(x00, y00);\n}\nvar area_default3 = areaStream2;\n\n// node_modules/d3-geo/src/path/bounds.js\nvar x03 = Infinity;\nvar y03 = x03;\nvar x1 = -x03;\nvar y1 = x1;\nvar boundsStream2 = {\n  point: boundsPoint2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2,\n  result: function() {\n    var bounds = [[x03, y03], [x1, y1]];\n    x1 = y1 = -(y03 = x03 = Infinity);\n    return bounds;\n  }\n};\nfunction boundsPoint2(x4, y4) {\n  if (x4 < x03)\n    x03 = x4;\n  if (x4 > x1)\n    x1 = x4;\n  if (y4 < y03)\n    y03 = y4;\n  if (y4 > y1)\n    y1 = y4;\n}\nvar bounds_default2 = boundsStream2;\n\n// node_modules/d3-geo/src/path/centroid.js\nvar X02 = 0;\nvar Y02 = 0;\nvar Z02 = 0;\nvar X12 = 0;\nvar Y12 = 0;\nvar Z12 = 0;\nvar X22 = 0;\nvar Y22 = 0;\nvar Z22 = 0;\nvar x002;\nvar y002;\nvar x04;\nvar y04;\nvar centroidStream2 = {\n  point: centroidPoint2,\n  lineStart: centroidLineStart2,\n  lineEnd: centroidLineEnd2,\n  polygonStart: function() {\n    centroidStream2.lineStart = centroidRingStart2;\n    centroidStream2.lineEnd = centroidRingEnd2;\n  },\n  polygonEnd: function() {\n    centroidStream2.point = centroidPoint2;\n    centroidStream2.lineStart = centroidLineStart2;\n    centroidStream2.lineEnd = centroidLineEnd2;\n  },\n  result: function() {\n    var centroid2 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];\n    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;\n    return centroid2;\n  }\n};\nfunction centroidPoint2(x4, y4) {\n  X02 += x4;\n  Y02 += y4;\n  ++Z02;\n}\nfunction centroidLineStart2() {\n  centroidStream2.point = centroidPointFirstLine;\n}\nfunction centroidPointFirstLine(x4, y4) {\n  centroidStream2.point = centroidPointLine;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidPointLine(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidLineEnd2() {\n  centroidStream2.point = centroidPoint2;\n}\nfunction centroidRingStart2() {\n  centroidStream2.point = centroidPointFirstRing;\n}\nfunction centroidRingEnd2() {\n  centroidPointRing(x002, y002);\n}\nfunction centroidPointFirstRing(x4, y4) {\n  centroidStream2.point = centroidPointRing;\n  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);\n}\nfunction centroidPointRing(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  z = y04 * x4 - x04 * y4;\n  X22 += z * (x04 + x4);\n  Y22 += z * (y04 + y4);\n  Z22 += z * 3;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nvar centroid_default2 = centroidStream2;\n\n// node_modules/d3-geo/src/path/context.js\nfunction PathContext(context) {\n  this._context = context;\n}\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0)\n      this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x4, y4);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x4, y4);\n        break;\n      }\n      default: {\n        this._context.moveTo(x4 + this._radius, y4);\n        this._context.arc(x4, y4, this._radius, 0, tau5);\n        break;\n      }\n    }\n  },\n  result: noop2\n};\n\n// node_modules/d3-geo/src/path/measure.js\nvar lengthSum2 = new Adder();\nvar lengthRing;\nvar x003;\nvar y003;\nvar x05;\nvar y05;\nvar lengthStream2 = {\n  point: noop2,\n  lineStart: function() {\n    lengthStream2.point = lengthPointFirst2;\n  },\n  lineEnd: function() {\n    if (lengthRing)\n      lengthPoint2(x003, y003);\n    lengthStream2.point = noop2;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length4 = +lengthSum2;\n    lengthSum2 = new Adder();\n    return length4;\n  }\n};\nfunction lengthPointFirst2(x4, y4) {\n  lengthStream2.point = lengthPoint2;\n  x003 = x05 = x4, y003 = y05 = y4;\n}\nfunction lengthPoint2(x4, y4) {\n  x05 -= x4, y05 -= y4;\n  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));\n  x05 = x4, y05 = y4;\n}\nvar measure_default = lengthStream2;\n\n// node_modules/d3-geo/src/path/string.js\nvar cacheDigits;\nvar cacheAppend;\nvar cacheRadius;\nvar cacheCircle;\nvar PathString = class {\n  constructor(digits) {\n    this._append = digits == null ? append2 : appendRound2(digits);\n    this._radius = 4.5;\n    this._ = \"\";\n  }\n  pointRadius(_) {\n    this._radius = +_;\n    return this;\n  }\n  polygonStart() {\n    this._line = 0;\n  }\n  polygonEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line === 0)\n      this._ += \"Z\";\n    this._point = NaN;\n  }\n  point(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._append`M${x4},${y4}`;\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._append`L${x4},${y4}`;\n        break;\n      }\n      default: {\n        this._append`M${x4},${y4}`;\n        if (this._radius !== cacheRadius || this._append !== cacheAppend) {\n          const r = this._radius;\n          const s2 = this._;\n          this._ = \"\";\n          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;\n          cacheRadius = r;\n          cacheAppend = this._append;\n          cacheCircle = this._;\n          this._ = s2;\n        }\n        this._ += cacheCircle;\n        break;\n      }\n    }\n  }\n  result() {\n    const result = this._;\n    this._ = \"\";\n    return result.length ? result : null;\n  }\n};\nfunction append2(strings) {\n  let i = 1;\n  this._ += strings[0];\n  for (const j = strings.length; i < j; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound2(digits) {\n  const d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new RangeError(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append2;\n  if (d !== cacheDigits) {\n    const k2 = 10 ** d;\n    cacheDigits = d;\n    cacheAppend = function append3(strings) {\n      let i = 1;\n      this._ += strings[0];\n      for (const j = strings.length; i < j; ++i) {\n        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n      }\n    };\n  }\n  return cacheAppend;\n}\n\n// node_modules/d3-geo/src/path/index.js\nfunction path_default(projection2, context) {\n  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;\n  function path2(object2) {\n    if (object2) {\n      if (typeof pointRadius === \"function\")\n        contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream_default(object2, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n  path2.area = function(object2) {\n    stream_default(object2, projectionStream(area_default3));\n    return area_default3.result();\n  };\n  path2.measure = function(object2) {\n    stream_default(object2, projectionStream(measure_default));\n    return measure_default.result();\n  };\n  path2.bounds = function(object2) {\n    stream_default(object2, projectionStream(bounds_default2));\n    return bounds_default2.result();\n  };\n  path2.centroid = function(object2) {\n    stream_default(object2, projectionStream(centroid_default2));\n    return centroid_default2.result();\n  };\n  path2.projection = function(_) {\n    if (!arguments.length)\n      return projection2;\n    projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream;\n    return path2;\n  };\n  path2.context = function(_) {\n    if (!arguments.length)\n      return context;\n    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\")\n      contextStream.pointRadius(pointRadius);\n    return path2;\n  };\n  path2.pointRadius = function(_) {\n    if (!arguments.length)\n      return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path2;\n  };\n  path2.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null)\n      digits = null;\n    else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    if (context === null)\n      contextStream = new PathString(digits);\n    return path2;\n  };\n  return path2.projection(projection2).digits(digits).context(context);\n}\n\n// node_modules/d3-geo/src/transform.js\nfunction transform_default(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\nfunction transformer(methods) {\n  return function(stream) {\n    var s2 = new TransformStream();\n    for (var key in methods)\n      s2[key] = methods[key];\n    s2.stream = stream;\n    return s2;\n  };\n}\nfunction TransformStream() {\n}\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x4, y4) {\n    this.stream.point(x4, y4);\n  },\n  sphere: function() {\n    this.stream.sphere();\n  },\n  lineStart: function() {\n    this.stream.lineStart();\n  },\n  lineEnd: function() {\n    this.stream.lineEnd();\n  },\n  polygonStart: function() {\n    this.stream.polygonStart();\n  },\n  polygonEnd: function() {\n    this.stream.polygonEnd();\n  }\n};\n\n// node_modules/d3-geo/src/projection/fit.js\nfunction fit(projection2, fitBounds, object2) {\n  var clip = projection2.clipExtent && projection2.clipExtent();\n  projection2.scale(150).translate([0, 0]);\n  if (clip != null)\n    projection2.clipExtent(null);\n  stream_default(object2, projection2.stream(bounds_default2));\n  fitBounds(bounds_default2.result());\n  if (clip != null)\n    projection2.clipExtent(clip);\n  return projection2;\n}\nfunction fitExtent(projection2, extent3, object2) {\n  return fit(projection2, function(b) {\n    var w = extent3[1][0] - extent3[0][0], h = extent3[1][1] - extent3[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x4 = +extent3[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent3[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitSize(projection2, size, object2) {\n  return fitExtent(projection2, [[0, 0], size], object2);\n}\nfunction fitWidth(projection2, width, object2) {\n  return fit(projection2, function(b) {\n    var w = +width, k2 = w / (b[1][0] - b[0][0]), x4 = (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitHeight(projection2, height, object2) {\n  return fit(projection2, function(b) {\n    var h = +height, k2 = h / (b[1][1] - b[0][1]), x4 = -k2 * b[0][0], y4 = (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\n\n// node_modules/d3-geo/src/projection/resample.js\nvar maxDepth = 16;\nvar cosMinDistance = cos2(30 * radians2);\nfunction resample_default(project2, delta2) {\n  return +delta2 ? resample(project2, delta2) : resampleNone(project2);\n}\nfunction resampleNone(project2) {\n  return transformer({\n    point: function(x4, y4) {\n      x4 = project2(x4, y4);\n      this.stream.point(x4[0], x4[1]);\n    }\n  });\n}\nfunction resample(project2, delta2) {\n  function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {\n    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a4 = a0 + a1, b = b02 + b12, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b * b + c6 * c6), phi2 = asin(c6 /= m3), lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a4), p = project2(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {\n        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m3, b /= m3, c6, depth, stream);\n        stream.point(x22, y22);\n        resampleLineTo(x22, y22, lambda22, a4, b, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;\n    var resampleStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        stream.polygonStart();\n        resampleStream.lineStart = ringStart;\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n        resampleStream.lineStart = lineStart;\n      }\n    };\n    function point6(x4, y4) {\n      x4 = project2(x4, y4);\n      stream.point(x4[0], x4[1]);\n    }\n    function lineStart() {\n      x06 = NaN;\n      resampleStream.point = linePoint2;\n      stream.lineStart();\n    }\n    function linePoint2(lambda, phi2) {\n      var c6 = cartesian([lambda, phi2]), p = project2(lambda, phi2);\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);\n      stream.point(x06, y06);\n    }\n    function lineEnd() {\n      resampleStream.point = point6;\n      stream.lineEnd();\n    }\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n    function ringPoint(lambda, phi2) {\n      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;\n      resampleStream.point = linePoint2;\n    }\n    function ringEnd() {\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n    return resampleStream;\n  };\n}\n\n// node_modules/d3-geo/src/projection/index.js\nvar transformRadians = transformer({\n  point: function(x4, y4) {\n    this.stream.point(x4 * radians2, y4 * radians2);\n  }\n});\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x4, y4) {\n      var r = rotate(x4, y4);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\nfunction scaleTranslate(k2, dx, dy, sx, sy) {\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [dx + k2 * x4, dy - k2 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [(x4 - dx) / k2 * sx, (dy - y4) / k2 * sy];\n  };\n  return transform2;\n}\nfunction scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {\n  if (!alpha)\n    return scaleTranslate(k2, dx, dy, sx, sy);\n  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [a4 * x4 - b * y4 + dx, dy - b * x4 - a4 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];\n  };\n  return transform2;\n}\nfunction projection(project2) {\n  return projectionMutator(function() {\n    return project2;\n  })();\n}\nfunction projectionMutator(projectAt) {\n  var project2, k2 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;\n  function projection2(point6) {\n    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);\n  }\n  function invert(point6) {\n    point6 = projectRotateTransform.invert(point6[0], point6[1]);\n    return point6 && [point6[0] * degrees3, point6[1] * degrees3];\n  }\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n  projection2.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, recenter()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (x4 = +_[0], y4 = +_[1], recenter()) : [x4, y4];\n  };\n  projection2.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];\n  };\n  projection2.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;\n  };\n  projection2.precision = function(_) {\n    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  function recenter() {\n    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x4 - center2[0], y4 - center2[1], sx, sy, alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose_default(project2, transform2);\n    projectRotateTransform = compose_default(rotate, projectTransform);\n    projectResample = resample_default(projectTransform, delta2);\n    return reset();\n  }\n  function reset() {\n    cache = cacheStream = null;\n    return projection2;\n  }\n  return function() {\n    project2 = projectAt.apply(this, arguments);\n    projection2.invert = project2.invert && invert;\n    return recenter();\n  };\n}\n\n// node_modules/d3-geo/src/projection/conic.js\nfunction conicProjection(projectAt) {\n  var phi02 = 0, phi12 = pi4 / 3, m3 = projectionMutator(projectAt), p = m3(phi02, phi12);\n  p.parallels = function(_) {\n    return arguments.length ? m3(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];\n  };\n  return p;\n}\n\n// node_modules/d3-geo/src/projection/cylindricalEqualArea.js\nfunction cylindricalEqualAreaRaw(phi02) {\n  var cosPhi03 = cos2(phi02);\n  function forward(lambda, phi2) {\n    return [lambda * cosPhi03, sin2(phi2) / cosPhi03];\n  }\n  forward.invert = function(x4, y4) {\n    return [x4 / cosPhi03, asin(y4 * cosPhi03)];\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/projection/conicEqualArea.js\nfunction conicEqualAreaRaw(y06, y12) {\n  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;\n  if (abs3(n) < epsilon7)\n    return cylindricalEqualAreaRaw(y06);\n  var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c6) / n;\n  function project2(x4, y4) {\n    var r = sqrt(c6 - 2 * n * sin2(y4)) / n;\n    return [r * sin2(x4 *= n), r0 - r * cos2(x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var r0y = r0 - y4, l = atan2(x4, abs3(r0y)) * sign(r0y);\n    if (r0y * n < 0)\n      l -= pi4 * sign(x4) * sign(r0y);\n    return [l / n, asin((c6 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];\n  };\n  return project2;\n}\nfunction conicEqualArea_default() {\n  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);\n}\n\n// node_modules/d3-geo/src/projection/albers.js\nfunction albers_default() {\n  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);\n}\n\n// node_modules/d3-geo/src/projection/albersUsa.js\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x4, y4) {\n      var i = -1;\n      while (++i < n)\n        streams[i].point(x4, y4);\n    },\n    sphere: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].sphere();\n    },\n    lineStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineStart();\n    },\n    lineEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineEnd();\n    },\n    polygonStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonStart();\n    },\n    polygonEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonEnd();\n    }\n  };\n}\nfunction albersUsa_default() {\n  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x4, y4) {\n    point6 = [x4, y4];\n  } };\n  function albersUsa(coordinates2) {\n    var x4 = coordinates2[0], y4 = coordinates2[1];\n    return point6 = null, (lower48Point.point(x4, y4), point6) || (alaskaPoint.point(x4, y4), point6) || (hawaiiPoint.point(x4, y4), point6);\n  }\n  albersUsa.invert = function(coordinates2) {\n    var k2 = lower48.scale(), t = lower48.translate(), x4 = (coordinates2[0] - t[0]) / k2, y4 = (coordinates2[1] - t[1]) / k2;\n    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);\n  };\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n  albersUsa.precision = function(_) {\n    if (!arguments.length)\n      return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n  albersUsa.scale = function(_) {\n    if (!arguments.length)\n      return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n  albersUsa.translate = function(_) {\n    if (!arguments.length)\n      return lower48.translate();\n    var k2 = lower48.scale(), x4 = +_[0], y4 = +_[1];\n    lower48Point = lower48.translate(_).clipExtent([[x4 - 0.455 * k2, y4 - 0.238 * k2], [x4 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);\n    alaskaPoint = alaska.translate([x4 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x4 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7], [x4 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    hawaiiPoint = hawaii.translate([x4 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x4 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7], [x4 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    return reset();\n  };\n  albersUsa.fitExtent = function(extent3, object2) {\n    return fitExtent(albersUsa, extent3, object2);\n  };\n  albersUsa.fitSize = function(size, object2) {\n    return fitSize(albersUsa, size, object2);\n  };\n  albersUsa.fitWidth = function(width, object2) {\n    return fitWidth(albersUsa, width, object2);\n  };\n  albersUsa.fitHeight = function(height, object2) {\n    return fitHeight(albersUsa, height, object2);\n  };\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n  return albersUsa.scale(1070);\n}\n\n// node_modules/d3-geo/src/projection/azimuthal.js\nfunction azimuthalRaw(scale3) {\n  return function(x4, y4) {\n    var cx = cos2(x4), cy = cos2(y4), k2 = scale3(cx * cy);\n    if (k2 === Infinity)\n      return [2, 0];\n    return [\n      k2 * cy * sin2(x4),\n      k2 * sin2(y4)\n    ];\n  };\n}\nfunction azimuthalInvert(angle2) {\n  return function(x4, y4) {\n    var z = sqrt(x4 * x4 + y4 * y4), c6 = angle2(z), sc = sin2(c6), cc2 = cos2(c6);\n    return [\n      atan2(x4 * sc, z * cc2),\n      asin(z && y4 * sc / z)\n    ];\n  };\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEqualArea.js\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\nfunction azimuthalEqualArea_default() {\n  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEquidistant.js\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c6) {\n  return (c6 = acos(c6)) && c6 / sin2(c6);\n});\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\nfunction azimuthalEquidistant_default() {\n  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/mercator.js\nfunction mercatorRaw(lambda, phi2) {\n  return [lambda, log(tan((halfPi3 + phi2) / 2))];\n}\nmercatorRaw.invert = function(x4, y4) {\n  return [x4, 2 * atan(exp(y4)) - halfPi3];\n};\nfunction mercator_default() {\n  return mercatorProjection(mercatorRaw).scale(961 / tau5);\n}\nfunction mercatorProjection(project2) {\n  var m3 = projection(project2), center2 = m3.center, scale3 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;\n  m3.scale = function(_) {\n    return arguments.length ? (scale3(_), reclip()) : scale3();\n  };\n  m3.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n  m3.center = function(_) {\n    return arguments.length ? (center2(_), reclip()) : center2();\n  };\n  m3.clipExtent = function(_) {\n    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  function reclip() {\n    var k2 = pi4 * scale3(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));\n    return clipExtent(x06 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project2 === mercatorRaw ? [[Math.max(t[0] - k2, x06), y06], [Math.min(t[0] + k2, x12), y12]] : [[x06, Math.max(t[1] - k2, y06)], [x12, Math.min(t[1] + k2, y12)]]);\n  }\n  return reclip();\n}\n\n// node_modules/d3-geo/src/projection/conicConformal.js\nfunction tany(y4) {\n  return tan((halfPi3 + y4) / 2);\n}\nfunction conicConformalRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;\n  if (!n)\n    return mercatorRaw;\n  function project2(x4, y4) {\n    if (f > 0) {\n      if (y4 < -halfPi3 + epsilon7)\n        y4 = -halfPi3 + epsilon7;\n    } else {\n      if (y4 > halfPi3 - epsilon7)\n        y4 = halfPi3 - epsilon7;\n    }\n    var r = f / pow2(tany(y4), n);\n    return [r * sin2(n * x4), f - r * cos2(n * x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var fy = f - y4, r = sign(n) * sqrt(x4 * x4 + fy * fy), l = atan2(x4, abs3(fy)) * sign(fy);\n    if (fy * n < 0)\n      l -= pi4 * sign(x4) * sign(fy);\n    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];\n  };\n  return project2;\n}\nfunction conicConformal_default() {\n  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);\n}\n\n// node_modules/d3-geo/src/projection/equirectangular.js\nfunction equirectangularRaw(lambda, phi2) {\n  return [lambda, phi2];\n}\nequirectangularRaw.invert = equirectangularRaw;\nfunction equirectangular_default() {\n  return projection(equirectangularRaw).scale(152.63);\n}\n\n// node_modules/d3-geo/src/projection/conicEquidistant.js\nfunction conicEquidistantRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;\n  if (abs3(n) < epsilon7)\n    return equirectangularRaw;\n  function project2(x4, y4) {\n    var gy = g - y4, nx = n * x4;\n    return [gy * sin2(nx), g - gy * cos2(nx)];\n  }\n  project2.invert = function(x4, y4) {\n    var gy = g - y4, l = atan2(x4, abs3(gy)) * sign(gy);\n    if (gy * n < 0)\n      l -= pi4 * sign(x4) * sign(gy);\n    return [l / n, g - sign(n) * sqrt(x4 * x4 + gy * gy)];\n  };\n  return project2;\n}\nfunction conicEquidistant_default() {\n  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);\n}\n\n// node_modules/d3-geo/src/projection/equalEarth.js\nvar A1 = 1.340264;\nvar A2 = -0.081106;\nvar A3 = 893e-6;\nvar A4 = 3796e-6;\nvar M = sqrt(3) / 2;\nvar iterations = 12;\nfunction equalEarthRaw(lambda, phi2) {\n  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\nequalEarthRaw.invert = function(x4, y4) {\n  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs3(delta) < epsilon22)\n      break;\n  }\n  return [\n    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),\n    asin(sin2(l) / M)\n  ];\n};\nfunction equalEarth_default() {\n  return projection(equalEarthRaw).scale(177.158);\n}\n\n// node_modules/d3-geo/src/projection/gnomonic.js\nfunction gnomonicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\ngnomonicRaw.invert = azimuthalInvert(atan);\nfunction gnomonic_default() {\n  return projection(gnomonicRaw).scale(144.049).clipAngle(60);\n}\n\n// node_modules/d3-geo/src/projection/identity.js\nfunction identity_default4() {\n  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({\n    point: function(x4, y4) {\n      var p = projection2([x4, y4]);\n      this.stream.point(p[0], p[1]);\n    }\n  }), postclip = identity_default3, cache, cacheStream;\n  function reset() {\n    kx2 = k2 * sx;\n    ky2 = k2 * sy;\n    cache = cacheStream = null;\n    return projection2;\n  }\n  function projection2(p) {\n    var x4 = p[0] * kx2, y4 = p[1] * ky2;\n    if (alpha) {\n      var t = y4 * ca3 - x4 * sa;\n      x4 = x4 * ca3 + y4 * sa;\n      y4 = t;\n    }\n    return [x4 + tx, y4 + ty];\n  }\n  projection2.invert = function(p) {\n    var x4 = p[0] - tx, y4 = p[1] - ty;\n    if (alpha) {\n      var t = y4 * ca3 + x4 * sa;\n      x4 = x4 * ca3 - y4 * sa;\n      y4 = t;\n    }\n    return [x4 / kx2, y4 / ky2];\n  };\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, reset()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  return projection2;\n}\n\n// node_modules/d3-geo/src/projection/naturalEarth1.js\nfunction naturalEarth1Raw(lambda, phi2) {\n  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n  return [\n    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),\n    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))\n  ];\n}\nnaturalEarth1Raw.invert = function(x4, y4) {\n  var phi2 = y4, i = 25, delta;\n  do {\n    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));\n  } while (abs3(delta) > epsilon7 && --i > 0);\n  return [\n    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),\n    phi2\n  ];\n};\nfunction naturalEarth1_default() {\n  return projection(naturalEarth1Raw).scale(175.295);\n}\n\n// node_modules/d3-geo/src/projection/orthographic.js\nfunction orthographicRaw(x4, y4) {\n  return [cos2(y4) * sin2(x4), sin2(y4)];\n}\northographicRaw.invert = azimuthalInvert(asin);\nfunction orthographic_default() {\n  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);\n}\n\n// node_modules/d3-geo/src/projection/stereographic.js\nfunction stereographicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = 1 + cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\nfunction stereographic_default() {\n  return projection(stereographicRaw).scale(250).clipAngle(142);\n}\n\n// node_modules/d3-geo/src/projection/transverseMercator.js\nfunction transverseMercatorRaw(lambda, phi2) {\n  return [log(tan((halfPi3 + phi2) / 2)), -lambda];\n}\ntransverseMercatorRaw.invert = function(x4, y4) {\n  return [-y4, 2 * atan(exp(x4)) - halfPi3];\n};\nfunction transverseMercator_default() {\n  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;\n  m3.center = function(_) {\n    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);\n  };\n  m3.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n  return rotate([0, 0, 90]).scale(159.155);\n}\n\n// node_modules/d3-hierarchy/src/cluster.js\nfunction defaultSeparation(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction meanX(children2) {\n  return children2.reduce(meanXReduce, 0) / children2.length;\n}\nfunction meanXReduce(x4, c6) {\n  return x4 + c6.x;\n}\nfunction maxY(children2) {\n  return 1 + children2.reduce(maxYReduce, 0);\n}\nfunction maxYReduce(y4, c6) {\n  return Math.max(y4, c6.y);\n}\nfunction leafLeft(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[0];\n  return node;\n}\nfunction leafRight(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[children2.length - 1];\n  return node;\n}\nfunction cluster_default() {\n  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;\n  function cluster2(root3) {\n    var previousNode, x4 = 0;\n    root3.eachAfter(function(node) {\n      var children2 = node.children;\n      if (children2) {\n        node.x = meanX(children2);\n        node.y = maxY(children2);\n      } else {\n        node.x = previousNode ? x4 += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n    var left2 = leafLeft(root3), right2 = leafRight(root3), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;\n    return root3.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root3.x) * dx;\n      node.y = (root3.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x06) / (x12 - x06) * dx;\n      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;\n    });\n  }\n  cluster2.separation = function(x4) {\n    return arguments.length ? (separation = x4, cluster2) : separation;\n  };\n  cluster2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? null : [dx, dy];\n  };\n  cluster2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? [dx, dy] : null;\n  };\n  return cluster2;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/count.js\nfunction count2(node) {\n  var sum5 = 0, children2 = node.children, i = children2 && children2.length;\n  if (!i)\n    sum5 = 1;\n  else\n    while (--i >= 0)\n      sum5 += children2[i].value;\n  node.value = sum5;\n}\nfunction count_default() {\n  return this.eachAfter(count2);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/each.js\nfunction each_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js\nfunction eachBefore_default(callback, that) {\n  var node = this, nodes = [node], children2, i, index3 = -1;\n  while (node = nodes.pop()) {\n    callback.call(that, node, ++index3, this);\n    if (children2 = node.children) {\n      for (i = children2.length - 1; i >= 0; --i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js\nfunction eachAfter_default(callback, that) {\n  var node = this, nodes = [node], next = [], children2, i, n, index3 = -1;\n  while (node = nodes.pop()) {\n    next.push(node);\n    if (children2 = node.children) {\n      for (i = 0, n = children2.length; i < n; ++i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  while (node = next.pop()) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/find.js\nfunction find_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    if (callback.call(that, node, ++index3, this)) {\n      return node;\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sum.js\nfunction sum_default(value) {\n  return this.eachAfter(function(node) {\n    var sum5 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;\n    while (--i >= 0)\n      sum5 += children2[i].value;\n    node.value = sum5;\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sort.js\nfunction sort_default2(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/path.js\nfunction path_default2(end) {\n  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];\n  while (start2 !== ancestor) {\n    start2 = start2.parent;\n    nodes.push(start2);\n  }\n  var k2 = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k2, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\nfunction leastCommonAncestor(a4, b) {\n  if (a4 === b)\n    return a4;\n  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c6 = null;\n  a4 = aNodes.pop();\n  b = bNodes.pop();\n  while (a4 === b) {\n    c6 = a4;\n    a4 = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c6;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/ancestors.js\nfunction ancestors_default() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/descendants.js\nfunction descendants_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/leaves.js\nfunction leaves_default() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/links.js\nfunction links_default() {\n  var root3 = this, links = [];\n  root3.each(function(node) {\n    if (node !== root3) {\n      links.push({ source: node.parent, target: node });\n    }\n  });\n  return links;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/iterator.js\nfunction* iterator_default2() {\n  var node = this, current, next = [node], children2, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      yield node;\n      if (children2 = node.children) {\n        for (i = 0, n = children2.length; i < n; ++i) {\n          next.push(children2[i]);\n        }\n      }\n    }\n  } while (next.length);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/index.js\nfunction hierarchy(data, children2) {\n  if (data instanceof Map) {\n    data = [void 0, data];\n    if (children2 === void 0)\n      children2 = mapChildren;\n  } else if (children2 === void 0) {\n    children2 = objectChildren;\n  }\n  var root3 = new Node2(data), node, nodes = [root3], child, childs, i, n;\n  while (node = nodes.pop()) {\n    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {\n      node.children = childs;\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = childs[i] = new Node2(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n  return root3.eachBefore(computeHeight);\n}\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\nfunction objectChildren(d) {\n  return d.children;\n}\nfunction mapChildren(d) {\n  return Array.isArray(d) ? d[1] : null;\n}\nfunction copyData(node) {\n  if (node.data.value !== void 0)\n    node.value = node.data.value;\n  node.data = node.data.data;\n}\nfunction computeHeight(node) {\n  var height = 0;\n  do\n    node.height = height;\n  while ((node = node.parent) && node.height < ++height);\n}\nfunction Node2(data) {\n  this.data = data;\n  this.depth = this.height = 0;\n  this.parent = null;\n}\nNode2.prototype = hierarchy.prototype = {\n  constructor: Node2,\n  count: count_default,\n  each: each_default2,\n  eachAfter: eachAfter_default,\n  eachBefore: eachBefore_default,\n  find: find_default2,\n  sum: sum_default,\n  sort: sort_default2,\n  path: path_default2,\n  ancestors: ancestors_default,\n  descendants: descendants_default,\n  leaves: leaves_default,\n  links: links_default,\n  copy: node_copy,\n  [Symbol.iterator]: iterator_default2\n};\n\n// node_modules/d3-hierarchy/src/accessors.js\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\nfunction required(f) {\n  if (typeof f !== \"function\")\n    throw new Error();\n  return f;\n}\n\n// node_modules/d3-hierarchy/src/constant.js\nfunction constantZero() {\n  return 0;\n}\nfunction constant_default9(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-hierarchy/src/lcg.js\nvar a2 = 1664525;\nvar c2 = 1013904223;\nvar m2 = 4294967296;\nfunction lcg_default2() {\n  let s2 = 1;\n  return () => (s2 = (a2 * s2 + c2) % m2) / m2;\n}\n\n// node_modules/d3-hierarchy/src/array.js\nfunction array_default2(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\nfunction shuffle(array4, random) {\n  let m3 = array4.length, t, i;\n  while (m3) {\n    i = random() * m3-- | 0;\n    t = array4[m3];\n    array4[m3] = array4[i];\n    array4[i] = t;\n  }\n  return array4;\n}\n\n// node_modules/d3-hierarchy/src/pack/enclose.js\nfunction enclose_default(circles) {\n  return packEncloseRandom(circles, lcg_default2());\n}\nfunction packEncloseRandom(circles, random) {\n  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B3 = [], p, e;\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p))\n      ++i;\n    else\n      e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;\n  }\n  return e;\n}\nfunction extendBasis(B3, p) {\n  var i, j;\n  if (enclosesWeakAll(p, B3))\n    return [p];\n  for (i = 0; i < B3.length; ++i) {\n    if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {\n      return [B3[i], p];\n    }\n  }\n  for (i = 0; i < B3.length - 1; ++i) {\n    for (j = i + 1; j < B3.length; ++j) {\n      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {\n        return [B3[i], B3[j], p];\n      }\n    }\n  }\n  throw new Error();\n}\nfunction enclosesNot(a4, b) {\n  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\nfunction enclosesWeak(a4, b) {\n  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction enclosesWeakAll(a4, B3) {\n  for (var i = 0; i < B3.length; ++i) {\n    if (!enclosesWeak(a4, B3[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction encloseBasis(B3) {\n  switch (B3.length) {\n    case 1:\n      return encloseBasis1(B3[0]);\n    case 2:\n      return encloseBasis2(B3[0], B3[1]);\n    case 3:\n      return encloseBasis3(B3[0], B3[1], B3[2]);\n  }\n}\nfunction encloseBasis1(a4) {\n  return {\n    x: a4.x,\n    y: a4.y,\n    r: a4.r\n  };\n}\nfunction encloseBasis2(a4, b) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x12 + x22 + x21 / l * r21) / 2,\n    y: (y12 + y22 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\nfunction encloseBasis3(a4, b, c6) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);\n  return {\n    x: x12 + xa + xb * r,\n    y: y12 + ya + yb * r,\n    r\n  };\n}\n\n// node_modules/d3-hierarchy/src/pack/siblings.js\nfunction place(b, a4, c6) {\n  var dx = b.x - a4.x, x4, a22, dy = b.y - a4.y, y4, b22, d2 = dx * dx + dy * dy;\n  if (d2) {\n    a22 = a4.r + c6.r, a22 *= a22;\n    b22 = b.r + c6.r, b22 *= b22;\n    if (a22 > b22) {\n      x4 = (d2 + b22 - a22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));\n      c6.x = b.x - x4 * dx - y4 * dy;\n      c6.y = b.y - x4 * dy + y4 * dx;\n    } else {\n      x4 = (d2 + a22 - b22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));\n      c6.x = a4.x + x4 * dx - y4 * dy;\n      c6.y = a4.y + x4 * dy + y4 * dx;\n    }\n  } else {\n    c6.x = a4.x + c6.r;\n    c6.y = a4.y;\n  }\n}\nfunction intersects(a4, b) {\n  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction score(node) {\n  var a4 = node._, b = node.next._, ab4 = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab4, dy = (a4.y * b.r + b.y * a4.r) / ab4;\n  return dx * dx + dy * dy;\n}\nfunction Node3(circle2) {\n  this._ = circle2;\n  this.next = null;\n  this.previous = null;\n}\nfunction packSiblingsRandom(circles, random) {\n  if (!(n = (circles = array_default2(circles)).length))\n    return 0;\n  var a4, b, c6, n, aa2, ca3, i, j, k2, sj, sk;\n  a4 = circles[0], a4.x = 0, a4.y = 0;\n  if (!(n > 1))\n    return a4.r;\n  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;\n  if (!(n > 2))\n    return a4.r + b.r;\n  place(b, a4, c6 = circles[2]);\n  a4 = new Node3(a4), b = new Node3(b), c6 = new Node3(c6);\n  a4.next = c6.previous = b;\n  b.next = a4.previous = c6;\n  c6.next = b.previous = a4;\n  pack:\n    for (i = 3; i < n; ++i) {\n      place(a4._, b._, c6 = circles[i]), c6 = new Node3(c6);\n      j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;\n      do {\n        if (sj <= sk) {\n          if (intersects(j._, c6._)) {\n            b = j, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sj += j._.r, j = j.next;\n        } else {\n          if (intersects(k2._, c6._)) {\n            a4 = k2, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sk += k2._.r, k2 = k2.previous;\n        }\n      } while (j !== k2.next);\n      c6.previous = a4, c6.next = b, a4.next = b.previous = b = c6;\n      aa2 = score(a4);\n      while ((c6 = c6.next) !== b) {\n        if ((ca3 = score(c6)) < aa2) {\n          a4 = c6, aa2 = ca3;\n        }\n      }\n      b = a4.next;\n    }\n  a4 = [b._], c6 = b;\n  while ((c6 = c6.next) !== b)\n    a4.push(c6._);\n  c6 = packEncloseRandom(a4, random);\n  for (i = 0; i < n; ++i)\n    a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;\n  return c6.r;\n}\nfunction siblings_default(circles) {\n  packSiblingsRandom(circles, lcg_default2());\n  return circles;\n}\n\n// node_modules/d3-hierarchy/src/pack/index.js\nfunction defaultRadius2(d) {\n  return Math.sqrt(d.value);\n}\nfunction pack_default() {\n  var radius2 = null, dx = 1, dy = 1, padding = constantZero;\n  function pack(root3) {\n    const random = lcg_default2();\n    root3.x = dx / 2, root3.y = dy / 2;\n    if (radius2) {\n      root3.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));\n    } else {\n      root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));\n    }\n    return root3;\n  }\n  pack.radius = function(x4) {\n    return arguments.length ? (radius2 = optional(x4), pack) : radius2;\n  };\n  pack.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];\n  };\n  pack.padding = function(x4) {\n    return arguments.length ? (padding = typeof x4 === \"function\" ? x4 : constant_default9(+x4), pack) : padding;\n  };\n  return pack;\n}\nfunction radiusLeaf(radius2) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius2(node) || 0);\n    }\n  };\n}\nfunction packChildrenRandom(padding, k2, random) {\n  return function(node) {\n    if (children2 = node.children) {\n      var children2, i, n = children2.length, r = padding(node) * k2 || 0, e;\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r += r;\n      e = packSiblingsRandom(children2, random);\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\nfunction translateChild(k2) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k2;\n    if (parent) {\n      node.x = parent.x + k2 * node.x;\n      node.y = parent.y + k2 * node.y;\n    }\n  };\n}\n\n// node_modules/d3-hierarchy/src/treemap/round.js\nfunction round_default2(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n\n// node_modules/d3-hierarchy/src/treemap/dice.js\nfunction dice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.y0 = y06, node.y1 = y12;\n    node.x0 = x06, node.x1 = x06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/partition.js\nfunction partition_default() {\n  var dx = 1, dy = 1, padding = 0, round2 = false;\n  function partition(root3) {\n    var n = root3.height + 1;\n    root3.x0 = root3.y0 = padding;\n    root3.x1 = dx;\n    root3.y1 = dy / n;\n    root3.eachBefore(positionNode(dy, n));\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(dy2, n) {\n    return function(node) {\n      if (node.children) {\n        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);\n      }\n      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      node.x0 = x06;\n      node.y0 = y06;\n      node.x1 = x12;\n      node.y1 = y12;\n    };\n  }\n  partition.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, partition) : round2;\n  };\n  partition.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];\n  };\n  partition.padding = function(x4) {\n    return arguments.length ? (padding = +x4, partition) : padding;\n  };\n  return partition;\n}\n\n// node_modules/d3-hierarchy/src/stratify.js\nvar preroot = { depth: -1 };\nvar ambiguous = {};\nvar imputed = {};\nfunction defaultId(d) {\n  return d.id;\n}\nfunction defaultParentId(d) {\n  return d.parentId;\n}\nfunction stratify_default() {\n  var id2 = defaultId, parentId = defaultParentId, path2;\n  function stratify(data) {\n    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();\n    if (path2 != null) {\n      const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i2 of P) {\n        if (!S.has(i2)) {\n          S.add(i2);\n          I.push(i2);\n          P.push(parentof(i2));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i2) => I[i2];\n      currentParentId = (_, i2) => P[i2];\n    }\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node2(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent)\n          throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous)\n          throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children)\n          parent.children.push(node);\n        else\n          parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root3)\n          throw new Error(\"multiple roots\");\n        root3 = node;\n      }\n    }\n    if (!root3)\n      throw new Error(\"no root\");\n    if (path2 != null) {\n      while (root3.data === imputed && root3.children.length === 1) {\n        root3 = root3.children[0], --n;\n      }\n      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {\n        node = nodes[i2];\n        if (node.data !== imputed)\n          break;\n        node.data = null;\n      }\n    }\n    root3.parent = preroot;\n    root3.eachBefore(function(node2) {\n      node2.depth = node2.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root3.parent = null;\n    if (n > 0)\n      throw new Error(\"cycle\");\n    return root3;\n  }\n  stratify.id = function(x4) {\n    return arguments.length ? (id2 = optional(x4), stratify) : id2;\n  };\n  stratify.parentId = function(x4) {\n    return arguments.length ? (parentId = optional(x4), stratify) : parentId;\n  };\n  stratify.path = function(x4) {\n    return arguments.length ? (path2 = optional(x4), stratify) : path2;\n  };\n  return stratify;\n}\nfunction normalize(path2) {\n  path2 = `${path2}`;\n  let i = path2.length;\n  if (slash(path2, i - 1) && !slash(path2, i - 2))\n    path2 = path2.slice(0, -1);\n  return path2[0] === \"/\" ? path2 : `/${path2}`;\n}\nfunction parentof(path2) {\n  let i = path2.length;\n  if (i < 2)\n    return \"\";\n  while (--i > 1)\n    if (slash(path2, i))\n      break;\n  return path2.slice(0, i);\n}\nfunction slash(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\n\n// node_modules/d3-hierarchy/src/tree.js\nfunction defaultSeparation2(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction nextLeft(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[0] : v2.t;\n}\nfunction nextRight(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[children2.length - 1] : v2.t;\n}\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\nfunction executeShifts(v2) {\n  var shift = 0, change = 0, children2 = v2.children, i = children2.length, w;\n  while (--i >= 0) {\n    w = children2[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\nfunction nextAncestor(vim, v2, ancestor) {\n  return vim.a.parent === v2.parent ? vim.a : ancestor;\n}\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null;\n  this.a = this;\n  this.z = 0;\n  this.m = 0;\n  this.c = 0;\n  this.s = 0;\n  this.t = null;\n  this.i = i;\n}\nTreeNode.prototype = Object.create(Node2.prototype);\nfunction treeRoot(root3) {\n  var tree2 = new TreeNode(root3, 0), node, nodes = [tree2], child, children2, i, n;\n  while (node = nodes.pop()) {\n    if (children2 = node._.children) {\n      node.children = new Array(n = children2.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));\n        child.parent = node;\n      }\n    }\n  }\n  (tree2.parent = new TreeNode(null, 0)).children = [tree2];\n  return tree2;\n}\nfunction tree_default() {\n  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;\n  function tree2(root3) {\n    var t = treeRoot(root3);\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n    if (nodeSize)\n      root3.eachBefore(sizeNode);\n    else {\n      var left2 = root3, right2 = root3, bottom2 = root3;\n      root3.eachBefore(function(node) {\n        if (node.x < left2.x)\n          left2 = node;\n        if (node.x > right2.x)\n          right2 = node;\n        if (node.depth > bottom2.depth)\n          bottom2 = node;\n      });\n      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);\n      root3.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx2;\n        node.y = node.depth * ky2;\n      });\n    }\n    return root3;\n  }\n  function firstWalk(v2) {\n    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;\n    if (children2) {\n      executeShifts(v2);\n      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;\n      if (w) {\n        v2.z = w.z + separation(v2._, w._);\n        v2.m = v2.z - midpoint;\n      } else {\n        v2.z = midpoint;\n      }\n    } else if (w) {\n      v2.z = w.z + separation(v2._, w._);\n    }\n    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);\n  }\n  function secondWalk(v2) {\n    v2._.x = v2.z + v2.parent.m;\n    v2.m += v2.parent.m;\n  }\n  function apportion(v2, w, ancestor) {\n    if (w) {\n      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v2;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v2;\n      }\n    }\n    return ancestor;\n  }\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n  tree2.separation = function(x4) {\n    return arguments.length ? (separation = x4, tree2) : separation;\n  };\n  tree2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? null : [dx, dy];\n  };\n  tree2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? [dx, dy] : null;\n  };\n  return tree2;\n}\n\n// node_modules/d3-hierarchy/src/treemap/slice.js\nfunction slice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.x0 = x06, node.x1 = x12;\n    node.y0 = y06, node.y1 = y06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/squarify.js\nvar phi = (1 + Math.sqrt(5)) / 2;\nfunction squarifyRatio(ratio, parent, x06, y06, x12, y12) {\n  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n  while (i0 < n) {\n    dx = x12 - x06, dy = y12 - y06;\n    do\n      sumValue = nodes[i1++].value;\n    while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue)\n        minValue = nodeValue;\n      if (nodeValue > maxValue)\n        maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) {\n        sumValue -= nodeValue;\n        break;\n      }\n      minRatio = newRatio;\n    }\n    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n    if (row.dice)\n      dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);\n    else\n      slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);\n    value -= sumValue, i0 = i1;\n  }\n  return rows;\n}\nvar squarify_default = function custom10(ratio) {\n  function squarify(parent, x06, y06, x12, y12) {\n    squarifyRatio(ratio, parent, x06, y06, x12, y12);\n  }\n  squarify.ratio = function(x4) {\n    return custom10((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return squarify;\n}(phi);\n\n// node_modules/d3-hierarchy/src/treemap/index.js\nfunction treemap_default() {\n  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;\n  function treemap(root3) {\n    root3.x0 = root3.y0 = 0;\n    root3.x1 = dx;\n    root3.y1 = dy;\n    root3.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(node) {\n    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;\n    if (x12 < x06)\n      x06 = x12 = (x06 + x12) / 2;\n    if (y12 < y06)\n      y06 = y12 = (y06 + y12) / 2;\n    node.x0 = x06;\n    node.y0 = y06;\n    node.x1 = x12;\n    node.y1 = y12;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x06 += paddingLeft(node) - p;\n      y06 += paddingTop(node) - p;\n      x12 -= paddingRight(node) - p;\n      y12 -= paddingBottom(node) - p;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      tile(node, x06, y06, x12, y12);\n    }\n  }\n  treemap.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, treemap) : round2;\n  };\n  treemap.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];\n  };\n  treemap.tile = function(x4) {\n    return arguments.length ? (tile = required(x4), treemap) : tile;\n  };\n  treemap.padding = function(x4) {\n    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();\n  };\n  treemap.paddingInner = function(x4) {\n    return arguments.length ? (paddingInner = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingInner;\n  };\n  treemap.paddingOuter = function(x4) {\n    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();\n  };\n  treemap.paddingTop = function(x4) {\n    return arguments.length ? (paddingTop = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingTop;\n  };\n  treemap.paddingRight = function(x4) {\n    return arguments.length ? (paddingRight = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingRight;\n  };\n  treemap.paddingBottom = function(x4) {\n    return arguments.length ? (paddingBottom = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingBottom;\n  };\n  treemap.paddingLeft = function(x4) {\n    return arguments.length ? (paddingLeft = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingLeft;\n  };\n  return treemap;\n}\n\n// node_modules/d3-hierarchy/src/treemap/binary.js\nfunction binary_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, i, n = nodes.length, sum5, sums = new Array(n + 1);\n  for (sums[0] = sum5 = i = 0; i < n; ++i) {\n    sums[i + 1] = sum5 += nodes[i].value;\n  }\n  partition(0, n, parent.value, x06, y06, x12, y12);\n  function partition(i2, j, value, x07, y07, x13, y13) {\n    if (i2 >= j - 1) {\n      var node = nodes[i2];\n      node.x0 = x07, node.y0 = y07;\n      node.x1 = x13, node.y1 = y13;\n      return;\n    }\n    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;\n    while (k2 < hi) {\n      var mid3 = k2 + hi >>> 1;\n      if (sums[mid3] < valueTarget)\n        k2 = mid3 + 1;\n      else\n        hi = mid3;\n    }\n    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)\n      --k2;\n    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;\n    if (x13 - x07 > y13 - y07) {\n      var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;\n      partition(i2, k2, valueLeft, x07, y07, xk, y13);\n      partition(k2, j, valueRight, xk, y07, x13, y13);\n    } else {\n      var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;\n      partition(i2, k2, valueLeft, x07, y07, x13, yk);\n      partition(k2, j, valueRight, x07, yk, x13, y13);\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/sliceDice.js\nfunction sliceDice_default(parent, x06, y06, x12, y12) {\n  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);\n}\n\n// node_modules/d3-hierarchy/src/treemap/resquarify.js\nvar resquarify_default = function custom11(ratio) {\n  function resquarify(parent, x06, y06, x12, y12) {\n    if ((rows = parent._squarify) && rows.ratio === ratio) {\n      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value = parent.value;\n      while (++j < m3) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i)\n          row.value += nodes[i].value;\n        if (row.dice)\n          dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);\n        else\n          slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);\n      rows.ratio = ratio;\n    }\n  }\n  resquarify.ratio = function(x4) {\n    return custom11((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return resquarify;\n}(phi);\n\n// node_modules/d3-polygon/src/area.js\nfunction area_default4(polygon) {\n  var i = -1, n = polygon.length, a4, b = polygon[n - 1], area2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    area2 += a4[1] * b[0] - a4[0] * b[1];\n  }\n  return area2 / 2;\n}\n\n// node_modules/d3-polygon/src/centroid.js\nfunction centroid_default3(polygon) {\n  var i = -1, n = polygon.length, x4 = 0, y4 = 0, a4, b = polygon[n - 1], c6, k2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    k2 += c6 = a4[0] * b[1] - b[0] * a4[1];\n    x4 += (a4[0] + b[0]) * c6;\n    y4 += (a4[1] + b[1]) * c6;\n  }\n  return k2 *= 3, [x4 / k2, y4 / k2];\n}\n\n// node_modules/d3-polygon/src/cross.js\nfunction cross_default(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) - (b[1] - a4[1]) * (c6[0] - a4[0]);\n}\n\n// node_modules/d3-polygon/src/hull.js\nfunction lexicographicOrder(a4, b) {\n  return a4[0] - b[0] || a4[1] - b[1];\n}\nfunction computeUpperHullIndexes(points) {\n  const n = points.length, indexes2 = [0, 1];\n  let size = 2, i;\n  for (i = 2; i < n; ++i) {\n    while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)\n      --size;\n    indexes2[size++] = i;\n  }\n  return indexes2.slice(0, size);\n}\nfunction hull_default(points) {\n  if ((n = points.length) < 3)\n    return null;\n  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);\n  for (i = 0; i < n; ++i)\n    sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i)\n    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);\n  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];\n  for (i = upperIndexes.length - 1; i >= 0; --i)\n    hull2.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)\n    hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);\n  return hull2;\n}\n\n// node_modules/d3-polygon/src/contains.js\nfunction contains_default3(polygon, point6) {\n  var n = polygon.length, p = polygon[n - 1], x4 = point6[0], y4 = point6[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x12 = p[0], y12 = p[1];\n    if (y12 > y4 !== y06 > y4 && x4 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12)\n      inside = !inside;\n    x06 = x12, y06 = y12;\n  }\n  return inside;\n}\n\n// node_modules/d3-polygon/src/length.js\nfunction length_default2(polygon) {\n  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.hypot(xa, ya);\n  }\n  return perimeter;\n}\n\n// node_modules/d3-random/src/defaultSource.js\nvar defaultSource_default = Math.random;\n\n// node_modules/d3-random/src/uniform.js\nvar uniform_default = function sourceRandomUniform(source) {\n  function randomUniform(min4, max5) {\n    min4 = min4 == null ? 0 : +min4;\n    max5 = max5 == null ? 1 : +max5;\n    if (arguments.length === 1)\n      max5 = min4, min4 = 0;\n    else\n      max5 -= min4;\n    return function() {\n      return source() * max5 + min4;\n    };\n  }\n  randomUniform.source = sourceRandomUniform;\n  return randomUniform;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/int.js\nvar int_default = function sourceRandomInt(source) {\n  function randomInt(min4, max5) {\n    if (arguments.length < 2)\n      max5 = min4, min4 = 0;\n    min4 = Math.floor(min4);\n    max5 = Math.floor(max5) - min4;\n    return function() {\n      return Math.floor(source() * max5 + min4);\n    };\n  }\n  randomInt.source = sourceRandomInt;\n  return randomInt;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/normal.js\nvar normal_default = function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x4, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y4;\n      if (x4 != null)\n        y4 = x4, x4 = null;\n      else\n        do {\n          x4 = source() * 2 - 1;\n          y4 = source() * 2 - 1;\n          r = x4 * x4 + y4 * y4;\n        } while (!r || r > 1);\n      return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n  randomNormal.source = sourceRandomNormal;\n  return randomNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logNormal.js\nvar logNormal_default = function sourceRandomLogNormal(source) {\n  var N = normal_default.source(source);\n  function randomLogNormal() {\n    var randomNormal = N.apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n  randomLogNormal.source = sourceRandomLogNormal;\n  return randomLogNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/irwinHall.js\nvar irwinHall_default = function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    if ((n = +n) <= 0)\n      return () => 0;\n    return function() {\n      for (var sum5 = 0, i = n; i > 1; --i)\n        sum5 += source();\n      return sum5 + i * source();\n    };\n  }\n  randomIrwinHall.source = sourceRandomIrwinHall;\n  return randomIrwinHall;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bates.js\nvar bates_default = function sourceRandomBates(source) {\n  var I = irwinHall_default.source(source);\n  function randomBates(n) {\n    if ((n = +n) === 0)\n      return source;\n    var randomIrwinHall = I(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n  randomBates.source = sourceRandomBates;\n  return randomBates;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/exponential.js\nvar exponential_default = function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log1p(-source()) / lambda;\n    };\n  }\n  randomExponential.source = sourceRandomExponential;\n  return randomExponential;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/pareto.js\nvar pareto_default = function sourceRandomPareto(source) {\n  function randomPareto(alpha) {\n    if ((alpha = +alpha) < 0)\n      throw new RangeError(\"invalid alpha\");\n    alpha = 1 / -alpha;\n    return function() {\n      return Math.pow(1 - source(), alpha);\n    };\n  }\n  randomPareto.source = sourceRandomPareto;\n  return randomPareto;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bernoulli.js\nvar bernoulli_default = function sourceRandomBernoulli(source) {\n  function randomBernoulli(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    return function() {\n      return Math.floor(source() + p);\n    };\n  }\n  randomBernoulli.source = sourceRandomBernoulli;\n  return randomBernoulli;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/geometric.js\nvar geometric_default = function sourceRandomGeometric(source) {\n  function randomGeometric(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    if (p === 0)\n      return () => Infinity;\n    if (p === 1)\n      return () => 1;\n    p = Math.log1p(-p);\n    return function() {\n      return 1 + Math.floor(Math.log1p(-source()) / p);\n    };\n  }\n  randomGeometric.source = sourceRandomGeometric;\n  return randomGeometric;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/gamma.js\nvar gamma_default = function sourceRandomGamma(source) {\n  var randomNormal = normal_default.source(source)();\n  function randomGamma(k2, theta) {\n    if ((k2 = +k2) < 0)\n      throw new RangeError(\"invalid k\");\n    if (k2 === 0)\n      return () => 0;\n    theta = theta == null ? 1 : +theta;\n    if (k2 === 1)\n      return () => -Math.log1p(-source()) * theta;\n    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c6 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;\n    return function() {\n      do {\n        do {\n          var x4 = randomNormal(), v2 = 1 + c6 * x4;\n        } while (v2 <= 0);\n        v2 *= v2 * v2;\n        var u4 = 1 - source();\n      } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));\n      return d * v2 * multiplier() * theta;\n    };\n  }\n  randomGamma.source = sourceRandomGamma;\n  return randomGamma;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/beta.js\nvar beta_default = function sourceRandomBeta(source) {\n  var G = gamma_default.source(source);\n  function randomBeta(alpha, beta) {\n    var X3 = G(alpha), Y3 = G(beta);\n    return function() {\n      var x4 = X3();\n      return x4 === 0 ? 0 : x4 / (x4 + Y3());\n    };\n  }\n  randomBeta.source = sourceRandomBeta;\n  return randomBeta;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/binomial.js\nvar binomial_default = function sourceRandomBinomial(source) {\n  var G = geometric_default.source(source), B3 = beta_default.source(source);\n  function randomBinomial(n, p) {\n    n = +n;\n    if ((p = +p) >= 1)\n      return () => n;\n    if (p <= 0)\n      return () => 0;\n    return function() {\n      var acc = 0, nn = n, pp = p;\n      while (nn * pp > 16 && nn * (1 - pp) > 16) {\n        var i = Math.floor((nn + 1) * pp), y4 = B3(i, nn - i + 1)();\n        if (y4 <= pp) {\n          acc += i;\n          nn -= i;\n          pp = (pp - y4) / (1 - y4);\n        } else {\n          nn = i - 1;\n          pp /= y4;\n        }\n      }\n      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);\n      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)\n        s2 += g();\n      return acc + (sign3 ? k2 : nn - k2);\n    };\n  }\n  randomBinomial.source = sourceRandomBinomial;\n  return randomBinomial;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/weibull.js\nvar weibull_default = function sourceRandomWeibull(source) {\n  function randomWeibull(k2, a4, b) {\n    var outerFunc;\n    if ((k2 = +k2) === 0) {\n      outerFunc = (x4) => -Math.log(x4);\n    } else {\n      k2 = 1 / k2;\n      outerFunc = (x4) => Math.pow(x4, k2);\n    }\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * outerFunc(-Math.log1p(-source()));\n    };\n  }\n  randomWeibull.source = sourceRandomWeibull;\n  return randomWeibull;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/cauchy.js\nvar cauchy_default = function sourceRandomCauchy(source) {\n  function randomCauchy(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * Math.tan(Math.PI * source());\n    };\n  }\n  randomCauchy.source = sourceRandomCauchy;\n  return randomCauchy;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logistic.js\nvar logistic_default = function sourceRandomLogistic(source) {\n  function randomLogistic(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      var u4 = source();\n      return a4 + b * Math.log(u4 / (1 - u4));\n    };\n  }\n  randomLogistic.source = sourceRandomLogistic;\n  return randomLogistic;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/poisson.js\nvar poisson_default = function sourceRandomPoisson(source) {\n  var G = gamma_default.source(source), B3 = binomial_default.source(source);\n  function randomPoisson(lambda) {\n    return function() {\n      var acc = 0, l = lambda;\n      while (l > 16) {\n        var n = Math.floor(0.875 * l), t = G(n)();\n        if (t > l)\n          return acc + B3(n - 1, l / t)();\n        acc += n;\n        l -= t;\n      }\n      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)\n        s2 -= Math.log1p(-source());\n      return acc + k2;\n    };\n  }\n  randomPoisson.source = sourceRandomPoisson;\n  return randomPoisson;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/lcg.js\nvar mul = 1664525;\nvar inc = 1013904223;\nvar eps = 1 / 4294967296;\nfunction lcg(seed = Math.random()) {\n  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;\n  return () => (state = mul * state + inc | 0, eps * (state >>> 0));\n}\n\n// node_modules/d3-scale/src/init.js\nfunction initRange(domain, range5) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1:\n      this.range(domain);\n      break;\n    default:\n      this.range(range5).domain(domain);\n      break;\n  }\n  return this;\n}\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1: {\n      if (typeof domain === \"function\")\n        this.interpolator(domain);\n      else\n        this.range(domain);\n      break;\n    }\n    default: {\n      this.domain(domain);\n      if (typeof interpolator === \"function\")\n        this.interpolator(interpolator);\n      else\n        this.range(interpolator);\n      break;\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-scale/src/ordinal.js\nvar implicit = Symbol(\"implicit\");\nfunction ordinal() {\n  var index3 = new InternMap(), domain = [], range5 = [], unknown = implicit;\n  function scale3(d) {\n    let i = index3.get(d);\n    if (i === void 0) {\n      if (unknown !== implicit)\n        return unknown;\n      index3.set(d, i = domain.push(d) - 1);\n    }\n    return range5[i % range5.length];\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [], index3 = new InternMap();\n    for (const value of _) {\n      if (index3.has(value))\n        continue;\n      index3.set(value, domain.push(value) - 1);\n    }\n    return scale3;\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), scale3) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return ordinal(domain, range5).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/band.js\nfunction band() {\n  var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange2 = scale3.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;\n  delete scale3.unknown;\n  function rescale() {\n    var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;\n    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round2)\n      step = Math.floor(step);\n    start2 += (stop - start2 - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round2)\n      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);\n    var values2 = range(n).map(function(i) {\n      return start2 + step * i;\n    });\n    return ordinalRange2(reverse3 ? values2.reverse() : values2);\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];\n  };\n  scale3.rangeRound = function(_) {\n    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();\n  };\n  scale3.bandwidth = function() {\n    return bandwidth;\n  };\n  scale3.step = function() {\n    return step;\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, rescale()) : round2;\n  };\n  scale3.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n  scale3.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n  scale3.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n  scale3.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n  scale3.copy = function() {\n    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n  return initRange.apply(rescale(), arguments);\n}\nfunction pointish(scale3) {\n  var copy3 = scale3.copy;\n  scale3.padding = scale3.paddingOuter;\n  delete scale3.paddingInner;\n  delete scale3.paddingOuter;\n  scale3.copy = function() {\n    return pointish(copy3());\n  };\n  return scale3;\n}\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// node_modules/d3-scale/src/constant.js\nfunction constants(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-scale/src/number.js\nfunction number3(x4) {\n  return +x4;\n}\n\n// node_modules/d3-scale/src/continuous.js\nvar unit = [0, 1];\nfunction identity3(x4) {\n  return x4;\n}\nfunction normalize2(a4, b) {\n  return (b -= a4 = +a4) ? function(x4) {\n    return (x4 - a4) / b;\n  } : constants(isNaN(b) ? NaN : 0.5);\n}\nfunction clamper(a4, b) {\n  var t;\n  if (a4 > b)\n    t = a4, a4 = b, b = t;\n  return function(x4) {\n    return Math.max(a4, Math.min(b, x4));\n  };\n}\nfunction bimap(domain, range5, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];\n  if (d1 < d0)\n    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);\n  else\n    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);\n  return function(x4) {\n    return r0(d0(x4));\n  };\n}\nfunction polymap(domain, range5, interpolate) {\n  var j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j), i = -1;\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range5 = range5.slice().reverse();\n  }\n  while (++i < j) {\n    d[i] = normalize2(domain[i], domain[i + 1]);\n    r[i] = interpolate(range5[i], range5[i + 1]);\n  }\n  return function(x4) {\n    var i2 = bisect_default(domain, x4, 1, j) - 1;\n    return r[i2](d[i2](x4));\n  };\n}\nfunction copy(source, target) {\n  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction transformer2() {\n  var domain = unit, range5 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;\n  function rescale() {\n    var n = Math.min(domain.length, range5.length);\n    if (clamp !== identity3)\n      clamp = clamper(domain[0], domain[n - 1]);\n    piecewise2 = n > 2 ? polymap : bimap;\n    output = input = null;\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range5, interpolate)))(transform2(clamp(x4)));\n  }\n  scale3.invert = function(y4) {\n    return clamp(untransform((input || (input = piecewise2(range5, domain.map(transform2), number_default)))(y4)));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return range5 = Array.from(_), interpolate = round_default, rescale();\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;\n  };\n  scale3.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t, u4) {\n    transform2 = t, untransform = u4;\n    return rescale();\n  };\n}\nfunction continuous() {\n  return transformer2()(identity3, identity3);\n}\n\n// node_modules/d3-scale/src/tickFormat.js\nfunction tickFormat(start2, stop, count3, specifier) {\n  var step = tickStep(start2, stop, count3), precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start2), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))\n        specifier.precision = precision;\n      return formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))\n        specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))\n        specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format(specifier);\n}\n\n// node_modules/d3-scale/src/linear.js\nfunction linearish(scale3) {\n  var domain = scale3.domain;\n  scale3.ticks = function(count3) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);\n  };\n  scale3.nice = function(count3) {\n    if (count3 == null)\n      count3 = 10;\n    var d = domain();\n    var i0 = 0;\n    var i1 = d.length - 1;\n    var start2 = d[i0];\n    var stop = d[i1];\n    var prestep;\n    var step;\n    var maxIter = 10;\n    if (stop < start2) {\n      step = start2, start2 = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n    while (maxIter-- > 0) {\n      step = tickIncrement(start2, stop, count3);\n      if (step === prestep) {\n        d[i0] = start2;\n        d[i1] = stop;\n        return domain(d);\n      } else if (step > 0) {\n        start2 = Math.floor(start2 / step) * step;\n        stop = Math.ceil(stop / step) * step;\n      } else if (step < 0) {\n        start2 = Math.ceil(start2 * step) / step;\n        stop = Math.floor(stop * step) / step;\n      } else {\n        break;\n      }\n      prestep = step;\n    }\n    return scale3;\n  };\n  return scale3;\n}\nfunction linear3() {\n  var scale3 = continuous();\n  scale3.copy = function() {\n    return copy(scale3, linear3());\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/identity.js\nfunction identity4(domain) {\n  var unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : x4;\n  }\n  scale3.invert = scale3;\n  scale3.domain = scale3.range = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), scale3) : domain.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return identity4(domain).unknown(unknown);\n  };\n  domain = arguments.length ? Array.from(domain, number3) : [0, 1];\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/nice.js\nfunction nice2(domain, interval2) {\n  domain = domain.slice();\n  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;\n  if (x12 < x06) {\n    t = i0, i0 = i1, i1 = t;\n    t = x06, x06 = x12, x12 = t;\n  }\n  domain[i0] = interval2.floor(x06);\n  domain[i1] = interval2.ceil(x12);\n  return domain;\n}\n\n// node_modules/d3-scale/src/log.js\nfunction transformLog(x4) {\n  return Math.log(x4);\n}\nfunction transformExp(x4) {\n  return Math.exp(x4);\n}\nfunction transformLogn(x4) {\n  return -Math.log(-x4);\n}\nfunction transformExpn(x4) {\n  return -Math.exp(-x4);\n}\nfunction pow10(x4) {\n  return isFinite(x4) ? +(\"1e\" + x4) : x4 < 0 ? 0 : x4;\n}\nfunction powp(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);\n}\nfunction logp(base) {\n  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);\n}\nfunction reflect(f) {\n  return (x4, k2) => -f(-x4, k2);\n}\nfunction loggish(transform2) {\n  const scale3 = transform2(transformLog, transformExp);\n  const domain = scale3.domain;\n  let base = 10;\n  let logs;\n  let pows;\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform2(transformLogn, transformExpn);\n    } else {\n      transform2(transformLog, transformExp);\n    }\n    return scale3;\n  }\n  scale3.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.ticks = (count3) => {\n    const d = domain();\n    let u4 = d[0];\n    let v2 = d[d.length - 1];\n    const r = v2 < u4;\n    if (r)\n      [u4, v2] = [v2, u4];\n    let i = logs(u4);\n    let j = logs(v2);\n    let k2;\n    let t;\n    const n = count3 == null ? 10 : +count3;\n    let z = [];\n    if (!(base % 1) && j - i < n) {\n      i = Math.floor(i), j = Math.ceil(j);\n      if (u4 > 0)\n        for (; i <= j; ++i) {\n          for (k2 = 1; k2 < base; ++k2) {\n            t = i < 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      else\n        for (; i <= j; ++i) {\n          for (k2 = base - 1; k2 >= 1; --k2) {\n            t = i > 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      if (z.length * 2 < n)\n        z = ticks(u4, v2, n);\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n    return r ? z.reverse() : z;\n  };\n  scale3.tickFormat = (count3, specifier) => {\n    if (count3 == null)\n      count3 = 10;\n    if (specifier == null)\n      specifier = base === 10 ? \"s\" : \",\";\n    if (typeof specifier !== \"function\") {\n      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)\n        specifier.trim = true;\n      specifier = format(specifier);\n    }\n    if (count3 === Infinity)\n      return specifier;\n    const k2 = Math.max(1, base * count3 / scale3.ticks().length);\n    return (d) => {\n      let i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5)\n        i *= base;\n      return i <= k2 ? specifier(d) : \"\";\n    };\n  };\n  scale3.nice = () => {\n    return domain(nice2(domain(), {\n      floor: (x4) => pows(Math.floor(logs(x4))),\n      ceil: (x4) => pows(Math.ceil(logs(x4)))\n    }));\n  };\n  return scale3;\n}\nfunction log2() {\n  const scale3 = loggish(transformer2()).domain([1, 10]);\n  scale3.copy = () => copy(scale3, log2()).base(scale3.base());\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/symlog.js\nfunction transformSymlog(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.log1p(Math.abs(x4 / c6));\n  };\n}\nfunction transformSymexp(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c6;\n  };\n}\nfunction symlogish(transform2) {\n  var c6 = 1, scale3 = transform2(transformSymlog(c6), transformSymexp(c6));\n  scale3.constant = function(_) {\n    return arguments.length ? transform2(transformSymlog(c6 = +_), transformSymexp(c6)) : c6;\n  };\n  return linearish(scale3);\n}\nfunction symlog() {\n  var scale3 = symlogish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, symlog()).constant(scale3.constant());\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/pow.js\nfunction transformPow(exponent2) {\n  return function(x4) {\n    return x4 < 0 ? -Math.pow(-x4, exponent2) : Math.pow(x4, exponent2);\n  };\n}\nfunction transformSqrt(x4) {\n  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);\n}\nfunction transformSquare(x4) {\n  return x4 < 0 ? -x4 * x4 : x4 * x4;\n}\nfunction powish(transform2) {\n  var scale3 = transform2(identity3, identity3), exponent2 = 1;\n  function rescale() {\n    return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));\n  }\n  scale3.exponent = function(_) {\n    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;\n  };\n  return linearish(scale3);\n}\nfunction pow3() {\n  var scale3 = powish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, pow3()).exponent(scale3.exponent());\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\nfunction sqrt2() {\n  return pow3.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/radial.js\nfunction square(x4) {\n  return Math.sign(x4) * x4 * x4;\n}\nfunction unsquare(x4) {\n  return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n}\nfunction radial() {\n  var squared = continuous(), range5 = [0, 1], round2 = false, unknown;\n  function scale3(x4) {\n    var y4 = unsquare(squared(x4));\n    return isNaN(y4) ? unknown : round2 ? Math.round(y4) : y4;\n  }\n  scale3.invert = function(y4) {\n    return squared.invert(square(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (squared.domain(_), scale3) : squared.domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (squared.range((range5 = Array.from(_, number3)).map(square)), scale3) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return scale3.range(_).round(true);\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, scale3) : round2;\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (squared.clamp(_), scale3) : squared.clamp();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return radial(squared.domain(), range5).round(round2).clamp(squared.clamp()).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/quantile.js\nfunction quantile2() {\n  var domain = [], range5 = [], thresholds = [], unknown;\n  function rescale() {\n    var i = 0, n = Math.max(1, range5.length);\n    thresholds = new Array(n - 1);\n    while (++i < n)\n      thresholds[i - 1] = quantileSorted(domain, i / n);\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : range5[bisect_default(thresholds, x4)];\n  }\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.quantiles = function() {\n    return thresholds.slice();\n  };\n  scale3.copy = function() {\n    return quantile2().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/quantize.js\nfunction quantize() {\n  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range5 = [0, 1], unknown;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n)\n      domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);\n    return scale3;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : scale3;\n  };\n  scale3.thresholds = function() {\n    return domain.slice();\n  };\n  scale3.copy = function() {\n    return quantize().domain([x06, x12]).range(range5).unknown(unknown);\n  };\n  return initRange.apply(linearish(scale3), arguments);\n}\n\n// node_modules/d3-scale/src/threshold.js\nfunction threshold() {\n  var domain = [0.5], range5 = [0, 1], unknown, n = 1;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return threshold().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-time/src/interval.js\nvar t02 = /* @__PURE__ */ new Date();\nvar t12 = /* @__PURE__ */ new Date();\nfunction timeInterval(floori, offseti, count3, field2) {\n  function interval2(date2) {\n    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;\n  }\n  interval2.floor = (date2) => {\n    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;\n  };\n  interval2.ceil = (date2) => {\n    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;\n  };\n  interval2.round = (date2) => {\n    const d0 = interval2(date2), d1 = interval2.ceil(date2);\n    return date2 - d0 < d1 - date2 ? d0 : d1;\n  };\n  interval2.offset = (date2, step) => {\n    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;\n  };\n  interval2.range = (start2, stop, step) => {\n    const range5 = [];\n    start2 = interval2.ceil(start2);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start2 < stop) || !(step > 0))\n      return range5;\n    let previous;\n    do\n      range5.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);\n    while (previous < start2 && start2 < stop);\n    return range5;\n  };\n  interval2.filter = (test) => {\n    return timeInterval((date2) => {\n      if (date2 >= date2)\n        while (floori(date2), !test(date2))\n          date2.setTime(date2 - 1);\n    }, (date2, step) => {\n      if (date2 >= date2) {\n        if (step < 0)\n          while (++step <= 0) {\n            while (offseti(date2, -1), !test(date2)) {\n            }\n          }\n        else\n          while (--step >= 0) {\n            while (offseti(date2, 1), !test(date2)) {\n            }\n          }\n      }\n    });\n  };\n  if (count3) {\n    interval2.count = (start2, end) => {\n      t02.setTime(+start2), t12.setTime(+end);\n      floori(t02), floori(t12);\n      return Math.floor(count3(t02, t12));\n    };\n    interval2.every = (step) => {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);\n    };\n  }\n  return interval2;\n}\n\n// node_modules/d3-time/src/millisecond.js\nvar millisecond = timeInterval(() => {\n}, (date2, step) => {\n  date2.setTime(+date2 + step);\n}, (start2, end) => {\n  return end - start2;\n});\nmillisecond.every = (k2) => {\n  k2 = Math.floor(k2);\n  if (!isFinite(k2) || !(k2 > 0))\n    return null;\n  if (!(k2 > 1))\n    return millisecond;\n  return timeInterval((date2) => {\n    date2.setTime(Math.floor(date2 / k2) * k2);\n  }, (date2, step) => {\n    date2.setTime(+date2 + step * k2);\n  }, (start2, end) => {\n    return (end - start2) / k2;\n  });\n};\nvar milliseconds = millisecond.range;\n\n// node_modules/d3-time/src/duration.js\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// node_modules/d3-time/src/second.js\nvar second = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds());\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationSecond);\n}, (start2, end) => {\n  return (end - start2) / durationSecond;\n}, (date2) => {\n  return date2.getUTCSeconds();\n});\nvar seconds = second.range;\n\n// node_modules/d3-time/src/minute.js\nvar timeMinute = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getMinutes();\n});\nvar timeMinutes = timeMinute.range;\nvar utcMinute = timeInterval((date2) => {\n  date2.setUTCSeconds(0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getUTCMinutes();\n});\nvar utcMinutes = utcMinute.range;\n\n// node_modules/d3-time/src/hour.js\nvar timeHour = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getHours();\n});\nvar timeHours = timeHour.range;\nvar utcHour = timeInterval((date2) => {\n  date2.setUTCMinutes(0, 0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getUTCHours();\n});\nvar utcHours = utcHour.range;\n\n// node_modules/d3-time/src/day.js\nvar timeDay = timeInterval(\n  (date2) => date2.setHours(0, 0, 0, 0),\n  (date2, step) => date2.setDate(date2.getDate() + step),\n  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,\n  (date2) => date2.getDate() - 1\n);\nvar timeDays = timeDay.range;\nvar utcDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return date2.getUTCDate() - 1;\n});\nvar utcDays = utcDay.range;\nvar unixDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return Math.floor(date2 / durationDay);\n});\nvar unixDays = unixDay.range;\n\n// node_modules/d3-time/src/week.js\nfunction timeWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setDate(date2.getDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\nvar timeSunday = timeWeekday(0);\nvar timeMonday = timeWeekday(1);\nvar timeTuesday = timeWeekday(2);\nvar timeWednesday = timeWeekday(3);\nvar timeThursday = timeWeekday(4);\nvar timeFriday = timeWeekday(5);\nvar timeSaturday = timeWeekday(6);\nvar timeSundays = timeSunday.range;\nvar timeMondays = timeMonday.range;\nvar timeTuesdays = timeTuesday.range;\nvar timeWednesdays = timeWednesday.range;\nvar timeThursdays = timeThursday.range;\nvar timeFridays = timeFriday.range;\nvar timeSaturdays = timeSaturday.range;\nfunction utcWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCDate(date2.getUTCDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2) / durationWeek;\n  });\n}\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\n// node_modules/d3-time/src/month.js\nvar timeMonth = timeInterval((date2) => {\n  date2.setDate(1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setMonth(date2.getMonth() + step);\n}, (start2, end) => {\n  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;\n}, (date2) => {\n  return date2.getMonth();\n});\nvar timeMonths = timeMonth.range;\nvar utcMonth = timeInterval((date2) => {\n  date2.setUTCDate(1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCMonth(date2.getUTCMonth() + step);\n}, (start2, end) => {\n  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;\n}, (date2) => {\n  return date2.getUTCMonth();\n});\nvar utcMonths = utcMonth.range;\n\n// node_modules/d3-time/src/year.js\nvar timeYear = timeInterval((date2) => {\n  date2.setMonth(0, 1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setFullYear(date2.getFullYear() + step);\n}, (start2, end) => {\n  return end.getFullYear() - start2.getFullYear();\n}, (date2) => {\n  return date2.getFullYear();\n});\ntimeYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);\n    date2.setMonth(0, 1);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setFullYear(date2.getFullYear() + step * k2);\n  });\n};\nvar timeYears = timeYear.range;\nvar utcYear = timeInterval((date2) => {\n  date2.setUTCMonth(0, 1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCFullYear(date2.getUTCFullYear() + step);\n}, (start2, end) => {\n  return end.getUTCFullYear() - start2.getUTCFullYear();\n}, (date2) => {\n  return date2.getUTCFullYear();\n});\nutcYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);\n    date2.setUTCMonth(0, 1);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);\n  });\n};\nvar utcYears = utcYear.range;\n\n// node_modules/d3-time/src/ticks.js\nfunction ticker(year, month, week, day, hour, minute) {\n  const tickIntervals = [\n    [second, 1, durationSecond],\n    [second, 5, 5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute, 1, durationMinute],\n    [minute, 5, 5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [hour, 1, durationHour],\n    [hour, 3, 3 * durationHour],\n    [hour, 6, 6 * durationHour],\n    [hour, 12, 12 * durationHour],\n    [day, 1, durationDay],\n    [day, 2, 2 * durationDay],\n    [week, 1, durationWeek],\n    [month, 1, durationMonth],\n    [month, 3, 3 * durationMonth],\n    [year, 1, durationYear]\n  ];\n  function ticks2(start2, stop, count3) {\n    const reverse3 = stop < start2;\n    if (reverse3)\n      [start2, stop] = [stop, start2];\n    const interval2 = count3 && typeof count3.range === \"function\" ? count3 : tickInterval(start2, stop, count3);\n    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];\n    return reverse3 ? ticks3.reverse() : ticks3;\n  }\n  function tickInterval(start2, stop, count3) {\n    const target = Math.abs(stop - start2) / count3;\n    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);\n    if (i === tickIntervals.length)\n      return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));\n    if (i === 0)\n      return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));\n    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n    return t.every(step);\n  }\n  return [ticks2, tickInterval];\n}\nvar [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);\nvar [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);\n\n// node_modules/d3-time-format/src/locale.js\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date2.setFullYear(d.y);\n    return date2;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date2.setUTCFullYear(d.y);\n    return date2;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\nfunction newDate(y4, m3, d) {\n  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };\n}\nfunction formatLocale(locale3) {\n  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;\n  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday2,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth2,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"g\": formatYearISO,\n    \"G\": formatFullYearISO,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"q\": formatQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear2,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"g\": formatUTCYearISO,\n    \"G\": formatUTCFullYearISO,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"q\": formatUTCQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"g\": parseYear,\n    \"G\": parseFullYear,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"q\": parseQuarter,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n  function newFormat(specifier, formats2) {\n    return function(date2) {\n      var string2 = [], i = -1, j = 0, n = specifier.length, c6, pad4, format3;\n      if (!(date2 instanceof Date))\n        date2 = /* @__PURE__ */ new Date(+date2);\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string2.push(specifier.slice(j, i));\n          if ((pad4 = pads[c6 = specifier.charAt(++i)]) != null)\n            c6 = specifier.charAt(++i);\n          else\n            pad4 = c6 === \"e\" ? \" \" : \"0\";\n          if (format3 = formats2[c6])\n            c6 = format3(date2, pad4);\n          string2.push(c6);\n          j = i + 1;\n        }\n      }\n      string2.push(specifier.slice(j, i));\n      return string2.join(\"\");\n    };\n  }\n  function newParse(specifier, Z) {\n    return function(string2) {\n      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += \"\", 0), week, day;\n      if (i != string2.length)\n        return null;\n      if (\"Q\" in d)\n        return new Date(d.Q);\n      if (\"s\" in d)\n        return new Date(d.s * 1e3 + (\"L\" in d ? d.L : 0));\n      if (Z && !(\"Z\" in d))\n        d.Z = 0;\n      if (\"p\" in d)\n        d.H = d.H % 12 + d.p * 12;\n      if (d.m === void 0)\n        d.m = \"q\" in d ? d.q : 0;\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53)\n          return null;\n        if (!(\"w\" in d))\n          d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();\n          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();\n          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);\n          week = timeDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d))\n          d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day = \"Z\" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n      }\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n      return localDate(d);\n    };\n  }\n  function parseSpecifier(d, specifier, string2, j) {\n    var i = 0, n = specifier.length, m3 = string2.length, c6, parse2;\n    while (i < n) {\n      if (j >= m3)\n        return -1;\n      c6 = specifier.charCodeAt(i++);\n      if (c6 === 37) {\n        c6 = specifier.charAt(i++);\n        parse2 = parses[c6 in pads ? specifier.charAt(i++) : c6];\n        if (!parse2 || (j = parse2(d, string2, j)) < 0)\n          return -1;\n      } else if (c6 != string2.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n    return j;\n  }\n  function parsePeriod(d, string2, i) {\n    var n = periodRe.exec(string2.slice(i));\n    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortWeekday(d, string2, i) {\n    var n = shortWeekdayRe.exec(string2.slice(i));\n    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseWeekday(d, string2, i) {\n    var n = weekdayRe.exec(string2.slice(i));\n    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortMonth(d, string2, i) {\n    var n = shortMonthRe.exec(string2.slice(i));\n    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseMonth(d, string2, i) {\n    var n = monthRe.exec(string2.slice(i));\n    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseLocaleDateTime(d, string2, i) {\n    return parseSpecifier(d, locale_dateTime, string2, i);\n  }\n  function parseLocaleDate(d, string2, i) {\n    return parseSpecifier(d, locale_date, string2, i);\n  }\n  function parseLocaleTime(d, string2, i) {\n    return parseSpecifier(d, locale_time, string2, i);\n  }\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n  function formatWeekday2(d) {\n    return locale_weekdays[d.getDay()];\n  }\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n  function formatMonth2(d) {\n    return locale_months[d.getMonth()];\n  }\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n  function formatQuarter(d) {\n    return 1 + ~~(d.getMonth() / 3);\n  }\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n  function formatUTCQuarter(d) {\n    return 1 + ~~(d.getUTCMonth() / 3);\n  }\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", false);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier += \"\", true);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    }\n  };\n}\nvar pads = { \"-\": \"\", \"_\": \" \", \"0\": \"0\" };\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\nfunction pad2(value, fill, width) {\n  var sign3 = value < 0 ? \"-\" : \"\", string2 = (sign3 ? -value : value) + \"\", length4 = string2.length;\n  return sign3 + (length4 < width ? new Array(width - length4 + 1).join(fill) + string2 : string2);\n}\nfunction requote(s2) {\n  return s2.replace(requoteRe, \"\\\\$&\");\n}\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\nfunction formatLookup(names) {\n  return new Map(names.map((name, i) => [name.toLowerCase(), i]));\n}\nfunction parseWeekdayNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekdayNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberISO(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\nfunction parseFullYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\nfunction parseYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;\n}\nfunction parseZone(d, string2, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string2.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\nfunction parseQuarter(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;\n}\nfunction parseMonthNumber(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\nfunction parseDayOfMonth(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseDayOfYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseHour24(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\nfunction parseMinutes(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\nfunction parseSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\nfunction parseMilliseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\nfunction parseMicroseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;\n}\nfunction parseLiteralPercent(d, string2, i) {\n  var n = percentRe.exec(string2.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\nfunction parseUnixTimestamp(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\nfunction parseUnixTimestampSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.s = +n[0], i + n[0].length) : -1;\n}\nfunction formatDayOfMonth(d, p) {\n  return pad2(d.getDate(), p, 2);\n}\nfunction formatHour24(d, p) {\n  return pad2(d.getHours(), p, 2);\n}\nfunction formatHour12(d, p) {\n  return pad2(d.getHours() % 12 || 12, p, 2);\n}\nfunction formatDayOfYear(d, p) {\n  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);\n}\nfunction formatMilliseconds(d, p) {\n  return pad2(d.getMilliseconds(), p, 3);\n}\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\nfunction formatMonthNumber(d, p) {\n  return pad2(d.getMonth() + 1, p, 2);\n}\nfunction formatMinutes(d, p) {\n  return pad2(d.getMinutes(), p, 2);\n}\nfunction formatSeconds(d, p) {\n  return pad2(d.getSeconds(), p, 2);\n}\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\nfunction formatWeekNumberSunday(d, p) {\n  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction dISO(d) {\n  var day = d.getDay();\n  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n}\nfunction formatWeekNumberISO(d, p) {\n  d = dISO(d);\n  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);\n}\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\nfunction formatWeekNumberMonday(d, p) {\n  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction formatYear2(d, p) {\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatYearISO(d, p) {\n  d = dISO(d);\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatFullYear(d, p) {\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatFullYearISO(d, p) {\n  var day = d.getDay();\n  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\")) + pad2(z / 60 | 0, \"0\", 2) + pad2(z % 60, \"0\", 2);\n}\nfunction formatUTCDayOfMonth(d, p) {\n  return pad2(d.getUTCDate(), p, 2);\n}\nfunction formatUTCHour24(d, p) {\n  return pad2(d.getUTCHours(), p, 2);\n}\nfunction formatUTCHour12(d, p) {\n  return pad2(d.getUTCHours() % 12 || 12, p, 2);\n}\nfunction formatUTCDayOfYear(d, p) {\n  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);\n}\nfunction formatUTCMilliseconds(d, p) {\n  return pad2(d.getUTCMilliseconds(), p, 3);\n}\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\nfunction formatUTCMonthNumber(d, p) {\n  return pad2(d.getUTCMonth() + 1, p, 2);\n}\nfunction formatUTCMinutes(d, p) {\n  return pad2(d.getUTCMinutes(), p, 2);\n}\nfunction formatUTCSeconds(d, p) {\n  return pad2(d.getUTCSeconds(), p, 2);\n}\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction UTCdISO(d) {\n  var day = d.getUTCDay();\n  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n}\nfunction formatUTCWeekNumberISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction formatUTCYear(d, p) {\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCYearISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCFullYear(d, p) {\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCFullYearISO(d, p) {\n  var day = d.getUTCDay();\n  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCZone() {\n  return \"+0000\";\n}\nfunction formatLiteralPercent() {\n  return \"%\";\n}\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1e3);\n}\n\n// node_modules/d3-time-format/src/defaultLocale.js\nvar locale2;\nvar timeFormat;\nvar timeParse;\nvar utcFormat;\nvar utcParse;\ndefaultLocale2({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\nfunction defaultLocale2(definition) {\n  locale2 = formatLocale(definition);\n  timeFormat = locale2.format;\n  timeParse = locale2.parse;\n  utcFormat = locale2.utcFormat;\n  utcParse = locale2.utcParse;\n  return locale2;\n}\n\n// node_modules/d3-time-format/src/isoFormat.js\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nfunction formatIsoNative(date2) {\n  return date2.toISOString();\n}\nvar formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);\nvar isoFormat_default = formatIso;\n\n// node_modules/d3-time-format/src/isoParse.js\nfunction parseIsoNative(string2) {\n  var date2 = new Date(string2);\n  return isNaN(date2) ? null : date2;\n}\nvar parseIso = +/* @__PURE__ */ new Date(\"2000-01-01T00:00:00.000Z\") ? parseIsoNative : utcParse(isoSpecifier);\nvar isoParse_default = parseIso;\n\n// node_modules/d3-scale/src/time.js\nfunction date(t) {\n  return new Date(t);\n}\nfunction number4(t) {\n  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);\n}\nfunction calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {\n  var scale3 = continuous(), invert = scale3.invert, domain = scale3.domain;\n  var formatMillisecond = format3(\".%L\"), formatSecond = format3(\":%S\"), formatMinute = format3(\"%I:%M\"), formatHour = format3(\"%I %p\"), formatDay = format3(\"%a %d\"), formatWeek = format3(\"%b %d\"), formatMonth2 = format3(\"%B\"), formatYear4 = format3(\"%Y\");\n  function tickFormat2(date2) {\n    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear4)(date2);\n  }\n  scale3.invert = function(y4) {\n    return new Date(invert(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);\n  };\n  scale3.ticks = function(interval2) {\n    var d = domain();\n    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    return specifier == null ? tickFormat2 : format3(specifier);\n  };\n  scale3.nice = function(interval2) {\n    var d = domain();\n    if (!interval2 || typeof interval2.range !== \"function\")\n      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n    return interval2 ? domain(nice2(d, interval2)) : scale3;\n  };\n  scale3.copy = function() {\n    return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));\n  };\n  return scale3;\n}\nfunction time() {\n  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/utcTime.js\nfunction utcTime() {\n  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/sequential.js\nfunction transformer3() {\n  var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : interpolator(k10 === 0 ? 0.5 : (x4 = (transform2(x4) - t03) * k10, clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale3) : [x06, x12];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1;\n      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale3) : [interpolator(0), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);\n    return scale3;\n  };\n}\nfunction copy2(source, target) {\n  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction sequential() {\n  var scale3 = linearish(transformer3()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, sequential());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialLog() {\n  var scale3 = loggish(transformer3()).domain([1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, sequentialLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSymlog() {\n  var scale3 = symlogish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialPow() {\n  var scale3 = powish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/sequentialQuantile.js\nfunction sequentialQuantile() {\n  var domain = [], interpolator = identity3;\n  function scale3(x4) {\n    if (x4 != null && !isNaN(x4 = +x4))\n      return interpolator((bisect_default(domain, x4, 1) - 1) / (domain.length - 1));\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return scale3;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  scale3.range = function() {\n    return domain.map((d, i) => interpolator(i / (domain.length - 1)));\n  };\n  scale3.quantiles = function(n) {\n    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));\n  };\n  scale3.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/diverging.js\nfunction transformer4() {\n  var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;\n  function scale3(x4) {\n    return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform2(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12, x22] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1, r2;\n      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;\n    return scale3;\n  };\n}\nfunction diverging() {\n  var scale3 = linearish(transformer4()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, diverging());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingLog() {\n  var scale3 = loggish(transformer4()).domain([0.1, 1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, divergingLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSymlog() {\n  var scale3 = symlogish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingPow() {\n  var scale3 = powish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale-chromatic/src/colors.js\nfunction colors_default(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n)\n    colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n\n// node_modules/d3-scale-chromatic/src/categorical/category10.js\nvar category10_default = colors_default(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Accent.js\nvar Accent_default = colors_default(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Dark2.js\nvar Dark2_default = colors_default(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Paired.js\nvar Paired_default = colors_default(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js\nvar Pastel1_default = colors_default(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js\nvar Pastel2_default = colors_default(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set1.js\nvar Set1_default = colors_default(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set2.js\nvar Set2_default = colors_default(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set3.js\nvar Set3_default = colors_default(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js\nvar Tableau10_default = colors_default(\"4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab\");\n\n// node_modules/d3-scale-chromatic/src/ramp.js\nvar ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);\n\n// node_modules/d3-scale-chromatic/src/diverging/BrBG.js\nvar scheme = new Array(3).concat(\n  \"d8b365f5f5f55ab4ac\",\n  \"a6611adfc27d80cdc1018571\",\n  \"a6611adfc27df5f5f580cdc1018571\",\n  \"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\n  \"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\n  \"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\n  \"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\n  \"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\n  \"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"\n).map(colors_default);\nvar BrBG_default = ramp_default(scheme);\n\n// node_modules/d3-scale-chromatic/src/diverging/PRGn.js\nvar scheme2 = new Array(3).concat(\n  \"af8dc3f7f7f77fbf7b\",\n  \"7b3294c2a5cfa6dba0008837\",\n  \"7b3294c2a5cff7f7f7a6dba0008837\",\n  \"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\n  \"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\n  \"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\n  \"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\n  \"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\n  \"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"\n).map(colors_default);\nvar PRGn_default = ramp_default(scheme2);\n\n// node_modules/d3-scale-chromatic/src/diverging/PiYG.js\nvar scheme3 = new Array(3).concat(\n  \"e9a3c9f7f7f7a1d76a\",\n  \"d01c8bf1b6dab8e1864dac26\",\n  \"d01c8bf1b6daf7f7f7b8e1864dac26\",\n  \"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\n  \"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\n  \"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\n  \"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\n  \"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\n  \"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"\n).map(colors_default);\nvar PiYG_default = ramp_default(scheme3);\n\n// node_modules/d3-scale-chromatic/src/diverging/PuOr.js\nvar scheme4 = new Array(3).concat(\n  \"998ec3f7f7f7f1a340\",\n  \"5e3c99b2abd2fdb863e66101\",\n  \"5e3c99b2abd2f7f7f7fdb863e66101\",\n  \"542788998ec3d8daebfee0b6f1a340b35806\",\n  \"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\n  \"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\n  \"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\n  \"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\n  \"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors_default);\nvar PuOr_default = ramp_default(scheme4);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdBu.js\nvar scheme5 = new Array(3).concat(\n  \"ef8a62f7f7f767a9cf\",\n  \"ca0020f4a58292c5de0571b0\",\n  \"ca0020f4a582f7f7f792c5de0571b0\",\n  \"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\n  \"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\n  \"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\n  \"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\n  \"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\n  \"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"\n).map(colors_default);\nvar RdBu_default = ramp_default(scheme5);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdGy.js\nvar scheme6 = new Array(3).concat(\n  \"ef8a62ffffff999999\",\n  \"ca0020f4a582bababa404040\",\n  \"ca0020f4a582ffffffbababa404040\",\n  \"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\n  \"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\n  \"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\n  \"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\n  \"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\n  \"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"\n).map(colors_default);\nvar RdGy_default = ramp_default(scheme6);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js\nvar scheme7 = new Array(3).concat(\n  \"fc8d59ffffbf91bfdb\",\n  \"d7191cfdae61abd9e92c7bb6\",\n  \"d7191cfdae61ffffbfabd9e92c7bb6\",\n  \"d73027fc8d59fee090e0f3f891bfdb4575b4\",\n  \"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\n  \"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\n  \"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\n  \"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\n  \"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"\n).map(colors_default);\nvar RdYlBu_default = ramp_default(scheme7);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js\nvar scheme8 = new Array(3).concat(\n  \"fc8d59ffffbf91cf60\",\n  \"d7191cfdae61a6d96a1a9641\",\n  \"d7191cfdae61ffffbfa6d96a1a9641\",\n  \"d73027fc8d59fee08bd9ef8b91cf601a9850\",\n  \"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\n  \"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\n  \"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\n  \"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\n  \"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"\n).map(colors_default);\nvar RdYlGn_default = ramp_default(scheme8);\n\n// node_modules/d3-scale-chromatic/src/diverging/Spectral.js\nvar scheme9 = new Array(3).concat(\n  \"fc8d59ffffbf99d594\",\n  \"d7191cfdae61abdda42b83ba\",\n  \"d7191cfdae61ffffbfabdda42b83ba\",\n  \"d53e4ffc8d59fee08be6f59899d5943288bd\",\n  \"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\n  \"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\n  \"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\n  \"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\n  \"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\"\n).map(colors_default);\nvar Spectral_default = ramp_default(scheme9);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js\nvar scheme10 = new Array(3).concat(\n  \"e5f5f999d8c92ca25f\",\n  \"edf8fbb2e2e266c2a4238b45\",\n  \"edf8fbb2e2e266c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"\n).map(colors_default);\nvar BuGn_default = ramp_default(scheme10);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js\nvar scheme11 = new Array(3).concat(\n  \"e0ecf49ebcda8856a7\",\n  \"edf8fbb3cde38c96c688419d\",\n  \"edf8fbb3cde38c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"\n).map(colors_default);\nvar BuPu_default = ramp_default(scheme11);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js\nvar scheme12 = new Array(3).concat(\n  \"e0f3dba8ddb543a2ca\",\n  \"f0f9e8bae4bc7bccc42b8cbe\",\n  \"f0f9e8bae4bc7bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"\n).map(colors_default);\nvar GnBu_default = ramp_default(scheme12);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js\nvar scheme13 = new Array(3).concat(\n  \"fee8c8fdbb84e34a33\",\n  \"fef0d9fdcc8afc8d59d7301f\",\n  \"fef0d9fdcc8afc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"\n).map(colors_default);\nvar OrRd_default = ramp_default(scheme13);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js\nvar scheme14 = new Array(3).concat(\n  \"ece2f0a6bddb1c9099\",\n  \"f6eff7bdc9e167a9cf02818a\",\n  \"f6eff7bdc9e167a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"\n).map(colors_default);\nvar PuBuGn_default = ramp_default(scheme14);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js\nvar scheme15 = new Array(3).concat(\n  \"ece7f2a6bddb2b8cbe\",\n  \"f1eef6bdc9e174a9cf0570b0\",\n  \"f1eef6bdc9e174a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"\n).map(colors_default);\nvar PuBu_default = ramp_default(scheme15);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js\nvar scheme16 = new Array(3).concat(\n  \"e7e1efc994c7dd1c77\",\n  \"f1eef6d7b5d8df65b0ce1256\",\n  \"f1eef6d7b5d8df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"\n).map(colors_default);\nvar PuRd_default = ramp_default(scheme16);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js\nvar scheme17 = new Array(3).concat(\n  \"fde0ddfa9fb5c51b8a\",\n  \"feebe2fbb4b9f768a1ae017e\",\n  \"feebe2fbb4b9f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"\n).map(colors_default);\nvar RdPu_default = ramp_default(scheme17);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js\nvar scheme18 = new Array(3).concat(\n  \"edf8b17fcdbb2c7fb8\",\n  \"ffffcca1dab441b6c4225ea8\",\n  \"ffffcca1dab441b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"\n).map(colors_default);\nvar YlGnBu_default = ramp_default(scheme18);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js\nvar scheme19 = new Array(3).concat(\n  \"f7fcb9addd8e31a354\",\n  \"ffffccc2e69978c679238443\",\n  \"ffffccc2e69978c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"\n).map(colors_default);\nvar YlGn_default = ramp_default(scheme19);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js\nvar scheme20 = new Array(3).concat(\n  \"fff7bcfec44fd95f0e\",\n  \"ffffd4fed98efe9929cc4c02\",\n  \"ffffd4fed98efe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"\n).map(colors_default);\nvar YlOrBr_default = ramp_default(scheme20);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js\nvar scheme21 = new Array(3).concat(\n  \"ffeda0feb24cf03b20\",\n  \"ffffb2fecc5cfd8d3ce31a1c\",\n  \"ffffb2fecc5cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"\n).map(colors_default);\nvar YlOrRd_default = ramp_default(scheme21);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js\nvar scheme22 = new Array(3).concat(\n  \"deebf79ecae13182bd\",\n  \"eff3ffbdd7e76baed62171b5\",\n  \"eff3ffbdd7e76baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"\n).map(colors_default);\nvar Blues_default = ramp_default(scheme22);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js\nvar scheme23 = new Array(3).concat(\n  \"e5f5e0a1d99b31a354\",\n  \"edf8e9bae4b374c476238b45\",\n  \"edf8e9bae4b374c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"\n).map(colors_default);\nvar Greens_default = ramp_default(scheme23);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js\nvar scheme24 = new Array(3).concat(\n  \"f0f0f0bdbdbd636363\",\n  \"f7f7f7cccccc969696525252\",\n  \"f7f7f7cccccc969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"\n).map(colors_default);\nvar Greys_default = ramp_default(scheme24);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js\nvar scheme25 = new Array(3).concat(\n  \"efedf5bcbddc756bb1\",\n  \"f2f0f7cbc9e29e9ac86a51a3\",\n  \"f2f0f7cbc9e29e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"\n).map(colors_default);\nvar Purples_default = ramp_default(scheme25);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js\nvar scheme26 = new Array(3).concat(\n  \"fee0d2fc9272de2d26\",\n  \"fee5d9fcae91fb6a4acb181d\",\n  \"fee5d9fcae91fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"\n).map(colors_default);\nvar Reds_default = ramp_default(scheme26);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js\nvar scheme27 = new Array(3).concat(\n  \"fee6cefdae6be6550d\",\n  \"feeddefdbe85fd8d3cd94701\",\n  \"feeddefdbe85fd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"\n).map(colors_default);\nvar Oranges_default = ramp_default(scheme27);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js\nfunction cividis_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + \", \" + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + \", \" + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js\nvar cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar c3 = cubehelix();\nfunction rainbow_default(t) {\n  if (t < 0 || t > 1)\n    t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c3.h = 360 * t - 100;\n  c3.s = 1.5 - 1.5 * ts;\n  c3.l = 0.8 - 0.9 * ts;\n  return c3 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js\nvar c4 = rgb();\nvar pi_1_3 = Math.PI / 3;\nvar pi_2_3 = Math.PI * 2 / 3;\nfunction sinebow_default(t) {\n  var x4;\n  t = (0.5 - t) * Math.PI;\n  c4.r = 255 * (x4 = Math.sin(t)) * x4;\n  c4.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;\n  c4.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;\n  return c4 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js\nfunction turbo_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + \", \" + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + \", \" + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js\nfunction ramp(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\nvar viridis_default = ramp(colors_default(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\nvar magma = ramp(colors_default(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\nvar inferno = ramp(colors_default(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\nvar plasma = ramp(colors_default(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\n// node_modules/d3-shape/src/constant.js\nfunction constant_default10(x4) {\n  return function constant3() {\n    return x4;\n  };\n}\n\n// node_modules/d3-shape/src/math.js\nvar abs4 = Math.abs;\nvar atan22 = Math.atan2;\nvar cos3 = Math.cos;\nvar max4 = Math.max;\nvar min3 = Math.min;\nvar sin3 = Math.sin;\nvar sqrt3 = Math.sqrt;\nvar epsilon8 = 1e-12;\nvar pi5 = Math.PI;\nvar halfPi4 = pi5 / 2;\nvar tau6 = 2 * pi5;\nfunction acos2(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi5 : Math.acos(x4);\n}\nfunction asin2(x4) {\n  return x4 >= 1 ? halfPi4 : x4 <= -1 ? -halfPi4 : Math.asin(x4);\n}\n\n// node_modules/d3-shape/src/path.js\nfunction withPath(shape) {\n  let digits = 3;\n  shape.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n  return () => new Path(digits);\n}\n\n// node_modules/d3-shape/src/arc.js\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction arcPadAngle(d) {\n  return d && d.padAngle;\n}\nfunction intersect(x06, y06, x12, y12, x22, y22, x32, y32) {\n  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;\n  if (t * t < epsilon8)\n    return;\n  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;\n  return [x06 + t * x10, y06 + t * y10];\n}\nfunction cornerTangents(x06, y06, x12, y12, r1, rc, cw) {\n  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox2 = lo * y01, oy2 = -lo * x01, x11 = x06 + ox2, y11 = y06 + oy2, x10 = x12 + ox2, y10 = y12 + oy2, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)\n    cx0 = cx1, cy0 = cy1;\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox2,\n    y01: -oy2,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\nfunction arc_default() {\n  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);\n  function arc() {\n    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;\n    if (!context)\n      context = buffer = path2();\n    if (r1 < r0)\n      r = r1, r1 = r0, r0 = r;\n    if (!(r1 > epsilon8))\n      context.moveTo(0, 0);\n    else if (da2 > tau6 - epsilon8) {\n      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon8) {\n        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    } else {\n      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;\n      if (rp > epsilon8) {\n        var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));\n        if ((da0 -= p02 * 2) > epsilon8)\n          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;\n        else\n          da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon8)\n          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;\n        else\n          da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);\n      if (rc > epsilon8) {\n        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;\n        if (da2 < pi5) {\n          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {\n            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);\n            rc0 = min3(rc, (r0 - lc) / (kc - 1));\n            rc1 = min3(rc, (r1 - lc) / (kc + 1));\n          } else {\n            rc0 = rc1 = 0;\n          }\n        }\n      }\n      if (!(da1 > epsilon8))\n        context.moveTo(x01, y01);\n      else if (rc1 > epsilon8) {\n        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);\n        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc1 < rc)\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);\n          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n      if (!(r0 > epsilon8) || !(da0 > epsilon8))\n        context.lineTo(x10, y10);\n      else if (rc0 > epsilon8) {\n        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);\n        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc0 < rc)\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);\n          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.arc(0, 0, r0, a10, a00, cw);\n    }\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;\n    return [cos3(a4) * r, sin3(a4) * r];\n  };\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : innerRadius;\n  };\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : outerRadius;\n  };\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : cornerRadius;\n  };\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padRadius;\n  };\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : startAngle;\n  };\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : endAngle;\n  };\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padAngle;\n  };\n  arc.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n  return arc;\n}\n\n// node_modules/d3-shape/src/array.js\nvar slice4 = Array.prototype.slice;\nfunction array_default3(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-shape/src/curve/linear.js\nfunction Linear(context) {\n  this._context = context;\n}\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default:\n        this._context.lineTo(x4, y4);\n        break;\n    }\n  }\n};\nfunction linear_default(context) {\n  return new Linear(context);\n}\n\n// node_modules/d3-shape/src/point.js\nfunction x3(p) {\n  return p[0];\n}\nfunction y3(p) {\n  return p[1];\n}\n\n// node_modules/d3-shape/src/line.js\nfunction line_default2(x4, y4) {\n  var defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);\n  x4 = typeof x4 === \"function\" ? x4 : x4 === void 0 ? x3 : constant_default10(x4);\n  y4 = typeof y4 === \"function\" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);\n  function line2(data) {\n    var i, n = (data = array_default3(data)).length, d, defined0 = false, buffer;\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0)\n          output.lineStart();\n        else\n          output.lineEnd();\n      }\n      if (defined0)\n        output.point(+x4(d, i, data), +y4(d, i, data));\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  line2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : x4;\n  };\n  line2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : y4;\n  };\n  line2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), line2) : defined2;\n  };\n  line2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;\n  };\n  line2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;\n  };\n  return line2;\n}\n\n// node_modules/d3-shape/src/area.js\nfunction area_default5(x06, y06, y12) {\n  var x12 = null, defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);\n  x06 = typeof x06 === \"function\" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);\n  y06 = typeof y06 === \"function\" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);\n  y12 = typeof y12 === \"function\" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);\n  function area2(data) {\n    var i, j, k2, n = (data = array_default3(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k2 = i - 1; k2 >= j; --k2) {\n            output.point(x0z[k2], y0z[k2]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);\n        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);\n      }\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  function arealine() {\n    return line_default2().defined(defined2).curve(curve).context(context);\n  }\n  area2.x = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), x12 = null, area2) : x06;\n  };\n  area2.x0 = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x06;\n  };\n  area2.x1 = function(_) {\n    return arguments.length ? (x12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x12;\n  };\n  area2.y = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), y12 = null, area2) : y06;\n  };\n  area2.y0 = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y06;\n  };\n  area2.y1 = function(_) {\n    return arguments.length ? (y12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y12;\n  };\n  area2.lineX0 = area2.lineY0 = function() {\n    return arealine().x(x06).y(y06);\n  };\n  area2.lineY1 = function() {\n    return arealine().x(x06).y(y12);\n  };\n  area2.lineX1 = function() {\n    return arealine().x(x12).y(y06);\n  };\n  area2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), area2) : defined2;\n  };\n  area2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;\n  };\n  area2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;\n  };\n  return area2;\n}\n\n// node_modules/d3-shape/src/descending.js\nfunction descending_default(a4, b) {\n  return b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-shape/src/identity.js\nfunction identity_default5(d) {\n  return d;\n}\n\n// node_modules/d3-shape/src/pie.js\nfunction pie_default() {\n  var value = identity_default5, sortValues = descending_default, sort3 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);\n  function pie(data) {\n    var i, n = (data = array_default3(data)).length, j, k2, sum5 = 0, index3 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;\n    for (i = 0; i < n; ++i) {\n      if ((v2 = arcs[index3[i] = i] = +value(data[i], i, data)) > 0) {\n        sum5 += v2;\n      }\n    }\n    if (sortValues != null)\n      index3.sort(function(i2, j2) {\n        return sortValues(arcs[i2], arcs[j2]);\n      });\n    else if (sort3 != null)\n      index3.sort(function(i2, j2) {\n        return sort3(data[i2], data[j2]);\n      });\n    for (i = 0, k2 = sum5 ? (da2 - n * pa) / sum5 : 0; i < n; ++i, a0 = a1) {\n      j = index3[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v2,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n    return arcs;\n  }\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : value;\n  };\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort3 = null, pie) : sortValues;\n  };\n  pie.sort = function(_) {\n    return arguments.length ? (sort3 = _, sortValues = null, pie) : sort3;\n  };\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : startAngle;\n  };\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : endAngle;\n  };\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : padAngle;\n  };\n  return pie;\n}\n\n// node_modules/d3-shape/src/curve/radial.js\nvar curveRadialLinear = curveRadial(linear_default);\nfunction Radial(curve) {\n  this._curve = curve;\n}\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a4, r) {\n    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));\n  }\n};\nfunction curveRadial(curve) {\n  function radial2(context) {\n    return new Radial(curve(context));\n  }\n  radial2._curve = curve;\n  return radial2;\n}\n\n// node_modules/d3-shape/src/lineRadial.js\nfunction lineRadial(l) {\n  var c6 = l.curve;\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  l.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return l;\n}\nfunction lineRadial_default() {\n  return lineRadial(line_default2().curve(curveRadialLinear));\n}\n\n// node_modules/d3-shape/src/areaRadial.js\nfunction areaRadial_default() {\n  var a4 = area_default5().curve(curveRadialLinear), c6 = a4.curve, x06 = a4.lineX0, x12 = a4.lineX1, y06 = a4.lineY0, y12 = a4.lineY1;\n  a4.angle = a4.x, delete a4.x;\n  a4.startAngle = a4.x0, delete a4.x0;\n  a4.endAngle = a4.x1, delete a4.x1;\n  a4.radius = a4.y, delete a4.y;\n  a4.innerRadius = a4.y0, delete a4.y0;\n  a4.outerRadius = a4.y1, delete a4.y1;\n  a4.lineStartAngle = function() {\n    return lineRadial(x06());\n  }, delete a4.lineX0;\n  a4.lineEndAngle = function() {\n    return lineRadial(x12());\n  }, delete a4.lineX1;\n  a4.lineInnerRadius = function() {\n    return lineRadial(y06());\n  }, delete a4.lineY0;\n  a4.lineOuterRadius = function() {\n    return lineRadial(y12());\n  }, delete a4.lineY1;\n  a4.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return a4;\n}\n\n// node_modules/d3-shape/src/pointRadial.js\nfunction pointRadial_default(x4, y4) {\n  return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];\n}\n\n// node_modules/d3-shape/src/curve/bump.js\nvar Bump = class {\n  constructor(context, x4) {\n    this._context = context;\n    this._x = x4;\n  }\n  areaStart() {\n    this._line = 0;\n  }\n  areaEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0: {\n        this._point = 1;\n        if (this._line)\n          this._context.lineTo(x4, y4);\n        else\n          this._context.moveTo(x4, y4);\n        break;\n      }\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._x)\n          this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);\n        else\n          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);\n        break;\n      }\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nvar BumpRadial = class {\n  constructor(context) {\n    this._context = context;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point === 0) {\n      this._point = 1;\n    } else {\n      const p02 = pointRadial_default(this._x0, this._y0);\n      const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y4) / 2);\n      const p2 = pointRadial_default(x4, this._y0);\n      const p3 = pointRadial_default(x4, y4);\n      this._context.moveTo(...p02);\n      this._context.bezierCurveTo(...p1, ...p2, ...p3);\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nfunction bumpX(context) {\n  return new Bump(context, true);\n}\nfunction bumpY(context) {\n  return new Bump(context, false);\n}\nfunction bumpRadial(context) {\n  return new BumpRadial(context);\n}\n\n// node_modules/d3-shape/src/link.js\nfunction linkSource(d) {\n  return d.source;\n}\nfunction linkTarget(d) {\n  return d.target;\n}\nfunction link2(curve) {\n  let source = linkSource, target = linkTarget, x4 = x3, y4 = y3, context = null, output = null, path2 = withPath(link4);\n  function link4() {\n    let buffer;\n    const argv = slice4.call(arguments);\n    const s2 = source.apply(this, argv);\n    const t = target.apply(this, argv);\n    if (context == null)\n      output = curve(buffer = path2());\n    output.lineStart();\n    argv[0] = s2, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    argv[0] = t, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    output.lineEnd();\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  link4.source = function(_) {\n    return arguments.length ? (source = _, link4) : source;\n  };\n  link4.target = function(_) {\n    return arguments.length ? (target = _, link4) : target;\n  };\n  link4.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : x4;\n  };\n  link4.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : y4;\n  };\n  link4.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link4) : context;\n  };\n  return link4;\n}\nfunction linkHorizontal() {\n  return link2(bumpX);\n}\nfunction linkVertical() {\n  return link2(bumpY);\n}\nfunction linkRadial() {\n  const l = link2(bumpRadial);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\n// node_modules/d3-shape/src/symbol/asterisk.js\nvar sqrt32 = sqrt3(3);\nvar asterisk_default = {\n  draw(context, size) {\n    const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;\n    const t = r / 2;\n    const u4 = t * sqrt32;\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n    context.moveTo(-u4, -t);\n    context.lineTo(u4, t);\n    context.moveTo(-u4, t);\n    context.lineTo(u4, -t);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/circle.js\nvar circle_default3 = {\n  draw(context, size) {\n    const r = sqrt3(size / pi5);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau6);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/cross.js\nvar cross_default2 = {\n  draw(context, size) {\n    const r = sqrt3(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond.js\nvar tan30 = sqrt3(1 / 3);\nvar tan30_2 = tan30 * 2;\nvar diamond_default = {\n  draw(context, size) {\n    const y4 = sqrt3(size / tan30_2);\n    const x4 = y4 * tan30;\n    context.moveTo(0, -y4);\n    context.lineTo(x4, 0);\n    context.lineTo(0, y4);\n    context.lineTo(-x4, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond2.js\nvar diamond2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.62625;\n    context.moveTo(0, -r);\n    context.lineTo(r, 0);\n    context.lineTo(0, r);\n    context.lineTo(-r, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/plus.js\nvar plus_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;\n    context.moveTo(-r, 0);\n    context.lineTo(r, 0);\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square.js\nvar square_default = {\n  draw(context, size) {\n    const w = sqrt3(size);\n    const x4 = -w / 2;\n    context.rect(x4, x4, w, w);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square2.js\nvar square2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.4431;\n    context.moveTo(r, r);\n    context.lineTo(r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/star.js\nvar ka = 0.8908130915292852;\nvar kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);\nvar kx = sin3(tau6 / 10) * kr;\nvar ky = -cos3(tau6 / 10) * kr;\nvar star_default = {\n  draw(context, size) {\n    const r = sqrt3(size * ka);\n    const x4 = kx * r;\n    const y4 = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x4, y4);\n    for (let i = 1; i < 5; ++i) {\n      const a4 = tau6 * i / 5;\n      const c6 = cos3(a4);\n      const s2 = sin3(a4);\n      context.lineTo(s2 * r, -c6 * r);\n      context.lineTo(c6 * x4 - s2 * y4, s2 * x4 + c6 * y4);\n    }\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle.js\nvar sqrt33 = sqrt3(3);\nvar triangle_default = {\n  draw(context, size) {\n    const y4 = -sqrt3(size / (sqrt33 * 3));\n    context.moveTo(0, y4 * 2);\n    context.lineTo(-sqrt33 * y4, -y4);\n    context.lineTo(sqrt33 * y4, -y4);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle2.js\nvar sqrt34 = sqrt3(3);\nvar triangle2_default = {\n  draw(context, size) {\n    const s2 = sqrt3(size) * 0.6824;\n    const t = s2 / 2;\n    const u4 = s2 * sqrt34 / 2;\n    context.moveTo(0, -s2);\n    context.lineTo(u4, t);\n    context.lineTo(-u4, t);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/wye.js\nvar c5 = -0.5;\nvar s = sqrt3(3) / 2;\nvar k = 1 / sqrt3(12);\nvar a3 = (k / 2 + 1) * 3;\nvar wye_default = {\n  draw(context, size) {\n    const r = sqrt3(size / a3);\n    const x06 = r / 2, y06 = r * k;\n    const x12 = x06, y12 = r * k + r;\n    const x22 = -x12, y22 = y12;\n    context.moveTo(x06, y06);\n    context.lineTo(x12, y12);\n    context.lineTo(x22, y22);\n    context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);\n    context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);\n    context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);\n    context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);\n    context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);\n    context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/times.js\nvar times_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;\n    context.moveTo(-r, -r);\n    context.lineTo(r, r);\n    context.moveTo(-r, r);\n    context.lineTo(r, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol.js\nvar symbolsFill = [\n  circle_default3,\n  cross_default2,\n  diamond_default,\n  square_default,\n  star_default,\n  triangle_default,\n  wye_default\n];\nvar symbolsStroke = [\n  circle_default3,\n  plus_default,\n  times_default,\n  triangle2_default,\n  asterisk_default,\n  square2_default,\n  diamond2_default\n];\nfunction Symbol2(type2, size) {\n  let context = null, path2 = withPath(symbol2);\n  type2 = typeof type2 === \"function\" ? type2 : constant_default10(type2 || circle_default3);\n  size = typeof size === \"function\" ? size : constant_default10(size === void 0 ? 64 : +size);\n  function symbol2() {\n    let buffer;\n    if (!context)\n      context = buffer = path2();\n    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  symbol2.type = function(_) {\n    return arguments.length ? (type2 = typeof _ === \"function\" ? _ : constant_default10(_), symbol2) : type2;\n  };\n  symbol2.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant_default10(+_), symbol2) : size;\n  };\n  symbol2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol2) : context;\n  };\n  return symbol2;\n}\n\n// node_modules/d3-shape/src/noop.js\nfunction noop_default2() {\n}\n\n// node_modules/d3-shape/src/curve/basis.js\nfunction point2(that, x4, y4) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x4) / 6,\n    (that._y0 + 4 * that._y1 + y4) / 6\n  );\n}\nfunction Basis(context) {\n  this._context = context;\n}\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3:\n        point2(this, this._x1, this._y1);\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basis_default2(context) {\n  return new Basis(context);\n}\n\n// node_modules/d3-shape/src/curve/basisClosed.js\nfunction BasisClosed(context) {\n  this._context = context;\n}\nBasisClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x2 = x4, this._y2 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 2:\n        this._point = 3;\n        this._x4 = x4, this._y4 = y4;\n        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);\n        break;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisClosed_default2(context) {\n  return new BasisClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/basisOpen.js\nfunction BasisOpen(context) {\n  this._context = context;\n}\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;\n        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisOpen_default(context) {\n  return new BasisOpen(context);\n}\n\n// node_modules/d3-shape/src/curve/bundle.js\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, j = x4.length - 1;\n    if (j > 0) {\n      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),\n          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)\n        );\n      }\n    }\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nvar bundle_default = function custom12(beta) {\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n  bundle.beta = function(beta2) {\n    return custom12(+beta2);\n  };\n  return bundle;\n}(0.85);\n\n// node_modules/d3-shape/src/curve/cardinal.js\nfunction point3(that, x4, y4) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x4),\n    that._y2 + that._k * (that._y1 - y4),\n    that._x2,\n    that._y2\n  );\n}\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        point3(this, this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        this._x1 = x4, this._y1 = y4;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinal_default = function custom13(tension) {\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom13(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalClosed.js\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalClosed_default = function custom14(tension) {\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom14(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalOpen.js\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalOpen_default = function custom15(tension) {\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom15(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/catmullRom.js\nfunction point4(that, x4, y4) {\n  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;\n  if (that._l01_a > epsilon8) {\n    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n  if (that._l23_a > epsilon8) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;\n    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;\n  }\n  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);\n}\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        this.point(this._x2, this._y2);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRom_default = function custom16(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom16(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomClosed.js\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomClosed_default = function custom17(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom17(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomOpen.js\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomOpen_default = function custom18(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom18(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/linearClosed.js\nfunction LinearClosed(context) {\n  this._context = context;\n}\nLinearClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point)\n      this._context.closePath();\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point)\n      this._context.lineTo(x4, y4);\n    else\n      this._point = 1, this._context.moveTo(x4, y4);\n  }\n};\nfunction linearClosed_default(context) {\n  return new LinearClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/monotone.js\nfunction sign2(x4) {\n  return x4 < 0 ? -1 : 1;\n}\nfunction slope3(that, x22, y22) {\n  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\nfunction point5(that, t03, t13) {\n  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;\n  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);\n}\nfunction MonotoneX(context) {\n  this._context = context;\n}\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n      case 3:\n        point5(this, this._t0, slope2(this, this._t0));\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    var t13 = NaN;\n    x4 = +x4, y4 = +y4;\n    if (x4 === this._x1 && y4 === this._y1)\n      return;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);\n        break;\n      default:\n        point5(this, this._t0, t13 = slope3(this, x4, y4));\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n    this._t0 = t13;\n  }\n};\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {\n  MonotoneX.prototype.point.call(this, y4, x4);\n};\nfunction ReflectContext(context) {\n  this._context = context;\n}\nReflectContext.prototype = {\n  moveTo: function(x4, y4) {\n    this._context.moveTo(y4, x4);\n  },\n  closePath: function() {\n    this._context.closePath();\n  },\n  lineTo: function(x4, y4) {\n    this._context.lineTo(y4, x4);\n  },\n  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {\n    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);\n  }\n};\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\n// node_modules/d3-shape/src/curve/natural.js\nfunction Natural(context) {\n  this._context = context;\n}\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, n = x4.length;\n    if (n) {\n      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);\n      if (n === 2) {\n        this._context.lineTo(x4[1], y4[1]);\n      } else {\n        var px = controlPoints(x4), py = controlPoints(y4);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);\n        }\n      }\n    }\n    if (this._line || this._line !== 0 && n === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nfunction controlPoints(x4) {\n  var i, n = x4.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);\n  a4[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];\n  for (i = 1; i < n - 1; ++i)\n    a4[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];\n  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];\n  for (i = 1; i < n; ++i)\n    m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];\n  a4[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i)\n    a4[i] = (r[i] - a4[i + 1]) / b[i];\n  b[n - 1] = (x4[n] + a4[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i)\n    b[i] = 2 * x4[i + 1] - a4[i + 1];\n  return [a4, b];\n}\nfunction natural_default(context) {\n  return new Natural(context);\n}\n\n// node_modules/d3-shape/src/curve/step.js\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2)\n      this._context.lineTo(this._x, this._y);\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    if (this._line >= 0)\n      this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y4);\n          this._context.lineTo(x4, y4);\n        } else {\n          var x12 = this._x * (1 - this._t) + x4 * this._t;\n          this._context.lineTo(x12, this._y);\n          this._context.lineTo(x12, y4);\n        }\n        break;\n      }\n    }\n    this._x = x4, this._y = y4;\n  }\n};\nfunction step_default(context) {\n  return new Step(context, 0.5);\n}\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\n// node_modules/d3-shape/src/offset/none.js\nfunction none_default(series, order) {\n  if (!((n = series.length) > 1))\n    return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m3; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n\n// node_modules/d3-shape/src/order/none.js\nfunction none_default2(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0)\n    o[n] = n;\n  return o;\n}\n\n// node_modules/d3-shape/src/stack.js\nfunction stackValue(d, key) {\n  return d[key];\n}\nfunction stackSeries(key) {\n  const series = [];\n  series.key = key;\n  return series;\n}\nfunction stack_default() {\n  var keys = constant_default10([]), order = none_default2, offset2 = none_default, value = stackValue;\n  function stack2(data) {\n    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;\n    for (const d of data) {\n      for (i = 0, ++j; i < n; ++i) {\n        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;\n      }\n    }\n    for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n    offset2(sz, oz);\n    return sz;\n  }\n  stack2.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : keys;\n  };\n  stack2.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), stack2) : value;\n  };\n  stack2.order = function(_) {\n    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : order;\n  };\n  stack2.offset = function(_) {\n    return arguments.length ? (offset2 = _ == null ? none_default : _, stack2) : offset2;\n  };\n  return stack2;\n}\n\n// node_modules/d3-shape/src/offset/expand.js\nfunction expand_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {\n    for (y4 = i = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    if (y4)\n      for (i = 0; i < n; ++i)\n        series[i][j][1] /= y4;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/diverging.js\nfunction diverging_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = 0, d[1] = dy;\n      }\n    }\n  }\n}\n\n// node_modules/d3-shape/src/offset/silhouette.js\nfunction silhouette_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var j = 0, s0 = series[order[0]], n, m3 = s0.length; j < m3; ++j) {\n    for (var i = 0, y4 = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y4 / 2;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/wiggle.js\nfunction wiggle_default(series, order) {\n  if (!((n = series.length) > 0) || !((m3 = (s0 = series[order[0]]).length) > 0))\n    return;\n  for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;\n      for (var k2 = 0; k2 < i; ++k2) {\n        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y4;\n    if (s1)\n      y4 -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y4;\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/order/appearance.js\nfunction appearance_default(series) {\n  var peaks = series.map(peak);\n  return none_default2(series).sort(function(a4, b) {\n    return peaks[a4] - peaks[b];\n  });\n}\nfunction peak(series) {\n  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n  while (++i < n)\n    if ((vi = +series[i][1]) > vj)\n      vj = vi, j = i;\n  return j;\n}\n\n// node_modules/d3-shape/src/order/ascending.js\nfunction ascending_default2(series) {\n  var sums = series.map(sum3);\n  return none_default2(series).sort(function(a4, b) {\n    return sums[a4] - sums[b];\n  });\n}\nfunction sum3(series) {\n  var s2 = 0, i = -1, n = series.length, v2;\n  while (++i < n)\n    if (v2 = +series[i][1])\n      s2 += v2;\n  return s2;\n}\n\n// node_modules/d3-shape/src/order/descending.js\nfunction descending_default2(series) {\n  return ascending_default2(series).reverse();\n}\n\n// node_modules/d3-shape/src/order/insideOut.js\nfunction insideOut_default(series) {\n  var n = series.length, i, j, sums = series.map(sum3), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top2 < bottom2) {\n      top2 += sums[j];\n      tops.push(j);\n    } else {\n      bottom2 += sums[j];\n      bottoms.push(j);\n    }\n  }\n  return bottoms.reverse().concat(tops);\n}\n\n// node_modules/d3-shape/src/order/reverse.js\nfunction reverse_default(series) {\n  return none_default2(series).reverse();\n}\n\n// node_modules/d3-zoom/src/constant.js\nvar constant_default11 = (x4) => () => x4;\n\n// node_modules/d3-zoom/src/event.js\nfunction ZoomEvent(type2, {\n  sourceEvent,\n  target,\n  transform: transform2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    transform: { value: transform2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-zoom/src/transform.js\nfunction Transform(k2, x4, y4) {\n  this.k = k2;\n  this.x = x4;\n  this.y = y4;\n}\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k2) {\n    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);\n  },\n  translate: function(x4, y4) {\n    return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);\n  },\n  apply: function(point6) {\n    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];\n  },\n  applyX: function(x4) {\n    return x4 * this.k + this.x;\n  },\n  applyY: function(y4) {\n    return y4 * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x4) {\n    return (x4 - this.x) / this.k;\n  },\n  invertY: function(y4) {\n    return (y4 - this.y) / this.k;\n  },\n  rescaleX: function(x4) {\n    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));\n  },\n  rescaleY: function(y4) {\n    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\nvar identity5 = new Transform(1, 0, 0);\ntransform.prototype = Transform.prototype;\nfunction transform(node) {\n  while (!node.__zoom)\n    if (!(node = node.parentNode))\n      return identity5;\n  return node.__zoom;\n}\n\n// node_modules/d3-zoom/src/noevent.js\nfunction nopropagation3(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default3(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-zoom/src/zoom.js\nfunction defaultFilter3(event) {\n  return (!event.ctrlKey || event.type === \"wheel\") && !event.button;\n}\nfunction defaultExtent2() {\n  var e = this;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    if (e.hasAttribute(\"viewBox\")) {\n      e = e.viewBox.baseVal;\n      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];\n    }\n    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];\n  }\n  return [[0, 0], [e.clientWidth, e.clientHeight]];\n}\nfunction defaultTransform() {\n  return this.__zoom || identity5;\n}\nfunction defaultWheelDelta(event) {\n  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);\n}\nfunction defaultTouchable3() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction defaultConstrain(transform2, extent3, translateExtent) {\n  var dx0 = transform2.invertX(extent3[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent3[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent3[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent3[1][1]) - translateExtent[1][1];\n  return transform2.translate(\n    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n  );\n}\nfunction zoom_default2() {\n  var filter4 = defaultFilter3, extent3 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default(\"start\", \"zoom\", \"end\"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;\n  function zoom(selection2) {\n    selection2.property(\"__zoom\", defaultTransform).on(\"wheel.zoom\", wheeled, { passive: false }).on(\"mousedown.zoom\", mousedowned).on(\"dblclick.zoom\", dblclicked).filter(touchable).on(\"touchstart.zoom\", touchstarted).on(\"touchmove.zoom\", touchmoved).on(\"touchend.zoom touchcancel.zoom\", touchended).style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  zoom.transform = function(collection, transform2, point6, event) {\n    var selection2 = collection.selection ? collection.selection() : collection;\n    selection2.property(\"__zoom\", defaultTransform);\n    if (collection !== selection2) {\n      schedule(collection, transform2, point6, event);\n    } else {\n      selection2.interrupt().each(function() {\n        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === \"function\" ? transform2.apply(this, arguments) : transform2).end();\n      });\n    }\n  };\n  zoom.scaleBy = function(selection2, k2, p, event) {\n    zoom.scaleTo(selection2, function() {\n      var k0 = this.__zoom.k, k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return k0 * k1;\n    }, p, event);\n  };\n  zoom.scaleTo = function(selection2, k2, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return constrain(translate(scale3(t03, k1), p02, p1), e, translateExtent);\n    }, p, event);\n  };\n  zoom.translateBy = function(selection2, x4, y4, event) {\n    zoom.transform(selection2, function() {\n      return constrain(this.__zoom.translate(\n        typeof x4 === \"function\" ? x4.apply(this, arguments) : x4,\n        typeof y4 === \"function\" ? y4.apply(this, arguments) : y4\n      ), extent3.apply(this, arguments), translateExtent);\n    }, null, event);\n  };\n  zoom.translateTo = function(selection2, x4, y4, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p;\n      return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(\n        typeof x4 === \"function\" ? -x4.apply(this, arguments) : -x4,\n        typeof y4 === \"function\" ? -y4.apply(this, arguments) : -y4\n      ), e, translateExtent);\n    }, p, event);\n  };\n  function scale3(transform2, k2) {\n    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));\n    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);\n  }\n  function translate(transform2, p02, p1) {\n    var x4 = p02[0] - p1[0] * transform2.k, y4 = p02[1] - p1[1] * transform2.k;\n    return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);\n  }\n  function centroid2(extent4) {\n    return [(+extent4[0][0] + +extent4[1][0]) / 2, (+extent4[0][1] + +extent4[1][1]) / 2];\n  }\n  function schedule(transition2, transform2, point6, event) {\n    transition2.on(\"start.zoom\", function() {\n      gesture(this, arguments).event(event).start();\n    }).on(\"interrupt.zoom end.zoom\", function() {\n      gesture(this, arguments).event(event).end();\n    }).tween(\"zoom\", function() {\n      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent3.apply(that, args), p = point6 == null ? centroid2(e) : typeof point6 === \"function\" ? point6.apply(that, args) : point6, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a4 = that.__zoom, b = typeof transform2 === \"function\" ? transform2.apply(that, args) : transform2, i = interpolate(a4.invert(p).concat(w / a4.k), b.invert(p).concat(w / b.k));\n      return function(t) {\n        if (t === 1)\n          t = b;\n        else {\n          var l = i(t), k2 = w / l[2];\n          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);\n        }\n        g.zoom(null, t);\n      };\n    });\n  }\n  function gesture(that, args, clean) {\n    return !clean && that.__zooming || new Gesture(that, args);\n  }\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.active = 0;\n    this.sourceEvent = null;\n    this.extent = extent3.apply(that, args);\n    this.taps = 0;\n  }\n  Gesture.prototype = {\n    event: function(event) {\n      if (event)\n        this.sourceEvent = event;\n      return this;\n    },\n    start: function() {\n      if (++this.active === 1) {\n        this.that.__zooming = this;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform2) {\n      if (this.mouse && key !== \"mouse\")\n        this.mouse[1] = transform2.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\")\n        this.touch0[1] = transform2.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\")\n        this.touch1[1] = transform2.invert(this.touch1[0]);\n      this.that.__zoom = transform2;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        delete this.that.__zooming;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new ZoomEvent(type2, {\n          sourceEvent: this.sourceEvent,\n          target: zoom,\n          type: type2,\n          transform: this.that.__zoom,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function wheeled(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    } else if (t.k === k2)\n      return;\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt_default(this);\n      g.start();\n    }\n    noevent_default3(event);\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale3(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n  function mousedowned(event, ...args) {\n    if (touchending || !filter4.apply(this, arguments))\n      return;\n    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true), p = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;\n    nodrag_default(event.view);\n    nopropagation3(event);\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt_default(this);\n    g.start();\n    function mousemoved(event2) {\n      noevent_default3(event2);\n      if (!g.moved) {\n        var dx = event2.clientX - x06, dy = event2.clientY - y06;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.event(event2).zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));\n    }\n    function mouseupped(event2) {\n      v2.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(event2.view, g.moved);\n      noevent_default3(event2);\n      g.event(event2).end();\n    }\n  }\n  function dblclicked(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var t03 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p02), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale3(t03, k1), p02, p1), extent3.apply(this, args), translateExtent);\n    noevent_default3(event);\n    if (duration > 0)\n      select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);\n    else\n      select_default2(this).call(zoom.transform, t13, p02, event);\n  }\n  function touchstarted(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;\n    nopropagation3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0)\n        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;\n      else if (!g.touch1 && g.touch0[2] !== p[2])\n        g.touch1 = p, g.taps = 0;\n    }\n    if (touchstarting)\n      touchstarting = clearTimeout(touchstarting);\n    if (started) {\n      if (g.taps < 2)\n        touchfirst = p[0], touchstarting = setTimeout(function() {\n          touchstarting = null;\n        }, touchDelay);\n      interrupt_default(this);\n      g.start();\n    }\n  }\n  function touchmoved(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;\n    noevent_default3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale3(t, Math.sqrt(dp / dl));\n      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    } else if (g.touch0)\n      p = g.touch0[0], l = g.touch0[1];\n    else\n      return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\n  }\n  function touchended(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;\n    nopropagation3(event);\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches[i];\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0)\n      g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0)\n      g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else {\n      g.end();\n      if (g.taps === 2) {\n        t = pointer_default(t, this);\n        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {\n          var p = select_default2(this).on(\"dblclick.zoom\");\n          if (p)\n            p.apply(this, arguments);\n        }\n      }\n    }\n  }\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant_default11(+_), zoom) : wheelDelta;\n  };\n  zoom.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : filter4;\n  };\n  zoom.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : touchable;\n  };\n  zoom.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent3;\n  };\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\n  };\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\n  };\n  zoom.constrain = function(_) {\n    return arguments.length ? (constrain = _, zoom) : constrain;\n  };\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n  zoom.tapDistance = function(_) {\n    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;\n  };\n  return zoom;\n}\n\n// node_modules/isoformat/src/format.js\nfunction format2(date2, fallback) {\n  if (!(date2 instanceof Date))\n    date2 = /* @__PURE__ */ new Date(+date2);\n  if (isNaN(date2))\n    return typeof fallback === \"function\" ? fallback(date2) : fallback;\n  const hours = date2.getUTCHours();\n  const minutes = date2.getUTCMinutes();\n  const seconds2 = date2.getUTCSeconds();\n  const milliseconds2 = date2.getUTCMilliseconds();\n  return `${formatYear3(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;\n}\nfunction formatYear3(year) {\n  return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);\n}\nfunction pad3(value, width) {\n  return `${value}`.padStart(width, \"0\");\n}\n\n// node_modules/isoformat/src/parse.js\nvar re2 = /^(?:[-+]\\d{2})?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{3})?)?(?:Z|[-+]\\d{2}:?\\d{2})?)?$/;\nfunction parse(string2, fallback) {\n  if (!re2.test(string2 += \"\"))\n    return typeof fallback === \"function\" ? fallback(string2) : fallback;\n  return new Date(string2);\n}\n\n// node_modules/@observablehq/plot/dist/time.js\nvar timeIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", timeMinute],\n  [\"hour\", timeHour],\n  [\"day\", timeDay],\n  [\"week\", timeSunday],\n  [\"month\", timeMonth],\n  [\"year\", timeYear],\n  [\"monday\", timeMonday],\n  [\"tuesday\", timeTuesday],\n  [\"wednesday\", timeWednesday],\n  [\"thursday\", timeThursday],\n  [\"friday\", timeFriday],\n  [\"saturday\", timeSaturday],\n  [\"sunday\", timeSunday]\n]);\nvar utcIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", utcMinute],\n  [\"hour\", utcHour],\n  [\"day\", utcDay],\n  [\"week\", utcSunday],\n  [\"month\", utcMonth],\n  [\"year\", utcYear],\n  [\"monday\", utcMonday],\n  [\"tuesday\", utcTuesday],\n  [\"wednesday\", utcWednesday],\n  [\"thursday\", utcThursday],\n  [\"friday\", utcFriday],\n  [\"saturday\", utcSaturday],\n  [\"sunday\", utcSunday]\n]);\nfunction maybeTimeInterval(interval2) {\n  const i = timeIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\nfunction maybeUtcInterval(interval2) {\n  const i = utcIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\n\n// node_modules/@observablehq/plot/dist/options.js\nvar TypedArray = Object.getPrototypeOf(Uint8Array);\nvar objectToString = Object.prototype.toString;\nfunction valueof(data, value, type2) {\n  const valueType = typeof value;\n  return valueType === \"string\" ? map4(data, field(value), type2) : valueType === \"function\" ? map4(data, value, type2) : valueType === \"number\" || value instanceof Date || valueType === \"boolean\" ? map4(data, constant2(value), type2) : value && typeof value.transform === \"function\" ? arrayify2(value.transform(data), type2) : arrayify2(value, type2);\n}\nvar field = (name) => (d) => d[name];\nvar indexOf = (d, i) => i;\nvar identity6 = { transform: (d) => d };\nvar one2 = () => 1;\nvar yes = () => true;\nvar string = (x4) => x4 == null ? x4 : `${x4}`;\nvar number5 = (x4) => x4 == null ? x4 : +x4;\nvar first = (x4) => x4 ? x4[0] : void 0;\nvar second2 = (x4) => x4 ? x4[1] : void 0;\nvar third = (x4) => x4 ? x4[2] : void 0;\nvar constant2 = (x4) => () => x4;\nfunction percentile(reduce2) {\n  const p = +`${reduce2}`.slice(1) / 100;\n  return (I, f) => quantile(I, p, f);\n}\nfunction maybeColorChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null ? [void 0, \"none\"] : isColor(value) ? [void 0, value] : [value, void 0];\n}\nfunction maybeNumberChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null || typeof value === \"number\" ? [void 0, value] : [value, void 0];\n}\nfunction maybeKeyword(input, name, allowed) {\n  if (input != null)\n    return keyword(input, name, allowed);\n}\nfunction keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i))\n    throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\nfunction arrayify2(data, type2) {\n  return data == null ? data : type2 === void 0 ? data instanceof Array || data instanceof TypedArray ? data : Array.from(data) : data instanceof type2 ? data : type2.from(data);\n}\nfunction map4(values2, f, type2 = Array) {\n  return values2 instanceof type2 ? values2.map(f) : type2.from(values2, f);\n}\nfunction slice5(values2, type2 = Array) {\n  return values2 instanceof type2 ? values2.slice() : type2.from(values2);\n}\nfunction isTypedArray(values2) {\n  return values2 instanceof TypedArray;\n}\nfunction isObject(option) {\n  return option?.toString === objectToString;\n}\nfunction isScaleOptions(option) {\n  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);\n}\nfunction isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\nfunction isDomainSort(sort3) {\n  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;\n}\nfunction maybeZero(x4, x12, x22, x32 = identity6) {\n  if (x12 === void 0 && x22 === void 0) {\n    x12 = 0, x22 = x4 === void 0 ? x32 : x4;\n  } else if (x12 === void 0) {\n    x12 = x4 === void 0 ? 0 : x4;\n  } else if (x22 === void 0) {\n    x22 = x4 === void 0 ? 0 : x4;\n  }\n  return [x12, x22];\n}\nfunction maybeTuple(x4, y4) {\n  return x4 === void 0 && y4 === void 0 ? [first, second2] : [x4, y4];\n}\nfunction maybeZ({ z, fill, stroke } = {}) {\n  if (z === void 0)\n    [z] = maybeColorChannel(fill);\n  if (z === void 0)\n    [z] = maybeColorChannel(stroke);\n  return z;\n}\nfunction range4(data) {\n  const n = data.length;\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i)\n    r[i] = i;\n  return r;\n}\nfunction take(values2, index3) {\n  return map4(index3, (i) => values2[i]);\n}\nfunction keyof2(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\nfunction maybeInput(key, options) {\n  if (options[key] !== void 0)\n    return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\nfunction column(source) {\n  let value;\n  return [\n    {\n      transform: () => value,\n      label: labelof(source)\n    },\n    (v2) => value = v2\n  ];\n}\nfunction maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\nfunction labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== void 0 ? value.label : defaultValue;\n}\nfunction mid(x12, x22) {\n  return {\n    transform(data) {\n      const X13 = x12.transform(data);\n      const X23 = x22.transform(data);\n      return isTemporal(X13) || isTemporal(X23) ? map4(X13, (_, i) => new Date((+X13[i] + +X23[i]) / 2)) : map4(X13, (_, i) => (+X13[i] + +X23[i]) / 2, Float64Array);\n    },\n    label: x12.label\n  };\n}\nfunction maybeInterval(interval2, type2) {\n  if (interval2 == null)\n    return;\n  if (typeof interval2 === \"number\") {\n    const n = interval2;\n    return {\n      floor: (d) => n * Math.floor(d / n),\n      offset: (d) => d + n,\n      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x4) => n * x4)\n    };\n  }\n  if (typeof interval2 === \"string\")\n    return (type2 === \"time\" ? maybeTimeInterval : maybeUtcInterval)(interval2);\n  if (typeof interval2.floor !== \"function\")\n    throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval2.offset !== \"function\")\n    throw new Error(\"invalid interval; missing offset method\");\n  return interval2;\n}\nfunction maybeValue(value) {\n  return value === void 0 || isOptions(value) ? value : { value };\n}\nfunction numberChannel(source) {\n  return source == null ? null : {\n    transform: (data) => valueof(data, source, Float64Array),\n    label: labelof(source)\n  };\n}\nfunction isTuples(data) {\n  if (!isIterable(data))\n    return false;\n  for (const d of data) {\n    if (d == null)\n      continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\nfunction isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\nfunction isTextual(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\nfunction isOrdinal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    const type2 = typeof value;\n    return type2 === \"string\" || type2 === \"boolean\";\n  }\n}\nfunction isTemporal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return value instanceof Date;\n  }\n}\nfunction isTemporalString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"string\" && isNaN(value) && parse(value);\n  }\n}\nfunction isNumericString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (typeof value !== \"string\")\n      return false;\n    if (!value.trim())\n      continue;\n    return !isNaN(value);\n  }\n}\nfunction isNumeric(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"number\";\n  }\n}\nfunction isEvery(values2, is) {\n  let every2;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (!is(value))\n      return false;\n    every2 = true;\n  }\n  return every2;\n}\nfunction isColor(value) {\n  if (typeof value !== \"string\")\n    return false;\n  value = value.toLowerCase().trim();\n  return value === \"none\" || value === \"currentcolor\" || value.startsWith(\"url(\") && value.endsWith(\")\") || // <funciri>, e.g. pattern or gradient\n  value.startsWith(\"var(\") && value.endsWith(\")\") || // CSS variable\n  color(value) !== null;\n}\nfunction isNoneish(value) {\n  return value == null || isNone(value);\n}\nfunction isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\nfunction isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\nfunction maybeFrameAnchor(value = \"middle\") {\n  return keyword(value, \"frameAnchor\", [\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\"\n  ]);\n}\nfunction orderof(values2) {\n  if (values2 == null)\n    return;\n  const first2 = values2[0];\n  const last = values2[values2.length - 1];\n  return descending(first2, last);\n}\nfunction inherit2(options = {}, ...rest) {\n  let o = options;\n  for (const defaults21 of rest) {\n    for (const key in defaults21) {\n      if (o[key] === void 0) {\n        const value = defaults21[key];\n        if (o === options)\n          o = { ...o, [key]: value };\n        else\n          o[key] = value;\n      }\n    }\n  }\n  return o;\n}\nfunction Named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = /* @__PURE__ */ new Set();\n  return Object.fromEntries(Array.from(things, (thing) => {\n    const { name } = thing;\n    if (name == null)\n      throw new Error(\"missing name\");\n    const key = `${name}`;\n    if (key === \"__proto__\")\n      throw new Error(`illegal name: ${key}`);\n    if (names.has(key))\n      throw new Error(`duplicate name: ${key}`);\n    names.add(key);\n    return [name, thing];\n  }));\n}\nfunction maybeNamed(things) {\n  return isIterable(things) ? Named(things) : things;\n}\n\n// node_modules/@observablehq/plot/dist/scales/index.js\nvar position = Symbol(\"position\");\nvar color2 = Symbol(\"color\");\nvar radius = Symbol(\"radius\");\nvar length3 = Symbol(\"length\");\nvar opacity = Symbol(\"opacity\");\nvar symbol = Symbol(\"symbol\");\nvar registry = /* @__PURE__ */ new Map([\n  [\"x\", position],\n  [\"y\", position],\n  [\"fx\", position],\n  [\"fy\", position],\n  [\"r\", radius],\n  [\"color\", color2],\n  [\"opacity\", opacity],\n  [\"symbol\", symbol],\n  [\"length\", length3]\n]);\n\n// node_modules/@observablehq/plot/dist/symbols.js\nvar sqrt35 = Math.sqrt(3);\nvar sqrt4_3 = 2 / sqrt35;\nvar symbolHexagon = {\n  draw(context, size) {\n    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;\n    context.moveTo(0, ry);\n    context.lineTo(rx, hy);\n    context.lineTo(rx, -hy);\n    context.lineTo(0, -ry);\n    context.lineTo(-rx, -hy);\n    context.lineTo(-rx, hy);\n    context.closePath();\n  }\n};\nvar symbols = /* @__PURE__ */ new Map([\n  [\"asterisk\", asterisk_default],\n  [\"circle\", circle_default3],\n  [\"cross\", cross_default2],\n  [\"diamond\", diamond_default],\n  [\"diamond2\", diamond2_default],\n  [\"hexagon\", symbolHexagon],\n  [\"plus\", plus_default],\n  [\"square\", square_default],\n  [\"square2\", square2_default],\n  [\"star\", star_default],\n  [\"times\", times_default],\n  [\"triangle\", triangle_default],\n  [\"triangle2\", triangle2_default],\n  [\"wye\", wye_default]\n]);\nfunction isSymbolObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction isSymbol(value) {\n  if (isSymbolObject(value))\n    return true;\n  if (typeof value !== \"string\")\n    return false;\n  return symbols.has(value.toLowerCase());\n}\nfunction maybeSymbol(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return symbol2;\n  const value = symbols.get(`${symbol2}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid symbol: ${symbol2}`);\n}\nfunction maybeSymbolChannel(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return [void 0, symbol2];\n  if (typeof symbol2 === \"string\") {\n    const value = symbols.get(`${symbol2}`.toLowerCase());\n    if (value)\n      return [void 0, value];\n  }\n  return [symbol2, void 0];\n}\n\n// node_modules/@observablehq/plot/dist/defined.js\nfunction defined(x4) {\n  return x4 != null && !Number.isNaN(x4);\n}\nfunction ascendingDefined2(a4, b) {\n  return +defined(b) - +defined(a4) || ascending(a4, b);\n}\nfunction descendingDefined(a4, b) {\n  return +defined(b) - +defined(a4) || descending(a4, b);\n}\nfunction nonempty(x4) {\n  return x4 != null && `${x4}` !== \"\";\n}\nfunction finite2(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction positive(x4) {\n  return x4 > 0 && isFinite(x4) ? x4 : NaN;\n}\nfunction negative(x4) {\n  return x4 < 0 && isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/basic.js\nfunction basic(options = {}, transform2) {\n  let { filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...remainingOptions } = options;\n  if (t13 === void 0) {\n    if (f1 != null)\n      t13 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      t13 = composeTransform(t13, sortTransform(s1));\n    if (r1)\n      t13 = composeTransform(t13, reverseTransform);\n  }\n  if (transform2 != null && i1 != null)\n    throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    transform: composeTransform(t13, transform2)\n  };\n}\nfunction initializer(options = {}, initializer2) {\n  let { filter: f1, sort: s1, reverse: r1, initializer: i1, ...remainingOptions } = options;\n  if (i1 === void 0) {\n    if (f1 != null)\n      i1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1)\n      i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    initializer: composeInitializer(i1, initializer2)\n  };\n}\nfunction composeTransform(t13, t22) {\n  if (t13 == null)\n    return t22 === null ? void 0 : t22;\n  if (t22 == null)\n    return t13 === null ? void 0 : t13;\n  return function(data, facets) {\n    ({ data, facets } = t13.call(this, data, facets));\n    return t22.call(this, arrayify2(data), facets);\n  };\n}\nfunction composeInitializer(i1, i2) {\n  if (i1 == null)\n    return i2 === null ? void 0 : i2;\n  if (i2 == null)\n    return i1 === null ? void 0 : i1;\n  return function(data, facets, channels, ...args) {\n    let c1, d1, f1, c22, d2, f2;\n    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));\n    ({ data: d2 = d1, facets: f2 = f1, channels: c22 } = i2.call(this, d1, f1, { ...channels, ...c1 }, ...args));\n    return { data: d2, facets: f2, channels: { ...c1, ...c22 } };\n  };\n}\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\nfunction filter3(test, options) {\n  return apply(options, filterTransform(test));\n}\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = valueof(data, value);\n    return { data, facets: facets.map((I) => I.filter((i) => V[i])) };\n  };\n}\nfunction reverse2(options) {\n  return { ...apply(options, reverseTransform), sort: null };\n}\nfunction reverseTransform(data, facets) {\n  return { data, facets: facets.map((I) => I.slice().reverse()) };\n}\nfunction shuffle2(options = {}) {\n  const { seed, ...remainingOptions } = options;\n  return { ...apply(remainingOptions, sortValue(seed == null ? Math.random : lcg(seed))), sort: null };\n}\nfunction sort2(order, options) {\n  return {\n    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),\n    sort: null\n  };\n}\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = (i, j) => compare(data[i], data[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareData)) };\n  };\n}\nfunction sortValue(value) {\n  let channel, order;\n  ({ channel, value, order = ascendingDefined2 } = { ...maybeValue(value) });\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = ascendingDefined2;\n        break;\n      case \"descending\":\n        order = descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === void 0) {\n      V = valueof(data, value);\n    } else {\n      if (channels === void 0)\n        throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V)\n        return {};\n      V = V.value;\n    }\n    const compareValue2 = (i, j) => order(V[i], V[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareValue2)) };\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/group.js\nfunction groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\nfunction groupX(outputs = { y: \"count\" }, options = {}) {\n  const { x: x4 = identity6 } = options;\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  return groupn(x4, null, outputs, options);\n}\nfunction groupY(outputs = { x: \"count\" }, options = {}) {\n  const { y: y4 = identity6 } = options;\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(null, y4, outputs, options);\n}\nfunction group2(outputs = { fill: \"count\" }, options = {}) {\n  let { x: x4, y: y4 } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(x4, y4, outputs, options);\n}\nfunction groupn(x4, y4, {\n  data: reduceData = reduceIdentity,\n  filter: filter4,\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  const [GX, setGX] = maybeColumn(x4);\n  const [GY, setGY] = maybeColumn(y4);\n  const {\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const X3 = valueof(data, x4);\n      const Y3 = valueof(data, y4);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GX2 = X3 && setGX([]);\n      const GY2 = Y3 && setGY([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y5, gg] of maybeGroup(I, Y3)) {\n            for (const [x5, g] of maybeGroup(gg, X3)) {\n              if (filter4 && !filter4.reduce(g))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(g, data));\n              if (X3)\n                GX2.push(x5);\n              if (Y3)\n                GY2.push(y5);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[g[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[g[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[g[0]]);\n              for (const o of outputs)\n                o.reduce(g);\n              if (sort3)\n                sort3.reduce(g);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (GX ? { x: GX } : { x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (GY ? { y: GY } : { y1: y12, y2: y22 }),\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction hasOutput(outputs, ...names) {\n  for (const { name } of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction maybeOutputs(outputs, inputs) {\n  const entries = Object.entries(outputs);\n  if (inputs.title != null && outputs.title === void 0)\n    entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === void 0)\n    entries.push([\"href\", reduceFirst]);\n  return entries.filter(([, reduce2]) => reduce2 !== void 0).map(([name, reduce2]) => {\n    return reduce2 === null ? { name, initialize() {\n    }, scope() {\n    }, reduce() {\n    } } : maybeOutput(name, reduce2, inputs);\n  });\n}\nfunction maybeOutput(name, reduce2, inputs) {\n  const evaluator = maybeEvaluator(name, reduce2, inputs);\n  const [output, setOutput] = column(evaluator.label);\n  let O;\n  return {\n    name,\n    output,\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent3) {\n      O.push(evaluator.reduce(I, extent3));\n    }\n  };\n}\nfunction maybeEvaluator(name, reduce2, inputs) {\n  const input = maybeInput(name, inputs);\n  const reducer2 = maybeReduce(reduce2, input);\n  let V, context;\n  return {\n    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),\n    initialize(data) {\n      V = input === void 0 ? data : valueof(data, input);\n      if (reducer2.scope === \"data\") {\n        context = reducer2.reduce(range4(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer2.scope === scope) {\n        context = reducer2.reduce(I, V);\n      }\n    },\n    reduce(I, extent3) {\n      return reducer2.scope == null ? reducer2.reduce(I, V, extent3) : reducer2.reduce(I, V, context, extent3);\n    }\n  };\n}\nfunction maybeGroup(I, X3) {\n  return X3 ? sort(group(I, (i) => X3[i]), first) : [[, I]];\n}\nfunction maybeReduce(reduce2, value) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return reduce2;\n  if (typeof reduce2 === \"function\")\n    return reduceFunction(reduce2);\n  if (/^p\\d{2}$/i.test(reduce2))\n    return reduceAccessor(percentile(reduce2));\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(deviation);\n    case \"min\":\n      return reduceAccessor(min);\n    case \"min-index\":\n      return reduceAccessor(minIndex);\n    case \"max\":\n      return reduceAccessor(max);\n    case \"max-index\":\n      return reduceAccessor(maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(median);\n    case \"variance\":\n      return reduceAccessor(variance);\n    case \"mode\":\n      return reduceAccessor(mode);\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n  }\n  throw new Error(`invalid reduce: ${reduce2}`);\n}\nfunction maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== void 0 && !outputs.some((o) => o.name === name)) {\n      return value;\n    }\n  }\n}\nfunction maybeSort(facets, sort3, reverse3) {\n  if (sort3) {\n    const S = sort3.output.transform();\n    const compare = (i, j) => ascendingDefined2(S[i], S[j]);\n    facets.forEach((f) => f.sort(compare));\n  }\n  if (reverse3) {\n    facets.forEach((f) => f.reverse());\n  }\n}\nfunction reduceFunction(f) {\n  return {\n    reduce(I, X3, extent3) {\n      return f(take(X3, I), extent3);\n    }\n  };\n}\nfunction reduceAccessor(f) {\n  return {\n    reduce(I, X3) {\n      return f(I, (i) => X3[i]);\n    }\n  };\n}\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduce(I, X3) {\n      const x4 = f(I, (i) => X3[i]);\n      return isTemporal(X3) ? new Date(x4) : x4;\n    }\n  };\n}\nvar reduceIdentity = {\n  reduce(I, X3) {\n    return take(X3, I);\n  }\n};\nvar reduceFirst = {\n  reduce(I, X3) {\n    return X3[I[0]];\n  }\n};\nvar reduceTitle = {\n  reduce(I, X3) {\n    const n = 5;\n    const groups2 = sort(rollup(I, (V) => V.length, (i) => X3[i]), second2);\n    const top2 = groups2.slice(-n).reverse();\n    if (top2.length < groups2.length) {\n      const bottom2 = groups2.slice(0, 1 - n);\n      top2[n - 1] = [`\\u2026 ${bottom2.length.toLocaleString(\"en-US\")} more`, sum(bottom2, second2)];\n    }\n    return top2.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\nvar reduceLast = {\n  reduce(I, X3) {\n    return X3[I[I.length - 1]];\n  }\n};\nvar reduceCount = {\n  label: \"Frequency\",\n  reduce(I) {\n    return I.length;\n  }\n};\nvar reduceDistinct = {\n  label: \"Distinct\",\n  reduce: (I, X3) => {\n    const s2 = new InternSet();\n    for (const i of I)\n      s2.add(X3[i]);\n    return s2.size;\n  }\n};\nvar reduceSum = reduceAccessor(sum);\nfunction reduceProportion(value, scope) {\n  return value == null ? { scope, label: \"Frequency\", reduce: (I, V, basis2 = 1) => I.length / basis2 } : { scope, reduce: (I, V, basis2 = 1) => sum(I, (i) => V[i]) / basis2 };\n}\nfunction mid2(x12, x22) {\n  const m3 = (+x12 + +x22) / 2;\n  return x12 instanceof Date ? new Date(m3) : m3;\n}\nvar reduceX = {\n  reduce(I, X3, { x1: x12, x2: x22 }) {\n    return mid2(x12, x22);\n  }\n};\nvar reduceY = {\n  reduce(I, X3, { y1: y12, y2: y22 }) {\n    return mid2(y12, y22);\n  }\n};\nvar reduceX1 = {\n  reduce(I, X3, { x1: x12 }) {\n    return x12;\n  }\n};\nvar reduceX2 = {\n  reduce(I, X3, { x2: x22 }) {\n    return x22;\n  }\n};\nvar reduceY1 = {\n  reduce(I, X3, { y1: y12 }) {\n    return y12;\n  }\n};\nvar reduceY2 = {\n  reduce(I, X3, { y2: y22 }) {\n    return y22;\n  }\n};\n\n// node_modules/@observablehq/plot/dist/channel.js\nfunction Channel(data, { scale: scale3, type: type2, value, filter: filter4, hint }, name) {\n  return inferChannelScale(name, {\n    scale: scale3,\n    type: type2,\n    value: valueof(data, value),\n    label: labelof(value),\n    filter: filter4,\n    hint\n  });\n}\nfunction Channels(channels, data) {\n  return Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, Channel(data, channel, name)]));\n}\nfunction valueObject(channels, scales) {\n  return Object.fromEntries(Object.entries(channels).map(([name, { scale: scaleName, value }]) => {\n    const scale3 = scaleName == null ? null : scales[scaleName];\n    return [name, scale3 == null ? value : map4(value, scale3)];\n  }));\n}\nfunction inferChannelScale(name, channel) {\n  const { scale: scale3, value } = channel;\n  if (scale3 === true || scale3 === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = isEvery(value, isColor) ? null : \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n        channel.scale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (isEvery(value, isSymbol)) {\n          channel.scale = null;\n          channel.value = map4(value, maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        break;\n      default:\n        channel.scale = registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale3 != null && !registry.has(scale3)) {\n    throw new Error(`unknown scale: ${scale3}`);\n  }\n  return channel;\n}\nfunction channelDomain(channels, facetChannels, data, options) {\n  const { reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;\n  for (const x4 in options) {\n    if (!registry.has(x4))\n      continue;\n    let { value: y4, reverse: reverse3 = defaultReverse, reduce: reduce2 = defaultReduce, limit = defaultLimit } = maybeValue(options[x4]);\n    if (reverse3 === void 0)\n      reverse3 = y4 === \"width\" || y4 === \"height\";\n    if (reduce2 == null || reduce2 === false)\n      continue;\n    const X3 = findScaleChannel(channels, x4) || facetChannels && findScaleChannel(facetChannels, x4);\n    if (!X3)\n      throw new Error(`missing channel for scale: ${x4}`);\n    const XV = X3.value;\n    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y4 == null) {\n      X3.domain = () => {\n        let domain = XV;\n        if (reverse3)\n          domain = domain.slice().reverse();\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV = y4 === \"data\" ? data : y4 === \"height\" ? difference2(channels, \"y1\", \"y2\") : y4 === \"width\" ? difference2(channels, \"x1\", \"x2\") : values(channels, y4, y4 === \"y\" ? \"y2\" : y4 === \"x\" ? \"x2\" : void 0);\n      const reducer2 = maybeReduce(reduce2 === true ? \"max\" : reduce2, YV);\n      X3.domain = () => {\n        let domain = rollup(range4(XV), (I) => reducer2.reduce(I, YV), (i) => XV[i]);\n        domain = sort(domain, reverse3 ? descendingGroup : ascendingGroup);\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain.map(first);\n      };\n    }\n  }\n}\nfunction findScaleChannel(channels, scale3) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale3)\n      return channel;\n  }\n}\nfunction difference2(channels, k1, k2) {\n  const X13 = values(channels, k1);\n  const X23 = values(channels, k2);\n  return map4(X23, (x22, i) => Math.abs(x22 - X13[i]), Float64Array);\n}\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== void 0)\n    channel = channels[alias];\n  if (channel)\n    return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return ascending(av, bv) || ascending(ak, bk);\n}\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return descending(av, bv) || ascending(ak, bk);\n}\n\n// node_modules/@observablehq/plot/dist/scales/schemes.js\nvar ordinalSchemes = /* @__PURE__ */ new Map([\n  // categorical\n  [\"accent\", Accent_default],\n  [\"category10\", category10_default],\n  [\"dark2\", Dark2_default],\n  [\"paired\", Paired_default],\n  [\"pastel1\", Pastel1_default],\n  [\"pastel2\", Pastel2_default],\n  [\"set1\", Set1_default],\n  [\"set2\", Set2_default],\n  [\"set3\", Set3_default],\n  [\"tableau10\", Tableau10_default],\n  // diverging\n  [\"brbg\", scheme112(scheme, BrBG_default)],\n  [\"prgn\", scheme112(scheme2, PRGn_default)],\n  [\"piyg\", scheme112(scheme3, PiYG_default)],\n  [\"puor\", scheme112(scheme4, PuOr_default)],\n  [\"rdbu\", scheme112(scheme5, RdBu_default)],\n  [\"rdgy\", scheme112(scheme6, RdGy_default)],\n  [\"rdylbu\", scheme112(scheme7, RdYlBu_default)],\n  [\"rdylgn\", scheme112(scheme8, RdYlGn_default)],\n  [\"spectral\", scheme112(scheme9, Spectral_default)],\n  // reversed diverging (for temperature data)\n  [\"burd\", scheme11r(scheme5, RdBu_default)],\n  [\"buylrd\", scheme11r(scheme7, RdYlBu_default)],\n  // sequential (single-hue)\n  [\"blues\", scheme92(scheme22, Blues_default)],\n  [\"greens\", scheme92(scheme23, Greens_default)],\n  [\"greys\", scheme92(scheme24, Greys_default)],\n  [\"oranges\", scheme92(scheme27, Oranges_default)],\n  [\"purples\", scheme92(scheme25, Purples_default)],\n  [\"reds\", scheme92(scheme26, Reds_default)],\n  // sequential (multi-hue)\n  [\"turbo\", schemei(turbo_default)],\n  [\"viridis\", schemei(viridis_default)],\n  [\"magma\", schemei(magma)],\n  [\"inferno\", schemei(inferno)],\n  [\"plasma\", schemei(plasma)],\n  [\"cividis\", schemei(cividis_default)],\n  [\"cubehelix\", schemei(cubehelix_default2)],\n  [\"warm\", schemei(warm)],\n  [\"cool\", schemei(cool)],\n  [\"bugn\", scheme92(scheme10, BuGn_default)],\n  [\"bupu\", scheme92(scheme11, BuPu_default)],\n  [\"gnbu\", scheme92(scheme12, GnBu_default)],\n  [\"orrd\", scheme92(scheme13, OrRd_default)],\n  [\"pubu\", scheme92(scheme15, PuBu_default)],\n  [\"pubugn\", scheme92(scheme14, PuBuGn_default)],\n  [\"purd\", scheme92(scheme16, PuRd_default)],\n  [\"rdpu\", scheme92(scheme17, RdPu_default)],\n  [\"ylgn\", scheme92(scheme19, YlGn_default)],\n  [\"ylgnbu\", scheme92(scheme18, YlGnBu_default)],\n  [\"ylorbr\", scheme92(scheme20, YlOrBr_default)],\n  [\"ylorrd\", scheme92(scheme21, YlOrRd_default)],\n  // cyclical\n  [\"rainbow\", schemeicyclical(rainbow_default)],\n  [\"sinebow\", schemeicyclical(sinebow_default)]\n]);\nfunction scheme92(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 1)\n      return [scheme28[3][1]];\n    if (n === 2)\n      return [scheme28[3][1], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme112(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][0], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme11r(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][2], scheme28[3][0]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();\n  };\n}\nfunction schemei(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));\n}\nfunction schemeicyclical(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\nfunction ordinalScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!ordinalSchemes.has(s2))\n    throw new Error(`unknown ordinal scheme: ${s2}`);\n  return ordinalSchemes.get(s2);\n}\nfunction ordinalRange(scheme28, length4) {\n  const s2 = ordinalScheme(scheme28);\n  const r = typeof s2 === \"function\" ? s2({ length: length4 }) : s2;\n  return r.length !== length4 ? r.slice(0, length4) : r;\n}\nfunction maybeBooleanRange(domain, scheme28 = \"greys\") {\n  const range5 = /* @__PURE__ */ new Set();\n  const [f, t] = ordinalRange(scheme28, 2);\n  for (const value of domain) {\n    if (value == null)\n      continue;\n    if (value === true)\n      range5.add(t);\n    else if (value === false)\n      range5.add(f);\n    else\n      return;\n  }\n  return [...range5];\n}\nvar quantitativeSchemes = /* @__PURE__ */ new Map([\n  // diverging\n  [\"brbg\", BrBG_default],\n  [\"prgn\", PRGn_default],\n  [\"piyg\", PiYG_default],\n  [\"puor\", PuOr_default],\n  [\"rdbu\", RdBu_default],\n  [\"rdgy\", RdGy_default],\n  [\"rdylbu\", RdYlBu_default],\n  [\"rdylgn\", RdYlGn_default],\n  [\"spectral\", Spectral_default],\n  // reversed diverging (for temperature data)\n  [\"burd\", (t) => RdBu_default(1 - t)],\n  [\"buylrd\", (t) => RdYlBu_default(1 - t)],\n  // sequential (single-hue)\n  [\"blues\", Blues_default],\n  [\"greens\", Greens_default],\n  [\"greys\", Greys_default],\n  [\"purples\", Purples_default],\n  [\"reds\", Reds_default],\n  [\"oranges\", Oranges_default],\n  // sequential (multi-hue)\n  [\"turbo\", turbo_default],\n  [\"viridis\", viridis_default],\n  [\"magma\", magma],\n  [\"inferno\", inferno],\n  [\"plasma\", plasma],\n  [\"cividis\", cividis_default],\n  [\"cubehelix\", cubehelix_default2],\n  [\"warm\", warm],\n  [\"cool\", cool],\n  [\"bugn\", BuGn_default],\n  [\"bupu\", BuPu_default],\n  [\"gnbu\", GnBu_default],\n  [\"orrd\", OrRd_default],\n  [\"pubugn\", PuBuGn_default],\n  [\"pubu\", PuBu_default],\n  [\"purd\", PuRd_default],\n  [\"rdpu\", RdPu_default],\n  [\"ylgnbu\", YlGnBu_default],\n  [\"ylgn\", YlGn_default],\n  [\"ylorbr\", YlOrBr_default],\n  [\"ylorrd\", YlOrRd_default],\n  // cyclical\n  [\"rainbow\", rainbow_default],\n  [\"sinebow\", sinebow_default]\n]);\nfunction quantitativeScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!quantitativeSchemes.has(s2))\n    throw new Error(`unknown quantitative scheme: ${s2}`);\n  return quantitativeSchemes.get(s2);\n}\nvar divergingSchemes = /* @__PURE__ */ new Set([\n  \"brbg\",\n  \"prgn\",\n  \"piyg\",\n  \"puor\",\n  \"rdbu\",\n  \"rdgy\",\n  \"rdylbu\",\n  \"rdylgn\",\n  \"spectral\",\n  \"burd\",\n  \"buylrd\"\n]);\nfunction isDivergingScheme(scheme28) {\n  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());\n}\n\n// node_modules/@observablehq/plot/dist/scales/quantitative.js\nvar flip = (i) => (t) => i(1 - t);\nvar unit2 = [0, 1];\nvar interpolators = /* @__PURE__ */ new Map([\n  // numbers\n  [\"number\", number_default],\n  // color spaces\n  [\"rgb\", rgb_default],\n  [\"hsl\", hsl_default],\n  [\"hcl\", hcl_default],\n  [\"lab\", lab2]\n]);\nfunction Interpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i))\n    throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\nfunction ScaleQ(key, scale3, channels, { type: type2, nice: nice3, clamp, zero: zero3, domain = inferAutoDomain(key, channels), unknown, round: round2, scheme: scheme28, interval: interval2, range: range5 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === \"cyclical\" ? \"rainbow\" : \"turbo\") : round2 ? round_default : number_default, reverse: reverse3 }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (type2 === \"cyclical\" || type2 === \"sequential\")\n    type2 = \"linear\";\n  reverse3 = !!reverse3;\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (interpolate.length === 1) {\n    if (reverse3) {\n      interpolate = flip(interpolate);\n      reverse3 = false;\n    }\n    if (range5 === void 0) {\n      range5 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range5.length === 2)\n        range5 = unit2;\n    }\n    scale3.interpolate((range5 === unit2 ? constant2 : interpolatePiecewise)(interpolate));\n  } else {\n    scale3.interpolate(interpolate);\n  }\n  if (zero3) {\n    const [min4, max5] = extent(domain);\n    if (min4 > 0 || max5 < 0) {\n      domain = slice5(domain);\n      if (orderof(domain) !== Math.sign(min4))\n        domain[domain.length - 1] = 0;\n      else\n        domain[0] = 0;\n    }\n  }\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain).unknown(unknown);\n  if (nice3)\n    scale3.nice(nice3 === true ? void 0 : nice3), domain = scale3.domain();\n  if (range5 !== void 0)\n    scale3.range(range5);\n  if (clamp)\n    scale3.clamp(clamp);\n  return { type: type2, domain, range: range5, scale: scale3, interpolate, interval: interval2 };\n}\nfunction ScaleLinear(key, channels, options) {\n  return ScaleQ(key, linear3(), channels, options);\n}\nfunction ScaleSqrt(key, channels, options) {\n  return ScalePow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScalePow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleQ(key, pow3().exponent(exponent2), channels, { ...options, type: \"pow\" });\n}\nfunction ScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {\n  return ScaleQ(key, log2().base(base), channels, { ...options, domain });\n}\nfunction ScaleSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleQ(key, symlog().constant(constant3), channels, options);\n}\nfunction ScaleQuantile(key, channels, {\n  range: range5,\n  quantiles = range5 === void 0 ? 5 : (range5 = [...range5]).length,\n  // deprecated; use n instead\n  n = quantiles,\n  scheme: scheme28 = \"rdylbu\",\n  domain = inferQuantileDomain(channels),\n  interpolate,\n  reverse: reverse3\n}) {\n  if (range5 === void 0) {\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  }\n  if (domain.length > 0) {\n    domain = quantile2(domain, range5 === void 0 ? { length: n } : range5).quantiles();\n  }\n  return ScaleThreshold(key, channels, { domain, range: range5, reverse: reverse3 });\n}\nfunction ScaleQuantize(key, channels, { range: range5, n = range5 === void 0 ? 5 : (range5 = [...range5]).length, scheme: scheme28 = \"rdylbu\", domain = inferAutoDomain(key, channels), unknown, interpolate, reverse: reverse3 }) {\n  const [min4, max5] = extent(domain);\n  let thresholds;\n  if (range5 === void 0) {\n    thresholds = ticks(min4, max5, n);\n    if (thresholds[0] <= min4)\n      thresholds.splice(0, 1);\n    if (thresholds[thresholds.length - 1] >= max5)\n      thresholds.pop();\n    n = thresholds.length + 1;\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  } else {\n    thresholds = quantize_default(number_default(min4, max5), n + 1).slice(1, -1);\n    if (min4 instanceof Date)\n      thresholds = thresholds.map((x4) => new Date(x4));\n  }\n  if (orderof(arrayify2(domain)) < 0)\n    thresholds.reverse();\n  return ScaleThreshold(key, channels, { domain: thresholds, range: range5, reverse: reverse3, unknown });\n}\nfunction ScaleThreshold(key, channels, {\n  domain = [0],\n  // explicit thresholds in ascending order\n  unknown,\n  scheme: scheme28 = \"rdylbu\",\n  interpolate,\n  range: range5 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,\n  reverse: reverse3\n}) {\n  domain = arrayify2(domain);\n  const sign3 = orderof(domain);\n  if (!isOrdered(domain, sign3))\n    throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse3)\n    range5 = reverse(range5);\n  return {\n    type: \"threshold\",\n    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range5 === void 0 ? [] : range5).unknown(unknown),\n    domain,\n    range: range5\n  };\n}\nfunction isOrdered(domain, sign3) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s2 = descending(d, d = domain[i]);\n    if (s2 !== 0 && s2 !== sign3)\n      return false;\n  }\n  return true;\n}\nfunction ScaleIdentity() {\n  return { type: \"identity\", scale: identity4() };\n}\nfunction inferDomain(channels, f = finite2) {\n  return channels.length ? [\n    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),\n    max(channels, ({ value }) => value === void 0 ? value : max(value, f))\n  ] : [0, 1];\n}\nfunction inferAutoDomain(key, channels) {\n  const type2 = registry.get(key);\n  return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);\n}\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite2)) : 1];\n}\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);\n  if (hint !== void 0)\n    return [0, hint.radius];\n  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));\n  const range5 = domain.map((d) => 3 * Math.sqrt(d / h25));\n  const k2 = 30 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLengthRange(channels, domain) {\n  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));\n  const range5 = domain.map((d) => 12 * d / h50);\n  const k2 = 60 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLogDomain(channels) {\n  for (const { value } of channels) {\n    if (value !== void 0) {\n      for (let v2 of value) {\n        if (v2 > 0)\n          return inferDomain(channels, positive);\n        if (v2 < 0)\n          return inferDomain(channels, negative);\n      }\n    }\n  }\n  return [1, 10];\n}\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const { value } of channels) {\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      domain.push(v2);\n  }\n  return domain;\n}\nfunction interpolatePiecewise(interpolate) {\n  return (i, j) => (t) => interpolate(i + t * (j - i));\n}\n\n// node_modules/@observablehq/plot/dist/scales/diverging.js\nfunction ScaleD(key, scale3, transform2, channels, { type: type2, nice: nice3, clamp, domain = inferDomain(channels), unknown, pivot = 0, scheme: scheme28, range: range5, symmetric = true, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : \"rdbu\") : number_default, reverse: reverse3 }) {\n  pivot = +pivot;\n  let [min4, max5] = domain;\n  if (descending(min4, max5) < 0)\n    [min4, max5] = [max5, min4], reverse3 = !reverse3;\n  min4 = Math.min(min4, pivot);\n  max5 = Math.max(max5, pivot);\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (range5 !== void 0) {\n    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range5) : piecewise(interpolate, range5);\n  }\n  if (reverse3)\n    interpolate = flip(interpolate);\n  if (symmetric) {\n    const mid3 = transform2.apply(pivot);\n    const mindelta = mid3 - transform2.apply(min4);\n    const maxdelta = transform2.apply(max5) - mid3;\n    if (mindelta < maxdelta)\n      min4 = transform2.invert(mid3 - maxdelta);\n    else if (mindelta > maxdelta)\n      max5 = transform2.invert(mid3 + mindelta);\n  }\n  scale3.domain([min4, pivot, max5]).unknown(unknown).interpolator(interpolate);\n  if (clamp)\n    scale3.clamp(clamp);\n  if (nice3)\n    scale3.nice(nice3);\n  return { type: type2, domain: [min4, max5], pivot, interpolate, scale: scale3 };\n}\nfunction ScaleDiverging(key, channels, options) {\n  return ScaleD(key, diverging(), transformIdentity, channels, options);\n}\nfunction ScaleDivergingSqrt(key, channels, options) {\n  return ScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScaleDivergingPow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow2(exponent2), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\nfunction ScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {\n  return ScaleD(key, divergingLog().base(base = +base), transformLog2, channels, { domain, pivot, ...options });\n}\nfunction ScaleDivergingSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleD(key, divergingSymlog().constant(constant3 = +constant3), transformSymlog2(constant3), channels, options);\n}\nvar transformIdentity = {\n  apply(x4) {\n    return x4;\n  },\n  invert(x4) {\n    return x4;\n  }\n};\nvar transformLog2 = {\n  apply: Math.log,\n  invert: Math.exp\n};\nvar transformSqrt2 = {\n  apply(x4) {\n    return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n  },\n  invert(x4) {\n    return Math.sign(x4) * (x4 * x4);\n  }\n};\nfunction transformPow2(exponent2) {\n  return exponent2 === 0.5 ? transformSqrt2 : {\n    apply(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), exponent2);\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), 1 / exponent2);\n    }\n  };\n}\nfunction transformSymlog2(constant3) {\n  return {\n    apply(x4) {\n      return Math.sign(x4) * Math.log1p(Math.abs(x4 / constant3));\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.expm1(Math.abs(x4)) * constant3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/scales/temporal.js\nfunction ScaleT(key, scale3, channels, options) {\n  return ScaleQ(key, scale3, channels, options);\n}\nfunction ScaleTime(key, channels, options) {\n  return ScaleT(key, time(), channels, options);\n}\nfunction ScaleUtc(key, channels, options) {\n  return ScaleT(key, utcTime(), channels, options);\n}\n\n// node_modules/@observablehq/plot/dist/scales/ordinal.js\nvar ordinalImplicit = Symbol(\"ordinal\");\nfunction ScaleO(key, scale3, channels, { type: type2, interval: interval2, domain, range: range5, reverse: reverse3, hint }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  if (type2 === \"categorical\" || type2 === ordinalImplicit)\n    type2 = \"ordinal\";\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain);\n  if (range5 !== void 0) {\n    if (typeof range5 === \"function\")\n      range5 = range5(domain);\n    scale3.range(range5);\n  }\n  return { type: type2, domain, range: range5, scale: scale3, hint, interval: interval2 };\n}\nfunction ScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range5, scheme: scheme28, unknown, ...options }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  let hint;\n  if (registry.get(key) === symbol) {\n    hint = inferSymbolHint(channels);\n    range5 = range5 === void 0 ? inferSymbolRange(hint) : map4(range5, maybeSymbol);\n  } else if (registry.get(key) === color2) {\n    if (range5 === void 0 && (type2 === \"ordinal\" || type2 === ordinalImplicit)) {\n      range5 = maybeBooleanRange(domain, scheme28);\n      if (range5 !== void 0)\n        scheme28 = void 0;\n    }\n    if (scheme28 === void 0 && range5 === void 0) {\n      scheme28 = type2 === \"ordinal\" ? \"turbo\" : \"tableau10\";\n    }\n    if (scheme28 !== void 0) {\n      if (range5 !== void 0) {\n        const interpolate = quantitativeScheme(scheme28);\n        const t03 = range5[0], d = range5[1] - range5[0];\n        range5 = ({ length: n }) => quantize_default((t) => interpolate(t03 + d * t), n);\n      } else {\n        range5 = ordinalScheme(scheme28);\n      }\n    }\n  }\n  if (unknown === implicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return ScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range5, hint });\n}\nfunction ScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {\n  return maybeRound(point().align(align).padding(padding), channels, options, key);\n}\nfunction ScaleBand(key, channels, { align = 0.5, padding = 0.1, paddingInner = padding, paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding, ...options }) {\n  return maybeRound(band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter), channels, options, key);\n}\nfunction maybeRound(scale3, channels, options, key) {\n  let { round: round2 } = options;\n  if (round2 !== void 0)\n    scale3.round(round2 = !!round2);\n  scale3 = ScaleO(key, scale3, channels, options);\n  scale3.round = round2;\n  return scale3;\n}\nfunction inferDomain2(channels, interval2, key) {\n  const values2 = new InternSet();\n  for (const { value, domain } of channels) {\n    if (domain !== void 0)\n      return domain();\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      values2.add(v2);\n  }\n  if (interval2 !== void 0) {\n    const [min4, max5] = extent(values2).map(interval2.floor, interval2);\n    return interval2.range(min4, interval2.offset(max5));\n  }\n  if (values2.size > 1e4 && registry.get(key) === position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return sort(values2, ascendingDefined2);\n}\nfunction inferHint(channels, key) {\n  let value;\n  for (const { hint } of channels) {\n    const candidate = hint?.[key];\n    if (candidate === void 0)\n      continue;\n    if (value === void 0)\n      value = candidate;\n    else if (value !== candidate)\n      return;\n  }\n  return value;\n}\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\nfunction inferSymbolRange(hint) {\n  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;\n}\n\n// node_modules/@observablehq/plot/dist/warnings.js\nvar warnings = 0;\nfunction consumeWarnings() {\n  const w = warnings;\n  warnings = 0;\n  return w;\n}\nfunction warn(message) {\n  console.warn(message);\n  ++warnings;\n}\n\n// node_modules/@observablehq/plot/dist/scales.js\nfunction Scales(channelsByScale, { label: globalLabel, inset: globalInset = 0, insetTop: globalInsetTop = globalInset, insetRight: globalInsetRight = globalInset, insetBottom: globalInsetBottom = globalInset, insetLeft: globalInsetLeft = globalInset, round: round2, nice: nice3, clamp, zero: zero3, align, padding, projection: projection2, facet: { label: facetLabel = globalLabel } = {}, ...options } = {}) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale3 = Scale(key, channels, {\n      round: registry.get(key) === position ? round2 : void 0,\n      nice: nice3,\n      clamp,\n      zero: zero3,\n      align,\n      padding,\n      projection: projection2,\n      ...scaleOptions\n    });\n    if (scale3) {\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform: transform2,\n        inset,\n        insetTop = inset !== void 0 ? inset : key === \"y\" ? globalInsetTop : 0,\n        // not fy\n        insetRight = inset !== void 0 ? inset : key === \"x\" ? globalInsetRight : 0,\n        // not fx\n        insetBottom = inset !== void 0 ? inset : key === \"y\" ? globalInsetBottom : 0,\n        // not fy\n        insetLeft = inset !== void 0 ? inset : key === \"x\" ? globalInsetLeft : 0\n        // not fx\n      } = scaleOptions || {};\n      if (transform2 == null)\n        transform2 = void 0;\n      else if (typeof transform2 !== \"function\")\n        throw new Error(\"invalid scale transform; not a function\");\n      scale3.percent = !!percent;\n      scale3.label = label === void 0 ? inferScaleLabel(channels, scale3) : label;\n      scale3.transform = transform2;\n      if (key === \"x\" || key === \"fx\") {\n        scale3.insetLeft = +insetLeft;\n        scale3.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale3.insetTop = +insetTop;\n        scale3.insetBottom = +insetBottom;\n      }\n      scales[key] = scale3;\n    }\n  }\n  return scales;\n}\nfunction ScaleFunctions(scales) {\n  return Object.fromEntries(Object.entries(scales).filter(([, { scale: scale3 }]) => scale3).map(([name, { scale: scale3, type: type2, interval: interval2, label }]) => {\n    scale3.type = type2;\n    if (interval2 != null)\n      scale3.interval = interval2;\n    if (label != null)\n      scale3.label = label;\n    return [name, scale3];\n  }));\n}\nfunction autoScaleRange(scales, dimensions) {\n  const { x: x4, y: y4, fx, fy } = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx)\n    autoScaleRangeX(fx, superdimensions);\n  if (fy)\n    autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x4)\n    autoScaleRangeX(x4, subdimensions);\n  if (y4)\n    autoScaleRangeY(y4, subdimensions);\n}\nfunction inferScaleLabel(channels = [], scale3) {\n  let label;\n  for (const { label: l } of channels) {\n    if (l === void 0)\n      continue;\n    if (label === void 0)\n      label = l;\n    else if (label !== l)\n      return;\n  }\n  if (label === void 0)\n    return;\n  if (isTemporalScale(scale3) && /^(date|time|year)$/i.test(label))\n    return;\n  if (!isOrdinalScale(scale3) && scale3.percent)\n    label = `${label} (%)`;\n  return { inferred: true, toString: () => label };\n}\nfunction outerDimensions(dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height, facet: { marginTop: facetMarginTop, marginRight: facetMarginRight, marginBottom: facetMarginBottom, marginLeft: facetMarginLeft } } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\nfunction innerDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height\n  };\n}\nfunction autoScaleRangeX(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetLeft, insetRight } = scale3;\n    const { width, marginLeft = 0, marginRight = 0 } = dimensions;\n    const left2 = marginLeft + insetLeft;\n    const right2 = width - marginRight - insetRight;\n    scale3.range = [left2, Math.max(left2, right2)];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRangeY(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetTop, insetBottom } = scale3;\n    const { height, marginTop = 0, marginBottom = 0 } = dimensions;\n    const top2 = marginTop + insetTop;\n    const bottom2 = height - marginBottom - insetBottom;\n    scale3.range = [Math.max(top2, bottom2), top2];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    else\n      scale3.range.reverse();\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRound(scale3) {\n  if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {\n    scale3.scale.round(true);\n  }\n}\nfunction roundError({ scale: scale3 }) {\n  const n = scale3.domain().length;\n  const [start2, stop] = scale3.range();\n  const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;\n  const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();\n  const m3 = n - paddingInner;\n  const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);\n  return (step - Math.floor(step)) * m3;\n}\nfunction piecewiseRange(scale3) {\n  const length4 = scale3.scale.domain().length + isThresholdScale(scale3);\n  if (!(length4 > 2))\n    return scale3.range;\n  const [start2, end] = scale3.range;\n  return Array.from({ length: length4 }, (_, i) => start2 + i / (length4 - 1) * (end - start2));\n}\nfunction normalizeScale(key, scale3, hint) {\n  return Scale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale3 });\n}\nfunction Scale(key, channels = [], options = {}) {\n  const type2 = inferScaleType(key, channels, options);\n  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== \"fx\" && key !== \"fy\" && isOrdinalScale({ type: type2 })) {\n    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n    if (values2.some(isTemporal))\n      warn(`Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isTemporalString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isNumericString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(type2)}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n  }\n  options.type = type2;\n  switch (type2) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, coerceNumbers);\n      break;\n    case \"identity\":\n      switch (registry.get(key)) {\n        case position:\n          options = coerceType(channels, options, coerceNumbers);\n          break;\n        case symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, coerceDates);\n      break;\n  }\n  switch (type2) {\n    case \"diverging\":\n      return ScaleDiverging(key, channels, options);\n    case \"diverging-sqrt\":\n      return ScaleDivergingSqrt(key, channels, options);\n    case \"diverging-pow\":\n      return ScaleDivergingPow(key, channels, options);\n    case \"diverging-log\":\n      return ScaleDivergingLog(key, channels, options);\n    case \"diverging-symlog\":\n      return ScaleDivergingSymlog(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case ordinalImplicit:\n      return ScaleOrdinal(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return ScaleLinear(key, channels, options);\n    case \"sqrt\":\n      return ScaleSqrt(key, channels, options);\n    case \"threshold\":\n      return ScaleThreshold(key, channels, options);\n    case \"quantile\":\n      return ScaleQuantile(key, channels, options);\n    case \"quantize\":\n      return ScaleQuantize(key, channels, options);\n    case \"pow\":\n      return ScalePow(key, channels, options);\n    case \"log\":\n      return ScaleLog(key, channels, options);\n    case \"symlog\":\n      return ScaleSymlog(key, channels, options);\n    case \"utc\":\n      return ScaleUtc(key, channels, options);\n    case \"time\":\n      return ScaleTime(key, channels, options);\n    case \"point\":\n      return ScalePoint(key, channels, options);\n    case \"band\":\n      return ScaleBand(key, channels, options);\n    case \"identity\":\n      return registry.get(key) === position ? ScaleIdentity() : { type: \"identity\" };\n    case void 0:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type2}`);\n  }\n}\nfunction formatScaleType(type2) {\n  return typeof type2 === \"symbol\" ? type2.description : type2;\n}\nvar typeProjection = { toString: () => \"projection\" };\nfunction inferScaleType(key, channels, { type: type2, domain, range: range5, scheme: scheme28, pivot, projection: projection2 }) {\n  if (key === \"fx\" || key === \"fy\")\n    return \"band\";\n  if ((key === \"x\" || key === \"y\") && projection2 != null)\n    type2 = typeProjection;\n  for (const { type: t } of channels) {\n    if (t === void 0)\n      continue;\n    else if (type2 === void 0)\n      type2 = t;\n    else if (type2 !== t)\n      throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);\n  }\n  if (type2 === typeProjection)\n    return;\n  if (type2 !== void 0)\n    return type2;\n  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))\n    return;\n  const kind = registry.get(key);\n  if (kind === radius)\n    return \"sqrt\";\n  if (kind === opacity || kind === length3)\n    return \"linear\";\n  if (kind === symbol)\n    return \"ordinal\";\n  if ((domain || range5 || []).length > 2)\n    return asOrdinalType(kind);\n  if (domain !== void 0) {\n    if (isOrdinal(domain))\n      return asOrdinalType(kind);\n    if (isTemporal(domain))\n      return \"utc\";\n    if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n      return \"diverging\";\n    return \"linear\";\n  }\n  const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n  if (values2.some(isOrdinal))\n    return asOrdinalType(kind);\n  if (values2.some(isTemporal))\n    return \"utc\";\n  if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n    return \"diverging\";\n  return \"linear\";\n}\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case position:\n      return \"point\";\n    case color2:\n      return ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\nfunction isTemporalScale({ type: type2 }) {\n  return type2 === \"time\" || type2 === \"utc\";\n}\nfunction isOrdinalScale({ type: type2 }) {\n  return type2 === \"ordinal\" || type2 === \"point\" || type2 === \"band\" || type2 === ordinalImplicit;\n}\nfunction isThresholdScale({ type: type2 }) {\n  return type2 === \"threshold\";\n}\nfunction isBandScale({ type: type2 }) {\n  return type2 === \"point\" || type2 === \"band\";\n}\nfunction isCollapsed(scale3) {\n  if (scale3 === void 0)\n    return true;\n  const domain = scale3.domain();\n  const value = scale3(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale3(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction coerceType(channels, { domain, ...options }, coerceValues) {\n  for (const c6 of channels) {\n    if (c6.value !== void 0) {\n      c6.value = coerceValues(c6.value);\n    }\n  }\n  return {\n    domain: domain === void 0 ? domain : coerceValues(domain),\n    ...options\n  };\n}\nfunction coerceSymbols(values2) {\n  return map4(values2, maybeSymbol);\n}\nfunction coerceDates(values2) {\n  return map4(values2, coerceDate);\n}\nfunction coerceNumbers(values2) {\n  return isTypedArray(values2) ? values2 : map4(values2, coerceNumber, Float64Array);\n}\nfunction coerceNumber(x4) {\n  return x4 == null ? NaN : Number(x4);\n}\nfunction coerceDate(x4) {\n  return x4 instanceof Date && !isNaN(x4) ? x4 : typeof x4 === \"string\" ? parse(x4) : x4 == null || isNaN(x4 = +x4) ? void 0 : new Date(x4);\n}\nfunction scale2(options = {}) {\n  let scale3;\n  for (const key in options) {\n    if (!registry.has(key))\n      continue;\n    if (!isScaleOptions(options[key]))\n      continue;\n    if (scale3 !== void 0)\n      throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale3 = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale3 === void 0)\n    throw new Error(\"invalid scale definition; no scale found\");\n  return scale3;\n}\nfunction exposeScales(scaleDescriptors) {\n  return (key) => {\n    if (!registry.has(key = `${key}`))\n      throw new Error(`unknown scale: ${key}`);\n    return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;\n  };\n}\nfunction exposeScale({ scale: scale3, type: type2, domain, range: range5, interpolate, interval: interval2, transform: transform2, percent, pivot }) {\n  if (type2 === \"identity\")\n    return { type: \"identity\", apply: (d) => d, invert: (d) => d };\n  const unknown = scale3.unknown ? scale3.unknown() : void 0;\n  return {\n    type: type2,\n    domain: slice5(domain),\n    ...range5 !== void 0 && { range: slice5(range5) },\n    ...transform2 !== void 0 && { transform: transform2 },\n    ...percent && { percent },\n    ...unknown !== void 0 && { unknown },\n    ...interval2 !== void 0 && { interval: interval2 },\n    // quantitative\n    ...interpolate !== void 0 && { interpolate },\n    ...scale3.clamp && { clamp: scale3.clamp() },\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...pivot !== void 0 && { pivot, symmetric: false },\n    // log, diverging-log\n    ...scale3.base && { base: scale3.base() },\n    // pow, diverging-pow\n    ...scale3.exponent && { exponent: scale3.exponent() },\n    // symlog, diverging-symlog\n    ...scale3.constant && { constant: scale3.constant() },\n    // band, point\n    ...scale3.align && { align: scale3.align(), round: scale3.round() },\n    ...scale3.padding && (scale3.paddingInner ? { paddingInner: scale3.paddingInner(), paddingOuter: scale3.paddingOuter() } : { padding: scale3.padding() }),\n    ...scale3.bandwidth && { bandwidth: scale3.bandwidth(), step: scale3.step() },\n    // utilities\n    apply: (t) => scale3(t),\n    ...scale3.invert && { invert: (t) => scale3.invert(t) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/projection.js\nvar pi6 = Math.PI;\nvar tau7 = 2 * pi6;\nvar defaultAspectRatio = 0.618;\nfunction Projection({ projection: projection2, inset: globalInset = 0, insetTop = globalInset, insetRight = globalInset, insetBottom = globalInset, insetLeft = globalInset } = {}, dimensions) {\n  if (projection2 == null)\n    return;\n  if (typeof projection2.stream === \"function\")\n    return projection2;\n  let options;\n  let domain;\n  let clip = \"frame\";\n  if (isObject(projection2)) {\n    let inset;\n    ({\n      type: projection2,\n      domain,\n      inset,\n      insetTop = inset !== void 0 ? inset : insetTop,\n      insetRight = inset !== void 0 ? inset : insetRight,\n      insetBottom = inset !== void 0 ? inset : insetBottom,\n      insetLeft = inset !== void 0 ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection2);\n    if (projection2 == null)\n      return;\n  }\n  if (typeof projection2 !== \"function\")\n    ({ type: projection2 } = namedProjection(projection2));\n  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection2 = projection2?.({ width: dx, height: dy, clip, ...options });\n  if (projection2 == null)\n    return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform2;\n  if (domain != null) {\n    const [[x06, y06], [x12, y12]] = path_default(projection2).bounds(domain);\n    const k2 = Math.min(dx / (x12 - x06), dy / (y12 - y06));\n    if (k2 > 0) {\n      tx -= (k2 * (x06 + x12) - dx) / 2;\n      ty -= (k2 * (y06 + y12) - dy) / 2;\n      transform2 = transform_default({\n        point(x4, y4) {\n          this.stream.point(x4 * k2 + tx, y4 * k2 + ty);\n        }\n      });\n    } else {\n      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n  transform2 ??= tx === 0 && ty === 0 ? identity7() : transform_default({\n    point(x4, y4) {\n      this.stream.point(x4 + tx, y4 + ty);\n    }\n  });\n  return { stream: (s2) => projection2.stream(transform2.stream(clip(s2))) };\n}\nfunction namedProjection(projection2) {\n  switch (`${projection2}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(albersUsa_default, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection2(albers_default, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(azimuthalEqualArea_default, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(azimuthalEquidistant_default, tau7, tau7);\n    case \"conic-conformal\":\n      return conicProjection2(conicConformal_default, tau7, tau7);\n    case \"conic-equal-area\":\n      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(equalEarth_default, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(equirectangular_default, tau7, pi6);\n    case \"gnomonic\":\n      return scaleProjection(gnomonic_default, 3.4641, 3.4641);\n    case \"identity\":\n      return { type: identity7 };\n    case \"reflect-y\":\n      return { type: reflectY };\n    case \"mercator\":\n      return scaleProjection(mercator_default, tau7, tau7);\n    case \"orthographic\":\n      return scaleProjection(orthographic_default, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(stereographic_default, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(transverseMercator_default, tau7, tau7);\n    default:\n      throw new Error(`unknown projection type: ${projection2}`);\n  }\n}\nfunction maybePostClip(clip, x12, y12, x22, y22) {\n  if (clip === false || clip == null || typeof clip === \"number\")\n    return (s2) => s2;\n  if (clip === true)\n    clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return clipRectangle(x12, y12, x22, y22);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\nfunction scaleProjection(createProjection, kx2, ky2) {\n  return {\n    type: ({ width, height, rotate, precision = 0.15, clip }) => {\n      const projection2 = createProjection();\n      if (precision != null)\n        projection2.precision?.(precision);\n      if (rotate != null)\n        projection2.rotate?.(rotate);\n      if (typeof clip === \"number\")\n        projection2.clipAngle?.(clip);\n      projection2.scale(Math.min(width / kx2, height / ky2));\n      projection2.translate([width / 2, height / 2]);\n      return projection2;\n    },\n    aspectRatio: ky2 / kx2\n  };\n}\nfunction conicProjection2(createProjection, kx2, ky2) {\n  const { type: type2, aspectRatio } = scaleProjection(createProjection, kx2, ky2);\n  return {\n    type: (options) => {\n      const { parallels, domain, width, height } = options;\n      const projection2 = type2(options);\n      if (parallels != null) {\n        projection2.parallels(parallels);\n        if (domain === void 0) {\n          projection2.fitSize([width, height], { type: \"Sphere\" });\n        }\n      }\n      return projection2;\n    },\n    aspectRatio\n  };\n}\nvar identity7 = constant2({ stream: (stream) => stream });\nvar reflectY = constant2(transform_default({\n  point(x4, y4) {\n    this.stream.point(x4, -y4);\n  }\n}));\nfunction maybeProject(cx, cy, channels, values2, context) {\n  const x4 = channels[cx] && channels[cx].scale === \"x\";\n  const y4 = channels[cy] && channels[cy].scale === \"y\";\n  if (x4 && y4) {\n    project(cx, cy, values2, context.projection);\n  } else if (x4) {\n    throw new Error(`projection requires paired x and y channels; ${cx} is missing ${cy}`);\n  } else if (y4) {\n    throw new Error(`projection requires paired x and y channels; ${cy} is missing ${cx}`);\n  }\n}\nfunction project(cx, cy, values2, projection2) {\n  const x4 = values2[cx];\n  const y4 = values2[cy];\n  const n = x4.length;\n  const X3 = values2[cx] = new Float64Array(n).fill(NaN);\n  const Y3 = values2[cy] = new Float64Array(n).fill(NaN);\n  let i;\n  const stream = projection2.stream({\n    point(x5, y5) {\n      X3[i] = x5;\n      Y3[i] = y5;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x4[i], y4[i]);\n  }\n}\nfunction projectionAspectRatio(projection2, marks2) {\n  if (typeof projection2?.stream === \"function\")\n    return defaultAspectRatio;\n  if (isObject(projection2))\n    projection2 = projection2.type;\n  if (projection2 == null)\n    return hasGeometry(marks2) ? defaultAspectRatio : void 0;\n  if (typeof projection2 !== \"function\") {\n    const { aspectRatio } = namedProjection(projection2);\n    if (aspectRatio)\n      return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\nfunction Position(channels, scales, context) {\n  const { x: x4, y: y4 } = channels;\n  let position2 = {};\n  if (x4)\n    position2.x = x4;\n  if (y4)\n    position2.y = y4;\n  position2 = valueObject(position2, scales);\n  if (context.projection)\n    maybeProject(\"x\", \"y\", channels, position2, context);\n  if (x4)\n    position2.x = coerceNumbers(position2.x);\n  if (y4)\n    position2.y = coerceNumbers(position2.y);\n  return position2;\n}\nfunction hasGeometry(marks2) {\n  for (const mark of marks2)\n    if (mark.channels.geometry)\n      return true;\n  return false;\n}\n\n// node_modules/@observablehq/plot/dist/context.js\nfunction Context(options = {}, dimensions) {\n  const { document: document2 = typeof window !== \"undefined\" ? window.document : void 0 } = options;\n  return { document: document2, projection: Projection(options, dimensions) };\n}\nfunction create2(name, { document: document2 }) {\n  return select_default2(creator_default(name).call(document2.documentElement));\n}\n\n// node_modules/@observablehq/plot/dist/memoize.js\nfunction memoize1(compute) {\n  let cacheValue, cacheKeys;\n  return (...keys) => {\n    if (cacheKeys?.length !== keys.length || cacheKeys.some((k2, i) => k2 !== keys[i])) {\n      cacheKeys = keys;\n      cacheValue = compute(...keys);\n    }\n    return cacheValue;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/format.js\nvar numberFormat = memoize1((locale3) => new Intl.NumberFormat(locale3));\nvar monthFormat = memoize1((locale3, month) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...month && { month } }));\nvar weekdayFormat = memoize1((locale3, weekday) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...weekday && { weekday } }));\nfunction formatNumber(locale3 = \"en-US\") {\n  const format3 = numberFormat(locale3);\n  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;\n}\nfunction formatMonth(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = monthFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatWeekday(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = weekdayFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatIsoDate(date2) {\n  return format2(date2, \"Invalid Date\");\n}\nfunction formatAuto(locale3 = \"en-US\") {\n  const number7 = formatNumber(locale3);\n  return (v2) => (v2 instanceof Date ? formatIsoDate : typeof v2 === \"number\" ? number7 : string)(v2);\n}\nvar formatDefault = formatAuto();\n\n// node_modules/@observablehq/plot/dist/style.js\nvar offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5;\nvar nextClipId = 0;\nfunction getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\nfunction styles(mark, { title, href, ariaLabel: variaLabel, ariaDescription, ariaHidden, target, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, opacity: opacity2, mixBlendMode, paintOrder, pointerEvents, shapeRendering }, { ariaLabel: cariaLabel, fill: defaultFill = \"currentColor\", fillOpacity: defaultFillOpacity, stroke: defaultStroke = \"none\", strokeOpacity: defaultStrokeOpacity, strokeWidth: defaultStrokeWidth, strokeLinecap: defaultStrokeLinecap, strokeLinejoin: defaultStrokeLinejoin, strokeMiterlimit: defaultStrokeMiterlimit, paintOrder: defaultPaintOrder }) {\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n  if (isNoneish(defaultFill)) {\n    if (!isNoneish(defaultStroke) && !isNoneish(fill))\n      defaultStroke = \"none\";\n  } else {\n    if (isNoneish(defaultStroke) && !isNoneish(stroke))\n      defaultFill = \"none\";\n  }\n  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = maybeNumberChannel(opacity2);\n  if (!isNone(cstroke)) {\n    if (strokeWidth === void 0)\n      strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === void 0)\n      strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === void 0)\n      strokeLinejoin = defaultStrokeLinejoin;\n    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))\n      strokeMiterlimit = defaultStrokeMiterlimit;\n    if (!isNone(cfill) && paintOrder === void 0)\n      paintOrder = defaultPaintOrder;\n  }\n  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n  mark.target = string(target);\n  mark.ariaLabel = string(cariaLabel);\n  mark.ariaDescription = string(ariaDescription);\n  mark.ariaHidden = string(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n  return {\n    title: { value: title, optional: true },\n    href: { value: href, optional: true },\n    ariaLabel: { value: variaLabel, optional: true },\n    fill: { value: vfill, scale: \"auto\", optional: true },\n    fillOpacity: { value: vfillOpacity, scale: \"opacity\", optional: true },\n    stroke: { value: vstroke, scale: \"auto\", optional: true },\n    strokeOpacity: { value: vstrokeOpacity, scale: \"opacity\", optional: true },\n    strokeWidth: { value: vstrokeWidth, optional: true },\n    opacity: { value: vopacity, scale: \"opacity\", optional: true }\n  };\n}\nfunction applyTitle(selection2, L) {\n  if (L)\n    selection2.filter((i) => nonempty(L[i])).append(\"title\").call(applyText, L);\n}\nfunction applyTitleGroup(selection2, L) {\n  if (L)\n    selection2.filter(([i]) => nonempty(L[i])).append(\"title\").call(applyTextGroup, L);\n}\nfunction applyText(selection2, T) {\n  if (T)\n    selection2.text((i) => formatDefault(T[i]));\n}\nfunction applyTextGroup(selection2, T) {\n  if (T)\n    selection2.text(([i]) => formatDefault(T[i]));\n}\nfunction applyChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", (i) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", (i) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", (i) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", (i) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", (i) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", (i) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", (i) => O[i]);\n  if (H)\n    applyHref(selection2, (i) => H[i], target);\n  applyTitle(selection2, T);\n}\nfunction applyGroupedChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", ([i]) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", ([i]) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", ([i]) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", ([i]) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", ([i]) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", ([i]) => O[i]);\n  if (H)\n    applyHref(selection2, ([i]) => H[i], target);\n  applyTitleGroup(selection2, T);\n}\nfunction groupAesthetics({ ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  return [AL, T, F, FO, S, SO, SW, O, H].filter((c6) => c6 !== void 0);\n}\nfunction groupZ2(I, Z, z) {\n  const G = group(I, (i) => Z[i]);\n  if (z === void 0 && G.size > I.length >> 1) {\n    warn(`Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`);\n  }\n  return G.values();\n}\nfunction* groupIndex(I, position2, { z }, channels) {\n  const { z: Z } = channels;\n  const A5 = groupAesthetics(channels);\n  const C3 = [...position2, ...A5];\n  for (const G of Z ? groupZ2(I, Z, z) : [I]) {\n    let Ag;\n    let Gg;\n    out:\n      for (const i of G) {\n        for (const c6 of C3) {\n          if (!defined(c6[i])) {\n            if (Gg)\n              Gg.push(-1);\n            continue out;\n          }\n        }\n        if (Ag === void 0) {\n          if (Gg)\n            yield Gg;\n          Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n          continue;\n        }\n        Gg.push(i);\n        for (let j = 0; j < A5.length; ++j) {\n          const k2 = keyof2(A5[j][i]);\n          if (k2 !== Ag[j]) {\n            yield Gg;\n            Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n            continue out;\n          }\n        }\n      }\n    if (Gg)\n      yield Gg;\n  }\n}\nfunction maybeClip(clip) {\n  if (clip === true)\n    clip = \"frame\";\n  else if (clip === false)\n    clip = null;\n  return maybeKeyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n}\nfunction applyClip(selection2, mark, dimensions, context) {\n  let clipUrl;\n  switch (mark.clip) {\n    case \"frame\": {\n      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2 = create2(\"svg:g\", context).call((g) => g.append(\"svg:clipPath\").attr(\"id\", id2).append(\"rect\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginRight - marginLeft).attr(\"height\", height - marginTop - marginBottom)).each(function() {\n        this.appendChild(selection2.node());\n        selection2.node = () => this;\n      });\n      break;\n    }\n    case \"sphere\": {\n      const { projection: projection2 } = context;\n      if (!projection2)\n        throw new Error(`the \"sphere\" clip option requires a projection`);\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2.append(\"clipPath\").attr(\"id\", id2).append(\"path\").attr(\"d\", path_default(projection2)({ type: \"Sphere\" }));\n      break;\n    }\n  }\n  applyAttr(selection2, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection2, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection2, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection2, \"clip-path\", clipUrl);\n}\nfunction applyIndirectStyles(selection2, mark, dimensions, context) {\n  applyClip(selection2, mark, dimensions, context);\n  applyAttr(selection2, \"fill\", mark.fill);\n  applyAttr(selection2, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection2, \"stroke\", mark.stroke);\n  applyAttr(selection2, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection2, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection2, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection2, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection2, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection2, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection2, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection2, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection2, \"paint-order\", mark.paintOrder);\n  applyAttr(selection2, \"pointer-events\", mark.pointerEvents);\n}\nfunction applyDirectStyles(selection2, mark) {\n  applyStyle(selection2, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection2, \"opacity\", mark.opacity);\n}\nfunction applyHref(selection2, href, target) {\n  selection2.each(function(i) {\n    const h = href(i);\n    if (h != null) {\n      const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, \"a\");\n      a4.setAttribute(\"fill\", \"inherit\");\n      a4.setAttributeNS(namespaces_default.xlink, \"href\", h);\n      if (target != null)\n        a4.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a4, this).appendChild(this);\n    }\n  });\n}\nfunction applyAttr(selection2, name, value) {\n  if (value != null)\n    selection2.attr(name, value);\n}\nfunction applyStyle(selection2, name, value) {\n  if (value != null)\n    selection2.style(name, value);\n}\nfunction applyTransform(selection2, mark, { x: x4, y: y4 }, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x4?.bandwidth)\n    tx += x4.bandwidth() / 2;\n  if (y4?.bandwidth)\n    ty += y4.bandwidth() / 2;\n  if (tx || ty)\n    selection2.attr(\"transform\", `translate(${tx},${ty})`);\n}\nfunction impliedString(value, impliedValue) {\n  if ((value = string(value)) !== impliedValue)\n    return value;\n}\nfunction impliedNumber(value, impliedValue) {\n  if ((value = number5(value)) !== impliedValue)\n    return value;\n}\nvar validClassName = /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/;\nfunction maybeClassName(name) {\n  if (name === void 0)\n    return `plot-${Math.random().toString(16).slice(2)}`;\n  name = `${name}`;\n  if (!validClassName.test(name))\n    throw new Error(`invalid class name: ${name}`);\n  return name;\n}\nfunction applyInlineStyles(selection2, style) {\n  if (typeof style === \"string\") {\n    selection2.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection2) {\n      Object.assign(element.style, style);\n    }\n  }\n}\nfunction applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {\n  return [\n    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,\n    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2\n  ];\n}\n\n// node_modules/@observablehq/plot/dist/dimensions.js\nfunction Dimensions(scales, marks2, options = {}) {\n  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;\n  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {\n    if (marginTop2 > marginTopDefault)\n      marginTopDefault = marginTop2;\n    if (marginRight2 > marginRightDefault)\n      marginRightDefault = marginRight2;\n    if (marginBottom2 > marginBottomDefault)\n      marginBottomDefault = marginBottom2;\n    if (marginLeft2 > marginLeftDefault)\n      marginLeftDefault = marginLeft2;\n  }\n  let { margin, marginTop = margin !== void 0 ? margin : marginTopDefault, marginRight = margin !== void 0 ? margin : marginRightDefault, marginBottom = margin !== void 0 ? margin : marginBottomDefault, marginLeft = margin !== void 0 ? margin : marginLeftDefault } = options;\n  marginTop = +marginTop;\n  marginRight = +marginRight;\n  marginBottom = +marginBottom;\n  marginLeft = +marginLeft;\n  let { width = 640, height = autoHeight(scales, marks2, options, {\n    width,\n    marginTopDefault,\n    marginRightDefault,\n    marginBottomDefault,\n    marginLeftDefault\n  }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault) } = options;\n  width = +width;\n  height = +height;\n  const dimensions = {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n  if (scales.fx || scales.fy) {\n    let { margin: facetMargin, marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop, marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight, marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom, marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft } = options.facet ?? {};\n    facetMarginTop = +facetMarginTop;\n    facetMarginRight = +facetMarginRight;\n    facetMarginBottom = +facetMarginBottom;\n    facetMarginLeft = +facetMarginLeft;\n    dimensions.facet = {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    };\n  }\n  return dimensions;\n}\nfunction autoHeight({ x: x4, y: y4, fy, fx }, marks2, { projection: projection2, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {\n  const nfy = fy ? fy.scale.domain().length : 1;\n  const ar = projectionAspectRatio(projection2, marks2);\n  if (ar) {\n    const nfx = fx ? fx.scale.domain().length : 1;\n    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;\n    const lar = Math.max(0.1, Math.min(10, far));\n    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);\n  }\n  const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;\n  if (aspectRatio != null) {\n    aspectRatio = +aspectRatio;\n    if (!(isFinite(aspectRatio) && aspectRatio > 0))\n      throw new Error(`invalid aspectRatio: ${aspectRatio}`);\n    const ratio = aspectRatioLength(\"y\", y4) / (aspectRatioLength(\"x\", x4) * aspectRatio);\n    const fxb = fx ? fx.scale.bandwidth() : 1;\n    const fyb = fy ? fy.scale.bandwidth() : 1;\n    const w = fxb * (width - marginLeftDefault - marginRightDefault) - x4.insetLeft - x4.insetRight;\n    return (ratio * w + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;\n  }\n  return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;\n}\nfunction aspectRatioLength(k2, scale3) {\n  if (!scale3)\n    throw new Error(`aspectRatio requires ${k2} scale`);\n  const { type: type2, domain } = scale3;\n  let transform2;\n  switch (type2) {\n    case \"linear\":\n    case \"utc\":\n    case \"time\":\n      transform2 = Number;\n      break;\n    case \"pow\": {\n      const exponent2 = scale3.scale.exponent();\n      transform2 = (x4) => Math.pow(x4, exponent2);\n      break;\n    }\n    case \"log\":\n      transform2 = Math.log;\n      break;\n    case \"point\":\n    case \"band\":\n      return domain.length;\n    default:\n      throw new Error(`unsupported ${k2} scale for aspectRatio: ${type2}`);\n  }\n  const [min4, max5] = extent(domain);\n  return Math.abs(transform2(max5) - transform2(min4));\n}\n\n// node_modules/@observablehq/plot/dist/facet.js\nfunction Facets(channelsByScale, options) {\n  const { fx, fy } = Scales(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x4, y4], i) => ({ x: x4, y: y4, i })) : fxDomain ? fxDomain.map((x4, i) => ({ x: x4, i })) : fyDomain ? fyDomain.map((y4, i) => ({ y: y4, i })) : void 0;\n}\nfunction facetOrder({ x: X3, y: Y3 }) {\n  const xi = X3 && new Map(X3.map((v2, i) => [v2, i]));\n  const yi = Y3 && new Map(Y3.map((v2, i) => [v2, i]));\n  return X3 && Y3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) || yi.get(a4.y) - yi.get(b.y) : X3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) : (a4, b) => yi.get(a4.y) - yi.get(b.y);\n}\nfunction facetGroups(data, { fx, fy }) {\n  const I = range4(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy ? rollup(I, (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G), (i) => FX[i], (i) => FY[i]) : fx ? rollup(I, (G) => (G.fx = FX[G[0]], G), (i) => FX[i]) : rollup(I, (G) => (G.fy = FY[G[0]], G), (i) => FY[i]);\n}\nfunction facetTranslate(fx, fy, { marginTop, marginLeft }) {\n  return fx && fy ? ({ x: x4, y: y4 }) => `translate(${fx(x4) - marginLeft},${fy(y4) - marginTop})` : fx ? ({ x: x4 }) => `translate(${fx(x4) - marginLeft},0)` : ({ y: y4 }) => `translate(0,${fy(y4) - marginTop})`;\n}\nfunction facetExclude(index3) {\n  const ex = [];\n  const e = new Uint32Array(sum(index3, (d) => d.length));\n  for (const i of index3) {\n    let n = 0;\n    for (const j of index3) {\n      if (i === j)\n        continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\nvar facetAnchors = /* @__PURE__ */ new Map([\n  [\"top\", facetAnchorTop],\n  [\"right\", facetAnchorRight],\n  [\"bottom\", facetAnchorBottom],\n  [\"left\", facetAnchorLeft],\n  [\"top-left\", and(facetAnchorTop, facetAnchorLeft)],\n  [\"top-right\", and(facetAnchorTop, facetAnchorRight)],\n  [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)],\n  [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)],\n  [\"top-empty\", facetAnchorTopEmpty],\n  [\"right-empty\", facetAnchorRightEmpty],\n  [\"bottom-empty\", facetAnchorBottomEmpty],\n  [\"left-empty\", facetAnchorLeftEmpty],\n  [\"empty\", facetAnchorEmpty]\n]);\nfunction maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null)\n    return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor)\n    return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\nfunction facetAnchorTop(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === 0 : true;\n}\nfunction facetAnchorBottom(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === Y3.length - 1 : true;\n}\nfunction facetAnchorLeft(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === 0 : true;\n}\nfunction facetAnchorRight(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === X3.length - 1 : true;\n}\nfunction facetAnchorTopEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i > 0) {\n    const y5 = Y3[i - 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i < Y3?.length - 1) {\n    const y5 = Y3[i + 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorLeftEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i > 0) {\n    const x5 = X3[i - 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorRightEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i < X3?.length - 1) {\n    const x5 = X3[i + 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorEmpty(facets, channels, { empty: empty4 }) {\n  return empty4;\n}\nfunction and(a4, b) {\n  return function() {\n    return a4.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\nfunction facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {\n  return fx && fy ? facets.map(({ x: x4, y: y4 }) => groups2.get(x4)?.get(y4) ?? []) : fx ? facets.map(({ x: x4 }) => groups2.get(x4) ?? []) : facets.map(({ y: y4 }) => groups2.get(y4) ?? []);\n}\n\n// node_modules/@observablehq/plot/dist/axes.js\nfunction inferFontVariant(scale3) {\n  return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction maybeAutoTickFormat(tickFormat2, domain) {\n  return tickFormat2 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat2 === \"function\" ? tickFormat2 : (typeof tickFormat2 === \"string\" ? isTemporal(domain) ? utcFormat : format : constant2)(tickFormat2);\n}\n\n// node_modules/@observablehq/plot/dist/legends/ramp.js\nfunction legendRamp(color3, options) {\n  let { label = color3.label, tickSize = 6, width = 240, height = 44 + tickSize, marginTop = 18, marginRight = 0, marginBottom = 16 + tickSize, marginLeft = 0, style, ticks: ticks2 = (width - marginLeft - marginRight) / 64, tickFormat: tickFormat2, fontVariant = inferFontVariant(color3), round: round2 = true, className } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  if (tickFormat2 === null)\n    tickFormat2 = () => null;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n          overflow: visible;\n        }\n        .${className} text {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style);\n  let tickAdjust = (g) => g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x4;\n  const applyRange = round2 ? (x5, range6) => x5.rangeRound(range6) : (x5, range6) => x5.range(range6);\n  const { type: type2, domain, range: range5, interpolate, scale: scale3, pivot } = color3;\n  if (interpolate) {\n    const interpolator = range5 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range5);\n    x4 = applyRange(scale3.copy(), quantize_default(number_default(marginLeft, width - marginRight), Math.min(domain.length + (pivot !== void 0), range5 === void 0 ? Infinity : range5.length)));\n    const n = 256;\n    const canvas = context.document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context2 = canvas.getContext(\"2d\");\n    for (let i = 0, j = n - 1; i < n; ++i) {\n      context2.fillStyle = interpolator(i / j);\n      context2.fillRect(i, 0, 1, 1);\n    }\n    svg2.append(\"image\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginLeft - marginRight).attr(\"height\", height - marginTop - marginBottom).attr(\"preserveAspectRatio\", \"none\").attr(\"xlink:href\", canvas.toDataURL());\n  } else if (type2 === \"threshold\") {\n    const thresholds = domain;\n    const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === \"string\" ? format(tickFormat2) : tickFormat2;\n    x4 = applyRange(linear3().domain([-1, range5.length - 1]), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(range5).enter().append(\"rect\").attr(\"x\", (d, i) => x4(i - 1)).attr(\"y\", marginTop).attr(\"width\", (d, i) => x4(i) - x4(i - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", (d) => d);\n    ticks2 = map4(thresholds, (_, i) => i);\n    tickFormat2 = (i) => thresholdFormat(thresholds[i], i);\n  } else {\n    x4 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(domain).enter().append(\"rect\").attr(\"x\", x4).attr(\"y\", marginTop).attr(\"width\", Math.max(0, x4.bandwidth() - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", scale3);\n    tickAdjust = () => {\n    };\n  }\n  svg2.append(\"g\").attr(\"transform\", `translate(0,${height - marginBottom})`).call(axisBottom(x4).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === \"string\" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === \"function\" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)).attr(\"font-size\", null).attr(\"font-family\", null).attr(\"font-variant\", impliedString(fontVariant, \"normal\")).call(tickAdjust).call((g) => g.select(\".domain\").remove());\n  if (label !== void 0) {\n    svg2.append(\"text\").attr(\"x\", marginLeft).attr(\"y\", marginTop - 6).attr(\"fill\", \"currentColor\").attr(\"font-weight\", \"bold\").text(label);\n  }\n  return svg2.node();\n}\n\n// node_modules/@observablehq/plot/dist/legends/swatches.js\nfunction maybeScale(scale3, key) {\n  if (key == null)\n    return key;\n  const s2 = scale3(key);\n  if (!s2)\n    throw new Error(`scale not found: ${key}`);\n  return s2;\n}\nfunction legendSwatches(color3, options) {\n  if (!isOrdinalScale(color3) && !isThresholdScale(color3))\n    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);\n  return legendItems(color3, options, (selection2, scale3) => selection2.append(\"svg\").attr(\"fill\", scale3.scale).append(\"rect\").attr(\"width\", \"100%\").attr(\"height\", \"100%\"), (className) => `.${className}-swatch svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n      }`);\n}\nfunction legendSymbols(symbol2, { fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : \"none\", fillOpacity = 1, stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? \"currentColor\" : \"none\", strokeOpacity = 1, strokeWidth = 1.5, r = 4.5, ...options } = {}, scale3) {\n  const [vf, cf] = maybeColorChannel(fill);\n  const [vs, cs] = maybeColorChannel(stroke);\n  const sf = maybeScale(scale3, vf);\n  const ss = maybeScale(scale3, vs);\n  const size = r * r * Math.PI;\n  fillOpacity = maybeNumberChannel(fillOpacity)[1];\n  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];\n  strokeWidth = maybeNumberChannel(strokeWidth)[1];\n  return legendItems(symbol2, options, (selection2) => selection2.append(\"svg\").attr(\"viewBox\", \"-8 -8 16 16\").attr(\"fill\", vf === \"color\" ? (d) => sf.scale(d) : null).attr(\"stroke\", vs === \"color\" ? (d) => ss.scale(d) : null).append(\"path\").attr(\"d\", (d) => {\n    const p = pathRound();\n    symbol2.scale(d).draw(p, size);\n    return p;\n  }), (className) => `.${className}-swatch > svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n        overflow: visible;\n        fill: ${cf};\n        fill-opacity: ${fillOpacity};\n        stroke: ${cs};\n        stroke-width: ${strokeWidth}px;\n        stroke-opacity: ${strokeOpacity};\n      }`);\n}\nfunction legendItems(scale3, options = {}, swatch, swatchStyle) {\n  let {\n    columns,\n    tickFormat: tickFormat2,\n    fontVariant = inferFontVariant(scale3),\n    // TODO label,\n    swatchSize = 15,\n    swatchWidth = swatchSize,\n    swatchHeight = swatchSize,\n    marginLeft = 0,\n    className,\n    style,\n    width\n  } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  tickFormat2 = maybeAutoTickFormat(tickFormat2, scale3.domain);\n  const swatches = create2(\"div\", context).attr(\"class\", className).attr(\"style\", `\n        --swatchWidth: ${+swatchWidth}px;\n        --swatchHeight: ${+swatchHeight}px;\n      `);\n  let extraStyle;\n  if (columns != null) {\n    extraStyle = `\n      .${className}-swatch {\n        display: flex;\n        align-items: center;\n        break-inside: avoid;\n        padding-bottom: 1px;\n      }\n      .${className}-swatch::before {\n        flex-shrink: 0;\n      }\n      .${className}-label {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n    `;\n    swatches.style(\"columns\", columns).selectAll().data(scale3.domain).enter().append(\"div\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).call((item) => item.append(\"div\").attr(\"class\", `${className}-label`).attr(\"title\", tickFormat2).text(tickFormat2));\n  } else {\n    extraStyle = `\n      .${className} {\n        display: flex;\n        align-items: center;\n        min-height: 33px;\n        flex-wrap: wrap;\n      }\n      .${className}-swatch {\n        display: inline-flex;\n        align-items: center;\n        margin-right: 1em;\n      }\n    `;\n    swatches.selectAll().data(scale3.domain).enter().append(\"span\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).append(function() {\n      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));\n    });\n  }\n  return swatches.call((div) => div.insert(\"style\", \"*\").text(`\n        .${className} {\n          font-family: system-ui, sans-serif;\n          font-size: 10px;\n          margin-bottom: 0.5em;${marginLeft === void 0 ? \"\" : `\n          margin-left: ${+marginLeft}px;`}${width === void 0 ? \"\" : `\n          width: ${width}px;`}\n        }\n        ${swatchStyle(className)}\n        ${extraStyle}\n      `)).style(\"font-variant\", impliedString(fontVariant, \"normal\")).call(applyInlineStyles, style).node();\n}\n\n// node_modules/@observablehq/plot/dist/legends.js\nvar legendRegistry = /* @__PURE__ */ new Map([\n  [\"symbol\", legendSymbols],\n  [\"color\", legendColor],\n  [\"opacity\", legendOpacity]\n]);\nfunction legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale3 = options[key];\n    if (isScaleOptions(scale3)) {\n      const context = Context(options);\n      let hint;\n      if (key === \"symbol\") {\n        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? \"color\" : void 0 } = options;\n        hint = { fill, stroke };\n      }\n      return value(normalizeScale(key, scale3, hint), legendOptions(context, scale3, options), (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null);\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\nfunction exposeLegends(scales, context, defaults21 = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key))\n      throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales))\n      return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults21[key], options), (key2) => scales[key2]);\n  };\n}\nfunction legendOptions(context, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {\n  return inherit2(options, context, { label, ticks: ticks2, tickFormat: tickFormat2 });\n}\nfunction legendColor(color3, { legend: legend2 = true, ...options }) {\n  if (legend2 === true)\n    legend2 = color3.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color3.domain === void 0)\n    return;\n  switch (`${legend2}`.toLowerCase()) {\n    case \"swatches\":\n      return legendSwatches(color3, options);\n    case \"ramp\":\n      return legendRamp(color3, options);\n    default:\n      throw new Error(`unknown legend type: ${legend2}`);\n  }\n}\nfunction legendOpacity({ type: type2, interpolate, ...scale3 }, { legend: legend2 = true, color: color3 = rgb(0, 0, 0), ...options }) {\n  if (!interpolate)\n    throw new Error(`${type2} opacity scales are not supported`);\n  if (legend2 === true)\n    legend2 = \"ramp\";\n  if (`${legend2}`.toLowerCase() !== \"ramp\")\n    throw new Error(`${legend2} opacity legends are not supported`);\n  return legendColor({ type: type2, ...scale3, interpolate: interpolateOpacity(color3) }, { legend: legend2, ...options });\n}\nfunction interpolateOpacity(color3) {\n  const { r, g, b } = rgb(color3) || rgb(0, 0, 0);\n  return (t) => `rgba(${r},${g},${b},${t})`;\n}\nfunction Legends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);\n      if (legend2 != null)\n        legends.push(legend2);\n    }\n  }\n  return legends;\n}\n\n// node_modules/@observablehq/plot/dist/mark.js\nvar Mark = class {\n  constructor(data, channels = {}, options = {}, defaults21) {\n    const { facet = \"auto\", facetAnchor, fx, fy, sort: sort3, dx = 0, dy = 0, margin = 0, marginTop = margin, marginRight = margin, marginBottom = margin, marginLeft = margin, clip, channels: extraChannels } = options;\n    this.data = data;\n    this.sort = isDomainSort(sort3) ? sort3 : null;\n    this.initializer = initializer(options).initializer;\n    this.transform = this.initializer ? options.transform : basic(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = keyword(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = fx;\n      this.fy = fy;\n    }\n    this.facetAnchor = maybeFacetAnchor(facetAnchor);\n    channels = maybeNamed(channels);\n    if (extraChannels !== void 0)\n      channels = { ...maybeNamed(extraChannels), ...channels };\n    if (defaults21 !== void 0)\n      channels = { ...styles(this, options, defaults21), ...channels };\n    this.channels = Object.fromEntries(Object.entries(channels).map(([name, channel]) => {\n      const { value } = channel;\n      if (isOptions(value)) {\n        channel = { ...channel, value: value.value };\n        if (value.scale !== void 0)\n          channel.scale = value.scale;\n      }\n      return [name, channel];\n    }).filter(([name, { value, optional: optional2 }]) => {\n      if (value != null)\n        return true;\n      if (optional2)\n        return false;\n      throw new Error(`missing channel value: ${name}`);\n    }));\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = maybeClip(clip);\n    if (this.facet === \"super\") {\n      if (fx || fy)\n        throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const { scale: scale3 } = channels[name];\n        if (scale3 !== \"x\" && scale3 !== \"y\")\n          continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n  }\n  initialize(facets, facetChannels) {\n    let data = arrayify2(this.data);\n    if (facets === void 0 && data != null)\n      facets = [range4(data)];\n    if (this.transform != null)\n      ({ facets, data } = this.transform(data, facets)), data = arrayify2(data);\n    const channels = Channels(this.channels, data);\n    if (this.sort != null)\n      channelDomain(channels, facetChannels, data, this.sort);\n    return { data, facets, channels };\n  }\n  filter(index3, channels, values2) {\n    for (const name in channels) {\n      const { filter: filter4 = defined } = channels[name];\n      if (filter4 !== null) {\n        const value = values2[name];\n        index3 = index3.filter((i) => filter4(value[i]));\n      }\n    }\n    return index3;\n  }\n  // If there is a projection, and there are both x and y channels (or x1 and\n  // y1, or x2 and y2 channels), and those channels are associated with the x\n  // and y scale respectively (and not already in screen coordinates as with an\n  // initializer), then apply the projection, replacing the x and y values. Note\n  // that the x and y scales themselves dont exist if there is a projection,\n  // but whether the channels are associated with scales still determines\n  // whether the projection should apply; think of the projection as a\n  // combination xy-scale.\n  project(channels, values2, context) {\n    maybeProject(\"x\", \"y\", channels, values2, context);\n    maybeProject(\"x1\", \"y1\", channels, values2, context);\n    maybeProject(\"x2\", \"y2\", channels, values2, context);\n  }\n  scale(channels, scales, context) {\n    const values2 = valueObject(channels, scales);\n    if (context.projection)\n      this.project(channels, values2, context);\n    return values2;\n  }\n};\nfunction marks(...marks2) {\n  marks2.plot = Mark.prototype.plot;\n  return marks2;\n}\n\n// node_modules/@observablehq/plot/dist/math.js\nvar radians3 = Math.PI / 180;\n\n// node_modules/@observablehq/plot/dist/transforms/inset.js\nfunction maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {\n  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);\n  return { inset, insetLeft, insetRight, ...options };\n}\nfunction maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {\n  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);\n  return { inset, insetTop, insetBottom, ...options };\n}\nfunction maybeInset(inset, inset1, inset2) {\n  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];\n}\n\n// node_modules/@observablehq/plot/dist/transforms/interval.js\nfunction maybeIntervalValue(value, { interval: interval2 }) {\n  value = { ...maybeValue(value) };\n  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);\n  return value;\n}\nfunction maybeIntervalK(k2, maybeInsetK, options, trivial) {\n  const { [k2]: v2, [`${k2}1`]: v1, [`${k2}2`]: v22 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null && !trivial)\n    return options;\n  const label = labelof(v2);\n  if (interval2 == null) {\n    let V;\n    const kv = { transform: (data) => V || (V = valueof(data, value)), label };\n    return {\n      ...options,\n      [k2]: void 0,\n      [`${k2}1`]: v1 === void 0 ? kv : v1,\n      [`${k2}2`]: v22 === void 0 ? kv : v22\n    };\n  }\n  let D1, V1;\n  function transform2(data) {\n    if (V1 !== void 0 && data === D1)\n      return V1;\n    return V1 = map4(valueof(D1 = data, value), (v3) => interval2.floor(v3));\n  }\n  return maybeInsetK({\n    ...options,\n    [k2]: void 0,\n    [`${k2}1`]: v1 === void 0 ? { transform: transform2, label } : v1,\n    [`${k2}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v3) => interval2.offset(v3)), label } : v22\n  });\n}\nfunction maybeIntervalMidK(k2, maybeInsetK, options) {\n  const { [k2]: v2 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null)\n    return options;\n  return maybeInsetK({\n    ...options,\n    [k2]: {\n      label: labelof(v2),\n      transform: (data) => {\n        const V1 = map4(valueof(data, value), (v3) => interval2.floor(v3));\n        const V2 = V1.map((v3) => interval2.offset(v3));\n        return V1.map(isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2);\n      }\n    }\n  });\n}\nfunction maybeTrivialIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options, true);\n}\nfunction maybeTrivialIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options, true);\n}\nfunction maybeIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options);\n}\nfunction maybeIntervalMidX(options = {}) {\n  return maybeIntervalMidK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalMidY(options = {}) {\n  return maybeIntervalMidK(\"y\", maybeInsetY, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/rule.js\nvar defaults = {\n  ariaLabel: \"rule\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar RuleX = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y1: Y13, y2: Y23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetTop, insetBottom } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions).call(applyTransform, this, { x: X3 && x4 }, offset, 0).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"x2\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"y1\", Y13 && !isCollapsed(y4) ? (i) => Y13[i] + insetTop : marginTop + insetTop).attr(\"y2\", Y23 && !isCollapsed(y4) ? y4.bandwidth ? (i) => Y23[i] + y4.bandwidth() - insetBottom : (i) => Y23[i] - insetBottom : height - marginBottom - insetBottom).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar RuleY = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12, scale: \"x\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true }\n    }, options, defaults);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { y: Y3, x1: X13, x2: X23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetLeft, insetRight } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y4 }, 0, offset).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X13 && !isCollapsed(x4) ? (i) => X13[i] + insetLeft : marginLeft + insetLeft).attr(\"x2\", X23 && !isCollapsed(x4) ? x4.bandwidth ? (i) => X23[i] + x4.bandwidth() - insetRight : (i) => X23[i] - insetRight : width - marginRight - insetRight).attr(\"y1\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).attr(\"y2\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction ruleX(data, options) {\n  let { x: x4 = identity6, y: y4, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);\n  [y12, y22] = maybeOptionalZero(y4, y12, y22);\n  return new RuleX(data, { ...rest, x: x4, y1: y12, y2: y22 });\n}\nfunction ruleY(data, options) {\n  let { y: y4 = identity6, x: x4, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);\n  [x12, x22] = maybeOptionalZero(x4, x12, x22);\n  return new RuleY(data, { ...rest, y: y4, x1: x12, x2: x22 });\n}\nfunction maybeOptionalZero(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [0, x22];\n    } else {\n      if (x22 === void 0)\n        return [0, x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [0, x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/template.js\nfunction template(strings, ...parts) {\n  let n = parts.length;\n  for (let j = 0, copy3 = true; j < n; ++j) {\n    if (typeof parts[j] !== \"function\") {\n      if (copy3) {\n        strings = strings.slice();\n        copy3 = false;\n      }\n      strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);\n      parts.splice(j, 1);\n      --j, --n;\n    }\n  }\n  return (i) => {\n    let s2 = strings[0];\n    for (let j = 0; j < n; ++j) {\n      s2 += parts[j](i) + strings[j + 1];\n    }\n    return s2;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/text.js\nvar defaults2 = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\nvar softHyphen = \"\\xAD\";\nvar Text = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf, frameAnchor, textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\", lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\", lineHeight = 1, lineWidth = Infinity, textOverflow, monospace, fontFamily = monospace ? \"ui-monospace, monospace\" : void 0, fontSize, fontStyle, fontVariant, fontWeight, rotate } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      fontSize: { value: vfontSize, optional: true },\n      rotate: { value: numberChannel(vrotate), optional: true },\n      text: { value: text2, filter: nonempty, optional: true }\n    }, options, defaults2);\n    this.rotate = crotate;\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.lineAnchor = keyword(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    if (!(this.lineWidth >= 0))\n      throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter2(this);\n    this.clipLine = clipper(this);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, rotate: R, text: T, title: TL, fontSize: FS } = channels;\n    const { rotate } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"text\").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`).call(applyAttr, \"font-size\", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction maybeTextOverflow(textOverflow) {\n  return textOverflow == null ? null : keyword(textOverflow, \"textOverflow\", [\n    \"clip\",\n    \"ellipsis\",\n    \"clip-start\",\n    \"clip-end\",\n    \"ellipsis-start\",\n    \"ellipsis-middle\",\n    \"ellipsis-end\"\n  ]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\nfunction applyMultilineText(selection2, mark, T, TL) {\n  if (!T)\n    return;\n  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;\n  selection2.each(function(i) {\n    const lines = splitLines(formatDefault(T[i])).map(clipLine);\n    const n = lines.length;\n    const y4 = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      for (let i2 = 0; i2 < n; ++i2) {\n        if (!lines[i2])\n          continue;\n        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        tspan.setAttribute(\"y\", `${(y4 + i2) * lineHeight}em`);\n        tspan.textContent = lines[i2];\n        this.appendChild(tspan);\n      }\n    } else {\n      if (y4)\n        this.setAttribute(\"y\", `${y4 * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(namespaces_default.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\nfunction text(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Text(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction textX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction textY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction applyIndirectTextStyles(selection2, mark, T) {\n  applyAttr(selection2, \"text-anchor\", mark.textAnchor);\n  applyAttr(selection2, \"font-family\", mark.fontFamily);\n  applyAttr(selection2, \"font-size\", mark.fontSize);\n  applyAttr(selection2, \"font-style\", mark.fontStyle);\n  applyAttr(selection2, \"font-variant\", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);\n  applyAttr(selection2, \"font-weight\", mark.fontWeight);\n}\nfunction inferFontVariant2(T) {\n  return isNumeric(T) || isTemporal(T) ? \"tabular-nums\" : void 0;\n}\nvar fontSizes = /* @__PURE__ */ new Set([\n  // global keywords\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n  // absolute keywords\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"xxx-large\",\n  // relative keywords\n  \"larger\",\n  \"smaller\"\n]);\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\")\n    return [void 0, fontSize];\n  if (typeof fontSize !== \"string\")\n    return [fontSize, void 0];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];\n}\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart, lineEnd = 0;\n  for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {\n    if (lineStart === void 0)\n      lineStart = wordStart;\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n    if (required2) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = void 0;\n      continue;\n    }\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\nfunction* lineBreaks(input) {\n  let i = 0, j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k2 = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\":\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \")\n          ;\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\")\n          ++k2;\n      case \"\\n\":\n        yield [i, j, true];\n        j += k2;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\nvar defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"\\u2018\": 31,\n  \"\\u2019\": 31,\n  \"\\u201C\": 47,\n  \"\\u201D\": 47,\n  \"\\u2026\": 82\n};\nfunction defaultWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += defaultWidthMap[text2[i]] ?? (isPictographic(text2, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum5;\n}\nfunction monospaceWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += isPictographic(text2, i) ? 200 : 100;\n  }\n  return sum5;\n}\nfunction splitter2({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow != null || lineWidth == Infinity)\n    return (text2) => text2.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return (text2) => lineWrap(text2, maxWidth, widthof);\n}\nfunction clipper({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow == null || lineWidth == Infinity)\n    return (text2) => text2;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-middle\":\n      return (text2) => clipMiddle(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\\u2026\");\n  }\n}\nfunction cut(text2, width, widthof, inset) {\n  const I = [];\n  let w = 0;\n  for (let i = 0, j = 0, n = text2.length; i < n; i = j) {\n    j = readCharacter(text2, i);\n    const l = widthof(text2, i, j);\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0)\n        j = i, i = I.pop(), w -= widthof(text2, i, j);\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\nfunction clipEnd(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const e = widthof(ellipsis);\n  const [i] = cut(text2, width, widthof, e);\n  return i < 0 ? text2 : text2.slice(0, i).trimEnd() + ellipsis;\n}\nfunction clipMiddle(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text2, width / 2, widthof, e);\n  const [j] = cut(text2, w - width / 2 - ei + e, widthof, -e);\n  return j < 0 ? ellipsis : text2.slice(0, i).trimEnd() + ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nfunction clipStart(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis);\n  const [j] = cut(text2, w - width + e, widthof, -e);\n  return j < 0 ? ellipsis : ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nvar reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nvar rePictographic = /\\p{Extended_Pictographic}/uy;\nfunction readCharacter(text2, i) {\n  i += isSurrogatePair(text2, i) ? 2 : 1;\n  if (isCombiner(text2, i))\n    i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text2, i))\n    return readCharacter(text2, i + 1);\n  return i;\n}\nfunction isAscii(text2, i) {\n  return text2.charCodeAt(i) < 128;\n}\nfunction isSurrogatePair(text2, i) {\n  const hi = text2.charCodeAt(i);\n  if (hi >= 55296 && hi < 56320) {\n    const lo = text2.charCodeAt(i + 1);\n    return lo >= 56320 && lo < 57344;\n  }\n  return false;\n}\nfunction isZeroWidthJoiner(text2, i) {\n  return text2.charCodeAt(i) === 8205;\n}\nfunction isCombiner(text2, i) {\n  return isAscii(text2, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text2));\n}\nfunction isPictographic(text2, i) {\n  return isAscii(text2, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text2));\n}\n\n// node_modules/@observablehq/plot/dist/marks/vector.js\nvar defaults3 = {\n  ariaLabel: \"vector\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\"\n};\nvar defaultRadius3 = 3.5;\nvar wingRatio = defaultRadius3 * 5;\nvar shapeArrow = {\n  draw(context, l, r) {\n    const wing = l * r / wingRatio;\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n    context.moveTo(-wing, wing - l);\n    context.lineTo(0, -l);\n    context.lineTo(wing, wing - l);\n  }\n};\nvar shapeSpike = {\n  draw(context, l, r) {\n    context.moveTo(-r, 0);\n    context.lineTo(0, -l);\n    context.lineTo(r, 0);\n  }\n};\nvar shapes = /* @__PURE__ */ new Map([\n  [\"arrow\", shapeArrow],\n  [\"spike\", shapeSpike]\n]);\nfunction isShapeObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction Shape(shape) {\n  if (isShapeObject(shape))\n    return shape;\n  const value = shapes.get(`${shape}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid shape: ${shape}`);\n}\nvar Vector = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r = defaultRadius3, length: length4, rotate, shape = shapeArrow, anchor = \"middle\", frameAnchor } = options;\n    const [vl, cl] = maybeNumberChannel(length4, 12);\n    const [vr, cr] = maybeNumberChannel(rotate, 0);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      length: { value: vl, scale: \"length\", optional: true },\n      rotate: { value: vr, optional: true }\n    }, options, defaults3);\n    this.r = +r;\n    this.length = cl;\n    this.rotate = cr;\n    this.shape = Shape(shape);\n    this.anchor = keyword(anchor, \"anchor\", [\"start\", \"middle\", \"end\"]);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, length: L, rotate: A5 } = channels;\n    const { length: length4, rotate, anchor, shape, r } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === \"start\" ? `` : anchor === \"end\" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length4})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length4 / 2})`}`).attr(\"d\", L ? (i) => {\n      const p = pathRound();\n      shape.draw(p, L[i], r);\n      return p;\n    } : (() => {\n      const p = pathRound();\n      shape.draw(p, length4, r);\n      return p;\n    })()).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction vector(data, options = {}) {\n  let { x: x4, y: y4, ...rest } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Vector(data, { ...rest, x: x4, y: y4 });\n}\nfunction vectorX(data, options = {}) {\n  const { x: x4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, x: x4 });\n}\nfunction vectorY(data, options = {}) {\n  const { y: y4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, y: y4 });\n}\nfunction spike(data, options = {}) {\n  const { shape = shapeSpike, stroke = defaults3.stroke, strokeWidth = 1, fill = stroke, fillOpacity = 0.3, anchor = \"start\", ...rest } = options;\n  return vector(data, { ...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor });\n}\n\n// node_modules/@observablehq/plot/dist/marks/axis.js\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !isIterable(data))\n    options = data, data = null;\n  if (options === void 0)\n    options = {};\n  return [data, options];\n}\nfunction maybeAnchor({ anchor } = {}, anchors) {\n  return anchor === void 0 ? anchors[0] : keyword(anchor, \"anchor\", anchors);\n}\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\nfunction axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\nfunction axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\nfunction axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\nfunction axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\nfunction axisKy(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"y\" ? 6 : 0, tickPadding, tickRotate, x: x4, marginTop = 20, marginRight = anchor === \"right\" ? 40 : 0, marginBottom = 20, marginLeft = anchor === \"left\" ? 40 : 0, label, labelOffset, labelAnchor, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKy(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKy(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"y\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"top\");\n      const clo = labelOffset ?? (anchor === \"right\" ? marginRight2 : marginLeft2) - 3;\n      if (cla === \"center\") {\n        this.textAnchor = void 0;\n        this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n        this.frameAnchor = anchor;\n        this.rotate = -90;\n      } else {\n        this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n        this.lineAnchor = cla;\n        this.frameAnchor = `${cla}-${anchor}`;\n        this.rotate = 0;\n      }\n      this.dy = cla === \"top\" ? 3 - marginTop2 : cla === \"bottom\" ? marginBottom2 - 3 : 0;\n      this.dx = anchor === \"right\" ? clo : -clo;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisKx(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"x\" ? 6 : 0, tickPadding, tickRotate, y: y4, marginTop = anchor === \"top\" ? 30 : 0, marginRight = 20, marginBottom = anchor === \"bottom\" ? 30 : 0, marginLeft = 20, label, labelAnchor, labelOffset, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKx(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKx(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"x\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"right\");\n      const clo = labelOffset ?? (anchor === \"top\" ? marginTop2 : marginBottom2) - 3;\n      if (cla === \"center\") {\n        this.frameAnchor = anchor;\n        this.textAnchor = void 0;\n      } else {\n        this.frameAnchor = `${anchor}-${cla}`;\n        this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n      }\n      this.lineAnchor = anchor;\n      this.dy = anchor === \"top\" ? -clo : clo;\n      this.dx = cla === \"right\" ? marginRight2 - 3 : cla === \"left\" ? 3 - marginLeft2 : 0;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisTickKy(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(vectorY, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinecap,\n    strokeLinejoin,\n    facetAnchor,\n    frameAnchor,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - offset + +insetLeft : +dx + offset - insetRight,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n  });\n}\nfunction axisTickKx(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(vectorX, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinejoin,\n    strokeLinecap,\n    facetAnchor,\n    frameAnchor,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy - offset - insetBottom : +dy + offset + +insetTop,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n  });\n}\nfunction axisTextKy(k2, anchor, data, { facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\", lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\", fontVariant, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(textY, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction axisTextKx(k2, anchor, data, { facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === \"bottom\" ? \"start\" : \"end\" : \"middle\", lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\", fontVariant, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(textX, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\nfunction gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\nfunction gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\nfunction gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\nfunction gridKy(k2, anchor, data, { y: y4 = k2 === \"y\" ? void 0 : null, x: x4 = null, x1: x12 = anchor === \"left\" ? x4 : null, x2: x22 = anchor === \"right\" ? x4 : null, ...options }) {\n  return axisMark(ruleY, k2, `${k2}-grid`, data, { y: y4, x1: x12, x2: x22, ...gridDefaults(options) });\n}\nfunction gridKx(k2, anchor, data, { x: x4 = k2 === \"x\" ? void 0 : null, y: y4 = null, y1: y12 = anchor === \"top\" ? y4 : null, y2: y22 = anchor === \"bottom\" ? y4 : null, ...options }) {\n  return axisMark(ruleX, k2, `${k2}-grid`, data, { x: x4, y1: y12, y2: y22, ...gridDefaults(options) });\n}\nfunction gridDefaults({ color: color3 = \"currentColor\", opacity: opacity2 = 0.1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, ...options }) {\n  return { stroke, strokeOpacity, strokeWidth, ...options };\n}\nfunction axisMark(mark, k2, ariaLabel, data, options, initialize) {\n  let channels;\n  const m3 = mark(data, initializer(options, function(data2, facets, _channels, scales) {\n    const { [k2]: scale3 } = scales;\n    if (!scale3)\n      throw new Error(`missing scale: ${k2}`);\n    let { ticks: ticks2, tickSpacing, interval: interval2 } = options;\n    if (isTemporalScale(scale3) && typeof ticks2 === \"string\")\n      interval2 = ticks2, ticks2 = void 0;\n    if (data2 == null) {\n      if (isIterable(ticks2)) {\n        data2 = arrayify2(ticks2);\n      } else if (scale3.ticks) {\n        if (ticks2 !== void 0) {\n          data2 = scale3.ticks(ticks2);\n        } else {\n          interval2 = maybeInterval(interval2 === void 0 ? scale3.interval : interval2, scale3.type);\n          if (interval2 !== void 0) {\n            const [min4, max5] = extent(scale3.domain());\n            data2 = interval2.range(min4, interval2.offset(interval2.floor(max5)));\n          } else {\n            const [min4, max5] = extent(scale3.range());\n            ticks2 = (max5 - min4) / (tickSpacing === void 0 ? k2 === \"x\" ? 80 : 35 : tickSpacing);\n            data2 = scale3.ticks(ticks2);\n          }\n        }\n      } else {\n        data2 = scale3.domain();\n      }\n      if (k2 === \"y\" || k2 === \"x\") {\n        facets = [range4(data2)];\n      } else {\n        channels[k2] = { scale: k2, value: identity6 };\n        facets = void 0;\n      }\n    }\n    initialize?.call(this, scale3, ticks2, channels);\n    return {\n      data: data2,\n      facets,\n      channels: Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, { ...channel, value: valueof(data2, channel.value) }]))\n    };\n  }));\n  if (data == null) {\n    channels = m3.channels;\n    m3.channels = {};\n  } else {\n    channels = {};\n  }\n  m3.ariaLabel = ariaLabel;\n  return m3;\n}\nfunction inferTextChannel(scale3, ticks2, tickFormat2) {\n  return { value: inferTickFormat(scale3, ticks2, tickFormat2) };\n}\nfunction inferTickFormat(scale3, ticks2, tickFormat2) {\n  return scale3.tickFormat ? scale3.tickFormat(isIterable(ticks2) ? null : ticks2, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === \"string\" ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : constant2(tickFormat2);\n}\nvar shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\nvar shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\nvar shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\nvar shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\nfunction inferFontVariant3(scale3) {\n  return scale3.bandwidth && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction inferScaleOrder(scale3) {\n  return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));\n}\nfunction inferAxisLabel(key, scale3, labelAnchor) {\n  const label = scale3.label;\n  if (scale3.bandwidth || !label?.inferred)\n    return label;\n  const order = inferScaleOrder(scale3);\n  return order ? key === \"x\" || labelAnchor === \"center\" ? key === \"x\" === order < 0 ? `\\u2190 ${label}` : `${label} \\u2192` : `${order < 0 ? \"\\u2191 \" : \"\\u2193 \"}${label}` : label;\n}\n\n// node_modules/@observablehq/plot/dist/marks/frame.js\nvar defaults4 = {\n  ariaLabel: \"frame\",\n  fill: \"none\",\n  stroke: \"currentColor\"\n};\nvar lineDefaults = {\n  ariaLabel: \"frame\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeLinecap: \"square\"\n};\nvar Frame = class extends Mark {\n  constructor(options = {}) {\n    const { anchor = null, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(void 0, void 0, options, anchor == null ? defaults4 : lineDefaults);\n    this.anchor = maybeKeyword(anchor, \"anchor\", [\"top\", \"right\", \"bottom\", \"left\"]);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = number5(rx);\n    this.ry = number5(ry);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    const x12 = marginLeft + insetLeft;\n    const x22 = width - marginRight - insetRight;\n    const y12 = marginTop + insetTop;\n    const y22 = height - marginBottom - insetBottom;\n    return create2(anchor ? \"svg:line\" : \"svg:rect\", context).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyTransform, this, {}).call(anchor === \"left\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x12).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"right\" ? (line2) => line2.attr(\"x1\", x22).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"top\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y12) : anchor === \"bottom\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y22).attr(\"y2\", y22) : (rect2) => rect2.attr(\"x\", x12).attr(\"y\", y12).attr(\"width\", x22 - x12).attr(\"height\", y22 - y12).attr(\"rx\", rx).attr(\"ry\", ry)).node();\n  }\n};\nfunction frame2(options) {\n  return new Frame(options);\n}\n\n// node_modules/@observablehq/plot/dist/plot.js\nfunction plot(options = {}) {\n  const { facet, style, caption, ariaLabel, ariaDescription } = options;\n  const className = maybeClassName(options.className);\n  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);\n  const topFacetState = maybeTopFacet(facet, options);\n  const facetStateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  const channelsByScale = /* @__PURE__ */ new Map();\n  if (topFacetState)\n    addScaleChannels(channelsByScale, [topFacetState]);\n  addScaleChannels(channelsByScale, facetStateByMark);\n  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));\n  for (const mark of axes) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  marks2.unshift(...axes);\n  const facets = Facets(channelsByScale, options);\n  if (facets !== void 0) {\n    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;\n    for (const mark of marks2) {\n      if (mark.facet === null || mark.facet === \"super\")\n        continue;\n      const facetState = facetStateByMark.get(mark);\n      if (facetState === void 0)\n        continue;\n      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;\n    }\n    const nonEmpty = /* @__PURE__ */ new Set();\n    for (const { facetsIndex } of facetStateByMark.values()) {\n      facetsIndex?.forEach((index3, i) => {\n        if (index3?.length > 0) {\n          nonEmpty.add(i);\n        }\n      });\n    }\n    facets.forEach(0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false);\n    for (const mark of marks2) {\n      if (mark.facet === \"exclude\") {\n        const facetState = facetStateByMark.get(mark);\n        if (facetState !== void 0)\n          facetState.facetsIndex = facetExclude(facetState.facetsIndex);\n      }\n    }\n  }\n  for (const key of registry.keys()) {\n    if (isScaleOptions(options[key]) && key !== \"fx\" && key !== \"fy\") {\n      channelsByScale.set(key, []);\n    }\n  }\n  const stateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    if (stateByMark.has(mark))\n      throw new Error(\"duplicate mark; each mark must be unique\");\n    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};\n    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels);\n    applyScaleTransforms(channels, options);\n    stateByMark.set(mark, { data, facets: facets2, channels });\n  }\n  const scaleDescriptors = Scales(addScaleChannels(channelsByScale, stateByMark), options);\n  const scales = ScaleFunctions(scaleDescriptors);\n  const dimensions = Dimensions(scaleDescriptors, marks2, options);\n  autoScaleRange(scaleDescriptors, dimensions);\n  const { fx, fy } = scales;\n  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;\n  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;\n  const context = Context(options, subdimensions, scaleDescriptors);\n  const newByScale = /* @__PURE__ */ new Set();\n  for (const [mark, state] of stateByMark) {\n    if (mark.initializer != null) {\n      const dimensions2 = mark.facet === \"super\" ? superdimensions : subdimensions;\n      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);\n      if (update.data !== void 0) {\n        state.data = update.data;\n      }\n      if (update.facets !== void 0) {\n        state.facets = update.facets;\n      }\n      if (update.channels !== void 0) {\n        inferChannelScales(update.channels);\n        Object.assign(state.channels, update.channels);\n        for (const channel of Object.values(update.channels)) {\n          const { scale: scale3 } = channel;\n          if (scale3 != null && registry.get(scale3) !== position) {\n            applyScaleTransform(channel, options);\n            newByScale.add(scale3);\n          }\n        }\n        const { fx: fx2, fy: fy2 } = update.channels;\n        if (fx2 != null || fy2 != null) {\n          const facetState = facetStateByMark.get(mark) ?? { channels: {} };\n          if (fx2 != null)\n            facetState.channels.fx = fx2;\n          if (fy2 != null)\n            facetState.channels.fy = fy2;\n          facetState.groups = facetGroups(state.data, facetState.channels);\n          facetState.facetsIndex = state.facets = facetFilter(facets, facetState);\n          facetStateByMark.set(mark, facetState);\n        }\n      }\n    }\n  }\n  if (newByScale.size) {\n    const newChannelsByScale = /* @__PURE__ */ new Map();\n    addScaleChannels(newChannelsByScale, stateByMark, (key) => newByScale.has(key));\n    addScaleChannels(channelsByScale, stateByMark, (key) => newByScale.has(key));\n    const newScaleDescriptors = inheritScaleLabels(Scales(newChannelsByScale, options), scaleDescriptors);\n    const newScales = ScaleFunctions(newScaleDescriptors);\n    Object.assign(scaleDescriptors, newScaleDescriptors);\n    Object.assign(scales, newScales);\n  }\n  for (const [mark, state] of stateByMark) {\n    state.values = mark.scale(state.channels, scales, context);\n  }\n  const { width, height } = dimensions;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"fill\", \"currentColor\").attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"text-anchor\", \"middle\").attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"aria-label\", ariaLabel).attr(\"aria-description\", ariaDescription).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n        }\n        .${className} text,\n        .${className} tspan {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style).node();\n  if (facets !== void 0) {\n    const facetDomains = { x: fx?.domain(), y: fy?.domain() };\n    facets.sort(facetOrder(facetDomains));\n    select_default2(svg2).selectAll().data(facets).enter().append(\"g\").attr(\"aria-label\", \"facet\").attr(\"transform\", facetTranslate(fx, fy, dimensions)).each(function(f) {\n      let empty4 = true;\n      for (const mark of marks2) {\n        if (mark.facet === \"super\")\n          continue;\n        const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n        if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty))\n          continue;\n        let index3 = null;\n        if (indexes2) {\n          index3 = indexes2[facetStateByMark.has(mark) ? f.i : 0];\n          index3 = mark.filter(index3, channels, values2);\n          if (index3.length === 0)\n            continue;\n          index3.fi = f.i;\n        }\n        const node = mark.render(index3, scales, values2, subdimensions, context);\n        if (node == null)\n          continue;\n        empty4 = false;\n        this.appendChild(node);\n      }\n      if (empty4)\n        this.remove();\n    });\n  }\n  for (const mark of marks2) {\n    if (facets !== void 0 && mark.facet !== \"super\")\n      continue;\n    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n    let index3 = null;\n    if (indexes2) {\n      index3 = indexes2[0];\n      index3 = mark.filter(index3, channels, values2);\n      if (index3.length === 0)\n        continue;\n    }\n    const node = mark.render(index3, scales, values2, superdimensions, context);\n    if (node != null)\n      svg2.appendChild(node);\n  }\n  let figure = svg2;\n  const legends = Legends(scaleDescriptors, context, options);\n  if (caption != null || legends.length > 0) {\n    const { document: document2 } = context;\n    figure = document2.createElement(\"figure\");\n    figure.style.maxWidth = \"initial\";\n    for (const legend2 of legends)\n      figure.appendChild(legend2);\n    figure.appendChild(svg2);\n    if (caption != null) {\n      const figcaption = document2.createElement(\"figcaption\");\n      figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));\n      figure.appendChild(figcaption);\n    }\n  }\n  figure.scale = exposeScales(scaleDescriptors);\n  figure.legend = exposeLegends(scaleDescriptors, context, options);\n  const w = consumeWarnings();\n  if (w > 0) {\n    select_default2(svg2).append(\"text\").attr(\"x\", width).attr(\"y\", 20).attr(\"dy\", \"-1em\").attr(\"text-anchor\", \"end\").attr(\"font-family\", \"initial\").text(\"\\u26A0\\uFE0F\").append(\"title\").text(`${w.toLocaleString(\"en-US\")} warning${w === 1 ? \"\" : \"s\"}. Please check the console.`);\n  }\n  return figure;\n}\nfunction plotThis({ marks: marks2 = [], ...options } = {}) {\n  return plot({ ...options, marks: [...marks2, this] });\n}\nMark.prototype.plot = plotThis;\nfunction flatMarks(marks2) {\n  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);\n}\nfunction markify(mark) {\n  return typeof mark.render === \"function\" ? mark : new Render(mark);\n}\nvar Render = class extends Mark {\n  constructor(render2) {\n    if (typeof render2 !== \"function\")\n      throw new TypeError(\"invalid mark; missing render function\");\n    super();\n    this.render = render2;\n  }\n  render() {\n  }\n};\nfunction applyScaleTransforms(channels, options) {\n  for (const name in channels)\n    applyScaleTransform(channels[name], options);\n  return channels;\n}\nfunction applyScaleTransform(channel, options) {\n  const { scale: scale3 } = channel;\n  if (scale3 == null)\n    return;\n  const { type: type2, percent, interval: interval2, transform: transform2 = percent ? (x4) => x4 * 100 : maybeInterval(interval2, type2)?.floor } = options[scale3] ?? {};\n  if (transform2 != null)\n    channel.value = map4(channel.value, transform2);\n}\nfunction inferChannelScales(channels) {\n  for (const name in channels) {\n    inferChannelScale(name, channels[name]);\n  }\n}\nfunction addScaleChannels(channelsByScale, stateByMark, filter4 = yes) {\n  for (const { channels } of stateByMark.values()) {\n    for (const name in channels) {\n      const channel = channels[name];\n      const { scale: scale3 } = channel;\n      if (scale3 != null && filter4(scale3)) {\n        const scaleChannels = channelsByScale.get(scale3);\n        if (scaleChannels !== void 0)\n          scaleChannels.push(channel);\n        else\n          channelsByScale.set(scale3, [channel]);\n      }\n    }\n  }\n  return channelsByScale;\n}\nfunction maybeTopFacet(facet, options) {\n  if (facet == null)\n    return;\n  const { x: x4, y: y4 } = facet;\n  if (x4 == null && y4 == null)\n    return;\n  const data = arrayify2(facet.data ?? x4 ?? y4);\n  if (data === void 0)\n    throw new Error(`missing facet data`);\n  const channels = {};\n  if (x4 != null)\n    channels.fx = Channel(data, { value: x4, scale: \"fx\" });\n  if (y4 != null)\n    channels.fy = Channel(data, { value: y4, scale: \"fy\" });\n  applyScaleTransforms(channels, options);\n  const groups2 = facetGroups(data, channels);\n  return { channels, groups: groups2, data: facet.data };\n}\nfunction maybeMarkFacet(mark, topFacetState, options) {\n  if (mark.facet === null || mark.facet === \"super\")\n    return;\n  const { fx, fy } = mark;\n  if (fx != null || fy != null) {\n    const data2 = arrayify2(mark.data ?? fx ?? fy);\n    if (data2 === void 0)\n      throw new Error(`missing facet data in ${mark.ariaLabel}`);\n    if (data2 === null)\n      return;\n    const channels2 = {};\n    if (fx != null)\n      channels2.fx = Channel(data2, { value: fx, scale: \"fx\" });\n    if (fy != null)\n      channels2.fy = Channel(data2, { value: fy, scale: \"fy\" });\n    applyScaleTransforms(channels2, options);\n    return { channels: channels2, groups: facetGroups(data2, channels2) };\n  }\n  if (topFacetState === void 0)\n    return;\n  const { channels, groups: groups2, data } = topFacetState;\n  if (mark.facet !== \"auto\" || mark.data === data)\n    return { channels, groups: groups2 };\n  if ((groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {\n    warn(`Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is \"auto\", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`);\n  }\n}\nfunction inferAxes(marks2, channelsByScale, options) {\n  let { projection: projection2, x: x4 = {}, y: y4 = {}, fx = {}, fy = {}, axis: axis2, grid, facet = {}, facet: { axis: facetAxis = axis2, grid: facetGrid } = facet, x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x4, y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y4, fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx, fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy } = options;\n  if (projection2 || !isScaleOptions(x4) && !hasScaleChannel(\"x\", marks2))\n    xAxis = xGrid = null;\n  if (projection2 || !isScaleOptions(y4) && !hasScaleChannel(\"y\", marks2))\n    yAxis = yGrid = null;\n  if (!channelsByScale.has(\"fx\"))\n    fxAxis = fxGrid = null;\n  if (!channelsByScale.has(\"fy\"))\n    fyAxis = fyGrid = null;\n  if (xAxis === void 0)\n    xAxis = !hasAxis(marks2, \"x\");\n  if (yAxis === void 0)\n    yAxis = !hasAxis(marks2, \"y\");\n  if (fxAxis === void 0)\n    fxAxis = !hasAxis(marks2, \"fx\");\n  if (fyAxis === void 0)\n    fyAxis = !hasAxis(marks2, \"fy\");\n  if (xAxis === true)\n    xAxis = \"bottom\";\n  if (yAxis === true)\n    yAxis = \"left\";\n  if (fxAxis === true)\n    fxAxis = xAxis === \"top\" || xAxis === null ? \"bottom\" : \"top\";\n  if (fyAxis === true)\n    fyAxis = yAxis === \"right\" || yAxis === null ? \"left\" : \"right\";\n  const axes = [];\n  maybeGrid(axes, fyGrid, gridFy, fy);\n  maybeAxis(axes, fyAxis, axisFy, \"right\", \"left\", facet, fy);\n  maybeGrid(axes, fxGrid, gridFx, fx);\n  maybeAxis(axes, fxAxis, axisFx, \"top\", \"bottom\", facet, fx);\n  maybeGrid(axes, yGrid, gridY, y4);\n  maybeAxis(axes, yAxis, axisY, \"left\", \"right\", options, y4);\n  maybeGrid(axes, xGrid, gridX, x4);\n  maybeAxis(axes, xAxis, axisX, \"bottom\", \"top\", options, x4);\n  return axes;\n}\nfunction maybeAxis(axes, axis2, axisType, primary, secondary, defaults21, options) {\n  if (!axis2)\n    return;\n  const both = isBoth(axis2);\n  options = axisOptions(both ? primary : axis2, defaults21, options);\n  const { line: line2 } = options;\n  if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2))\n    axes.push(frame2(lineOptions(options)));\n  axes.push(axisType(options));\n  if (both)\n    axes.push(axisType({ ...options, anchor: secondary, label: null }));\n}\nfunction maybeGrid(axes, grid, gridType, options) {\n  if (!grid || isNone(grid))\n    return;\n  axes.push(gridType(gridOptions(grid, options)));\n}\nfunction isBoth(value) {\n  return /^\\s*both\\s*$/i.test(value);\n}\nfunction axisOptions(anchor, defaults21, { line: line2 = defaults21.line, ticks: ticks2, tickSize, tickSpacing, tickPadding, tickFormat: tickFormat2, tickRotate, fontVariant, ariaLabel, ariaDescription, label = defaults21.label, labelAnchor, labelOffset }) {\n  return {\n    anchor,\n    line: line2,\n    ticks: ticks2,\n    tickSize,\n    tickSpacing,\n    tickPadding,\n    tickFormat: tickFormat2,\n    tickRotate,\n    fontVariant,\n    ariaLabel,\n    ariaDescription,\n    label,\n    labelAnchor,\n    labelOffset\n  };\n}\nfunction lineOptions(options) {\n  const { anchor, line: line2 } = options;\n  return { anchor, facetAnchor: anchor + \"-empty\", stroke: line2 === true ? void 0 : line2 };\n}\nfunction gridOptions(grid, { stroke = isColor(grid) ? grid : void 0, ticks: ticks2 = isGridTicks(grid) ? grid : void 0, tickSpacing, ariaLabel, ariaDescription }) {\n  return {\n    stroke,\n    ticks: ticks2,\n    tickSpacing,\n    ariaLabel,\n    ariaDescription\n  };\n}\nfunction isGridTicks(grid) {\n  switch (typeof grid) {\n    case \"number\":\n      return true;\n    case \"string\":\n      return !isColor(grid);\n  }\n  return isIterable(grid) || typeof grid?.range === \"function\";\n}\nfunction hasAxis(marks2, k2) {\n  const prefix = `${k2}-axis `;\n  return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));\n}\nfunction hasScaleChannel(k2, marks2) {\n  for (const mark of marks2) {\n    for (const key in mark.channels) {\n      if (mark.channels[key].scale === k2) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction inheritScaleLabels(newScales, scales) {\n  for (const key in newScales) {\n    const newScale = newScales[key];\n    const scale3 = scales[key];\n    if (newScale.label === void 0 && scale3) {\n      newScale.label = scale3.label;\n    }\n  }\n  return newScales;\n}\nfunction actualDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  const fxr = fx && outerRange(fx);\n  const fyr = fy && outerRange(fy);\n  return {\n    marginTop: fy ? fyr[0] : marginTop,\n    marginRight: fx ? width - fxr[1] : marginRight,\n    marginBottom: fy ? height - fyr[1] : marginBottom,\n    marginLeft: fx ? fxr[0] : marginLeft,\n    // Some marks, namely the x- and y-axis labels, want to know what the\n    // desired (rather than actual) margins are for positioning.\n    inset: {\n      marginTop: dimensions.marginTop,\n      marginRight: dimensions.marginRight,\n      marginBottom: dimensions.marginBottom,\n      marginLeft: dimensions.marginLeft\n    },\n    width,\n    height\n  };\n}\nfunction outerRange(scale3) {\n  const domain = scale3.domain();\n  let x12 = scale3(domain[0]);\n  let x22 = scale3(domain[domain.length - 1]);\n  if (x22 < x12)\n    [x12, x22] = [x22, x12];\n  return [x12, x22 + scale3.bandwidth()];\n}\n\n// node_modules/@observablehq/plot/dist/curve.js\nvar curves = /* @__PURE__ */ new Map([\n  [\"basis\", basis_default2],\n  [\"basis-closed\", basisClosed_default2],\n  [\"basis-open\", basisOpen_default],\n  [\"bundle\", bundle_default],\n  [\"bump-x\", bumpX],\n  [\"bump-y\", bumpY],\n  [\"cardinal\", cardinal_default],\n  [\"cardinal-closed\", cardinalClosed_default],\n  [\"cardinal-open\", cardinalOpen_default],\n  [\"catmull-rom\", catmullRom_default],\n  [\"catmull-rom-closed\", catmullRomClosed_default],\n  [\"catmull-rom-open\", catmullRomOpen_default],\n  [\"linear\", linear_default],\n  [\"linear-closed\", linearClosed_default],\n  [\"monotone-x\", monotoneX],\n  [\"monotone-y\", monotoneY],\n  [\"natural\", natural_default],\n  [\"step\", step_default],\n  [\"step-after\", stepAfter],\n  [\"step-before\", stepBefore]\n]);\nfunction Curve(curve = linear_default, tension) {\n  if (typeof curve === \"function\")\n    return curve;\n  const c6 = curves.get(`${curve}`.toLowerCase());\n  if (!c6)\n    throw new Error(`unknown curve: ${curve}`);\n  if (tension !== void 0) {\n    if (\"beta\" in c6) {\n      return c6.beta(tension);\n    } else if (\"tension\" in c6) {\n      return c6.tension(tension);\n    } else if (\"alpha\" in c6) {\n      return c6.alpha(tension);\n    }\n  }\n  return c6;\n}\nfunction PathCurve(curve = curveAuto, tension) {\n  return typeof curve !== \"function\" && `${curve}`.toLowerCase() === \"auto\" ? curveAuto : Curve(curve, tension);\n}\nfunction curveAuto(context) {\n  return linear_default(context);\n}\n\n// node_modules/@observablehq/plot/dist/transforms/bin.js\nfunction binX(outputs = { y: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(maybeBinValue(x4, options, identity6), null, null, y4, outputs, maybeInsetX(options));\n}\nfunction binY(outputs = { x: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(null, maybeBinValue(y4, options, identity6), x4, null, outputs, maybeInsetY(options));\n}\nfunction bin2(outputs = { fill: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = maybeBinValueTuple(options);\n  return binn(x4, y4, null, null, outputs, maybeInsetX(maybeInsetY(options)));\n}\nfunction maybeDenseInterval(bin3, k2, options = {}) {\n  return options?.interval == null ? options : bin3({ [k2]: options?.reduce === void 0 ? reduceFirst : options.reduce, filter: null }, options);\n}\nfunction maybeDenseIntervalX(options) {\n  return maybeDenseInterval(binX, \"y\", options);\n}\nfunction maybeDenseIntervalY(options) {\n  return maybeDenseInterval(binY, \"x\", options);\n}\nfunction binn(bx, by, gx, gy, {\n  data: reduceData = reduceIdentity,\n  // TODO avoid materializing when unused?\n  filter: filter4 = reduceCount,\n  // return only non-empty bins by default\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  if (gx != null && hasOutput(outputs, \"x\", \"x1\", \"x2\"))\n    gx = null;\n  if (gy != null && hasOutput(outputs, \"y\", \"y1\", \"y2\"))\n    gy = null;\n  const [BX1, setBX1] = maybeColumn(bx);\n  const [BX2, setBX2] = maybeColumn(bx);\n  const [BY1, setBY1] = maybeColumn(by);\n  const [BY2, setBY2] = maybeColumn(by);\n  const [k2, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = maybeColumn(k2);\n  const {\n    x: x4,\n    y: y4,\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval: interval2,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const K2 = valueof(data, k2);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GK2 = K2 && setGK([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      const BX12 = bx && setBX1([]);\n      const BX22 = bx && setBX2([]);\n      const BY12 = by && setBY1([]);\n      const BY22 = by && setBY2([]);\n      const bin3 = Bin(bx?.(data), by?.(data));\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [k3, g] of maybeGroup(I, K2)) {\n            for (const [b, extent3] of bin3(g)) {\n              if (filter4 && !filter4.reduce(b, extent3))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(b, data, extent3));\n              if (K2)\n                GK2.push(k3);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[b[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[b[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[b[0]]);\n              if (BX12)\n                BX12.push(extent3.x1), BX22.push(extent3.x2);\n              if (BY12)\n                BY12.push(extent3.y1), BY22.push(extent3.y2);\n              for (const o of outputs)\n                o.reduce(b, extent3);\n              if (sort3)\n                sort3.reduce(b);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x4, x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y4, y1: y12, y2: y22 }),\n    ...GK && { [gk]: GK },\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {\n  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];\n}\nfunction maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {\n  value = { ...maybeValue(value) };\n  if (value.domain === void 0)\n    value.domain = domain;\n  if (value.cumulative === void 0)\n    value.cumulative = cumulative;\n  if (value.thresholds === void 0)\n    value.thresholds = thresholds;\n  if (value.interval === void 0)\n    value.interval = interval2;\n  if (value.value === void 0)\n    value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\nfunction maybeBinValueTuple(options) {\n  let { x: x4, y: y4 } = options;\n  x4 = maybeBinValue(x4, options);\n  y4 = maybeBinValue(y4, options);\n  [x4.value, y4.value] = maybeTuple(x4.value, y4.value);\n  return { x: x4, y: y4 };\n}\nfunction maybeBin(options) {\n  if (options == null)\n    return;\n  const { value, cumulative, domain = extent, thresholds } = options;\n  const bin3 = (data) => {\n    let V = valueof(data, value);\n    let T;\n    if (isTemporal(V) || isTimeThresholds(thresholds)) {\n      V = map4(V, coerceDate, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\")\n        t = utcTickInterval(min4, max5, t);\n      if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    } else {\n      V = map4(V, coerceNumber, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\") {\n        if (domain === extent) {\n          let step = tickIncrement(min4, max5, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min4 / step);\n              let r1 = Math.round(max5 / step);\n              if (!(r0 * step <= min4))\n                --r0;\n              if (!(r1 * step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min4 * step);\n              let r1 = Math.round(max5 * step);\n              if (!(r0 / step <= min4))\n                --r0;\n              if (!(r1 / step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) / step;\n            } else {\n              t = [min4];\n            }\n          } else {\n            t = [min4];\n          }\n        } else {\n          t = ticks(min4, max5, t);\n        }\n      } else if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    }\n    const E2 = [];\n    if (T.length === 1)\n      E2.push([T[0], T[0]]);\n    else\n      for (let i = 1; i < T.length; ++i)\n        E2.push([T[i - 1], T[i]]);\n    E2.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E2, T, V);\n    return E2;\n  };\n  bin3.label = labelof(value);\n  return bin3;\n}\nfunction maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {\n  if (thresholds === void 0) {\n    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return thresholdFreedmanDiaconis;\n      case \"scott\":\n        return thresholdScott;\n      case \"sturges\":\n        return thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    const interval3 = maybeInterval(thresholds);\n    if (interval3 !== void 0)\n      return interval3;\n    throw new Error(`invalid thresholds: ${thresholds}`);\n  }\n  return thresholds;\n}\nfunction maybeRangeInterval(interval2) {\n  interval2 = maybeInterval(interval2);\n  if (!isInterval(interval2))\n    throw new Error(`invalid interval: ${interval2}`);\n  return interval2;\n}\nfunction thresholdAuto(values2, min4, max5) {\n  return Math.min(200, thresholdScott(values2, min4, max5));\n}\nfunction isTimeThresholds(t) {\n  return isTimeInterval(t) || isIterable(t) && isTemporal(t);\n}\nfunction isTimeInterval(t) {\n  return isInterval(t) && typeof t === \"function\" && t() instanceof Date;\n}\nfunction isInterval(t) {\n  return t ? typeof t.range === \"function\" : false;\n}\nfunction Bin(EX, EY) {\n  return EX && EY ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [ix, [x12, x22]] of EX.entries()) {\n      const Y3 = EY.bin(X3[ix]);\n      for (const [iy, [y12, y22]] of EY.entries()) {\n        yield [Y3[iy], { x1: x12, y1: y12, x2: x22, y2: y22 }];\n      }\n    }\n  } : EX ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [i, [x12, x22]] of EX.entries()) {\n      yield [X3[i], { x1: x12, x2: x22 }];\n    }\n  } : function* (I) {\n    const Y3 = EY.bin(I);\n    for (const [i, [y12, y22]] of EY.entries()) {\n      yield [Y3[i], { y1: y12, y2: y22 }];\n    }\n  };\n}\nfunction bin1(E2, T, V) {\n  T = T.map(coerceNumber);\n  return (I) => {\n    const B3 = E2.map(() => []);\n    for (const i of I)\n      B3[bisect_default(T, V[i]) - 1]?.push(i);\n    return B3;\n  };\n}\nfunction bin1cp(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = 1, n = B3.length; i < n; ++i) {\n      const C3 = B3[i - 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\nfunction bin1cn(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = B3.length - 2; i >= 0; --i) {\n      const C3 = B3[i + 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/identity.js\nfunction maybeIdentityX(options = {}) {\n  const { x: x4, x1: x12, x2: x22 } = options;\n  return x12 === void 0 && x22 === void 0 && x4 === void 0 ? { ...options, x: identity6 } : options;\n}\nfunction maybeIdentityY(options = {}) {\n  const { y: y4, y1: y12, y2: y22 } = options;\n  return y12 === void 0 && y22 === void 0 && y4 === void 0 ? { ...options, y: identity6 } : options;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/stack.js\nfunction stackX(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4, ...rest } = options;\n  const [transform2, Y3, x12, x22] = stackAlias(y4, x4, \"x\", stack2, rest);\n  return { ...transform2, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };\n}\nfunction stackX1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackX2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, , X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackY(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4, ...rest } = options;\n  const [transform2, X3, y12, y22] = stackAlias(x4, y4, \"y\", stack2, rest);\n  return { ...transform2, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };\n}\nfunction stackY1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction stackY2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, , Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction maybeStackX({ x: x4, x1: x12, x2: x22, ...options } = {}) {\n  if (x12 === void 0 && x22 === void 0)\n    return stackX({ x: x4, ...options });\n  [x12, x22] = maybeZero(x4, x12, x22);\n  return { ...options, x1: x12, x2: x22 };\n}\nfunction maybeStackY({ y: y4, y1: y12, y2: y22, ...options } = {}) {\n  if (y12 === void 0 && y22 === void 0)\n    return stackY({ y: y4, ...options });\n  [y12, y22] = maybeZero(y4, y12, y22);\n  return { ...options, y1: y12, y2: y22 };\n}\nfunction mergeOptions2(options) {\n  const { offset: offset2, order, reverse: reverse3, ...rest } = options;\n  return [{ offset: offset2, order, reverse: reverse3 }, rest];\n}\nfunction stack(x4, y4 = one2, ky2, { offset: offset2, order, reverse: reverse3 }, options) {\n  const z = maybeZ(options);\n  const [X3, setX] = maybeColumn(x4);\n  const [Y13, setY1] = column(y4);\n  const [Y23, setY2] = column(y4);\n  offset2 = maybeOffset(offset2);\n  order = maybeOrder(order, offset2, ky2);\n  return [\n    basic(options, (data, facets) => {\n      const X4 = x4 == null ? void 0 : setX(valueof(data, x4));\n      const Y3 = valueof(data, y4, Float64Array);\n      const Z = valueof(data, z);\n      const O = order && order(data, X4, Y3, Z);\n      const n = data.length;\n      const Y14 = setY1(new Float64Array(n));\n      const Y24 = setY2(new Float64Array(n));\n      const facetstacks = [];\n      for (const facet of facets) {\n        const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];\n        if (O)\n          applyOrder(stacks, O);\n        for (const stack2 of stacks) {\n          let yn = 0, yp = 0;\n          if (reverse3)\n            stack2.reverse();\n          for (const i of stack2) {\n            const y5 = Y3[i];\n            if (y5 < 0)\n              yn = Y24[i] = (Y14[i] = yn) + y5;\n            else if (y5 > 0)\n              yp = Y24[i] = (Y14[i] = yp) + y5;\n            else\n              Y24[i] = Y14[i] = yp;\n          }\n        }\n        facetstacks.push(stacks);\n      }\n      if (offset2)\n        offset2(facetstacks, Y14, Y24, Z);\n      return { data, facets };\n    }),\n    X3,\n    Y13,\n    Y23\n  ];\n}\nvar stackAlias = stack;\nfunction maybeOffset(offset2) {\n  if (offset2 == null)\n    return;\n  if (typeof offset2 === \"function\")\n    return offset2;\n  switch (`${offset2}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset2}`);\n}\nfunction extent2(stack2, Y23) {\n  let min4 = 0, max5 = 0;\n  for (const i of stack2) {\n    const y4 = Y23[i];\n    if (y4 < min4)\n      min4 = y4;\n    if (y4 > max5)\n      max5 = y4;\n  }\n  return [min4, max5];\n}\nfunction offsetExpand(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = 1 / (yp - yn || 1);\n        Y13[i] = m3 * (Y13[i] - yn);\n        Y23[i] = m3 * (Y23[i] - yn);\n      }\n    }\n  }\n}\nfunction offsetCenter(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = (yp + yn) / 2;\n        Y13[i] -= m3;\n        Y23[i] -= m3;\n      }\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetWiggle(facetstacks, Y13, Y23, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new InternMap();\n    let y4 = 0;\n    for (const stack2 of stacks) {\n      let j = -1;\n      const Fi = stack2.map((i) => Math.abs(Y23[i] - Y13[i]));\n      const Df = stack2.map((i) => {\n        j = Z ? Z[i] : ++j;\n        const value = Y23[i] - Y13[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...cumsum(Df)];\n      for (const i of stack2) {\n        Y13[i] += y4;\n        Y23[i] += y4;\n      }\n      const s1 = sum(Fi);\n      if (s1)\n        y4 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetZero(stacks, Y13, Y23) {\n  const m3 = min(stacks, (stack2) => min(stack2, (i) => Y13[i]));\n  for (const stack2 of stacks) {\n    for (const i of stack2) {\n      Y13[i] -= m3;\n      Y23[i] -= m3;\n    }\n  }\n}\nfunction offsetCenterFacets(facetstacks, Y13, Y23) {\n  const n = facetstacks.length;\n  if (n === 1)\n    return;\n  const facets = facetstacks.map((stacks) => stacks.flat());\n  const m3 = facets.map((I) => (min(I, (i) => Y13[i]) + max(I, (i) => Y23[i])) / 2);\n  const m0 = min(m3);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m3[j];\n    for (const i of facets[j]) {\n      Y13[i] += p;\n      Y23[i] += p;\n    }\n  }\n}\nfunction maybeOrder(order, offset2, ky2) {\n  if (order === void 0 && offset2 === offsetWiggle)\n    return orderInsideOut;\n  if (order == null)\n    return;\n  if (typeof order === \"string\") {\n    switch (order.toLowerCase()) {\n      case \"value\":\n      case ky2:\n        return orderY;\n      case \"z\":\n        return orderZ;\n      case \"sum\":\n        return orderSum;\n      case \"appearance\":\n        return orderAppearance;\n      case \"inside-out\":\n        return orderInsideOut;\n    }\n    return orderFunction(field(order));\n  }\n  if (typeof order === \"function\")\n    return orderFunction(order);\n  if (Array.isArray(order))\n    return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\nfunction orderY(data, X3, Y3) {\n  return Y3;\n}\nfunction orderZ(order, X3, Y3, Z) {\n  return Z;\n}\nfunction orderSum(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => sum(I, (i) => Y3[i]), (i) => Z[i]));\n}\nfunction orderAppearance(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => X3[greatest(I, (i) => Y3[i])], (i) => Z[i]));\n}\nfunction orderInsideOut(data, X3, Y3, Z) {\n  const I = range4(data);\n  const K2 = groupSort(I, (I2) => X3[greatest(I2, (i) => Y3[i])], (i) => Z[i]);\n  const sums = rollup(I, (I2) => sum(I2, (i) => Y3[i]), (i) => Z[i]);\n  const Kp = [], Kn = [];\n  let s2 = 0;\n  for (const k2 of K2) {\n    if (s2 < 0) {\n      s2 += sums.get(k2);\n      Kp.push(k2);\n    } else {\n      s2 -= sums.get(k2);\n      Kn.push(k2);\n    }\n  }\n  return orderZDomain(Z, Kn.reverse().concat(Kp));\n}\nfunction orderFunction(f) {\n  return (data) => valueof(data, f);\n}\nfunction orderGiven(domain) {\n  return (data, X3, Y3, Z) => orderZDomain(Z, domain);\n}\nfunction orderZDomain(Z, domain) {\n  if (!Z)\n    throw new Error(\"missing channel: z\");\n  domain = new InternMap(domain.map((d, i) => [d, i]));\n  return Z.map((z) => domain.get(z));\n}\nfunction applyOrder(stacks, O) {\n  for (const stack2 of stacks) {\n    stack2.sort((i, j) => ascendingDefined2(O[i], O[j]));\n  }\n}\n\n// node_modules/@observablehq/plot/dist/marks/area.js\nvar defaults5 = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Area = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, z, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults5);\n    this.z = z;\n    this.curve = Curve(curve, tension);\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call((g) => g.selectAll().data(groupIndex(index3, [X13, Y13, X23, Y23], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(\"d\", area_default5().curve(this.curve).defined((i) => i >= 0).x0((i) => X13[i]).y0((i) => Y13[i]).x1((i) => X23[i]).y1((i) => Y23[i]))).node();\n  }\n};\nfunction area(data, options) {\n  if (options === void 0)\n    return areaY(data, { x: first, y: second2 });\n  return new Area(data, options);\n}\nfunction areaX(data, options) {\n  const { y: y4 = indexOf, ...rest } = maybeDenseIntervalY(options);\n  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y4, y2: void 0 })));\n}\nfunction areaY(data, options) {\n  const { x: x4 = indexOf, ...rest } = maybeDenseIntervalX(options);\n  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x4, x2: void 0 })));\n}\n\n// node_modules/@observablehq/plot/dist/marks/marker.js\nfunction markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {\n  mark.markerStart = maybeMarker(markerStart);\n  mark.markerMid = maybeMarker(markerMid);\n  mark.markerEnd = maybeMarker(markerEnd);\n}\nfunction maybeMarker(marker) {\n  if (marker == null || marker === false)\n    return null;\n  if (marker === true)\n    return markerCircleFill;\n  if (typeof marker === \"function\")\n    return marker;\n  switch (`${marker}`.toLowerCase()) {\n    case \"none\":\n      return null;\n    case \"arrow\":\n      return markerArrow;\n    case \"dot\":\n      return markerDot;\n    case \"circle\":\n    case \"circle-fill\":\n      return markerCircleFill;\n    case \"circle-stroke\":\n      return markerCircleStroke;\n  }\n  throw new Error(`invalid marker: ${marker}`);\n}\nfunction markerArrow(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"orient\", \"auto\").attr(\"fill\", \"none\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).attr(\"stroke-linecap\", \"round\").attr(\"stroke-linejoin\", \"round\").call((marker) => marker.append(\"path\").attr(\"d\", \"M-1.5,-3l3,3l-3,3\")).node();\n}\nfunction markerDot(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"none\").call((marker) => marker.append(\"circle\").attr(\"r\", 2.5)).node();\n}\nfunction markerCircleFill(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"white\").attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nfunction markerCircleStroke(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", \"white\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nvar nextMarkerId = 0;\nfunction applyMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && ((i) => S[i]));\n}\nfunction applyGroupedMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && (([i]) => S[i]));\n}\nfunction applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke) {\n  const iriByMarkerColor = /* @__PURE__ */ new Map();\n  function applyMarker(marker) {\n    return function(i) {\n      const color3 = strokeof(i);\n      let iriByColor = iriByMarkerColor.get(marker);\n      if (!iriByColor)\n        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());\n      let iri = iriByColor.get(color3);\n      if (!iri) {\n        const context = { document: this.ownerDocument };\n        const node = this.parentNode.insertBefore(marker(color3, context), this);\n        const id2 = `plot-marker-${++nextMarkerId}`;\n        node.setAttribute(\"id\", id2);\n        iriByColor.set(color3, iri = `url(#${id2})`);\n      }\n      return iri;\n    };\n  }\n  if (markerStart)\n    path2.attr(\"marker-start\", applyMarker(markerStart));\n  if (markerMid)\n    path2.attr(\"marker-mid\", applyMarker(markerMid));\n  if (markerEnd)\n    path2.attr(\"marker-end\", applyMarker(markerEnd));\n}\n\n// node_modules/@observablehq/plot/dist/marks/link.js\nvar defaults6 = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Link = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults6);\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", curve === curveAuto && context.projection ? sphereLink(context.projection, X13, Y13, X23, Y23) : (i) => {\n      const p = pathRound();\n      const c6 = curve(p);\n      c6.lineStart();\n      c6.point(X13[i], Y13[i]);\n      c6.point(X23[i], Y23[i]);\n      c6.lineEnd();\n      return p;\n    }).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels)).node();\n  }\n};\nfunction sphereLink(projection2, X13, Y13, X23, Y23) {\n  const path2 = path_default(projection2);\n  X13 = coerceNumbers(X13);\n  Y13 = coerceNumbers(Y13);\n  X23 = coerceNumbers(X23);\n  Y23 = coerceNumbers(Y23);\n  return (i) => path2({\n    type: \"LineString\",\n    coordinates: [\n      [X13[i], Y13[i]],\n      [X23[i], Y23[i]]\n    ]\n  });\n}\nfunction link3(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Link(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\nfunction maybeSameValue(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [x22];\n    } else {\n      if (x22 === void 0)\n        return [x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/marks/arrow.js\nvar defaults7 = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\nvar Arrow = class extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1: x12,\n      y1: y12,\n      x2: x22,\n      y2: y22,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8,\n      // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset\n    } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults7);\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13, SW } = channels;\n    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;\n    const sw = SW ? (i) => SW[i] : constant2(strokeWidth === void 0 ? 1 : strokeWidth);\n    const bendAngle = bend * radians3;\n    const wingAngle = headAngle * radians3 / 2;\n    const wingScale = headLength / 1.5;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => {\n      let x12 = X13[i], y12 = Y13[i], x22 = X23[i], y22 = Y23[i];\n      const lineLength = Math.hypot(x22 - x12, y22 - y12);\n      if (lineLength <= insetStart + insetEnd)\n        return null;\n      let lineAngle = Math.atan2(y22 - y12, x22 - x12);\n      const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);\n      const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n      if (insetStart || insetEnd) {\n        if (r < 1e5) {\n          const sign3 = Math.sign(bendAngle);\n          const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r, sign3);\n          if (insetStart) {\n            [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));\n          }\n          if (insetEnd) {\n            const [x5, y5] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign3 * Math.sign(insetEnd));\n            lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);\n            x22 = x5, y22 = y5;\n          }\n        } else {\n          const dx = x22 - x12, dy = y22 - y12, d = Math.hypot(dx, dy);\n          if (insetStart)\n            x12 += dx / d * insetStart, y12 += dy / d * insetStart;\n          if (insetEnd)\n            x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;\n        }\n      }\n      const endAngle = lineAngle + bendAngle;\n      const leftAngle = endAngle + wingAngle;\n      const rightAngle = endAngle - wingAngle;\n      const x32 = x22 - headLength2 * Math.cos(leftAngle);\n      const y32 = y22 - headLength2 * Math.sin(leftAngle);\n      const x4 = x22 - headLength2 * Math.cos(rightAngle);\n      const y4 = y22 - headLength2 * Math.sin(rightAngle);\n      return `M${x12},${y12}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x4},${y4}`;\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction pointPointCenter([ax, ay], [bx, by], r, sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const k2 = sign3 * Math.sqrt(r * r - d * d / 4) / d;\n  return [(ax + bx) / 2 - dy * k2, (ay + by) / 2 + dx * k2];\n}\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const x4 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y4 = sign3 * Math.sqrt(ar * ar - x4 * x4);\n  return [ax + (dx * x4 + dy * y4) / d, ay + (dy * x4 - dx * y4) / d];\n}\nfunction arrow(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Arrow(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/dot.js\nvar defaults8 = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\nfunction withDefaultSort(options) {\n  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: \"r\", order: \"descending\" }, options) : options;\n}\nvar Dot = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r, rotate, symbol: symbol2 = circle_default3, frameAnchor } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);\n    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true },\n      rotate: { value: vrotate, optional: true },\n      symbol: { value: vsymbol, scale: \"auto\", optional: true }\n    }, withDefaultSort(options), defaults8);\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    const { channels } = this;\n    const { symbol: symbolChannel } = channels;\n    if (symbolChannel) {\n      const { fill: fillChannel, stroke: strokeChannel } = channels;\n      symbolChannel.hint = {\n        fill: fillChannel ? fillChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.fill,\n        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.stroke\n      };\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, r: R, rotate: A5, symbol: S } = channels;\n    const { r, rotate, symbol: symbol2 } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const circle2 = this.symbol === circle_default3;\n    const size = R ? void 0 : r * r * Math.PI;\n    if (negative(r))\n      index3 = [];\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(circle2 ? \"circle\" : \"path\").call(applyDirectStyles, this).call(circle2 ? (selection2) => {\n      selection2.attr(\"cx\", X3 ? (i) => X3[i] : cx).attr(\"cy\", Y3 ? (i) => Y3[i] : cy).attr(\"r\", R ? (i) => R[i] : r);\n    } : (selection2) => {\n      selection2.attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}`).attr(\"d\", R && S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : R ? (i) => {\n        const p = pathRound();\n        symbol2.draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, size);\n        return p;\n      } : (() => {\n        const p = pathRound();\n        symbol2.draw(p, size);\n        return p;\n      })());\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction dot(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Dot(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction dotX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction dotY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction circle(data, options) {\n  return dot(data, { ...options, symbol: \"circle\" });\n}\nfunction hexagon(data, options) {\n  return dot(data, { ...options, symbol: \"hexagon\" });\n}\n\n// node_modules/@observablehq/plot/dist/marks/line.js\nvar defaults9 = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Line = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults9);\n    this.z = z;\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  filter(index3) {\n    return index3;\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(groupIndex(index3, [X3, Y3], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels).attr(\"d\", curve === curveAuto && context.projection ? sphereLine(context.projection, X3, Y3) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i]))).node();\n  }\n};\nfunction sphereLine(projection2, X3, Y3) {\n  const path2 = path_default(projection2);\n  X3 = coerceNumbers(X3);\n  Y3 = coerceNumbers(Y3);\n  return (I) => {\n    let line2 = [];\n    const lines = [line2];\n    for (const i of I) {\n      if (i === -1) {\n        line2 = [];\n        lines.push(line2);\n      } else {\n        line2.push([X3[i], Y3[i]]);\n      }\n    }\n    return path2({ type: \"MultiLineString\", coordinates: lines });\n  };\n}\nfunction line(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Line(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction lineX(data, options = {}) {\n  const { x: x4 = identity6, y: y4 = indexOf, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4 }));\n}\nfunction lineY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4 }));\n}\n\n// node_modules/@observablehq/plot/dist/marks/bar.js\nvar AbstractBar = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    super(data, channels, options, defaults21);\n    const { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", this._x(scales, channels, dimensions)).attr(\"width\", this._width(scales, channels, dimensions)).attr(\"y\", this._y(scales, channels, dimensions)).attr(\"height\", this._height(scales, channels, dimensions)).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n  _x(scales, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _y(scales, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _width({ x: x4 }, { x: X3 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    const bandwidth = X3 && x4 ? x4.bandwidth() : width - marginRight - marginLeft;\n    return Math.max(0, bandwidth - insetLeft - insetRight);\n  }\n  _height({ y: y4 }, { y: Y3 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    const bandwidth = Y3 && y4 ? y4.bandwidth() : height - marginTop - marginBottom;\n    return Math.max(0, bandwidth - insetTop - insetBottom);\n  }\n};\nvar defaults10 = {\n  ariaLabel: \"bar\"\n};\nvar BarX = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4 } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      x2: { value: x22, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, 0, 0);\n  }\n  _x({ x: x4 }, { x1: X13, x2: X23 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return isCollapsed(x4) ? marginLeft + insetLeft : (i) => Math.min(X13[i], X23[i]) + insetLeft;\n  }\n  _width({ x: x4 }, { x1: X13, x2: X23 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    return isCollapsed(x4) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight);\n  }\n};\nvar BarY = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22 } = options;\n    super(data, {\n      y1: { value: y12, scale: \"y\" },\n      y2: { value: y22, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, 0);\n  }\n  _y({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop }) {\n    const { insetTop } = this;\n    return isCollapsed(y4) ? marginTop + insetTop : (i) => Math.min(Y13[i], Y23[i]) + insetTop;\n  }\n  _height({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    return isCollapsed(y4) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y23[i] - Y13[i]) - insetTop - insetBottom);\n  }\n};\nfunction barX(data, options = { y: indexOf, x2: identity6 }) {\n  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));\n}\nfunction barY(data, options = { x: indexOf, y2: identity6 }) {\n  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/rect.js\nvar defaults11 = {\n  ariaLabel: \"rect\"\n};\nvar Rect = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults11);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x1: X13, y1: Y13, x2: X23, y2: Y23 } = channels;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { projection: projection2 } = context;\n    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X13 && X23 && x4, y: Y13 && Y23 && y4 }, 0, 0).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.min(X13[i], X23[i]) + insetLeft : marginLeft + insetLeft).attr(\"y\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.min(Y13[i], Y23[i]) + insetTop : marginTop + insetTop).attr(\"width\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft).attr(\"height\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.max(0, Math.abs(Y13[i] - Y23[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction rect(data, options) {\n  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));\n}\nfunction rectX(data, options = { y: indexOf, interval: 1, x2: identity6 }) {\n  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));\n}\nfunction rectY(data, options = { x: indexOf, interval: 1, y2: identity6 }) {\n  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/cell.js\nvar defaults12 = {\n  ariaLabel: \"cell\"\n};\nvar Cell = class extends AbstractBar {\n  constructor(data, { x: x4, y: y4, ...options } = {}) {\n    super(data, {\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults12);\n  }\n  _transform(selection2, mark) {\n    selection2.call(applyTransform, mark, {}, 0, 0);\n  }\n};\nfunction cell(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Cell(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction cellX(data, options = {}) {\n  let { x: x4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, x: x4, fill, stroke });\n}\nfunction cellY(data, options = {}) {\n  let { y: y4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, y: y4, fill, stroke });\n}\n\n// node_modules/@observablehq/plot/dist/marks/auto.js\nfunction autoSpec(data, options) {\n  options = normalizeOptions(options);\n  let {\n    fx,\n    fy,\n    x: { value: xValue, reduce: xReduce, zero: xZero, ...xOptions },\n    y: { value: yValue, reduce: yReduce, zero: yZero, ...yOptions },\n    color: { value: colorValue, color: colorColor, reduce: colorReduce },\n    size: { value: sizeValue, reduce: sizeReduce },\n    // TODO constant radius?\n    mark\n  } = options;\n  const { x: x4, y: y4 } = options;\n  let X3, Y3;\n  if (xReduce === void 0)\n    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === void 0)\n    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n  if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3 ??= materializeValue(data, x4))) && (yValue == null || isOrdinal(Y3 ??= materializeValue(data, y4)))) {\n    sizeReduce = \"count\";\n  }\n  if (xZero === void 0)\n    xZero = isZeroReducer(xReduce) ? true : void 0;\n  if (yZero === void 0)\n    yZero = isZeroReducer(yReduce) ? true : void 0;\n  if (xValue == null && yValue == null)\n    throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null)\n    throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null)\n    throw new Error(\"reducing y requires x\");\n  if (mark === void 0) {\n    mark = sizeValue != null || sizeReduce != null ? \"dot\" : xZero || yZero || colorReduce != null ? \"bar\" : xValue != null && yValue != null ? isOrdinal(X3 ??= materializeValue(data, x4)) || isOrdinal(Y3 ??= materializeValue(data, y4)) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? \"dot\" : \"line\" : xValue != null || yValue != null ? \"rule\" : null;\n  }\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      ...xZero !== void 0 && { zero: xZero },\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      ...yZero !== void 0 && { zero: yZero },\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...colorColor !== void 0 && { color: colorColor }\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark\n  };\n}\nfunction auto(data, options) {\n  options = normalizeOptions(options);\n  const { x: x4, y: y4, color: color3, size } = options;\n  const X3 = materializeValue(data, x4);\n  const Y3 = materializeValue(data, y4);\n  const C3 = materializeValue(data, color3);\n  const S = materializeValue(data, size);\n  let { fx, fy, x: { reduce: xReduce, zero: xZero, ...xOptions }, y: { reduce: yReduce, zero: yZero, ...yOptions }, color: { color: colorColor, reduce: colorReduce }, size: { reduce: sizeReduce }, mark } = autoSpec(data, {\n    ...options,\n    x: { ...x4, value: X3 },\n    y: { ...y4, value: Y3 },\n    color: { ...color3, value: C3 },\n    size: { ...size, value: S }\n  });\n  let Z;\n  let colorMode;\n  if (mark != null) {\n    switch (`${mark}`.toLowerCase()) {\n      case \"dot\":\n        mark = dot;\n        colorMode = \"stroke\";\n        break;\n      case \"line\":\n        mark = X3 && Y3 ? line : X3 ? lineX : lineY;\n        colorMode = \"stroke\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"area\":\n        mark = yZero ? areaY : xZero || Y3 && isMonotonic(Y3) ? areaX : areaY;\n        colorMode = \"fill\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"rule\":\n        mark = X3 ? ruleX : ruleY;\n        colorMode = \"stroke\";\n        break;\n      case \"bar\":\n        mark = yZero ? isOrdinalReduced(xReduce, X3) ? barY : rectY : xZero ? isOrdinalReduced(yReduce, Y3) ? barX : rectX : isOrdinalReduced(xReduce, X3) && isOrdinalReduced(yReduce, Y3) ? cell : isOrdinalReduced(xReduce, X3) ? barY : isOrdinalReduced(yReduce, Y3) ? barX : rect;\n        colorMode = \"fill\";\n        break;\n      default:\n        throw new Error(`invalid mark: ${mark}`);\n    }\n  }\n  let markOptions = {\n    fx,\n    fy,\n    x: X3 ?? void 0,\n    y: Y3 ?? void 0,\n    [colorMode]: C3 ?? colorColor,\n    z: Z,\n    r: S ?? void 0\n    // treat null size as undefined for default constant radius\n  };\n  let transform2;\n  let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`);\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transform2 = isOrdinal(X3) ? groupX : binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transform2 = isOrdinal(Y3) ? groupY : binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X3 && Y3) {\n      transform2 = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin2;\n    } else if (X3) {\n      transform2 = isOrdinal(X3) ? groupX : binX;\n    } else if (Y3) {\n      transform2 = isOrdinal(Y3) ? groupY : binY;\n    }\n  }\n  if (transform2) {\n    if (transform2 === bin2 || transform2 === binX)\n      markOptions.x = { value: X3, ...xOptions };\n    if (transform2 === bin2 || transform2 === binY)\n      markOptions.y = { value: Y3, ...yOptions };\n    markOptions = transform2(transformOptions, markOptions);\n  }\n  if (xZero === void 0)\n    xZero = transform2 !== binX && (mark === barX || mark === areaX || mark === rectX);\n  if (yZero === void 0)\n    yZero = transform2 !== binY && (mark === barY || mark === areaY || mark === rectY);\n  const frames = fx != null || fy != null ? frame2({ strokeOpacity: 0.1 }) : null;\n  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];\n  mark = mark(data, markOptions);\n  return colorMode === \"stroke\" ? marks(frames, rules, mark) : marks(frames, mark, rules);\n}\nfunction isMonotonic(values2) {\n  let previous;\n  let previousOrder;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (previous === void 0) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign(ascending(previous, value));\n    if (!order)\n      continue;\n    if (previousOrder !== void 0 && order !== previousOrder)\n      return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\nfunction normalizeOptions({ x: x4, y: y4, color: color3, size, fx, fy, mark } = {}) {\n  if (!isOptions(x4))\n    x4 = makeOptions(x4);\n  if (!isOptions(y4))\n    y4 = makeOptions(y4);\n  if (!isOptions(color3))\n    color3 = isColor(color3) ? { color: color3 } : makeOptions(color3);\n  if (!isOptions(size))\n    size = makeOptions(size);\n  if (isOptions(fx))\n    ({ value: fx } = makeOptions(fx));\n  if (isOptions(fy))\n    ({ value: fy } = makeOptions(fy));\n  return { x: x4, y: y4, color: color3, size, fx, fy, mark };\n}\nfunction materializeValue(data, options) {\n  const V = valueof(data, options.value);\n  if (V)\n    V.label = labelof(options.value);\n  return V;\n}\nfunction makeOptions(value) {\n  return isReducer(value) ? { reduce: value } : { value };\n}\nfunction isZeroReducer(reduce2) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce2);\n}\nfunction isSelectReducer(reduce2) {\n  return /^(?:first|last|mode)$/i.test(reduce2);\n}\nfunction isOrdinalReduced(reduce2, value) {\n  return reduce2 != null && !isSelectReducer(reduce2) || !value ? false : isOrdinal(value);\n}\nfunction isReducer(reduce2) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return true;\n  if (/^p\\d{2}$/i.test(reduce2))\n    return true;\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\":\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\":\n    case \"max\":\n    case \"max-index\":\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      return true;\n  }\n  return false;\n}\nfunction isHighCardinality(value) {\n  return value ? new InternSet(value).size > value.length >> 1 : false;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/map.js\nfunction mapX(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"x\", \"x1\", \"x2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction mapY(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"y\", \"y1\", \"y2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction map5(outputs = {}, options = {}) {\n  const z = maybeZ(options);\n  const channels = Object.entries(outputs).map(([key, map6]) => {\n    const input = maybeInput(key, options);\n    if (input == null)\n      throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = column(input);\n    return { key, input, output, setOutput, map: maybeMap(map6) };\n  });\n  return {\n    ...basic(options, (data, facets) => {\n      const Z = valueof(data, z);\n      const X3 = channels.map(({ input }) => valueof(data, input));\n      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n          channels.forEach(({ map: map6 }, i) => map6.map(I, X3[i], MX[i]));\n        }\n      }\n      return { data, facets };\n    }),\n    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))\n  };\n}\nvar mapAlias = map5;\nfunction maybeMap(map6) {\n  if (map6 && typeof map6.map === \"function\")\n    return map6;\n  if (typeof map6 === \"function\")\n    return mapFunction(map6);\n  switch (`${map6}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction(rank);\n    case \"quantile\":\n      return mapFunction(rankQuantile);\n  }\n  throw new Error(`invalid map: ${map6}`);\n}\nfunction rankQuantile(V) {\n  const n = count(V) - 1;\n  return rank(V).map((r) => r / n);\n}\nfunction mapFunction(f) {\n  return {\n    map(I, S, T) {\n      const M2 = f(take(S, I));\n      if (M2.length !== I.length)\n        throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i)\n        T[I[i]] = M2[i];\n    }\n  };\n}\nvar mapCumsum = {\n  map(I, S, T) {\n    let sum5 = 0;\n    for (const i of I)\n      T[i] = sum5 += S[i];\n  }\n};\n\n// node_modules/@observablehq/plot/dist/marks/tick.js\nvar defaults13 = {\n  ariaLabel: \"tick\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar AbstractTick = class extends Mark {\n  constructor(data, channels, options) {\n    super(data, channels, options, defaults13);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", this._x1(scales, channels, dimensions)).attr(\"x2\", this._x2(scales, channels, dimensions)).attr(\"y1\", this._y1(scales, channels, dimensions)).attr(\"y2\", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar TickX = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, offset, 0);\n  }\n  _x1(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _x2(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _y1({ y: y4 }, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 && y4 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _y2({ y: y4 }, { y: Y3 }, { height, marginBottom }) {\n    const { insetBottom } = this;\n    return Y3 && y4 ? (i) => Y3[i] + y4.bandwidth() - insetBottom : height - marginBottom - insetBottom;\n  }\n};\nvar TickY = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, offset);\n  }\n  _x1({ x: x4 }, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 && x4 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _x2({ x: x4 }, { x: X3 }, { width, marginRight }) {\n    const { insetRight } = this;\n    return X3 && x4 ? (i) => X3[i] + x4.bandwidth() - insetRight : width - marginRight - insetRight;\n  }\n  _y1(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n  _y2(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n};\nfunction tickX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new TickX(data, { ...remainingOptions, x: x4 });\n}\nfunction tickY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new TickY(data, { ...remainingOptions, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/box.js\nfunction boxX(data, options = {}) {\n  const { x: x4 = { transform: (x5) => x5 }, y: y4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = y4 != null ? groupY : groupZ;\n  return marks(ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barX(data, group3({ x1: \"p25\", x2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickX(data, group3({ x: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ x: oqr }, { x: x4, y: y4, z: y4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction boxY(data, options = {}) {\n  const { y: y4 = { transform: (y5) => y5 }, x: x4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = x4 != null ? groupX : groupZ;\n  return marks(ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barY(data, group3({ y1: \"p25\", y2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickY(data, group3({ y: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ y: oqr }, { x: x4, y: y4, z: x4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction oqr(values2) {\n  const r1 = loqr1(values2);\n  const r2 = hiqr2(values2);\n  return values2.map((v2) => v2 < r1 || v2 > r2 ? v2 : NaN);\n}\nfunction loqr1(values2, value) {\n  const lo = quartile1(values2, value) * 2.5 - quartile3(values2, value) * 1.5;\n  return min(values2, (d) => d >= lo ? d : NaN);\n}\nfunction hiqr2(values2, value) {\n  const hi = quartile3(values2, value) * 2.5 - quartile1(values2, value) * 1.5;\n  return max(values2, (d) => d <= hi ? d : NaN);\n}\nfunction quartile1(values2, value) {\n  return quantile(values2, 0.25, value);\n}\nfunction quartile3(values2, value) {\n  return quantile(values2, 0.75, value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/raster.js\nvar defaults14 = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\nfunction number6(input, name) {\n  const x4 = +input;\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nfunction integer(input, name) {\n  const x4 = Math.floor(input);\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nvar AbstractRaster = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    let { width, height, x: x4, y: y4, x1: x12 = x4 == null ? 0 : void 0, y1: y12 = y4 == null ? 0 : void 0, x2: x22 = x4 == null ? width : void 0, y2: y22 = y4 == null ? height : void 0, pixelSize = defaults21.pixelSize, blur: blur3 = 0, interpolate } = options;\n    if (width != null)\n      width = integer(width, \"width\");\n    if (height != null)\n      height = integer(height, \"height\");\n    if (x12 != null)\n      x12 = number6(x12, \"x1\");\n    if (y12 != null)\n      y12 = number6(y12, \"y1\");\n    if (x22 != null)\n      x22 = number6(x22, \"x2\");\n    if (y22 != null)\n      y22 = number6(y22, \"y2\");\n    if (x4 == null && (x12 == null || x22 == null))\n      throw new Error(\"missing x\");\n    if (y4 == null && (y12 == null || y22 == null))\n      throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      if (x4 === void 0 && x12 != null && x22 != null)\n        x4 = denseX(x12, x22, width, height);\n      if (y4 === void 0 && y12 != null && y22 != null)\n        y4 = denseY(y12, y22, width, height);\n    }\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12 == null ? null : [x12], scale: \"x\", optional: true, filter: null },\n      y1: { value: y12 == null ? null : [y12], scale: \"y\", optional: true, filter: null },\n      x2: { value: x22 == null ? null : [x22], scale: \"x\", optional: true, filter: null },\n      y2: { value: y22 == null ? null : [y22], scale: \"y\", optional: true, filter: null },\n      ...channels\n    }, options, defaults21);\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number6(pixelSize, \"pixelSize\");\n    this.blur = number6(blur3, \"blur\");\n    this.interpolate = x4 == null || y4 == null ? null : maybeInterpolate(interpolate);\n  }\n};\nvar Raster = class extends AbstractRaster {\n  constructor(data, options = {}) {\n    const { imageRendering } = options;\n    if (data == null) {\n      const { fill, fillOpacity } = options;\n      if (maybeNumberChannel(fillOpacity)[0] !== void 0)\n        options = sampler(\"fillOpacity\", options);\n      if (maybeColorChannel(fill)[0] !== void 0)\n        options = sampler(\"fill\", options);\n    }\n    super(data, void 0, options, defaults14);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, { color: color3, ...scales }, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const color3 = scales.color ?? ((x4) => x4);\n    const { x: X3, y: Y3 } = channels;\n    const { document: document2 } = context;\n    const [x12, y12, x22, y22] = renderBounds(channels, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const n = w * h;\n    let { fill: F, fillOpacity: FO } = channels;\n    let offset2 = 0;\n    if (this.interpolate) {\n      const kx2 = w / dx;\n      const ky2 = h / dy;\n      const IX = map4(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map4(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      if (F)\n        F = this.interpolate(index3, w, h, IX, IY, F);\n      if (FO)\n        FO = this.interpolate(index3, w, h, IX, IY, FO);\n    } else if (this.data == null && index3)\n      offset2 = index3.fi * n;\n    const canvas = document2.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image2 = context2d.createImageData(w, h);\n    const imageData = image2.data;\n    let { r, g, b } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };\n    let a4 = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color3(F[i + offset2]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({ r, g, b } = rgb(fi));\n      }\n      if (FO)\n        a4 = FO[i + offset2] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a4;\n    }\n    if (this.blur > 0)\n      blurImage(image2, this.blur);\n    context2d.putImageData(image2, 0, 0);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g2) => g2.append(\"image\").attr(\"transform\", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr(\"width\", Math.abs(dx)).attr(\"height\", Math.abs(dy)).attr(\"preserveAspectRatio\", \"none\").call(applyAttr, \"image-rendering\", this.imageRendering).call(applyDirectStyles, this).attr(\"xlink:href\", canvas.toDataURL())).node();\n  }\n};\nfunction maybeTuples(k2, data, options) {\n  if (arguments.length < 3)\n    options = data, data = null;\n  let { x: x4, y: y4, [k2]: z, ...rest } = options;\n  if (x4 === void 0 && y4 === void 0 && isTuples(data)) {\n    x4 = first, y4 = second2;\n    if (z === void 0)\n      z = third;\n  }\n  return [data, { ...rest, x: x4, y: y4, [k2]: z }];\n}\nfunction raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(data, data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity6 });\n}\nfunction renderBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, dimensions, { projection: projection2 }) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return [\n    x12 && projection2 == null ? x12[0] : marginLeft,\n    y12 && projection2 == null ? y12[0] : marginTop,\n    x22 && projection2 == null ? x22[0] : width - marginRight,\n    y22 && projection2 == null ? y22[0] : height - marginBottom\n  ];\n}\nfunction rasterBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, scales, dimensions, context) {\n  const channels = {};\n  if (x12)\n    channels.x1 = x12;\n  if (y12)\n    channels.y1 = y12;\n  if (x22)\n    channels.x2 = x22;\n  if (y22)\n    channels.y2 = y22;\n  return renderBounds(valueObject(channels, scales), dimensions, context);\n}\nfunction sampler(name, options = {}) {\n  const { [name]: value } = options;\n  if (typeof value !== \"function\")\n    throw new Error(`invalid ${name}: not a function`);\n  return initializer({ ...options, [name]: void 0 }, function(data, facets, channels, scales, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    if (!x4)\n      throw new Error(\"missing scale: x\");\n    if (!y4)\n      throw new Error(\"missing scale: y\");\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2 } = this;\n    const { width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = options;\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx2 = dx / w;\n    const ky2 = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [void 0]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x4.invert(x12 + xi * kx2), y4.invert(y12 + yi * ky2), facet);\n        }\n      }\n    }\n    return { data: V, facets, channels: { [name]: { value: V, scale: true } } };\n  });\n}\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\")\n    return interpolate;\n  if (interpolate == null)\n    return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\nfunction interpolateNone(index3, width, height, X3, Y3, V) {\n  const W = new Array(width * height);\n  for (const i of index3) {\n    if (X3[i] < 0 || X3[i] >= width || Y3[i] < 0 || Y3[i] >= height)\n      continue;\n    W[Math.floor(Y3[i]) * width + Math.floor(X3[i])] = V[i];\n  }\n  return W;\n}\nfunction interpolatorBarycentric({ random = lcg(42) } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const n = index3.length;\n    const nw = width >> 2;\n    const nh = (height >> 2) - 1;\n    const m3 = n + nw * 2 + nh * 2;\n    const XY2 = new Float64Array(m3 * 2);\n    for (let i2 = 0; i2 < n; ++i2)\n      XY2[i2 * 2] = X3[index3[i2]], XY2[i2 * 2 + 1] = Y3[index3[i2]];\n    let i = n;\n    const addPoint = (x4, y4) => (XY2[i * 2] = x4, XY2[i * 2 + 1] = y4, i++);\n    for (let j = 0; j <= nw; ++j)\n      addPoint(j / nw * width, 0), addPoint(j / nw * width, height);\n    for (let j = 0; j < nh; ++j)\n      addPoint(width, j / nh * height), addPoint(0, j / nh * height);\n    V = take(V, index3);\n    const delaunay = new Delaunay(XY2.subarray(0, n * 2));\n    for (let j = n, ij; j < m3; ++j)\n      V[j] = V[ij = delaunay.find(XY2[j * 2], XY2[j * 2 + 1], ij)];\n    const { points, triangles } = new Delaunay(XY2);\n    const W = new V.constructor(width * height);\n    const mix = mixer(V, random);\n    for (let i2 = 0; i2 < triangles.length; i2 += 3) {\n      const ta = triangles[i2];\n      const tb = triangles[i2 + 1];\n      const tc = triangles[i2 + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x12 = Math.min(Ax, Bx, Cx);\n      const x22 = Math.max(Ax, Bx, Cx);\n      const y12 = Math.min(Ay, By, Cy);\n      const y22 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z)\n        continue;\n      const va = V[ta];\n      const vb = V[tb];\n      const vc = V[tc];\n      for (let x4 = Math.floor(x12); x4 < x22; ++x4) {\n        for (let y4 = Math.floor(y12); y4 < y22; ++y4) {\n          if (x4 < 0 || x4 >= width || y4 < 0 || y4 >= height)\n            continue;\n          const xp = x4 + 0.5;\n          const yp = y4 + 0.5;\n          const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z;\n          if (ga < 0)\n            continue;\n          const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z;\n          if (gb < 0)\n            continue;\n          const gc = 1 - ga - gb;\n          if (gc < 0)\n            continue;\n          W[x4 + width * y4] = mix(va, ga, vb, gb, vc, gc, x4, y4);\n        }\n      }\n    }\n    return W;\n  };\n}\nfunction interpolateNearest(index3, width, height, X3, Y3, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n  let iy, ix;\n  for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n    ix = iy;\n    for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n      ix = delaunay.find(x4, y4, ix);\n      if (x4 === 0.5)\n        iy = ix;\n      W[k2] = V[index3[ix]];\n    }\n  }\n  return W;\n}\nfunction interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n    let iy, ix, iw;\n    for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n      ix = iy;\n      for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n        let cx = x4;\n        let cy = y4;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x4 === 0.5)\n          iy = ix;\n        let distance;\n        let step = 0;\n        while ((distance = Math.hypot(X3[index3[iw]] - cx, Y3[index3[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle2 = random(x4, y4, step) * 2 * Math.PI;\n          cx += Math.cos(angle2) * distance;\n          cy += Math.sin(angle2) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k2] = V[index3[iw]];\n      }\n    }\n    return W;\n  };\n}\nfunction blend(a4, ca3, b, cb, c6, cc2) {\n  return ca3 * a4 + cb * b + cc2 * c6;\n}\nfunction pick(random) {\n  return (a4, ca3, b, cb, c6, cc2, x4, y4) => {\n    const u4 = random(x4, y4);\n    return u4 < ca3 ? a4 : u4 < ca3 + cb ? b : c6;\n  };\n}\nfunction mixer(F, random) {\n  return isNumeric(F) || isTemporal(F) ? blend : pick(random);\n}\nfunction denseX(x12, x22, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X3 = new Float64Array(n);\n      const kx2 = (x22 - x12) / width;\n      const x06 = x12 + kx2 / 2;\n      for (let i = 0; i < n; ++i)\n        X3[i] = i % width * kx2 + x06;\n      return X3;\n    }\n  };\n}\nfunction denseY(y12, y22, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y3 = new Float64Array(n);\n      const ky2 = (y22 - y12) / height;\n      const y06 = y12 + ky2 / 2;\n      for (let i = 0; i < n; ++i)\n        Y3[i] = Math.floor(i / width) % height * ky2 + y06;\n      return Y3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/contour.js\nvar defaults15 = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\nvar Contour = class extends AbstractRaster {\n  constructor(data, { smooth = true, value, ...options } = {}) {\n    const channels = styles({}, options, defaults15);\n    if (value === void 0) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== void 0)\n            throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n    if (value != null) {\n      const v2 = { transform: (D3) => D3.map((d) => d.value), label: labelof(value) };\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v2;\n        }\n      }\n    }\n    if (data == null) {\n      if (value == null)\n        throw new Error(\"missing contour value\");\n      options = sampler(\"value\", { value, ...options });\n      value = null;\n    } else {\n      let { interpolate } = options;\n      if (value === void 0)\n        value = identity6;\n      if (interpolate === void 0)\n        options.interpolate = \"nearest\";\n    }\n    super(data, { value: { value, optional: true } }, contourGeometry(options), defaults15);\n    const contourChannels = { geometry: { value: identity6 } };\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const { scale: scale3 } = channel;\n      if (scale3 === \"x\" || scale3 === \"y\" || key === \"value\")\n        continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index3, { x: x4, y: y4, value, ...channels }, values2) {\n    return super.filter(index3, channels, values2);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G } = channels;\n    const path2 = path_default();\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction contourGeometry({ thresholds, interval: interval2, ...options }) {\n  thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const kx2 = w / dx;\n    const ky2 = h / dy;\n    const V = channels.value.value;\n    const VV = [];\n    if (this.interpolate) {\n      const { x: X3, y: Y3 } = Position(channels, scales, context);\n      const IX = map2(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map2(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index3 = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index3, w, h, IX, IY, V));\n      }\n    } else if (facets) {\n      const n = w * h;\n      const m3 = facets.length;\n      for (let i = 0; i < m3; ++i)\n        VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n    if (this.blur > 0)\n      for (const V2 of VV)\n        blur2({ data: V2, width: w, height: h }, this.blur);\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null)\n      throw new Error(`unsupported thresholds: ${thresholds}`);\n    const { contour: contour2 } = contours_default().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V2 of VV)\n      contourFacets.push(range(contourData.length, contourData.push(...T.map((t) => contour2(V2, t)))));\n    for (const { coordinates: coordinates2 } of contourData) {\n      for (const rings of coordinates2) {\n        for (const ring of rings) {\n          for (const point6 of ring) {\n            point6[0] = point6[0] / kx2 + x12;\n            point6[1] = point6[1] / ky2 + y12;\n          }\n        }\n      }\n    }\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: Channels(this.contourChannels, contourData)\n    };\n  });\n}\nfunction maybeTicks(thresholds, V, min4, max5) {\n  if (typeof thresholds?.range === \"function\")\n    return thresholds.range(thresholds.floor(min4), max5);\n  if (typeof thresholds === \"function\")\n    thresholds = thresholds(V, min4, max5);\n  if (typeof thresholds !== \"number\")\n    return arrayify2(thresholds, Array);\n  const tz = ticks(...nice(min4, max5, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max5)\n    tz.pop();\n  while (tz[1] < min4)\n    tz.shift();\n  return tz;\n}\nfunction contour() {\n  return new Contour(...maybeTuples(\"value\", ...arguments));\n}\nfunction finiteExtent(VV) {\n  return [min(VV, (V) => min(V, finite3)), max(VV, (V) => max(V, finite3))];\n}\nfunction finite3(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/marks/delaunay.js\nvar delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\nvar voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar DelaunayLink = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, delaunayLinkDefaults);\n    this.curve = Curve(curve, tension);\n    markers(this, options);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { curve } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function links(index4) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k2 in channels)\n        newChannels[k2] = [];\n      const X13 = [];\n      const X23 = [];\n      const Y13 = [];\n      const Y23 = [];\n      function link4(ti, tj) {\n        ti = index4[ti];\n        tj = index4[tj];\n        newIndex.push(++i);\n        X13[i] = xi(ti);\n        Y13[i] = yi(ti);\n        X23[i] = xi(tj);\n        Y23[i] = yi(tj);\n        for (const k2 in channels)\n          newChannels[k2].push(channels[k2][tj]);\n      }\n      const { halfedges, hull: hull2, triangles } = Delaunay.from(index4, xi, yi);\n      for (let i2 = 0; i2 < halfedges.length; ++i2) {\n        const j = halfedges[i2];\n        if (j > i2)\n          link4(triangles[i2], triangles[j]);\n      }\n      for (let i2 = 0; i2 < hull2.length; ++i2) {\n        link4(hull2[i2], hull2[(i2 + 1) % hull2.length]);\n      }\n      select_default2(this).selectAll().data(newIndex).join(\"path\").call(applyDirectStyles, mark).attr(\"d\", (i2) => {\n        const p = pathRound();\n        const c6 = curve(p);\n        c6.lineStart();\n        c6.point(X13[i2], Y13[i2]);\n        c6.point(X23[i2], Y23[i2]);\n        c6.lineEnd();\n        return p;\n      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(links) : (g) => g.datum(index3).each(links)).node();\n  }\n};\nvar AbstractDelaunayMark = class extends Mark {\n  constructor(data, options = {}, defaults21, zof = ({ z }) => z) {\n    const { x: x4, y: y4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: zof(options), optional: true }\n    }, options, defaults21);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function mesh(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      select_default2(this).append(\"path\").datum(index4[0]).call(applyDirectStyles, mark).attr(\"d\", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(mesh) : (g) => g.datum(index3).each(mesh)).node();\n  }\n};\nvar DelaunayMesh = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n};\nvar Hull = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n};\nvar Voronoi2 = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, voronoiDefaults);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function cells(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      const voronoi2 = voronoiof(delaunay, dimensions);\n      select_default2(this).selectAll().data(index4).enter().append(\"path\").call(applyDirectStyles, mark).attr(\"d\", (_, i) => voronoi2.renderCell(i)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(cells) : (g) => g.datum(index3).each(cells)).node();\n  }\n};\nvar VoronoiMesh = class extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n};\nfunction voronoiof(delaunay, dimensions) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\nfunction delaunayMark(DelaunayMark, data, { x: x4, y: y4, ...options } = {}) {\n  [x4, y4] = maybeTuple(x4, y4);\n  return new DelaunayMark(data, { ...options, x: x4, y: y4 });\n}\nfunction delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\nfunction delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\nfunction hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\nfunction voronoi(data, options) {\n  return delaunayMark(Voronoi2, data, options);\n}\nfunction voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/density.js\nvar defaults16 = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Density = class extends Mark {\n  constructor(data, { x: x4, y: y4, z, weight, fill, stroke, ...options } = {}) {\n    const fillDensity = isDensity(fill) && (fill = \"currentColor\", true);\n    const strokeDensity = isDensity(stroke) && (stroke = \"currentColor\", true);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: maybeZ({ z, fill, stroke }), optional: true },\n      weight: { value: weight, optional: true }\n    }, densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity), defaults16);\n    if (fillDensity)\n      this.fill = void 0;\n    if (strokeDensity)\n      this.stroke = void 0;\n    this.z = z;\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { contours } = channels;\n    const path2 = path_default();\n    return create_default(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", (i) => path2(contours[i]))).node();\n  }\n};\nfunction density(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Density(data, { ...remainingOptions, x: x4, y: y4 });\n}\nvar dropChannels = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\", \"weight\"]);\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k2 = 100;\n  let { bandwidth, thresholds } = options;\n  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;\n  thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === \"function\" ? coerceNumbers(thresholds) : +thresholds;\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const { z } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const { width, height } = dimensions;\n    const { x: X3, y: Y3 } = Position(channels, scales, context);\n    const newChannels = Object.fromEntries(Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }]));\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n    const density2 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index3 of Z ? groupZ2(facet, Z, z) : [facet]) {\n        const contour2 = density2.contours(index3);\n        facetContours.push([index3, contour2]);\n      }\n    }\n    let T = thresholds;\n    if (!isTypedArray(T)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour2] of facetContours) {\n          const max5 = contour2.max;\n          if (max5 > maxValue)\n            maxValue = max5;\n        }\n      }\n      T = Float64Array.from({ length: thresholds - 1 }, (_, i) => maxValue * k2 * (i + 1) / thresholds);\n    }\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index3, contour2] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour2(t / k2));\n          if (FD)\n            FD.push(t);\n          if (SD)\n            SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index3[0]]);\n          }\n        }\n      }\n    }\n    if (FD)\n      FD.push(0);\n    if (SD)\n      SD.push(0);\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...FD && { fill: { value: FD, scale: \"color\" } },\n        ...SD && { stroke: { value: SD, scale: \"color\" } },\n        contours: { value: contours }\n      }\n    };\n  });\n}\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/geo.js\nvar defaults17 = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Geo = class extends Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = maybeNumberChannel(options.r, 3);\n    super(data, {\n      geometry: { value: options.geometry },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true }\n    }, withDefaultSort(options), defaults17);\n    this.r = cr;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G, r: R } = channels;\n    const path2 = path_default(context.projection ?? scaleProjection2(scales));\n    const { r } = this;\n    if (negative(r))\n      index3 = [];\n    else if (r !== void 0)\n      path2.pointRadius(r);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", R ? (i) => path2.pointRadius(R[i])(G[i]) : (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction scaleProjection2({ x: X3, y: Y3 }) {\n  if (X3 || Y3) {\n    X3 ??= (x4) => x4;\n    Y3 ??= (y4) => y4;\n    return transform_default({\n      point(x4, y4) {\n        this.stream.point(X3(x4), Y3(y4));\n      }\n    });\n  }\n}\nfunction geo(data, { geometry = identity6, ...options } = {}) {\n  switch (data?.type) {\n    case \"FeatureCollection\":\n      data = data.features;\n      break;\n    case \"GeometryCollection\":\n      data = data.geometries;\n      break;\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      data = [data];\n      break;\n  }\n  return new Geo(data, { geometry, ...options });\n}\nfunction sphere({ strokeWidth = 1.5, ...options } = {}) {\n  return geo({ type: \"Sphere\" }, { strokeWidth, ...options });\n}\nfunction graticule2({ strokeOpacity = 0.1, ...options } = {}) {\n  return geo(graticule10(), { strokeOpacity, ...options });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/hexbin.js\nvar ox = 0.5;\nvar oy = 0;\nfunction hexbin(outputs = { fill: \"count\" }, { binWidth, ...options } = {}) {\n  binWidth = binWidth === void 0 ? 20 : number5(binWidth);\n  outputs = maybeOutputs(outputs, options);\n  const { z, fill, stroke } = options;\n  if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, \"fill\"))\n    options.stroke = \"none\";\n  if (options.symbol === void 0)\n    options.symbol = \"hexagon\";\n  if (options.r === void 0 && !hasOutput(outputs, \"r\"))\n    options.r = binWidth / 2;\n  return initializer(options, (data, facets, channels, scales, _, context) => {\n    let { x: X3, y: Y3, z: Z, fill: F, stroke: S, symbol: Q } = channels;\n    if (X3 === void 0)\n      throw new Error(\"missing channel: x\");\n    if (Y3 === void 0)\n      throw new Error(\"missing channel: y\");\n    ({ x: X3, y: Y3 } = Position(channels, scales, context));\n    Z = Z ? Z.value : valueof(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n    const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S, symbol: Q });\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs)\n      o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs)\n        o.scope(\"facet\", facet);\n      for (const [f, I] of maybeGroup(facet, G)) {\n        for (const bin3 of hbin(I, X3, Y3, binWidth)) {\n          binFacet.push(++i);\n          BX.push(bin3.x);\n          BY.push(bin3.y);\n          if (Z)\n            GZ.push(G === Z ? f : Z[bin3[0]]);\n          if (F)\n            GF.push(G === F ? f : F[bin3[0]]);\n          if (S)\n            GS.push(G === S ? f : S[bin3[0]]);\n          if (Q)\n            GQ.push(G === Q ? f : Q[bin3[0]]);\n          for (const o of outputs)\n            o.reduce(bin3);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n    const binChannels = {\n      x: { value: BX },\n      y: { value: BY },\n      ...Z && { z: { value: GZ } },\n      ...F && { fill: { value: GF, scale: true } },\n      ...S && { stroke: { value: GS, scale: true } },\n      ...Q && { symbol: { value: GQ, scale: true } },\n      ...Object.fromEntries(outputs.map(({ name, output }) => [\n        name,\n        { scale: true, radius: name === \"r\" ? binWidth / 2 : void 0, value: output.transform() }\n      ]))\n    };\n    return { data, facets: binFacets, channels: binChannels };\n  });\n}\nfunction hbin(I, X3, Y3, dx) {\n  const dy = dx * (1.5 / sqrt35);\n  const bins = /* @__PURE__ */ new Map();\n  for (const i of I) {\n    let px = X3[i], py = Y3[i];\n    if (isNaN(px) || isNaN(py))\n      continue;\n    let pj = Math.round(py = (py - oy) / dy), pi7 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi7, pi22 = pi7 + (px < pi7 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)\n        pi7 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n    }\n    const key = `${pi7},${pj}`;\n    let bin3 = bins.get(key);\n    if (bin3 === void 0) {\n      bins.set(key, bin3 = []);\n      bin3.x = (pi7 + (pj & 1) / 2) * dx + ox;\n      bin3.y = pj * dy + oy;\n    }\n    bin3.push(i);\n  }\n  return bins.values();\n}\n\n// node_modules/@observablehq/plot/dist/marks/hexgrid.js\nvar defaults18 = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\nfunction hexgrid(options) {\n  return new Hexgrid(options);\n}\nvar Hexgrid = class extends Mark {\n  constructor({ binWidth = 20, clip = true, ...options } = {}) {\n    super(void 0, void 0, { clip, ...options }, defaults18);\n    this.binWidth = number5(binWidth);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { binWidth } = this;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const x06 = marginLeft - ox, x12 = width - marginRight - ox, y06 = marginTop - oy, y12 = height - marginBottom - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x06 / wx), i1 = Math.ceil(x12 / wx), j0 = Math.floor((y06 + hy) / wy), j1 = Math.ceil((y12 - hy) / wy) + 1, path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path2;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path2}`;\n      }\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append(\"path\").call(applyDirectStyles, this).attr(\"d\", d)).node();\n  }\n};\nfunction round(x4) {\n  return Math.round(x4 * 1e3) / 1e3;\n}\n\n// node_modules/@observablehq/plot/dist/marks/image.js\nvar defaults19 = {\n  ariaLabel: \"image\",\n  fill: null,\n  stroke: null\n};\nfunction isPath(string2) {\n  return /^\\.*\\//.test(string2);\n}\nfunction isUrl(string2) {\n  return /^(blob|data|file|http|https):/i.test(string2);\n}\nfunction maybePathChannel(value) {\n  return typeof value === \"string\" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];\n}\nvar Image2 = class extends Mark {\n  constructor(data, options = {}) {\n    let { x: x4, y: y4, width, height, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;\n    if (width === void 0 && height !== void 0)\n      width = height;\n    else if (height === void 0 && width !== void 0)\n      height = width;\n    const [vs, cs] = maybePathChannel(src);\n    const [vw, cw] = maybeNumberChannel(width, 16);\n    const [vh, ch] = maybeNumberChannel(height, 16);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      width: { value: vw, filter: positive, optional: true },\n      height: { value: vh, filter: positive, optional: true },\n      src: { value: vs, optional: true }\n    }, options, defaults19);\n    this.src = cs;\n    this.width = cw;\n    this.height = ch;\n    this.preserveAspectRatio = impliedString(preserveAspectRatio, \"xMidYMid\");\n    this.crossOrigin = string(crossOrigin);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, width: W, height: H, src: S } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"image\").call(applyDirectStyles, this).attr(\"x\", W && X3 ? (i) => X3[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X3 ? (i) => X3[i] - this.width / 2 : cx - this.width / 2).attr(\"y\", H && Y3 ? (i) => Y3[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y3 ? (i) => Y3[i] - this.height / 2 : cy - this.height / 2).attr(\"width\", W ? (i) => W[i] : this.width).attr(\"height\", H ? (i) => H[i] : this.height).call(applyAttr, \"href\", S ? (i) => S[i] : this.src).call(applyAttr, \"preserveAspectRatio\", this.preserveAspectRatio).call(applyAttr, \"crossorigin\", this.crossOrigin).call(applyAttr, \"image-rendering\", this.imageRendering).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction image(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Image2(data, { ...remainingOptions, x: x4, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/stats.js\nfunction ibetainv(p, a4, b) {\n  var EPS = 1e-8;\n  var a1 = a4 - 1;\n  var b12 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u4, err, x4, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a4 >= 1 && b >= 1) {\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x4 = -x4;\n    al = (x4 * x4 - 3) / 6;\n    h = 2 / (1 / (2 * a4 - 1) + 1 / (2 * b - 1));\n    w = x4 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a4 - 1)) * (al + 5 / 6 - 2 / (3 * h));\n    x4 = a4 / (a4 + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a4 / (a4 + b));\n    lnb = Math.log(b / (a4 + b));\n    t = Math.exp(a4 * lna) / a4;\n    u4 = Math.exp(b * lnb) / b;\n    w = t + u4;\n    if (p < t / w)\n      x4 = Math.pow(a4 * w * p, 1 / a4);\n    else\n      x4 = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -gammaln(a4) - gammaln(b) + gammaln(a4 + b);\n  for (; j < 10; j++) {\n    if (x4 === 0 || x4 === 1)\n      return x4;\n    err = ibeta(x4, a4, b) - p;\n    t = Math.exp(a1 * Math.log(x4) + b12 * Math.log(1 - x4) + afac);\n    u4 = err / t;\n    x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b12 / (1 - x4))));\n    if (x4 <= 0)\n      x4 = 0.5 * (x4 + t);\n    if (x4 >= 1)\n      x4 = 0.5 * (x4 + t + 1);\n    if (Math.abs(t) < EPS * x4 && j > 0)\n      break;\n  }\n  return x4;\n}\nfunction ibeta(x4, a4, b) {\n  var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln(a4 + b) - gammaln(a4) - gammaln(b) + a4 * Math.log(x4) + b * Math.log(1 - x4));\n  if (x4 < 0 || x4 > 1)\n    return false;\n  if (x4 < (a4 + 1) / (a4 + b + 2))\n    return bt * betacf(x4, a4, b) / a4;\n  return 1 - bt * betacf(1 - x4, b, a4) / b;\n}\nfunction betacf(x4, a4, b) {\n  var fpmin = 1e-30;\n  var m3 = 1;\n  var qab = a4 + b;\n  var qap = a4 + 1;\n  var qam = a4 - 1;\n  var c6 = 1;\n  var d = 1 - qab * x4 / qap;\n  var m22, aa2, del, h;\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n  for (; m3 <= 100; m3++) {\n    m22 = 2 * m3;\n    aa2 = m3 * (b - m3) * x4 / ((qam + m22) * (a4 + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    h *= d * c6;\n    aa2 = -(a4 + m3) * (qab + m3) * x4 / ((a4 + m22) * (qap + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    del = d * c6;\n    h *= del;\n    if (Math.abs(del - 1) < 3e-7)\n      break;\n  }\n  return h;\n}\nfunction gammaln(x4) {\n  var j = 0;\n  var cof = [\n    76.18009172947146,\n    -86.5053203294167,\n    24.01409824083091,\n    -1.231739572450155,\n    0.001208650973866179,\n    -5395239384953e-18\n  ];\n  var ser = 1.000000000190015;\n  var xx, y4, tmp2;\n  tmp2 = (y4 = xx = x4) + 5.5;\n  tmp2 -= (xx + 0.5) * Math.log(tmp2);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y4;\n  return Math.log(2.506628274631 * ser / xx) - tmp2;\n}\nfunction qt(p, dof) {\n  var x4 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n  x4 = Math.sqrt(dof * (1 - x4) / x4);\n  return p > 0.5 ? x4 : -x4;\n}\n\n// node_modules/@observablehq/plot/dist/marks/linearRegression.js\nvar defaults20 = {\n  ariaLabel: \"linear-regression\",\n  fill: \"currentColor\",\n  fillOpacity: 0.1,\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar LinearRegression = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, ci = 0.95, precision = 4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults20);\n    this.z = z;\n    this.ci = +ci;\n    this.precision = +precision;\n    if (!(0 <= this.ci && this.ci < 1))\n      throw new Error(`invalid ci; not in [0, 1): ${ci}`);\n    if (!(this.precision > 0))\n      throw new Error(`invalid precision: ${precision}`);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { ci } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(Z ? groupZ2(index3, Z, this.z) : [index3]).enter().call((enter) => enter.append(\"path\").attr(\"fill\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr(\"d\", (I) => this._renderLine(I, X3, Y3)).call(ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr(\"stroke\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {\n      ...channels,\n      stroke: null,\n      strokeOpacity: null,\n      strokeWidth: null\n    }).attr(\"d\", (I) => this._renderBand(I, X3, Y3)) : () => {\n    }))).node();\n  }\n};\nfunction pathBefore() {\n  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, \"path\"), this);\n}\nvar LinearRegressionX = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    const g = confidenceIntervalF(I, Y3, X3, (1 - ci) / 2, f);\n    return area_default5().y((y4) => y4).x0((y4) => g(y4, -1)).x1((y4) => g(y4, 1))(range(y12, y22 - precision / 2, precision).concat(y22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    return `M${f(y12)},${y12}L${f(y22)},${y22}`;\n  }\n};\nvar LinearRegressionY = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    const g = confidenceIntervalF(I, X3, Y3, (1 - ci) / 2, f);\n    return area_default5().x((x4) => x4).y0((x4) => g(x4, -1)).y1((x4) => g(x4, 1))(range(x12, x22 - precision / 2, precision).concat(x22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    return `M${x12},${f(x12)}L${x22},${f(x22)}`;\n  }\n};\nfunction linearRegressionX(data, options = {}) {\n  const { y: y4 = indexOf, x: x4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionX(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionY(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionF(I, X3, Y3) {\n  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n  for (const i of I) {\n    const xi = X3[i];\n    const yi = Y3[i];\n    sumX += xi;\n    sumY += yi;\n    sumXY += xi * yi;\n    sumX2 += xi * xi;\n  }\n  const n = I.length;\n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  return (x4) => slope * x4 + intercept;\n}\nfunction confidenceIntervalF(I, X3, Y3, p, f) {\n  const mean2 = sum(I, (i) => X3[i]) / I.length;\n  let a4 = 0, b = 0;\n  for (const i of I) {\n    a4 += (X3[i] - mean2) ** 2;\n    b += (Y3[i] - f(X3[i])) ** 2;\n  }\n  const sy = Math.sqrt(b / (I.length - 2));\n  const t = qt(p, I.length - 2);\n  return (x4, k2) => {\n    const Y4 = f(x4);\n    const se = sy * Math.sqrt(1 / I.length + (x4 - mean2) ** 2 / a4);\n    return Y4 + k2 * t * se;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/tree.js\nfunction treeNode(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    frameAnchor,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (frameAnchor === void 0)\n    frameAnchor = treeAnchor.frameAnchor;\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeNodeValue);\n  const [X3, setX] = column();\n  const [Y3, setY] = column();\n  return {\n    x: X3,\n    y: Y3,\n    frameAnchor,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X4 = setX([]);\n      const Y4 = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const node of root3.descendants()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X4, Y4);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction treeLink(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    curve = \"bump-x\",\n    stroke = \"#555\",\n    strokeWidth = 1.5,\n    strokeOpacity = 0.5,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  remainingOptions = { curve, stroke, strokeWidth, strokeOpacity, ...remainingOptions };\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeLinkValue);\n  const [X13, setX1] = column();\n  const [X23, setX2] = column();\n  const [Y13, setY1] = column();\n  const [Y23, setY2] = column();\n  return {\n    x1: X13,\n    x2: X23,\n    y1: Y13,\n    y2: Y23,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X14 = setX1([]);\n      const X24 = setX2([]);\n      const Y14 = setY1([]);\n      const Y24 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const { source, target } of root3.links()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X14, Y14);\n          treeAnchor.position(target, treeIndex, X24, Y24);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\nvar treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = y4;\n    Y3[i] = -x4;\n  }\n};\nvar treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = -y4;\n    Y3[i] = -x4;\n  }\n};\nfunction maybeTreeSort(sort3) {\n  return sort3 == null || typeof sort3 === \"function\" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith(\"node:\") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));\n}\nfunction nodeSort(value) {\n  return (a4, b) => ascendingDefined2(value(a4), value(b));\n}\nfunction nodeData(field2) {\n  return (node) => node.data?.[field2];\n}\nfunction normalizer(delimiter = \"/\") {\n  return `${delimiter}` === \"/\" ? (P) => P : (P) => P.map(replaceAll(delimiter, \"/\"));\n}\nfunction replaceAll(search, replace) {\n  search = new RegExp(regexEscape(search), \"g\");\n  return (value) => value == null ? null : `${value}`.replace(search, replace);\n}\nfunction regexEscape(string2) {\n  return `${string2}`.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isNodeValue(option) {\n  return isObject(option) && typeof option.node === \"function\";\n}\nfunction isLinkValue(option) {\n  return isObject(option) && typeof option.link === \"function\";\n}\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\"))\n    return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  if (isLinkValue(value))\n    return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\"))\n    return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\nfunction nodePath(node) {\n  return node.id;\n}\nfunction nodeName(node) {\n  return nameof(node.id);\n}\nfunction nodeDepth(node) {\n  return node.depth;\n}\nfunction nodeHeight(node) {\n  return node.height;\n}\nfunction nodeInternal(node) {\n  return !!node.children;\n}\nfunction parentValue(evaluate) {\n  return (child, parent) => parent == null ? void 0 : evaluate(parent);\n}\nfunction nameof(path2) {\n  let i = path2.length;\n  while (--i > 0)\n    if (slash2(path2, i))\n      break;\n  return path2.slice(i + 1);\n}\nfunction slash2(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\nvar output_setValues = 2;\nvar output_evaluate = 3;\nvar output_values = 4;\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== void 0) {\n      outputs.push([name, ...column(value), treeValue]);\n    }\n  }\n  return outputs;\n}\n\n// node_modules/@observablehq/plot/dist/marks/tree.js\nfunction tree(data, options = {}) {\n  let { fill, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, marker, markerStart = marker, markerEnd = marker, dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd), text: textText = \"node:name\", textStroke = \"white\", title = \"node:path\", dx, dy, ...remainingOptions } = options;\n  if (dx === void 0)\n    dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;\n  return marks(link3(data, treeLink({\n    markerStart,\n    markerEnd,\n    stroke: stroke !== void 0 ? stroke : fill === void 0 ? \"node:internal\" : fill,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    ...remainingOptions\n  })), dotDot ? dot(data, treeNode({ fill: fill === void 0 ? \"node:internal\" : fill, title, ...remainingOptions })) : null, textText != null ? text(data, treeNode({\n    text: textText,\n    fill: fill === void 0 ? \"currentColor\" : fill,\n    stroke: textStroke,\n    dx,\n    dy,\n    title,\n    ...remainingOptions\n  })) : null);\n}\nfunction cluster(data, options) {\n  return tree(data, { ...options, treeLayout: cluster_default });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/centroid.js\nfunction centroid({ geometry = identity6, ...options } = {}) {\n  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, { projection: projection2 }) => {\n    const G = valueof(data, geometry);\n    const n = G.length;\n    const X3 = new Float64Array(n);\n    const Y3 = new Float64Array(n);\n    const path2 = path_default(projection2);\n    for (let i = 0; i < n; ++i)\n      [X3[i], Y3[i]] = path2.centroid(G[i]);\n    return { data, facets, channels: { x: { value: X3 }, y: { value: Y3 } } };\n  });\n}\nfunction geoCentroid({ geometry = identity6, ...options } = {}) {\n  let C3;\n  return {\n    ...options,\n    x: { transform: (data) => Float64Array.from(C3 = valueof(valueof(data, geometry), centroid_default), ([x4]) => x4) },\n    y: { transform: () => Float64Array.from(C3, ([, y4]) => y4) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/dodge.js\nvar import_interval_tree_1d = __toESM(require_interval_tree(), 1);\nvar anchorXLeft = ({ marginLeft }) => [1, marginLeft];\nvar anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];\nvar anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];\nvar anchorYTop = ({ marginTop }) => [1, marginTop];\nvar anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];\nvar anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];\nfunction maybeAnchor2(anchor) {\n  return typeof anchor === \"string\" ? { anchor } : anchor;\n}\nfunction dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"left\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, number5(padding), options);\n}\nfunction dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"bottom\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, number5(padding), options);\n}\nfunction mergeOptions3(options) {\n  const { anchor, padding, ...rest } = options;\n  return [{ anchor, padding }, rest];\n}\nfunction dodge(y4, x4, anchor, padding, options) {\n  const { r } = options;\n  if (r != null && typeof r !== \"number\") {\n    const { channels, sort: sort3, reverse: reverse3 } = options;\n    options = { ...options, channels: { r: { value: r, scale: \"r\" }, ...maybeNamed(channels) } };\n    if (sort3 === void 0 && reverse3 === void 0)\n      options.sort = { channel: \"r\", order: \"descending\" };\n  }\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    let { [x4]: X3, r: R } = channels;\n    if (!channels[x4])\n      throw new Error(`missing channel: ${x4}`);\n    ({ [x4]: X3 } = Position(channels, scales, context));\n    const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number5(options.r) : 3;\n    if (R)\n      R = coerceNumbers(valueof(R.value, scales[R.scale] || identity6));\n    let [ky2, ty] = anchor(dimensions);\n    const compare = ky2 ? compareAscending : compareSymmetric;\n    const Y3 = new Float64Array(X3.length);\n    const radius2 = R ? (i) => R[i] : () => r2;\n    for (let I of facets) {\n      const tree2 = (0, import_interval_tree_1d.default)();\n      I = I.filter(R ? (i) => finite2(X3[i]) && positive(R[i]) : (i) => finite2(X3[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius2(i);\n        const y06 = ky2 ? ri + padding : 0;\n        const l = X3[i] - ri;\n        const h = X3[i] + ri;\n        let k2 = 2;\n        tree2.queryInterval(l - padding, h + padding, ([, , j]) => {\n          const yj = Y3[j] - y06;\n          const dx = X3[i] - X3[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * r2);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k2++] = yj - dy;\n          intervals[k2++] = yj + dy;\n        });\n        let candidates = intervals.slice(0, k2);\n        if (ky2)\n          candidates = candidates.filter((y5) => y5 >= 0);\n        out:\n          for (const y5 of candidates.sort(compare)) {\n            for (let j = 0; j < k2; j += 2) {\n              if (intervals[j] + 1e-6 < y5 && y5 < intervals[j + 1] - 1e-6) {\n                continue out;\n              }\n            }\n            Y3[i] = y5 + y06;\n            break;\n          }\n        tree2.insert([l, h, i]);\n      }\n    }\n    if (!ky2)\n      ky2 = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y3[i] = Y3[i] * ky2 + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [x4]: { value: X3 },\n        [y4]: { value: Y3 },\n        ...R && { r: { value: R } }\n      }\n    };\n  });\n}\nfunction compareSymmetric(a4, b) {\n  return Math.abs(a4) - Math.abs(b);\n}\nfunction compareAscending(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/normalize.js\nfunction normalizeX(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapX(normalize3(basis2), options);\n}\nfunction normalizeY(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapY(normalize3(basis2), options);\n}\nfunction normalize3(basis2) {\n  if (basis2 === void 0)\n    return normalizeFirst;\n  if (typeof basis2 === \"function\")\n    return normalizeBasis((I, S) => basis2(take(S, I)));\n  if (/^p\\d{2}$/i.test(basis2))\n    return normalizeAccessor(percentile(basis2));\n  switch (`${basis2}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis2}`);\n}\nfunction normalizeBasis(basis2) {\n  return {\n    map(I, S, T) {\n      const b = +basis2(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, (i) => S[i]));\n}\nvar normalizeExtent = {\n  map(I, S, T) {\n    const [s1, s2] = extent(I, (i) => S[i]), d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\nvar normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeDeviation = {\n  map(I, S, T) {\n    const m3 = mean(I, (i) => S[i]);\n    const d = deviation(I, (i) => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m3) / d : 0;\n    }\n  }\n};\nvar normalizeMax = normalizeAccessor(max);\nvar normalizeMean = normalizeAccessor(mean);\nvar normalizeMedian = normalizeAccessor(median);\nvar normalizeMin = normalizeAccessor(min);\nvar normalizeSum = normalizeAccessor(sum);\n\n// node_modules/@observablehq/plot/dist/transforms/window.js\nfunction windowX(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapX(window2(windowOptions), options);\n}\nfunction windowY(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapY(window2(windowOptions), options);\n}\nfunction window2(options = {}) {\n  if (typeof options === \"number\")\n    options = { k: options };\n  let { k: k2, reduce: reduce2, shift, anchor, strict } = options;\n  if (anchor === void 0 && shift !== void 0) {\n    anchor = maybeShift(shift);\n    warn(`Warning: the shift option is deprecated; please use anchor \"${anchor}\" instead.`);\n  }\n  if (!((k2 = Math.floor(k2)) > 0))\n    throw new Error(`invalid k: ${k2}`);\n  return maybeReduce2(reduce2)(k2, maybeAnchor3(anchor, k2), strict);\n}\nfunction maybeAnchor3(anchor = \"middle\", k2) {\n  switch (`${anchor}`.toLowerCase()) {\n    case \"middle\":\n      return k2 - 1 >> 1;\n    case \"start\":\n      return 0;\n    case \"end\":\n      return k2 - 1;\n  }\n  throw new Error(`invalid anchor: ${anchor}`);\n}\nfunction maybeShift(shift) {\n  switch (`${shift}`.toLowerCase()) {\n    case \"centered\":\n      return \"middle\";\n    case \"leading\":\n      return \"start\";\n    case \"trailing\":\n      return \"end\";\n  }\n  throw new Error(`invalid shift: ${shift}`);\n}\nfunction maybeReduce2(reduce2 = \"mean\") {\n  if (typeof reduce2 === \"string\") {\n    if (/^p\\d{2}$/i.test(reduce2))\n      return reduceNumbers(percentile(reduce2));\n    switch (reduce2.toLowerCase()) {\n      case \"deviation\":\n        return reduceNumbers(deviation);\n      case \"max\":\n        return reduceArray(max);\n      case \"mean\":\n        return reduceMean;\n      case \"median\":\n        return reduceNumbers(median);\n      case \"min\":\n        return reduceArray(min);\n      case \"mode\":\n        return reduceArray(mode);\n      case \"sum\":\n        return reduceSum2;\n      case \"variance\":\n        return reduceNumbers(variance);\n      case \"difference\":\n        return reduceDifference;\n      case \"ratio\":\n        return reduceRatio;\n      case \"first\":\n        return reduceFirst2;\n      case \"last\":\n        return reduceLast2;\n    }\n  }\n  if (typeof reduce2 !== \"function\")\n    throw new Error(`invalid reduce: ${reduce2}`);\n  return reduceArray(reduce2);\n}\nfunction slice6(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\nfunction reduceNumbers(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      let nans = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        if (isNaN(C3[i]))\n          ++nans;\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        if (isNaN(C3[i + k2 - 1]))\n          ++nans;\n        T[I[i + s2]] = nans === 0 ? f(C3.subarray(i, i + k2)) : NaN;\n        if (isNaN(C3[i]))\n          --nans;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(C3.subarray(0, i + k2));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(C3.subarray(i, i + k2));\n      }\n    }\n  };\n}\nfunction reduceArray(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      let count3 = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        count3 += defined(S[I[i]]);\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        count3 += defined(S[I[i + k2 - 1]]);\n        if (count3 === k2)\n          T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n        count3 -= defined(S[I[i]]);\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, 0, i + k2)));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n      }\n    }\n  };\n}\nfunction reduceSum2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      let nans = 0;\n      let sum5 = 0;\n      for (let i = 0; i < k2 - 1; ++i) {\n        const v2 = S[I[i]];\n        if (v2 === null || isNaN(v2))\n          ++nans;\n        else\n          sum5 += +v2;\n      }\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        if (b === null || isNaN(b))\n          ++nans;\n        else\n          sum5 += +b;\n        T[I[i + s2]] = nans === 0 ? sum5 : NaN;\n        if (a4 === null || isNaN(a4))\n          --nans;\n        else\n          sum5 -= +a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      let sum5 = 0;\n      const n = I.length;\n      for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n        sum5 += +S[I[i]] || 0;\n      }\n      for (let i = -s2, j = n - s2; i < j; ++i) {\n        sum5 += +S[I[i + k2 - 1]] || 0;\n        T[I[i + s2]] = sum5;\n        sum5 -= +S[I[i]] || 0;\n      }\n    }\n  };\n}\nfunction reduceMean(k2, s2, strict) {\n  if (strict) {\n    const sum5 = reduceSum2(k2, s2, strict);\n    return {\n      map(I, S, T) {\n        sum5.map(I, S, T);\n        for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n          T[I[i + s2]] /= k2;\n        }\n      }\n    };\n  } else {\n    return {\n      map(I, S, T) {\n        let sum5 = 0;\n        let count3 = 0;\n        const n = I.length;\n        for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n          let v2 = S[I[i]];\n          if (v2 !== null && !isNaN(v2 = +v2))\n            sum5 += v2, ++count3;\n        }\n        for (let i = -s2, j = n - s2; i < j; ++i) {\n          let a4 = S[I[i + k2 - 1]];\n          let b = S[I[i]];\n          if (a4 !== null && !isNaN(a4 = +a4))\n            sum5 += a4, ++count3;\n          T[I[i + s2]] = sum5 / count3;\n          if (b !== null && !isNaN(b = +b))\n            sum5 -= b, --count3;\n        }\n      }\n    };\n  }\n}\nfunction firstDefined(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    const v2 = S[I[i]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction lastDefined(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    const v2 = S[I[j]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction firstNumber(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    let v2 = S[I[i]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction lastNumber(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    let v2 = S[I[j]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction reduceDifference(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b - a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) - firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceRatio(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b / a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) / firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceFirst2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = firstDefined(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceLast2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i + k2 - 1]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastDefined(S, I, i, k2);\n      }\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/select.js\nfunction select(selector, options = {}) {\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  let key, value;\n  for (key in selector) {\n    if (value !== void 0)\n      throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === void 0)\n    throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\")\n    return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\nfunction selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\nfunction selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\nfunction selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\nfunction selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\nfunction selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\nfunction selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\nfunction* selectorFirst(I) {\n  yield I[0];\n}\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\nfunction* selectorMin(I, X3) {\n  yield least(I, (i) => X3[i]);\n}\nfunction* selectorMax(I, X3) {\n  yield greatest(I, (i) => X3[i]);\n}\nfunction selectChannel(v2, selector, options) {\n  if (v2 != null) {\n    if (options[v2] == null)\n      throw new Error(`missing channel: ${v2}`);\n    v2 = options[v2];\n  }\n  const z = maybeZ(options);\n  return basic(options, (data, facets) => {\n    const Z = valueof(data, z);\n    const V = valueof(data, v2);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return { data, facets: selectFacets };\n  });\n}\n\n// node_modules/tslib/tslib.es6.js\nfunction __rest(s2, e) {\n  var t = {};\n  for (var p in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)\n      t[p] = s2[p];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))\n        t[p[i]] = s2[p[i]];\n    }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s2 = typeof Symbol === \"function\" && Symbol.iterator, m3 = s2 && o[s2], i = 0;\n  if (m3)\n    return m3.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s2 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v2) {\n  return this instanceof __await ? (this.v = v2, this) : new __await(v2);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v2) {\n        return new Promise(function(a4, b) {\n          q.push([n, v2, a4, b]) > 1 || resume(n, v2);\n        });\n      };\n  }\n  function resume(n, v2) {\n    try {\n      step(g[n](v2));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v2) {\n    if (f(v2), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v2) {\n      return (p = !p) ? { value: __await(o[n](v2)), done: false } : f ? f(v2) : v2;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m3 = o[Symbol.asyncIterator], i;\n  return m3 ? m3.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v2) {\n      return new Promise(function(resolve, reject) {\n        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v2) {\n    Promise.resolve(v2).then(function(v3) {\n      resolve({ value: v3, done: d });\n    }, reject);\n  }\n}\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar buffer_exports = {};\n__export(buffer_exports, {\n  compareArrayLike: () => compareArrayLike,\n  joinUint8Arrays: () => joinUint8Arrays,\n  memcpy: () => memcpy,\n  rebaseValueOffsets: () => rebaseValueOffsets,\n  toArrayBufferView: () => toArrayBufferView,\n  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,\n  toArrayBufferViewIterator: () => toArrayBufferViewIterator,\n  toBigInt64Array: () => toBigInt64Array,\n  toBigUint64Array: () => toBigUint64Array,\n  toFloat32Array: () => toFloat32Array,\n  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,\n  toFloat32ArrayIterator: () => toFloat32ArrayIterator,\n  toFloat64Array: () => toFloat64Array,\n  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,\n  toFloat64ArrayIterator: () => toFloat64ArrayIterator,\n  toInt16Array: () => toInt16Array,\n  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,\n  toInt16ArrayIterator: () => toInt16ArrayIterator,\n  toInt32Array: () => toInt32Array,\n  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,\n  toInt32ArrayIterator: () => toInt32ArrayIterator,\n  toInt8Array: () => toInt8Array,\n  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,\n  toInt8ArrayIterator: () => toInt8ArrayIterator,\n  toUint16Array: () => toUint16Array,\n  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,\n  toUint16ArrayIterator: () => toUint16ArrayIterator,\n  toUint32Array: () => toUint32Array,\n  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,\n  toUint32ArrayIterator: () => toUint32ArrayIterator,\n  toUint8Array: () => toUint8Array,\n  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,\n  toUint8ArrayIterator: () => toUint8ArrayIterator,\n  toUint8ClampedArray: () => toUint8ClampedArray,\n  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,\n  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator\n});\n\n// node_modules/apache-arrow/util/utf8.mjs\nvar decoder = new TextDecoder(\"utf-8\");\nvar decodeUtf8 = (buffer) => decoder.decode(buffer);\nvar encoder = new TextEncoder();\nvar encodeUtf8 = (value) => encoder.encode(value);\n\n// node_modules/apache-arrow/util/compat.mjs\nvar [BigIntCtor, BigIntAvailable] = (() => {\n  const BigIntUnavailableError = () => {\n    throw new Error(\"BigInt is not available in this environment\");\n  };\n  function BigIntUnavailable() {\n    throw BigIntUnavailableError();\n  }\n  BigIntUnavailable.asIntN = () => {\n    throw BigIntUnavailableError();\n  };\n  BigIntUnavailable.asUintN = () => {\n    throw BigIntUnavailableError();\n  };\n  return typeof BigInt !== \"undefined\" ? [BigInt, true] : [BigIntUnavailable, false];\n})();\nvar [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {\n  const BigInt64ArrayUnavailableError = () => {\n    throw new Error(\"BigInt64Array is not available in this environment\");\n  };\n  class BigInt64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigInt64ArrayUnavailableError();\n    }\n  }\n  return typeof BigInt64Array !== \"undefined\" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];\n})();\nvar [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {\n  const BigUint64ArrayUnavailableError = () => {\n    throw new Error(\"BigUint64Array is not available in this environment\");\n  };\n  class BigUint64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigUint64ArrayUnavailableError();\n    }\n  }\n  return typeof BigUint64Array !== \"undefined\" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];\n})();\nvar isNumber = (x4) => typeof x4 === \"number\";\nvar isBoolean = (x4) => typeof x4 === \"boolean\";\nvar isFunction = (x4) => typeof x4 === \"function\";\nvar isObject2 = (x4) => x4 != null && Object(x4) === x4;\nvar isPromise = (x4) => {\n  return isObject2(x4) && isFunction(x4.then);\n};\nvar isIterable2 = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.iterator]);\n};\nvar isAsyncIterable = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.asyncIterator]);\n};\nvar isArrowJSON = (x4) => {\n  return isObject2(x4) && isObject2(x4[\"schema\"]);\n};\nvar isIteratorResult = (x4) => {\n  return isObject2(x4) && \"done\" in x4 && \"value\" in x4;\n};\nvar isFileHandle = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"stat\"]) && isNumber(x4[\"fd\"]);\n};\nvar isFetchResponse = (x4) => {\n  return isObject2(x4) && isReadableDOMStream(x4[\"body\"]);\n};\nvar isReadableInterop = (x4) => \"_getDOMStream\" in x4 && \"_getNodeStream\" in x4;\nvar isWritableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"abort\"]) && isFunction(x4[\"getWriter\"]) && !isReadableInterop(x4);\n};\nvar isReadableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"cancel\"]) && isFunction(x4[\"getReader\"]) && !isReadableInterop(x4);\n};\nvar isWritableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"end\"]) && isFunction(x4[\"write\"]) && isBoolean(x4[\"writable\"]) && !isReadableInterop(x4);\n};\nvar isReadableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"read\"]) && isFunction(x4[\"pipe\"]) && isBoolean(x4[\"readable\"]) && !isReadableInterop(x4);\n};\nvar isFlatbuffersByteBuffer = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"clear\"]) && isFunction(x4[\"bytes\"]) && isFunction(x4[\"position\"]) && isFunction(x4[\"setPosition\"]) && isFunction(x4[\"capacity\"]) && isFunction(x4[\"getBufferIdentifier\"]) && isFunction(x4[\"createLong\"]);\n};\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar SharedArrayBuf = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : ArrayBuffer;\nfunction collapseContiguousByteRanges(chunks) {\n  const result = chunks[0] ? [chunks[0]] : [];\n  let xOffset, yOffset, xLen, yLen;\n  for (let x4, y4, i = 0, j = 0, n = chunks.length; ++i < n; ) {\n    x4 = result[j];\n    y4 = chunks[i];\n    if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    ({ byteOffset: xOffset, byteLength: xLen } = x4);\n    ({ byteOffset: yOffset, byteLength: yLen } = y4);\n    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    result[j] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);\n  }\n  return result;\n}\nfunction memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));\n  dst.set(src, targetByteOffset);\n  return target;\n}\nfunction joinUint8Arrays(chunks, size) {\n  const result = collapseContiguousByteRanges(chunks);\n  const byteLength = result.reduce((x4, b) => x4 + b.byteLength, 0);\n  let source, sliced, buffer;\n  let offset2 = 0, index3 = -1;\n  const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);\n  for (const n = result.length; ++index3 < n; ) {\n    source = result[index3];\n    sliced = source.subarray(0, Math.min(source.length, length4 - offset2));\n    if (length4 <= offset2 + sliced.length) {\n      if (sliced.length < source.length) {\n        result[index3] = source.subarray(sliced.length);\n      } else if (sliced.length === source.length) {\n        index3++;\n      }\n      buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;\n      break;\n    }\n    memcpy(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);\n    offset2 += sliced.length;\n  }\n  return [buffer || new Uint8Array(0), result.slice(index3), byteLength - (buffer ? buffer.byteLength : 0)];\n}\nfunction toArrayBufferView(ArrayBufferViewCtor, input) {\n  let value = isIteratorResult(input) ? input.value : input;\n  if (value instanceof ArrayBufferViewCtor) {\n    if (ArrayBufferViewCtor === Uint8Array) {\n      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);\n    }\n    return value;\n  }\n  if (!value) {\n    return new ArrayBufferViewCtor(0);\n  }\n  if (typeof value === \"string\") {\n    value = encodeUtf8(value);\n  }\n  if (value instanceof ArrayBuffer) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (value instanceof SharedArrayBuf) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (isFlatbuffersByteBuffer(value)) {\n    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());\n  }\n  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);\n}\nvar toInt8Array = (input) => toArrayBufferView(Int8Array, input);\nvar toInt16Array = (input) => toArrayBufferView(Int16Array, input);\nvar toInt32Array = (input) => toArrayBufferView(Int32Array, input);\nvar toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);\nvar toUint8Array = (input) => toArrayBufferView(Uint8Array, input);\nvar toUint16Array = (input) => toArrayBufferView(Uint16Array, input);\nvar toUint32Array = (input) => toArrayBufferView(Uint32Array, input);\nvar toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);\nvar toFloat32Array = (input) => toArrayBufferView(Float32Array, input);\nvar toFloat64Array = (input) => toArrayBufferView(Float64Array, input);\nvar toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);\nvar pump = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* toArrayBufferViewIterator(ArrayCtor, source) {\n  const wrap = function* (x4) {\n    yield x4;\n  };\n  const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;\n  yield* pump(function* (it) {\n    let r = null;\n    do {\n      r = it.next(yield toArrayBufferView(ArrayCtor, r));\n    } while (!r.done);\n  }(buffers[Symbol.iterator]()));\n  return new ArrayCtor();\n}\nvar toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);\nvar toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);\nvar toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);\nvar toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);\nvar toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);\nvar toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);\nvar toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);\nvar toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);\nvar toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);\nfunction toArrayBufferViewAsyncIterator(ArrayCtor, source) {\n  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {\n    if (isPromise(source)) {\n      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));\n    }\n    const wrap = function(x4) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield yield __await(yield __await(x4));\n      });\n    };\n    const emit = function(source2) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {\n          let r = null;\n          do {\n            r = it.next(yield r === null || r === void 0 ? void 0 : r.value);\n          } while (!r.done);\n        }(source2[Symbol.iterator]())))));\n      });\n    };\n    const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;\n    yield __await(\n      // otherwise if AsyncIterable, use it\n      yield* __asyncDelegator(__asyncValues(pump(function(it) {\n        return __asyncGenerator(this, arguments, function* () {\n          let r = null;\n          do {\n            r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));\n          } while (!r.done);\n        });\n      }(buffers[Symbol.asyncIterator]()))))\n    );\n    return yield __await(new ArrayCtor());\n  });\n}\nvar toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);\nvar toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);\nvar toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);\nvar toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);\nvar toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);\nvar toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);\nvar toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);\nvar toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);\nvar toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);\nfunction rebaseValueOffsets(offset2, length4, valueOffsets) {\n  if (offset2 !== 0) {\n    valueOffsets = valueOffsets.slice(0, length4 + 1);\n    for (let i = -1; ++i <= length4; ) {\n      valueOffsets[i] += offset2;\n    }\n  }\n  return valueOffsets;\n}\nfunction compareArrayLike(a4, b) {\n  let i = 0;\n  const n = a4.length;\n  if (n !== b.length) {\n    return false;\n  }\n  if (n > 0) {\n    do {\n      if (a4[i] !== b[i]) {\n        return false;\n      }\n    } while (++i < n);\n  }\n  return true;\n}\n\n// node_modules/apache-arrow/io/adapters.mjs\nvar adapters_default = {\n  fromIterable(source) {\n    return pump2(fromIterable(source));\n  },\n  fromAsyncIterable(source) {\n    return pump2(fromAsyncIterable(source));\n  },\n  fromDOMStream(source) {\n    return pump2(fromDOMStream(source));\n  },\n  fromNodeStream(stream) {\n    return pump2(fromNodeStream(stream));\n  },\n  // @ts-ignore\n  toDOMStream(source, options) {\n    throw new Error(`\"toDOMStream\" not available in this environment`);\n  },\n  // @ts-ignore\n  toNodeStream(source, options) {\n    throw new Error(`\"toNodeStream\" not available in this environment`);\n  }\n};\nvar pump2 = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* fromIterable(source) {\n  let done, threw = false;\n  let buffers = [], buffer;\n  let cmd, size, bufferLength = 0;\n  function byteRange() {\n    if (cmd === \"peek\") {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  }\n  ({ cmd, size } = yield null);\n  const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n  try {\n    do {\n      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      }\n      if (done || size <= bufferLength) {\n        do {\n          ({ cmd, size } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === \"function\" && it.throw(e);\n  } finally {\n    threw === false && typeof it.return === \"function\" && it.return(null);\n  }\n  return null;\n}\nfunction fromAsyncIterable(source) {\n  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n    let done, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && typeof it.throw === \"function\" && (yield __await(it.throw(e)));\n    } finally {\n      threw === false && typeof it.return === \"function\" && (yield __await(it.return(new Uint8Array(0))));\n    }\n    return yield __await(null);\n  });\n}\nfunction fromDOMStream(source) {\n  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n    let done = false, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = new AdaptiveByteReader(source);\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it[\"read\"]()) : yield __await(it[\"read\"](size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(toUint8Array(buffer));\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && (yield __await(it[\"cancel\"](e)));\n    } finally {\n      threw === false ? yield __await(it[\"cancel\"]()) : source[\"locked\"] && it.releaseLock();\n    }\n    return yield __await(null);\n  });\n}\nvar AdaptiveByteReader = class {\n  constructor(source) {\n    this.source = source;\n    this.reader = null;\n    this.reader = this.source[\"getReader\"]();\n    this.reader[\"closed\"].catch(() => {\n    });\n  }\n  get closed() {\n    return this.reader ? this.reader[\"closed\"].catch(() => {\n    }) : Promise.resolve();\n  }\n  releaseLock() {\n    if (this.reader) {\n      this.reader.releaseLock();\n    }\n    this.reader = null;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { reader, source } = this;\n      reader && (yield reader[\"cancel\"](reason).catch(() => {\n      }));\n      source && (source[\"locked\"] && this.releaseLock());\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (size === 0) {\n        return { done: this.reader == null, value: new Uint8Array(0) };\n      }\n      const result = yield this.reader.read();\n      !result.done && (result.value = toUint8Array(result));\n      return result;\n    });\n  }\n};\nvar onEvent = (stream, event) => {\n  const handler = (_) => resolve([event, _]);\n  let resolve;\n  return [event, handler, new Promise((r) => (resolve = r) && stream[\"once\"](event, handler))];\n};\nfunction fromNodeStream(stream) {\n  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n    const events = [];\n    let event = \"error\";\n    let done = false, err = null;\n    let cmd, size, bufferLength = 0;\n    let buffers = [], buffer;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    if (stream[\"isTTY\"]) {\n      yield yield __await(new Uint8Array(0));\n      return yield __await(null);\n    }\n    try {\n      events[0] = onEvent(stream, \"end\");\n      events[1] = onEvent(stream, \"error\");\n      do {\n        events[2] = onEvent(stream, \"readable\");\n        [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));\n        if (event === \"error\") {\n          break;\n        }\n        if (!(done = event === \"end\")) {\n          if (!Number.isFinite(size - bufferLength)) {\n            buffer = toUint8Array(stream[\"read\"]());\n          } else {\n            buffer = toUint8Array(stream[\"read\"](size - bufferLength));\n            if (buffer.byteLength < size - bufferLength) {\n              buffer = toUint8Array(stream[\"read\"]());\n            }\n          }\n          if (buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } finally {\n      yield __await(cleanup(events, event === \"error\" ? err : null));\n    }\n    return yield __await(null);\n    function cleanup(events2, err2) {\n      buffer = buffers = null;\n      return new Promise((resolve, reject) => {\n        for (const [evt, fn] of events2) {\n          stream[\"off\"](evt, fn);\n        }\n        try {\n          const destroy = stream[\"destroy\"];\n          destroy && destroy.call(stream, err2);\n          err2 = void 0;\n        } catch (e) {\n          err2 = e || err2;\n        } finally {\n          err2 != null ? reject(err2) : resolve();\n        }\n      });\n    }\n  });\n}\n\n// node_modules/apache-arrow/enum.mjs\nvar MetadataVersion;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion || (MetadataVersion = {}));\nvar UnionMode;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode || (UnionMode = {}));\nvar Precision;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision || (Precision = {}));\nvar DateUnit;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit || (DateUnit = {}));\nvar TimeUnit;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit || (TimeUnit = {}));\nvar IntervalUnit;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit || (IntervalUnit = {}));\nvar MessageHeader;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nvar Type;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"Float\"] = 3] = \"Float\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct\"] = 13] = \"Struct\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type3[Type3[\"Int8\"] = -2] = \"Int8\";\n  Type3[Type3[\"Int16\"] = -3] = \"Int16\";\n  Type3[Type3[\"Int32\"] = -4] = \"Int32\";\n  Type3[Type3[\"Int64\"] = -5] = \"Int64\";\n  Type3[Type3[\"Uint8\"] = -6] = \"Uint8\";\n  Type3[Type3[\"Uint16\"] = -7] = \"Uint16\";\n  Type3[Type3[\"Uint32\"] = -8] = \"Uint32\";\n  Type3[Type3[\"Uint64\"] = -9] = \"Uint64\";\n  Type3[Type3[\"Float16\"] = -10] = \"Float16\";\n  Type3[Type3[\"Float32\"] = -11] = \"Float32\";\n  Type3[Type3[\"Float64\"] = -12] = \"Float64\";\n  Type3[Type3[\"DateDay\"] = -13] = \"DateDay\";\n  Type3[Type3[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type3[Type3[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type3[Type3[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type3[Type3[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type3[Type3[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type3[Type3[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type3[Type3[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type3[Type3[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type3[Type3[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type3[Type3[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type3[Type3[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type3[Type3[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type3[Type3[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\nvar BufferType;\n(function(BufferType2) {\n  BufferType2[BufferType2[\"OFFSET\"] = 0] = \"OFFSET\";\n  BufferType2[BufferType2[\"DATA\"] = 1] = \"DATA\";\n  BufferType2[BufferType2[\"VALIDITY\"] = 2] = \"VALIDITY\";\n  BufferType2[BufferType2[\"TYPE\"] = 3] = \"TYPE\";\n})(BufferType || (BufferType = {}));\n\n// node_modules/apache-arrow/util/vector.mjs\nvar vector_exports = {};\n__export(vector_exports, {\n  clampIndex: () => clampIndex,\n  clampRange: () => clampRange,\n  createElementComparator: () => createElementComparator\n});\n\n// node_modules/apache-arrow/util/pretty.mjs\nvar undf = void 0;\nfunction valueToString(x4) {\n  if (x4 === null) {\n    return \"null\";\n  }\n  if (x4 === undf) {\n    return \"undefined\";\n  }\n  switch (typeof x4) {\n    case \"number\":\n      return `${x4}`;\n    case \"bigint\":\n      return `${x4}`;\n    case \"string\":\n      return `\"${x4}\"`;\n  }\n  if (typeof x4[Symbol.toPrimitive] === \"function\") {\n    return x4[Symbol.toPrimitive](\"string\");\n  }\n  if (ArrayBuffer.isView(x4)) {\n    if (x4 instanceof BigInt64ArrayCtor || x4 instanceof BigUint64ArrayCtor) {\n      return `[${[...x4].map((x5) => valueToString(x5))}]`;\n    }\n    return `[${x4}]`;\n  }\n  return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_, y4) => typeof y4 === \"bigint\" ? `${y4}` : y4);\n}\n\n// node_modules/apache-arrow/util/bn.mjs\nvar bn_exports = {};\n__export(bn_exports, {\n  BN: () => BN,\n  bignumToBigInt: () => bignumToBigInt,\n  bignumToString: () => bignumToString,\n  isArrowBigNumSymbol: () => isArrowBigNumSymbol\n});\nvar isArrowBigNumSymbol = Symbol.for(\"isArrowBigNum\");\nfunction BigNum(x4, ...xs) {\n  if (xs.length === 0) {\n    return Object.setPrototypeOf(toArrayBufferView(this[\"TypedArray\"], x4), this.constructor.prototype);\n  }\n  return Object.setPrototypeOf(new this[\"TypedArray\"](x4, ...xs), this.constructor.prototype);\n}\nBigNum.prototype[isArrowBigNumSymbol] = true;\nBigNum.prototype.toJSON = function() {\n  return `\"${bignumToString(this)}\"`;\n};\nBigNum.prototype.valueOf = function() {\n  return bignumToNumber(this);\n};\nBigNum.prototype.toString = function() {\n  return bignumToString(this);\n};\nBigNum.prototype[Symbol.toPrimitive] = function(hint = \"default\") {\n  switch (hint) {\n    case \"number\":\n      return bignumToNumber(this);\n    case \"string\":\n      return bignumToString(this);\n    case \"default\":\n      return bignumToBigInt(this);\n  }\n  return bignumToString(this);\n};\nfunction SignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction UnsignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction DecimalBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nObject.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype, BigNum.prototype, { \"constructor\": SignedBigNum, \"signed\": true, \"TypedArray\": Int32Array, \"BigIntArray\": BigInt64ArrayCtor });\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, { \"constructor\": UnsignedBigNum, \"signed\": false, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nObject.assign(DecimalBigNum.prototype, BigNum.prototype, { \"constructor\": DecimalBigNum, \"signed\": true, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nfunction bignumToNumber(bn) {\n  const { buffer, byteOffset, length: length4, \"signed\": signed } = bn;\n  const words = new BigUint64ArrayCtor(buffer, byteOffset, length4);\n  const negative2 = signed && words[words.length - 1] & BigInt(1) << BigInt(63);\n  let number7 = negative2 ? BigInt(1) : BigInt(0);\n  let i = BigInt(0);\n  if (!negative2) {\n    for (const word of words) {\n      number7 += word * (BigInt(1) << BigInt(32) * i++);\n    }\n  } else {\n    for (const word of words) {\n      number7 += ~word * (BigInt(1) << BigInt(32) * i++);\n    }\n    number7 *= BigInt(-1);\n  }\n  return number7;\n}\nvar bignumToString;\nvar bignumToBigInt;\nif (!BigIntAvailable) {\n  bignumToString = decimalToString;\n  bignumToBigInt = bignumToString;\n} else {\n  bignumToBigInt = (a4) => a4.byteLength === 8 ? new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0] : decimalToString(a4);\n  bignumToString = (a4) => a4.byteLength === 8 ? `${new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0]}` : decimalToString(a4);\n}\nfunction decimalToString(a4) {\n  let digits = \"\";\n  const base64 = new Uint32Array(2);\n  let base32 = new Uint16Array(a4.buffer, a4.byteOffset, a4.byteLength / 2);\n  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n  let i = -1;\n  const n = base32.length - 1;\n  do {\n    for (base64[0] = base32[i = 0]; i < n; ) {\n      base32[i++] = base64[1] = base64[0] / 10;\n      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];\n    }\n    base32[i] = base64[1] = base64[0] / 10;\n    base64[0] = base64[0] - base64[1] * 10;\n    digits = `${base64[0]}${digits}`;\n  } while (checks[0] || checks[1] || checks[2] || checks[3]);\n  return digits !== null && digits !== void 0 ? digits : `0`;\n}\nvar BN = class {\n  /** @nocollapse */\n  static new(num, isSigned) {\n    switch (isSigned) {\n      case true:\n        return new SignedBigNum(num);\n      case false:\n        return new UnsignedBigNum(num);\n    }\n    switch (num.constructor) {\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case BigInt64ArrayCtor:\n        return new SignedBigNum(num);\n    }\n    if (num.byteLength === 16) {\n      return new DecimalBigNum(num);\n    }\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static signed(num) {\n    return new SignedBigNum(num);\n  }\n  /** @nocollapse */\n  static unsigned(num) {\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static decimal(num) {\n    return new DecimalBigNum(num);\n  }\n  constructor(num, isSigned) {\n    return BN.new(num, isSigned);\n  }\n};\n\n// node_modules/apache-arrow/type.mjs\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\nvar _f;\nvar _g;\nvar _h;\nvar _j;\nvar _k;\nvar _l;\nvar _m;\nvar _o;\nvar _p;\nvar _q;\nvar _r;\nvar _s;\nvar _t;\nvar _u;\nvar DataType = class {\n  /** @nocollapse */\n  static isNull(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Null;\n  }\n  /** @nocollapse */\n  static isInt(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Int;\n  }\n  /** @nocollapse */\n  static isFloat(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Float;\n  }\n  /** @nocollapse */\n  static isBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Binary;\n  }\n  /** @nocollapse */\n  static isUtf8(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Utf8;\n  }\n  /** @nocollapse */\n  static isBool(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Bool;\n  }\n  /** @nocollapse */\n  static isDecimal(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Decimal;\n  }\n  /** @nocollapse */\n  static isDate(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Date;\n  }\n  /** @nocollapse */\n  static isTime(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Time;\n  }\n  /** @nocollapse */\n  static isTimestamp(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Timestamp;\n  }\n  /** @nocollapse */\n  static isInterval(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Interval;\n  }\n  /** @nocollapse */\n  static isList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.List;\n  }\n  /** @nocollapse */\n  static isStruct(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Struct;\n  }\n  /** @nocollapse */\n  static isUnion(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Union;\n  }\n  /** @nocollapse */\n  static isFixedSizeBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeBinary;\n  }\n  /** @nocollapse */\n  static isFixedSizeList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeList;\n  }\n  /** @nocollapse */\n  static isMap(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Map;\n  }\n  /** @nocollapse */\n  static isDictionary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Dictionary;\n  }\n  /** @nocollapse */\n  static isDenseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Dense;\n  }\n  /** @nocollapse */\n  static isSparseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Sparse;\n  }\n  get typeId() {\n    return Type.NONE;\n  }\n};\n_a = Symbol.toStringTag;\nDataType[_a] = ((proto) => {\n  proto.children = null;\n  proto.ArrayType = Array;\n  return proto[Symbol.toStringTag] = \"DataType\";\n})(DataType.prototype);\nvar Null = class extends DataType {\n  toString() {\n    return `Null`;\n  }\n  get typeId() {\n    return Type.Null;\n  }\n};\n_b = Symbol.toStringTag;\nNull[_b] = ((proto) => proto[Symbol.toStringTag] = \"Null\")(Null.prototype);\nvar Int_ = class extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Int;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 8:\n        return this.isSigned ? Int8Array : Uint8Array;\n      case 16:\n        return this.isSigned ? Int16Array : Uint16Array;\n      case 32:\n        return this.isSigned ? Int32Array : Uint32Array;\n      case 64:\n        return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;\n  }\n};\n_c = Symbol.toStringTag;\nInt_[_c] = ((proto) => {\n  proto.isSigned = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Int\";\n})(Int_.prototype);\nvar Int8 = class extends Int_ {\n  constructor() {\n    super(true, 8);\n  }\n  get ArrayType() {\n    return Int8Array;\n  }\n};\nvar Int16 = class extends Int_ {\n  constructor() {\n    super(true, 16);\n  }\n  get ArrayType() {\n    return Int16Array;\n  }\n};\nvar Int32 = class extends Int_ {\n  constructor() {\n    super(true, 32);\n  }\n  get ArrayType() {\n    return Int32Array;\n  }\n};\nvar Int64 = class extends Int_ {\n  constructor() {\n    super(true, 64);\n  }\n  get ArrayType() {\n    return BigInt64ArrayCtor;\n  }\n};\nvar Uint8 = class extends Int_ {\n  constructor() {\n    super(false, 8);\n  }\n  get ArrayType() {\n    return Uint8Array;\n  }\n};\nvar Uint16 = class extends Int_ {\n  constructor() {\n    super(false, 16);\n  }\n  get ArrayType() {\n    return Uint16Array;\n  }\n};\nvar Uint32 = class extends Int_ {\n  constructor() {\n    super(false, 32);\n  }\n  get ArrayType() {\n    return Uint32Array;\n  }\n};\nvar Uint64 = class extends Int_ {\n  constructor() {\n    super(false, 64);\n  }\n  get ArrayType() {\n    return BigUint64ArrayCtor;\n  }\n};\nObject.defineProperty(Int8.prototype, \"ArrayType\", { value: Int8Array });\nObject.defineProperty(Int16.prototype, \"ArrayType\", { value: Int16Array });\nObject.defineProperty(Int32.prototype, \"ArrayType\", { value: Int32Array });\nObject.defineProperty(Int64.prototype, \"ArrayType\", { value: BigInt64ArrayCtor });\nObject.defineProperty(Uint8.prototype, \"ArrayType\", { value: Uint8Array });\nObject.defineProperty(Uint16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Uint32.prototype, \"ArrayType\", { value: Uint32Array });\nObject.defineProperty(Uint64.prototype, \"ArrayType\", { value: BigUint64ArrayCtor });\nvar Float = class extends DataType {\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId() {\n    return Type.Float;\n  }\n  get ArrayType() {\n    switch (this.precision) {\n      case Precision.HALF:\n        return Uint16Array;\n      case Precision.SINGLE:\n        return Float32Array;\n      case Precision.DOUBLE:\n        return Float64Array;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `Float${this.precision << 5 || 16}`;\n  }\n};\n_d = Symbol.toStringTag;\nFloat[_d] = ((proto) => {\n  proto.precision = null;\n  return proto[Symbol.toStringTag] = \"Float\";\n})(Float.prototype);\nvar Float16 = class extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n};\nvar Float32 = class extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n};\nvar Float64 = class extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n};\nObject.defineProperty(Float16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Float32.prototype, \"ArrayType\", { value: Float32Array });\nObject.defineProperty(Float64.prototype, \"ArrayType\", { value: Float64Array });\nvar Binary = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return `Binary`;\n  }\n};\n_e = Symbol.toStringTag;\nBinary[_e] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Binary\";\n})(Binary.prototype);\nvar Utf8 = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Utf8;\n  }\n  toString() {\n    return `Utf8`;\n  }\n};\n_f = Symbol.toStringTag;\nUtf8[_f] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Utf8\";\n})(Utf8.prototype);\nvar Bool = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Bool;\n  }\n  toString() {\n    return `Bool`;\n  }\n};\n_g = Symbol.toStringTag;\nBool[_g] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Bool\";\n})(Bool.prototype);\nvar Decimal = class extends DataType {\n  constructor(scale3, precision, bitWidth = 128) {\n    super();\n    this.scale = scale3;\n    this.precision = precision;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Decimal;\n  }\n  toString() {\n    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;\n  }\n};\n_h = Symbol.toStringTag;\nDecimal[_h] = ((proto) => {\n  proto.scale = null;\n  proto.precision = null;\n  proto.ArrayType = Uint32Array;\n  return proto[Symbol.toStringTag] = \"Decimal\";\n})(Decimal.prototype);\nvar Date_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Date;\n  }\n  toString() {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n};\n_j = Symbol.toStringTag;\nDate_[_j] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Date\";\n})(Date_.prototype);\nvar Time_ = class extends DataType {\n  constructor(unit3, bitWidth) {\n    super();\n    this.unit = unit3;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Time;\n  }\n  toString() {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 32:\n        return Int32Array;\n      case 64:\n        return BigInt64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n};\n_k = Symbol.toStringTag;\nTime_[_k] = ((proto) => {\n  proto.unit = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Time\";\n})(Time_.prototype);\nvar Timestamp_ = class extends DataType {\n  constructor(unit3, timezone) {\n    super();\n    this.unit = unit3;\n    this.timezone = timezone;\n  }\n  get typeId() {\n    return Type.Timestamp;\n  }\n  toString() {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;\n  }\n};\n_l = Symbol.toStringTag;\nTimestamp_[_l] = ((proto) => {\n  proto.unit = null;\n  proto.timezone = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Timestamp\";\n})(Timestamp_.prototype);\nvar Interval_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Interval;\n  }\n  toString() {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n};\n_m = Symbol.toStringTag;\nInterval_[_m] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Interval\";\n})(Interval_.prototype);\nvar List = class extends DataType {\n  constructor(child) {\n    super();\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.List;\n  }\n  toString() {\n    return `List<${this.valueType}>`;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n};\n_o = Symbol.toStringTag;\nList[_o] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"List\";\n})(List.prototype);\nvar Struct = class extends DataType {\n  constructor(children2) {\n    super();\n    this.children = children2;\n  }\n  get typeId() {\n    return Type.Struct;\n  }\n  toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_p = Symbol.toStringTag;\nStruct[_p] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"Struct\";\n})(Struct.prototype);\nvar Union_ = class extends DataType {\n  constructor(mode2, typeIds, children2) {\n    super();\n    this.mode = mode2;\n    this.children = children2;\n    this.typeIds = typeIds = Int32Array.from(typeIds);\n    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));\n  }\n  get typeId() {\n    return Type.Union;\n  }\n  toString() {\n    return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;\n  }\n};\n_q = Symbol.toStringTag;\nUnion_[_q] = ((proto) => {\n  proto.mode = null;\n  proto.typeIds = null;\n  proto.children = null;\n  proto.typeIdToChildIndex = null;\n  proto.ArrayType = Int8Array;\n  return proto[Symbol.toStringTag] = \"Union\";\n})(Union_.prototype);\nvar FixedSizeBinary = class extends DataType {\n  constructor(byteWidth) {\n    super();\n    this.byteWidth = byteWidth;\n  }\n  get typeId() {\n    return Type.FixedSizeBinary;\n  }\n  toString() {\n    return `FixedSizeBinary[${this.byteWidth}]`;\n  }\n};\n_r = Symbol.toStringTag;\nFixedSizeBinary[_r] = ((proto) => {\n  proto.byteWidth = null;\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"FixedSizeBinary\";\n})(FixedSizeBinary.prototype);\nvar FixedSizeList = class extends DataType {\n  constructor(listSize, child) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n  toString() {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n};\n_s = Symbol.toStringTag;\nFixedSizeList[_s] = ((proto) => {\n  proto.children = null;\n  proto.listSize = null;\n  return proto[Symbol.toStringTag] = \"FixedSizeList\";\n})(FixedSizeList.prototype);\nvar Map_ = class extends DataType {\n  constructor(child, keysSorted = false) {\n    super();\n    this.children = [child];\n    this.keysSorted = keysSorted;\n  }\n  get typeId() {\n    return Type.Map;\n  }\n  get keyType() {\n    return this.children[0].type.children[0].type;\n  }\n  get valueType() {\n    return this.children[0].type.children[1].type;\n  }\n  get childType() {\n    return this.children[0].type;\n  }\n  toString() {\n    return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_t = Symbol.toStringTag;\nMap_[_t] = ((proto) => {\n  proto.children = null;\n  proto.keysSorted = null;\n  return proto[Symbol.toStringTag] = \"Map_\";\n})(Map_.prototype);\nvar getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);\nvar Dictionary = class extends DataType {\n  constructor(dictionary, indices, id2, isOrdered2) {\n    super();\n    this.indices = indices;\n    this.dictionary = dictionary;\n    this.isOrdered = isOrdered2 || false;\n    this.id = id2 == null ? getId() : typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get typeId() {\n    return Type.Dictionary;\n  }\n  get children() {\n    return this.dictionary.children;\n  }\n  get valueType() {\n    return this.dictionary;\n  }\n  get ArrayType() {\n    return this.dictionary.ArrayType;\n  }\n  toString() {\n    return `Dictionary<${this.indices}, ${this.dictionary}>`;\n  }\n};\n_u = Symbol.toStringTag;\nDictionary[_u] = ((proto) => {\n  proto.id = null;\n  proto.indices = null;\n  proto.isOrdered = null;\n  proto.dictionary = null;\n  return proto[Symbol.toStringTag] = \"Dictionary\";\n})(Dictionary.prototype);\nfunction strideForType(type2) {\n  const t = type2;\n  switch (type2.typeId) {\n    case Type.Decimal:\n      return type2.bitWidth / 32;\n    case Type.Timestamp:\n      return 2;\n    case Type.Date:\n      return 1 + t.unit;\n    case Type.Interval:\n      return 1 + t.unit;\n    case Type.FixedSizeList:\n      return t.listSize;\n    case Type.FixedSizeBinary:\n      return t.byteWidth;\n    default:\n      return 1;\n  }\n}\n\n// node_modules/apache-arrow/visitor.mjs\nvar Visitor = class {\n  visitMany(nodes, ...args) {\n    return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));\n  }\n  visit(...args) {\n    return this.getVisitFn(args[0], false).apply(this, args);\n  }\n  getVisitFn(node, throwIfNotFound = true) {\n    return getVisitFn(this, node, throwIfNotFound);\n  }\n  getVisitFnByTypeId(typeId, throwIfNotFound = true) {\n    return getVisitFnByTypeId(this, typeId, throwIfNotFound);\n  }\n  visitNull(_node, ..._args) {\n    return null;\n  }\n  visitBool(_node, ..._args) {\n    return null;\n  }\n  visitInt(_node, ..._args) {\n    return null;\n  }\n  visitFloat(_node, ..._args) {\n    return null;\n  }\n  visitUtf8(_node, ..._args) {\n    return null;\n  }\n  visitBinary(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeBinary(_node, ..._args) {\n    return null;\n  }\n  visitDate(_node, ..._args) {\n    return null;\n  }\n  visitTimestamp(_node, ..._args) {\n    return null;\n  }\n  visitTime(_node, ..._args) {\n    return null;\n  }\n  visitDecimal(_node, ..._args) {\n    return null;\n  }\n  visitList(_node, ..._args) {\n    return null;\n  }\n  visitStruct(_node, ..._args) {\n    return null;\n  }\n  visitUnion(_node, ..._args) {\n    return null;\n  }\n  visitDictionary(_node, ..._args) {\n    return null;\n  }\n  visitInterval(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeList(_node, ..._args) {\n    return null;\n  }\n  visitMap(_node, ..._args) {\n    return null;\n  }\n};\nfunction getVisitFn(visitor, node, throwIfNotFound = true) {\n  if (typeof node === \"number\") {\n    return getVisitFnByTypeId(visitor, node, throwIfNotFound);\n  }\n  if (typeof node === \"string\" && node in Type) {\n    return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);\n  }\n  if (node && node instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);\n  }\n  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);\n  }\n  return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);\n}\nfunction getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {\n  let fn = null;\n  switch (dtype) {\n    case Type.Null:\n      fn = visitor.visitNull;\n      break;\n    case Type.Bool:\n      fn = visitor.visitBool;\n      break;\n    case Type.Int:\n      fn = visitor.visitInt;\n      break;\n    case Type.Int8:\n      fn = visitor.visitInt8 || visitor.visitInt;\n      break;\n    case Type.Int16:\n      fn = visitor.visitInt16 || visitor.visitInt;\n      break;\n    case Type.Int32:\n      fn = visitor.visitInt32 || visitor.visitInt;\n      break;\n    case Type.Int64:\n      fn = visitor.visitInt64 || visitor.visitInt;\n      break;\n    case Type.Uint8:\n      fn = visitor.visitUint8 || visitor.visitInt;\n      break;\n    case Type.Uint16:\n      fn = visitor.visitUint16 || visitor.visitInt;\n      break;\n    case Type.Uint32:\n      fn = visitor.visitUint32 || visitor.visitInt;\n      break;\n    case Type.Uint64:\n      fn = visitor.visitUint64 || visitor.visitInt;\n      break;\n    case Type.Float:\n      fn = visitor.visitFloat;\n      break;\n    case Type.Float16:\n      fn = visitor.visitFloat16 || visitor.visitFloat;\n      break;\n    case Type.Float32:\n      fn = visitor.visitFloat32 || visitor.visitFloat;\n      break;\n    case Type.Float64:\n      fn = visitor.visitFloat64 || visitor.visitFloat;\n      break;\n    case Type.Utf8:\n      fn = visitor.visitUtf8;\n      break;\n    case Type.Binary:\n      fn = visitor.visitBinary;\n      break;\n    case Type.FixedSizeBinary:\n      fn = visitor.visitFixedSizeBinary;\n      break;\n    case Type.Date:\n      fn = visitor.visitDate;\n      break;\n    case Type.DateDay:\n      fn = visitor.visitDateDay || visitor.visitDate;\n      break;\n    case Type.DateMillisecond:\n      fn = visitor.visitDateMillisecond || visitor.visitDate;\n      break;\n    case Type.Timestamp:\n      fn = visitor.visitTimestamp;\n      break;\n    case Type.TimestampSecond:\n      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMillisecond:\n      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMicrosecond:\n      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampNanosecond:\n      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;\n      break;\n    case Type.Time:\n      fn = visitor.visitTime;\n      break;\n    case Type.TimeSecond:\n      fn = visitor.visitTimeSecond || visitor.visitTime;\n      break;\n    case Type.TimeMillisecond:\n      fn = visitor.visitTimeMillisecond || visitor.visitTime;\n      break;\n    case Type.TimeMicrosecond:\n      fn = visitor.visitTimeMicrosecond || visitor.visitTime;\n      break;\n    case Type.TimeNanosecond:\n      fn = visitor.visitTimeNanosecond || visitor.visitTime;\n      break;\n    case Type.Decimal:\n      fn = visitor.visitDecimal;\n      break;\n    case Type.List:\n      fn = visitor.visitList;\n      break;\n    case Type.Struct:\n      fn = visitor.visitStruct;\n      break;\n    case Type.Union:\n      fn = visitor.visitUnion;\n      break;\n    case Type.DenseUnion:\n      fn = visitor.visitDenseUnion || visitor.visitUnion;\n      break;\n    case Type.SparseUnion:\n      fn = visitor.visitSparseUnion || visitor.visitUnion;\n      break;\n    case Type.Dictionary:\n      fn = visitor.visitDictionary;\n      break;\n    case Type.Interval:\n      fn = visitor.visitInterval;\n      break;\n    case Type.IntervalDayTime:\n      fn = visitor.visitIntervalDayTime || visitor.visitInterval;\n      break;\n    case Type.IntervalYearMonth:\n      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;\n      break;\n    case Type.FixedSizeList:\n      fn = visitor.visitFixedSizeList;\n      break;\n    case Type.Map:\n      fn = visitor.visitMap;\n      break;\n  }\n  if (typeof fn === \"function\")\n    return fn;\n  if (!throwIfNotFound)\n    return () => null;\n  throw new Error(`Unrecognized type '${Type[dtype]}'`);\n}\nfunction inferDType(type2) {\n  switch (type2.typeId) {\n    case Type.Null:\n      return Type.Null;\n    case Type.Int: {\n      const { bitWidth, isSigned } = type2;\n      switch (bitWidth) {\n        case 8:\n          return isSigned ? Type.Int8 : Type.Uint8;\n        case 16:\n          return isSigned ? Type.Int16 : Type.Uint16;\n        case 32:\n          return isSigned ? Type.Int32 : Type.Uint32;\n        case 64:\n          return isSigned ? Type.Int64 : Type.Uint64;\n      }\n      return Type.Int;\n    }\n    case Type.Float:\n      switch (type2.precision) {\n        case Precision.HALF:\n          return Type.Float16;\n        case Precision.SINGLE:\n          return Type.Float32;\n        case Precision.DOUBLE:\n          return Type.Float64;\n      }\n      return Type.Float;\n    case Type.Binary:\n      return Type.Binary;\n    case Type.Utf8:\n      return Type.Utf8;\n    case Type.Bool:\n      return Type.Bool;\n    case Type.Decimal:\n      return Type.Decimal;\n    case Type.Time:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimeSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimeMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimeMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimeNanosecond;\n      }\n      return Type.Time;\n    case Type.Timestamp:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimestampSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimestampMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimestampMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimestampNanosecond;\n      }\n      return Type.Timestamp;\n    case Type.Date:\n      switch (type2.unit) {\n        case DateUnit.DAY:\n          return Type.DateDay;\n        case DateUnit.MILLISECOND:\n          return Type.DateMillisecond;\n      }\n      return Type.Date;\n    case Type.Interval:\n      switch (type2.unit) {\n        case IntervalUnit.DAY_TIME:\n          return Type.IntervalDayTime;\n        case IntervalUnit.YEAR_MONTH:\n          return Type.IntervalYearMonth;\n      }\n      return Type.Interval;\n    case Type.Map:\n      return Type.Map;\n    case Type.List:\n      return Type.List;\n    case Type.Struct:\n      return Type.Struct;\n    case Type.Union:\n      switch (type2.mode) {\n        case UnionMode.Dense:\n          return Type.DenseUnion;\n        case UnionMode.Sparse:\n          return Type.SparseUnion;\n      }\n      return Type.Union;\n    case Type.FixedSizeBinary:\n      return Type.FixedSizeBinary;\n    case Type.FixedSizeList:\n      return Type.FixedSizeList;\n    case Type.Dictionary:\n      return Type.Dictionary;\n  }\n  throw new Error(`Unrecognized type '${Type[type2.typeId]}'`);\n}\nVisitor.prototype.visitInt8 = null;\nVisitor.prototype.visitInt16 = null;\nVisitor.prototype.visitInt32 = null;\nVisitor.prototype.visitInt64 = null;\nVisitor.prototype.visitUint8 = null;\nVisitor.prototype.visitUint16 = null;\nVisitor.prototype.visitUint32 = null;\nVisitor.prototype.visitUint64 = null;\nVisitor.prototype.visitFloat16 = null;\nVisitor.prototype.visitFloat32 = null;\nVisitor.prototype.visitFloat64 = null;\nVisitor.prototype.visitDateDay = null;\nVisitor.prototype.visitDateMillisecond = null;\nVisitor.prototype.visitTimestampSecond = null;\nVisitor.prototype.visitTimestampMillisecond = null;\nVisitor.prototype.visitTimestampMicrosecond = null;\nVisitor.prototype.visitTimestampNanosecond = null;\nVisitor.prototype.visitTimeSecond = null;\nVisitor.prototype.visitTimeMillisecond = null;\nVisitor.prototype.visitTimeMicrosecond = null;\nVisitor.prototype.visitTimeNanosecond = null;\nVisitor.prototype.visitDenseUnion = null;\nVisitor.prototype.visitSparseUnion = null;\nVisitor.prototype.visitIntervalDayTime = null;\nVisitor.prototype.visitIntervalYearMonth = null;\n\n// node_modules/apache-arrow/util/math.mjs\nvar math_exports = {};\n__export(math_exports, {\n  float64ToUint16: () => float64ToUint16,\n  uint16ToFloat64: () => uint16ToFloat64\n});\nvar f64 = new Float64Array(1);\nvar u32 = new Uint32Array(f64.buffer);\nfunction uint16ToFloat64(h) {\n  const expo = (h & 31744) >> 10;\n  const sigf = (h & 1023) / 1024;\n  const sign3 = Math.pow(-1, (h & 32768) >> 15);\n  switch (expo) {\n    case 31:\n      return sign3 * (sigf ? Number.NaN : 1 / 0);\n    case 0:\n      return sign3 * (sigf ? 6103515625e-14 * sigf : 0);\n  }\n  return sign3 * Math.pow(2, expo - 15) * (1 + sigf);\n}\nfunction float64ToUint16(d) {\n  if (d !== d) {\n    return 32256;\n  }\n  f64[0] = d;\n  const sign3 = (u32[1] & 2147483648) >> 16 & 65535;\n  let expo = u32[1] & 2146435072, sigf = 0;\n  if (expo >= 1089470464) {\n    if (u32[0] > 0) {\n      expo = 31744;\n    } else {\n      expo = (expo & 2080374784) >> 16;\n      sigf = (u32[1] & 1048575) >> 10;\n    }\n  } else if (expo <= 1056964608) {\n    sigf = 1048576 + (u32[1] & 1048575);\n    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;\n    expo = 0;\n  } else {\n    expo = expo - 1056964608 >> 10;\n    sigf = (u32[1] & 1048575) + 512 >> 10;\n  }\n  return sign3 | expo | sigf & 65535;\n}\n\n// node_modules/apache-arrow/visitor/set.mjs\nvar SetVisitor = class extends Visitor {\n};\nfunction wrapSet(fn) {\n  return (data, _1, _2) => {\n    if (data.setValid(_1, _2 != null)) {\n      return fn(data, _1, _2);\n    }\n  };\n}\nvar setEpochMsToDays = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs / 864e5);\n};\nvar setEpochMsToMillisecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs / 4294967296);\n};\nvar setEpochMsToMicrosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e3 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);\n};\nvar setEpochMsToNanosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e6 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);\n};\nvar setVariableWidthBytes = (values2, valueOffsets, index3, value) => {\n  if (index3 + 1 < valueOffsets.length) {\n    const { [index3]: x4, [index3 + 1]: y4 } = valueOffsets;\n    values2.set(value.subarray(0, y4 - x4), x4);\n  }\n};\nvar setBool = ({ offset: offset2, values: values2 }, index3, val) => {\n  const idx = offset2 + index3;\n  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);\n};\nvar setInt = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat16 = ({ values: values2 }, index3, value) => {\n  values2[index3] = float64ToUint16(value);\n};\nvar setAnyFloat = (data, index3, value) => {\n  switch (data.type.precision) {\n    case Precision.HALF:\n      return setFloat16(data, index3, value);\n    case Precision.SINGLE:\n    case Precision.DOUBLE:\n      return setFloat(data, index3, value);\n  }\n};\nvar setDateDay = ({ values: values2 }, index3, value) => {\n  setEpochMsToDays(values2, index3, value.valueOf());\n};\nvar setDateMillisecond = ({ values: values2 }, index3, value) => {\n  setEpochMsToMillisecondsLong(values2, index3 * 2, value.valueOf());\n};\nvar setFixedSizeBinary = ({ stride, values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setBinary = ({ values: values2, valueOffsets }, index3, value) => setVariableWidthBytes(values2, valueOffsets, index3, value);\nvar setUtf8 = ({ values: values2, valueOffsets }, index3, value) => {\n  setVariableWidthBytes(values2, valueOffsets, index3, encodeUtf8(value));\n};\nvar setDate = (data, index3, value) => {\n  data.type.unit === DateUnit.DAY ? setDateDay(data, index3, value) : setDateMillisecond(data, index3, value);\n};\nvar setTimestampSecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value / 1e3);\nvar setTimestampMillisecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value);\nvar setTimestampMicrosecond = ({ values: values2 }, index3, value) => setEpochMsToMicrosecondsLong(values2, index3 * 2, value);\nvar setTimestampNanosecond = ({ values: values2 }, index3, value) => setEpochMsToNanosecondsLong(values2, index3 * 2, value);\nvar setTimestamp = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimestampSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimestampMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimestampMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimestampNanosecond(data, index3, value);\n  }\n};\nvar setTimeSecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMillisecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMicrosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeNanosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTime = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimeSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimeMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimeMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimeNanosecond(data, index3, value);\n  }\n};\nvar setDecimal = ({ values: values2, stride }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setList = (data, index3, value) => {\n  const values2 = data.children[0];\n  const valueOffsets = data.valueOffsets;\n  const set4 = instance.getVisitFn(values2);\n  if (Array.isArray(value)) {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value[++idx]);\n    }\n  } else {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value.get(++idx));\n    }\n  }\n};\nvar setMap = (data, index3, value) => {\n  const values2 = data.children[0];\n  const { valueOffsets } = data;\n  const set4 = instance.getVisitFn(values2);\n  let { [index3]: idx, [index3 + 1]: end } = valueOffsets;\n  const entries = value instanceof Map ? value.entries() : Object.entries(value);\n  for (const val of entries) {\n    set4(values2, idx, val);\n    if (++idx >= end)\n      break;\n  }\n};\nvar _setStructArrayValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2[i]);\nvar _setStructVectorValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2.get(i));\nvar _setStructMapValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2.get(f.name));\nvar _setStructObjectValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2[f.name]);\nvar setStruct = (data, index3, value) => {\n  const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));\n  const set4 = value instanceof Map ? _setStructMapValue(index3, value) : value instanceof Vector2 ? _setStructVectorValue(index3, value) : Array.isArray(value) ? _setStructArrayValue(index3, value) : _setStructObjectValue(index3, value);\n  data.type.children.forEach((f, i) => set4(childSetters[i], data.children[i], f, i));\n};\nvar setUnion = (data, index3, value) => {\n  data.type.mode === UnionMode.Dense ? setDenseUnion(data, index3, value) : setSparseUnion(data, index3, value);\n};\nvar setDenseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, data.valueOffsets[index3], value);\n};\nvar setSparseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, index3, value);\n};\nvar setDictionary = (data, index3, value) => {\n  var _a5;\n  (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index3], value);\n};\nvar setIntervalValue = (data, index3, value) => {\n  data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index3, value) : setIntervalYearMonth(data, index3, value);\n};\nvar setIntervalDayTime = ({ values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, 2), 2 * index3);\n};\nvar setIntervalYearMonth = ({ values: values2 }, index3, value) => {\n  values2[index3] = value[0] * 12 + value[1] % 12;\n};\nvar setFixedSizeList = (data, index3, value) => {\n  const { stride } = data;\n  const child = data.children[0];\n  const set4 = instance.getVisitFn(child);\n  if (Array.isArray(value)) {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value[idx]);\n    }\n  } else {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value.get(idx));\n    }\n  }\n};\nSetVisitor.prototype.visitBool = wrapSet(setBool);\nSetVisitor.prototype.visitInt = wrapSet(setInt);\nSetVisitor.prototype.visitInt8 = wrapSet(setInt);\nSetVisitor.prototype.visitInt16 = wrapSet(setInt);\nSetVisitor.prototype.visitInt32 = wrapSet(setInt);\nSetVisitor.prototype.visitInt64 = wrapSet(setInt);\nSetVisitor.prototype.visitUint8 = wrapSet(setInt);\nSetVisitor.prototype.visitUint16 = wrapSet(setInt);\nSetVisitor.prototype.visitUint32 = wrapSet(setInt);\nSetVisitor.prototype.visitUint64 = wrapSet(setInt);\nSetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);\nSetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);\nSetVisitor.prototype.visitFloat32 = wrapSet(setFloat);\nSetVisitor.prototype.visitFloat64 = wrapSet(setFloat);\nSetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);\nSetVisitor.prototype.visitBinary = wrapSet(setBinary);\nSetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);\nSetVisitor.prototype.visitDate = wrapSet(setDate);\nSetVisitor.prototype.visitDateDay = wrapSet(setDateDay);\nSetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);\nSetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);\nSetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);\nSetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);\nSetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);\nSetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);\nSetVisitor.prototype.visitTime = wrapSet(setTime);\nSetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);\nSetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);\nSetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);\nSetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);\nSetVisitor.prototype.visitDecimal = wrapSet(setDecimal);\nSetVisitor.prototype.visitList = wrapSet(setList);\nSetVisitor.prototype.visitStruct = wrapSet(setStruct);\nSetVisitor.prototype.visitUnion = wrapSet(setUnion);\nSetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);\nSetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);\nSetVisitor.prototype.visitDictionary = wrapSet(setDictionary);\nSetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);\nSetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);\nSetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);\nSetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);\nSetVisitor.prototype.visitMap = wrapSet(setMap);\nvar instance = new SetVisitor();\n\n// node_modules/apache-arrow/row/struct.mjs\nvar kParent = Symbol.for(\"parent\");\nvar kRowIndex = Symbol.for(\"rowIndex\");\nvar StructRow = class {\n  constructor(parent, rowIndex) {\n    this[kParent] = parent;\n    this[kRowIndex] = rowIndex;\n    return new Proxy(this, new StructRowProxyHandler());\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const i = this[kRowIndex];\n    const parent = this[kParent];\n    const keys = parent.type.children;\n    const json = {};\n    for (let j = -1, n = keys.length; ++j < n; ) {\n      json[keys[j].name] = instance2.visit(parent.children[j], i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n  [Symbol.iterator]() {\n    return new StructRowIterator(this[kParent], this[kRowIndex]);\n  }\n};\nvar StructRowIterator = class {\n  constructor(data, rowIndex) {\n    this.childIndex = 0;\n    this.children = data.children;\n    this.rowIndex = rowIndex;\n    this.childFields = data.type.children;\n    this.numChildren = this.childFields.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.childIndex;\n    if (i < this.numChildren) {\n      this.childIndex = i + 1;\n      return {\n        done: false,\n        value: [\n          this.childFields[i].name,\n          instance2.visit(this.children[i], this.rowIndex)\n        ]\n      };\n    }\n    return { done: true, value: null };\n  }\n};\nObject.defineProperties(StructRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }\n});\nvar StructRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kParent].type.children.map((f) => f.name);\n  }\n  has(row, key) {\n    return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;\n  }\n  getOwnPropertyDescriptor(row, key) {\n    if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      instance.visit(row[kParent].children[idx], row[kRowIndex], val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key) || typeof key === \"symbol\") {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\n\n// node_modules/apache-arrow/visitor/get.mjs\nvar GetVisitor = class extends Visitor {\n};\nfunction wrapGet(fn) {\n  return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;\n}\nvar epochDaysToMs = (data, index3) => 864e5 * data[index3];\nvar epochMillisecondsLongToMs = (data, index3) => 4294967296 * data[index3 + 1] + (data[index3] >>> 0);\nvar epochMicrosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e3) + (data[index3] >>> 0) / 1e3;\nvar epochNanosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e6) + (data[index3] >>> 0) / 1e6;\nvar epochMillisecondsToDate = (epochMs) => new Date(epochMs);\nvar epochDaysToDate = (data, index3) => epochMillisecondsToDate(epochDaysToMs(data, index3));\nvar epochMillisecondsLongToDate = (data, index3) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index3));\nvar getNull = (_data, _index) => null;\nvar getVariableWidthBytes = (values2, valueOffsets, index3) => {\n  if (index3 + 1 >= valueOffsets.length) {\n    return null;\n  }\n  const x4 = valueOffsets[index3];\n  const y4 = valueOffsets[index3 + 1];\n  return values2.subarray(x4, y4);\n};\nvar getBool = ({ offset: offset2, values: values2 }, index3) => {\n  const idx = offset2 + index3;\n  const byte = values2[idx >> 3];\n  return (byte & 1 << idx % 8) !== 0;\n};\nvar getDateDay = ({ values: values2 }, index3) => epochDaysToDate(values2, index3);\nvar getDateMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToDate(values2, index3 * 2);\nvar getNumeric = ({ stride, values: values2 }, index3) => values2[stride * index3];\nvar getFloat16 = ({ stride, values: values2 }, index3) => uint16ToFloat64(values2[stride * index3]);\nvar getBigInts = ({ values: values2 }, index3) => values2[index3];\nvar getFixedSizeBinary = ({ stride, values: values2 }, index3) => values2.subarray(stride * index3, stride * (index3 + 1));\nvar getBinary = ({ values: values2, valueOffsets }, index3) => getVariableWidthBytes(values2, valueOffsets, index3);\nvar getUtf8 = ({ values: values2, valueOffsets }, index3) => {\n  const bytes = getVariableWidthBytes(values2, valueOffsets, index3);\n  return bytes !== null ? decodeUtf8(bytes) : null;\n};\nvar getInt = ({ values: values2 }, index3) => values2[index3];\nvar getFloat = ({ type: type2, values: values2 }, index3) => type2.precision !== Precision.HALF ? values2[index3] : uint16ToFloat64(values2[index3]);\nvar getDate = (data, index3) => data.type.unit === DateUnit.DAY ? getDateDay(data, index3) : getDateMillisecond(data, index3);\nvar getTimestampSecond = ({ values: values2 }, index3) => 1e3 * epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMicrosecond = ({ values: values2 }, index3) => epochMicrosecondsLongToMs(values2, index3 * 2);\nvar getTimestampNanosecond = ({ values: values2 }, index3) => epochNanosecondsLongToMs(values2, index3 * 2);\nvar getTimestamp = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimestampSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimestampMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimestampMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimestampNanosecond(data, index3);\n  }\n};\nvar getTimeSecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMillisecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMicrosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeNanosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTime = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimeSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimeMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimeMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimeNanosecond(data, index3);\n  }\n};\nvar getDecimal = ({ values: values2, stride }, index3) => BN.decimal(values2.subarray(stride * index3, stride * (index3 + 1)));\nvar getList = (data, index3) => {\n  const { valueOffsets, stride, children: children2 } = data;\n  const { [index3 * stride]: begin, [index3 * stride + 1]: end } = valueOffsets;\n  const child = children2[0];\n  const slice7 = child.slice(begin, end - begin);\n  return new Vector2([slice7]);\n};\nvar getMap = (data, index3) => {\n  const { valueOffsets, children: children2 } = data;\n  const { [index3]: begin, [index3 + 1]: end } = valueOffsets;\n  const child = children2[0];\n  return new MapRow(child.slice(begin, end - begin));\n};\nvar getStruct = (data, index3) => {\n  return new StructRow(data, index3);\n};\nvar getUnion = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index3) : getSparseUnion(data, index3);\n};\nvar getDenseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, data.valueOffsets[index3]);\n};\nvar getSparseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, index3);\n};\nvar getDictionary = (data, index3) => {\n  var _a5;\n  return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index3]);\n};\nvar getInterval = (data, index3) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index3) : getIntervalYearMonth(data, index3);\nvar getIntervalDayTime = ({ values: values2 }, index3) => values2.subarray(2 * index3, 2 * (index3 + 1));\nvar getIntervalYearMonth = ({ values: values2 }, index3) => {\n  const interval2 = values2[index3];\n  const int32s = new Int32Array(2);\n  int32s[0] = Math.trunc(interval2 / 12);\n  int32s[1] = Math.trunc(interval2 % 12);\n  return int32s;\n};\nvar getFixedSizeList = (data, index3) => {\n  const { stride, children: children2 } = data;\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  return new Vector2([slice7]);\n};\nGetVisitor.prototype.visitNull = wrapGet(getNull);\nGetVisitor.prototype.visitBool = wrapGet(getBool);\nGetVisitor.prototype.visitInt = wrapGet(getInt);\nGetVisitor.prototype.visitInt8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitUint8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitFloat = wrapGet(getFloat);\nGetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);\nGetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);\nGetVisitor.prototype.visitBinary = wrapGet(getBinary);\nGetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);\nGetVisitor.prototype.visitDate = wrapGet(getDate);\nGetVisitor.prototype.visitDateDay = wrapGet(getDateDay);\nGetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);\nGetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);\nGetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);\nGetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);\nGetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);\nGetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);\nGetVisitor.prototype.visitTime = wrapGet(getTime);\nGetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);\nGetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);\nGetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);\nGetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);\nGetVisitor.prototype.visitDecimal = wrapGet(getDecimal);\nGetVisitor.prototype.visitList = wrapGet(getList);\nGetVisitor.prototype.visitStruct = wrapGet(getStruct);\nGetVisitor.prototype.visitUnion = wrapGet(getUnion);\nGetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);\nGetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);\nGetVisitor.prototype.visitDictionary = wrapGet(getDictionary);\nGetVisitor.prototype.visitInterval = wrapGet(getInterval);\nGetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);\nGetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);\nGetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);\nGetVisitor.prototype.visitMap = wrapGet(getMap);\nvar instance2 = new GetVisitor();\n\n// node_modules/apache-arrow/row/map.mjs\nvar kKeys = Symbol.for(\"keys\");\nvar kVals = Symbol.for(\"vals\");\nvar MapRow = class {\n  constructor(slice7) {\n    this[kKeys] = new Vector2([slice7.children[0]]).memoize();\n    this[kVals] = slice7.children[1];\n    return new Proxy(this, new MapRowProxyHandler());\n  }\n  [Symbol.iterator]() {\n    return new MapRowIterator(this[kKeys], this[kVals]);\n  }\n  get size() {\n    return this[kKeys].length;\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const keys = this[kKeys];\n    const vals = this[kVals];\n    const json = {};\n    for (let i = -1, n = keys.length; ++i < n; ) {\n      json[keys.get(i)] = instance2.visit(vals, i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n};\nvar MapRowIterator = class {\n  constructor(keys, vals) {\n    this.keys = keys;\n    this.vals = vals;\n    this.keyIndex = 0;\n    this.numKeys = keys.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.keyIndex;\n    if (i === this.numKeys) {\n      return { done: true, value: null };\n    }\n    this.keyIndex++;\n    return {\n      done: false,\n      value: [\n        this.keys.get(i),\n        instance2.visit(this.vals, i)\n      ]\n    };\n  }\n};\nvar MapRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kKeys].toArray().map(String);\n  }\n  has(row, key) {\n    return row[kKeys].includes(key);\n  }\n  getOwnPropertyDescriptor(row, key) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      const val = instance2.visit(Reflect.get(row, kVals), idx);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      instance.visit(Reflect.get(row, kVals), idx, val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key)) {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\nObject.defineProperties(MapRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kVals]: { writable: true, enumerable: false, configurable: false, value: null }\n});\n\n// node_modules/apache-arrow/util/vector.mjs\nfunction clampIndex(source, index3, then) {\n  const length4 = source.length;\n  const adjust = index3 > -1 ? index3 : length4 + index3 % length4;\n  return then ? then(source, adjust) : adjust;\n}\nvar tmp;\nfunction clampRange(source, begin, end, then) {\n  const { length: len = 0 } = source;\n  let lhs = typeof begin !== \"number\" ? 0 : begin;\n  let rhs = typeof end !== \"number\" ? len : end;\n  lhs < 0 && (lhs = (lhs % len + len) % len);\n  rhs < 0 && (rhs = (rhs % len + len) % len);\n  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);\n  rhs > len && (rhs = len);\n  return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\nvar isNaNFast = (value) => value !== value;\nfunction createElementComparator(search) {\n  const typeofSearch = typeof search;\n  if (typeofSearch !== \"object\" || search === null) {\n    if (isNaNFast(search)) {\n      return isNaNFast;\n    }\n    return (value) => value === search;\n  }\n  if (search instanceof Date) {\n    const valueOfSearch = search.valueOf();\n    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;\n  }\n  if (ArrayBuffer.isView(search)) {\n    return (value) => value ? compareArrayLike(search, value) : false;\n  }\n  if (search instanceof Map) {\n    return createMapComparator(search);\n  }\n  if (Array.isArray(search)) {\n    return createArrayLikeComparator(search);\n  }\n  if (search instanceof Vector2) {\n    return createVectorComparator(search);\n  }\n  return createObjectComparator(search, true);\n}\nfunction createArrayLikeComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[i]);\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createMapComparator(lhs) {\n  let i = -1;\n  const comparators = [];\n  for (const v2 of lhs.values())\n    comparators[++i] = createElementComparator(v2);\n  return createSubElementsComparator(comparators);\n}\nfunction createVectorComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs.get(i));\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createObjectComparator(lhs, allowEmpty = false) {\n  const keys = Object.keys(lhs);\n  if (!allowEmpty && keys.length === 0) {\n    return () => false;\n  }\n  const comparators = [];\n  for (let i = -1, n = keys.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[keys[i]]);\n  }\n  return createSubElementsComparator(comparators, keys);\n}\nfunction createSubElementsComparator(comparators, keys) {\n  return (rhs) => {\n    if (!rhs || typeof rhs !== \"object\") {\n      return false;\n    }\n    switch (rhs.constructor) {\n      case Array:\n        return compareArray(comparators, rhs);\n      case Map:\n        return compareObject(comparators, rhs, rhs.keys());\n      case MapRow:\n      case StructRow:\n      case Object:\n      case void 0:\n        return compareObject(comparators, rhs, keys || Object.keys(rhs));\n    }\n    return rhs instanceof Vector2 ? compareVector(comparators, rhs) : false;\n  };\n}\nfunction compareArray(comparators, arr) {\n  const n = comparators.length;\n  if (arr.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](arr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareVector(comparators, vec2) {\n  const n = comparators.length;\n  if (vec2.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](vec2.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareObject(comparators, obj, keys) {\n  const lKeyItr = keys[Symbol.iterator]();\n  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n  let i = 0;\n  const n = comparators.length;\n  let rVal = rValItr.next();\n  let lKey = lKeyItr.next();\n  let rKey = rKeyItr.next();\n  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n      break;\n    }\n  }\n  if (i === n && lKey.done && rKey.done && rVal.done) {\n    return true;\n  }\n  lKeyItr.return && lKeyItr.return();\n  rKeyItr.return && rKeyItr.return();\n  rValItr.return && rValItr.return();\n  return false;\n}\n\n// node_modules/apache-arrow/util/bit.mjs\nvar bit_exports = {};\n__export(bit_exports, {\n  BitIterator: () => BitIterator,\n  getBit: () => getBit,\n  getBool: () => getBool2,\n  packBools: () => packBools,\n  popcnt_array: () => popcnt_array,\n  popcnt_bit_range: () => popcnt_bit_range,\n  popcnt_uint32: () => popcnt_uint32,\n  setBool: () => setBool2,\n  truncateBitmap: () => truncateBitmap\n});\nfunction getBool2(_data, _index, byte, bit) {\n  return (byte & 1 << bit) !== 0;\n}\nfunction getBit(_data, _index, byte, bit) {\n  return (byte & 1 << bit) >> bit;\n}\nfunction setBool2(bytes, index3, value) {\n  return value ? !!(bytes[index3 >> 3] |= 1 << index3 % 8) || true : !(bytes[index3 >> 3] &= ~(1 << index3 % 8)) && false;\n}\nfunction truncateBitmap(offset2, length4, bitmap) {\n  const alignedSize = bitmap.byteLength + 7 & ~7;\n  if (offset2 > 0 || bitmap.byteLength < alignedSize) {\n    const bytes = new Uint8Array(alignedSize);\n    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (\n      // Otherwise iterate each bit from the offset and return a new one\n      packBools(new BitIterator(bitmap, offset2, length4, null, getBool2)).subarray(0, alignedSize)\n    ));\n    return bytes;\n  }\n  return bitmap;\n}\nfunction packBools(values2) {\n  const xs = [];\n  let i = 0, bit = 0, byte = 0;\n  for (const value of values2) {\n    value && (byte |= 1 << bit);\n    if (++bit === 8) {\n      xs[i++] = byte;\n      byte = bit = 0;\n    }\n  }\n  if (i === 0 || bit > 0) {\n    xs[i++] = byte;\n  }\n  const b = new Uint8Array(xs.length + 7 & ~7);\n  b.set(xs);\n  return b;\n}\nvar BitIterator = class {\n  constructor(bytes, begin, length4, context, get3) {\n    this.bytes = bytes;\n    this.length = length4;\n    this.context = context;\n    this.get = get3;\n    this.bit = begin % 8;\n    this.byteIndex = begin >> 3;\n    this.byte = bytes[this.byteIndex++];\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.length) {\n      if (this.bit === 8) {\n        this.bit = 0;\n        this.byte = this.bytes[this.byteIndex++];\n      }\n      return {\n        value: this.get(this.context, this.index++, this.byte, this.bit++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction popcnt_bit_range(data, lhs, rhs) {\n  if (rhs - lhs <= 0) {\n    return 0;\n  }\n  if (rhs - lhs < 8) {\n    let sum5 = 0;\n    for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {\n      sum5 += bit;\n    }\n    return sum5;\n  }\n  const rhsInside = rhs >> 3 << 3;\n  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);\n  return (\n    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8\n    popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8\n    popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8\n    popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)\n  );\n}\nfunction popcnt_array(arr, byteOffset, byteLength) {\n  let cnt = 0, pos = Math.trunc(byteOffset);\n  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;\n  while (len - pos >= 4) {\n    cnt += popcnt_uint32(view.getUint32(pos));\n    pos += 4;\n  }\n  while (len - pos >= 2) {\n    cnt += popcnt_uint32(view.getUint16(pos));\n    pos += 2;\n  }\n  while (len - pos >= 1) {\n    cnt += popcnt_uint32(view.getUint8(pos));\n    pos += 1;\n  }\n  return cnt;\n}\nfunction popcnt_uint32(uint32) {\n  let i = Math.trunc(uint32);\n  i = i - (i >>> 1 & 1431655765);\n  i = (i & 858993459) + (i >>> 2 & 858993459);\n  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;\n}\n\n// node_modules/apache-arrow/data.mjs\nvar kUnknownNullCount = -1;\nvar Data = class {\n  constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {\n    this.type = type2;\n    this.children = children2;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset2 || 0, 0));\n    this.length = Math.floor(Math.max(length4 || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    let buffer;\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type2);\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n    this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get buffers() {\n    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n  }\n  get byteLength() {\n    let byteLength = 0;\n    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;\n    valueOffsets && (byteLength += valueOffsets.byteLength);\n    values2 && (byteLength += values2.byteLength);\n    nullBitmap && (byteLength += nullBitmap.byteLength);\n    typeIds && (byteLength += typeIds.byteLength);\n    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);\n  }\n  get nullCount() {\n    let nullCount = this._nullCount;\n    let nullBitmap;\n    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n    }\n    return nullCount;\n  }\n  getValid(index3) {\n    if (this.nullable && this.nullCount > 0) {\n      const pos = this.offset + index3;\n      const val = this.nullBitmap[pos >> 3];\n      return (val & 1 << pos % 8) !== 0;\n    }\n    return true;\n  }\n  setValid(index3, value) {\n    if (!this.nullable) {\n      return value;\n    }\n    if (!this.nullBitmap || this.nullBitmap.byteLength <= index3 >> 3) {\n      const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);\n      Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });\n    }\n    const { nullBitmap, offset: offset2 } = this;\n    const pos = offset2 + index3 >> 3;\n    const bit = (offset2 + index3) % 8;\n    const val = nullBitmap[pos] >> bit & 1;\n    value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);\n    return value;\n  }\n  clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {\n    return new Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);\n  }\n  slice(offset2, length4) {\n    const { stride, typeId, children: children2 } = this;\n    const nullCount = +(this._nullCount === 0) - 1;\n    const childStride = typeId === 16 ? stride : 1;\n    const buffers = this._sliceBuffers(offset2, length4, stride, typeId);\n    return this.clone(\n      this.type,\n      this.offset + offset2,\n      length4,\n      nullCount,\n      buffers,\n      // Don't slice children if we have value offsets (the variable-width types)\n      children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)\n    );\n  }\n  _changeLengthAndBackfillNullBitmap(newLength) {\n    if (this.typeId === Type.Null) {\n      return this.clone(this.type, 0, newLength, 0);\n    }\n    const { length: length4, nullCount } = this;\n    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);\n    bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;\n    if (nullCount > 0) {\n      bitmap.set(truncateBitmap(this.offset, length4, this.nullBitmap), 0);\n    }\n    const buffers = this.buffers;\n    buffers[BufferType.VALIDITY] = bitmap;\n    return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);\n  }\n  _sliceBuffers(offset2, length4, stride, typeId) {\n    let arr;\n    const { buffers } = this;\n    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length4));\n    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));\n    return buffers;\n  }\n  _sliceChildren(children2, offset2, length4) {\n    return children2.map((child) => child.slice(offset2, length4));\n  }\n};\nData.prototype.children = Object.freeze([]);\nvar MakeDataVisitor = class extends Visitor {\n  visit(props) {\n    return this.getVisitFn(props[\"type\"]).call(this, props);\n  }\n  visitNull(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"length\"]: length4 = 0 } = props;\n    return new Data(type2, offset2, length4, 0);\n  }\n  visitBool(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length >> 3, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitInt(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFloat(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitUtf8(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitFixedSizeBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDate(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTimestamp(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTime(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDecimal(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n  visitStruct(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { length: length4 = children2.reduce((len, { length: length5 }) => Math.max(len, length5), 0), nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);\n  }\n  visitUnion(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const typeIds = toArrayBufferView(type2.ArrayType, props[\"typeIds\"]);\n    const { [\"length\"]: length4 = typeIds.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    if (DataType.isSparseUnion(type2)) {\n      return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap, typeIds], children2);\n    }\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children2);\n  }\n  visitDictionary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.indices.ArrayType, props[\"data\"]);\n    const { [\"dictionary\"]: dictionary = new Vector2([new MakeDataVisitor().visit({ type: type2.dictionary })]) } = props;\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);\n  }\n  visitInterval(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFixedSizeList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.valueType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { [\"length\"]: length4 = child.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);\n  }\n  visitMap(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.childType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n};\nfunction makeData(props) {\n  return new MakeDataVisitor().visit(props);\n}\n\n// node_modules/apache-arrow/util/chunk.mjs\nvar ChunkedIterator = class {\n  constructor(numChunks = 0, getChunkIterator) {\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  next() {\n    while (this.chunkIndex < this.numChunks) {\n      const next = this.chunkIterator.next();\n      if (!next.done) {\n        return next;\n      }\n      if (++this.chunkIndex < this.numChunks) {\n        this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n      }\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction computeChunkNullCounts(chunks) {\n  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\nfunction computeChunkOffsets(chunks) {\n  return chunks.reduce((offsets, chunk, index3) => {\n    offsets[index3 + 1] = offsets[index3] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\nfunction sliceChunks(chunks, offsets, begin, end) {\n  const slices = [];\n  for (let i = -1, n = chunks.length; ++i < n; ) {\n    const chunk = chunks[i];\n    const offset2 = offsets[i];\n    const { length: length4 } = chunk;\n    if (offset2 >= end) {\n      break;\n    }\n    if (begin >= offset2 + length4) {\n      continue;\n    }\n    if (offset2 >= begin && offset2 + length4 <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    const from = Math.max(0, begin - offset2);\n    const to = Math.min(end - offset2, length4);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\nfunction binarySearch(chunks, offsets, idx, fn) {\n  let lhs = 0, mid3 = 0, rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid3 = lhs + Math.trunc((rhs - lhs) * 0.5);\n    idx < offsets[mid3] ? rhs = mid3 : lhs = mid3;\n  } while (lhs < rhs);\n}\nfunction isChunkedValid(data, index3) {\n  return data.getValid(index3);\n}\nfunction wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function(index3) {\n    const data = this.data;\n    return binarySearch(data, this._offsets, index3, chunkedFn);\n  };\n}\nfunction wrapChunkedCall2(fn) {\n  let _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function(index3, value) {\n    const data = this.data;\n    _2 = value;\n    const result = binarySearch(data, this._offsets, index3, chunkedFn);\n    _2 = void 0;\n    return result;\n  };\n}\nfunction wrapChunkedIndexOf(indexOf2) {\n  let _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    let begin = fromIndex, index3 = 0, total = 0;\n    for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {\n      const chunk = data[i];\n      if (~(index3 = indexOf2(chunk, _1, begin))) {\n        return total + index3;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function(element, offset2) {\n    _1 = element;\n    const data = this.data;\n    const result = typeof offset2 !== \"number\" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset2, chunkedIndexOf);\n    _1 = void 0;\n    return result;\n  };\n}\n\n// node_modules/apache-arrow/visitor/indexof.mjs\nvar IndexOfVisitor = class extends Visitor {\n};\nfunction nullIndexOf(data, searchElement) {\n  return searchElement === null && data.length > 0 ? 0 : -1;\n}\nfunction indexOfNull(data, fromIndex) {\n  const { nullBitmap } = data;\n  if (!nullBitmap || data.nullCount <= 0) {\n    return -1;\n  }\n  let i = 0;\n  for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {\n    if (!isValid) {\n      return i;\n    }\n    ++i;\n  }\n  return -1;\n}\nfunction indexOfValue(data, searchElement, fromIndex) {\n  if (searchElement === void 0) {\n    return -1;\n  }\n  if (searchElement === null) {\n    return indexOfNull(data, fromIndex);\n  }\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction indexOfUnion(data, searchElement, fromIndex) {\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nIndexOfVisitor.prototype.visitNull = nullIndexOf;\nIndexOfVisitor.prototype.visitBool = indexOfValue;\nIndexOfVisitor.prototype.visitInt = indexOfValue;\nIndexOfVisitor.prototype.visitInt8 = indexOfValue;\nIndexOfVisitor.prototype.visitInt16 = indexOfValue;\nIndexOfVisitor.prototype.visitInt32 = indexOfValue;\nIndexOfVisitor.prototype.visitInt64 = indexOfValue;\nIndexOfVisitor.prototype.visitUint8 = indexOfValue;\nIndexOfVisitor.prototype.visitUint16 = indexOfValue;\nIndexOfVisitor.prototype.visitUint32 = indexOfValue;\nIndexOfVisitor.prototype.visitUint64 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat = indexOfValue;\nIndexOfVisitor.prototype.visitFloat16 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat32 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat64 = indexOfValue;\nIndexOfVisitor.prototype.visitUtf8 = indexOfValue;\nIndexOfVisitor.prototype.visitBinary = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;\nIndexOfVisitor.prototype.visitDate = indexOfValue;\nIndexOfVisitor.prototype.visitDateDay = indexOfValue;\nIndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestamp = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTime = indexOfValue;\nIndexOfVisitor.prototype.visitTimeSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitDecimal = indexOfValue;\nIndexOfVisitor.prototype.visitList = indexOfValue;\nIndexOfVisitor.prototype.visitStruct = indexOfValue;\nIndexOfVisitor.prototype.visitUnion = indexOfValue;\nIndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitDictionary = indexOfValue;\nIndexOfVisitor.prototype.visitInterval = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;\nIndexOfVisitor.prototype.visitMap = indexOfValue;\nvar instance3 = new IndexOfVisitor();\n\n// node_modules/apache-arrow/visitor/iterator.mjs\nvar IteratorVisitor = class extends Visitor {\n};\nfunction vectorIterator(vector2) {\n  const { type: type2 } = vector2;\n  if (vector2.nullCount === 0 && vector2.stride === 1 && (type2.typeId === Type.Timestamp || type2 instanceof Int_ && type2.bitWidth !== 64 || type2 instanceof Time_ && type2.bitWidth !== 64 || type2 instanceof Float && type2.precision !== Precision.HALF)) {\n    return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n      const data = vector2.data[chunkIndex];\n      return data.values.subarray(0, data.length)[Symbol.iterator]();\n    });\n  }\n  let offset2 = 0;\n  return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n    const data = vector2.data[chunkIndex];\n    const length4 = data.length;\n    const inner = vector2.slice(offset2, offset2 + length4);\n    offset2 += length4;\n    return new VectorIterator(inner);\n  });\n}\nvar VectorIterator = class {\n  constructor(vector2) {\n    this.vector = vector2;\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.vector.length) {\n      return {\n        value: this.vector.get(this.index++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nIteratorVisitor.prototype.visitNull = vectorIterator;\nIteratorVisitor.prototype.visitBool = vectorIterator;\nIteratorVisitor.prototype.visitInt = vectorIterator;\nIteratorVisitor.prototype.visitInt8 = vectorIterator;\nIteratorVisitor.prototype.visitInt16 = vectorIterator;\nIteratorVisitor.prototype.visitInt32 = vectorIterator;\nIteratorVisitor.prototype.visitInt64 = vectorIterator;\nIteratorVisitor.prototype.visitUint8 = vectorIterator;\nIteratorVisitor.prototype.visitUint16 = vectorIterator;\nIteratorVisitor.prototype.visitUint32 = vectorIterator;\nIteratorVisitor.prototype.visitUint64 = vectorIterator;\nIteratorVisitor.prototype.visitFloat = vectorIterator;\nIteratorVisitor.prototype.visitFloat16 = vectorIterator;\nIteratorVisitor.prototype.visitFloat32 = vectorIterator;\nIteratorVisitor.prototype.visitFloat64 = vectorIterator;\nIteratorVisitor.prototype.visitUtf8 = vectorIterator;\nIteratorVisitor.prototype.visitBinary = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;\nIteratorVisitor.prototype.visitDate = vectorIterator;\nIteratorVisitor.prototype.visitDateDay = vectorIterator;\nIteratorVisitor.prototype.visitDateMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestamp = vectorIterator;\nIteratorVisitor.prototype.visitTimestampSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitTime = vectorIterator;\nIteratorVisitor.prototype.visitTimeSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitDecimal = vectorIterator;\nIteratorVisitor.prototype.visitList = vectorIterator;\nIteratorVisitor.prototype.visitStruct = vectorIterator;\nIteratorVisitor.prototype.visitUnion = vectorIterator;\nIteratorVisitor.prototype.visitDenseUnion = vectorIterator;\nIteratorVisitor.prototype.visitSparseUnion = vectorIterator;\nIteratorVisitor.prototype.visitDictionary = vectorIterator;\nIteratorVisitor.prototype.visitInterval = vectorIterator;\nIteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;\nIteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeList = vectorIterator;\nIteratorVisitor.prototype.visitMap = vectorIterator;\nvar instance4 = new IteratorVisitor();\n\n// node_modules/apache-arrow/visitor/bytelength.mjs\nvar sum4 = (x4, y4) => x4 + y4;\nvar GetByteLengthVisitor = class extends Visitor {\n  visitNull(____, _) {\n    return 0;\n  }\n  visitInt(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitFloat(data, _) {\n    return data.type.ArrayType.BYTES_PER_ELEMENT;\n  }\n  visitBool(____, _) {\n    return 1 / 8;\n  }\n  visitDecimal(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitDate(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitTime(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitTimestamp(data, _) {\n    return data.type.unit === TimeUnit.SECOND ? 4 : 8;\n  }\n  visitInterval(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitStruct(data, i) {\n    return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitFixedSizeBinary(data, _) {\n    return data.type.byteWidth;\n  }\n  visitMap(data, i) {\n    return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitDictionary(data, i) {\n    var _a5;\n    return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);\n  }\n};\nvar getUtf8ByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getBinaryByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getListByteLength = ({ valueOffsets, stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const { [index3 * stride]: start2 } = valueOffsets;\n  const { [index3 * stride + 1]: end } = valueOffsets;\n  const visit = instance5.getVisitFn(child.type);\n  const slice7 = child.slice(start2, end - start2);\n  let size = 8;\n  for (let idx = -1, len = end - start2; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getFixedSizeListByteLength = ({ stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  const visit = instance5.getVisitFn(child.type);\n  let size = 0;\n  for (let idx = -1, len = slice7.length; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getUnionByteLength = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index3) : getSparseUnionByteLength(data, index3);\n};\nvar getDenseUnionByteLength = ({ type: type2, children: children2, typeIds, valueOffsets }, index3) => {\n  const childIndex = type2.typeIdToChildIndex[typeIds[index3]];\n  return 8 + instance5.visit(children2[childIndex], valueOffsets[index3]);\n};\nvar getSparseUnionByteLength = ({ children: children2 }, index3) => {\n  return 4 + instance5.visitMany(children2, children2.map(() => index3)).reduce(sum4, 0);\n};\nGetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;\nGetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;\nGetByteLengthVisitor.prototype.visitList = getListByteLength;\nGetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;\nGetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;\nGetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;\nGetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;\nvar instance5 = new GetByteLengthVisitor();\n\n// node_modules/apache-arrow/vector.mjs\nvar _a2;\nvar visitorsByTypeId = {};\nvar vectorPrototypesByTypeId = {};\nvar Vector2 = class {\n  constructor(input) {\n    var _b2, _c2, _d2;\n    const data = input[0] instanceof Vector2 ? input.flatMap((x4) => x4.data) : input;\n    if (data.length === 0 || data.some((x4) => !(x4 instanceof Data))) {\n      throw new TypeError(\"Vector constructor expects an Array of Data instances.\");\n    }\n    const type2 = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;\n    switch (data.length) {\n      case 0:\n        this._offsets = [0];\n        break;\n      case 1: {\n        const { get: get3, set: set4, indexOf: indexOf2, byteLength } = visitorsByTypeId[type2.typeId];\n        const unchunkedData = data[0];\n        this.isValid = (index3) => isChunkedValid(unchunkedData, index3);\n        this.get = (index3) => get3(unchunkedData, index3);\n        this.set = (index3, value) => set4(unchunkedData, index3, value);\n        this.indexOf = (index3) => indexOf2(unchunkedData, index3);\n        this.getByteLength = (index3) => byteLength(unchunkedData, index3);\n        this._offsets = [0, unchunkedData.length];\n        break;\n      }\n      default:\n        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type2.typeId]);\n        this._offsets = computeChunkOffsets(data);\n        break;\n    }\n    this.data = data;\n    this.type = type2;\n    this.stride = strideForType(type2);\n    this.numChildren = (_d2 = (_c2 = type2.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;\n    this.length = this._offsets[this._offsets.length - 1];\n  }\n  /**\n   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.\n   */\n  get byteLength() {\n    if (this._byteLength === -1) {\n      this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);\n    }\n    return this._byteLength;\n  }\n  /**\n   * The number of null elements in this Vector.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * The Array or TypedAray constructor used for the JS representation\n   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.\n   */\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  /**\n   * The name that should be printed when the Vector is logged in a message.\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;\n  }\n  /**\n   * The name of this Vector.\n   */\n  get VectorName() {\n    return `${Type[this.type.typeId]}Vector`;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  includes(element, offset2) {\n    return this.indexOf(element, offset2) > 0;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for the Vector's elements.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(this);\n  }\n  /**\n   * Combines two or more Vectors of the same type.\n   * @param others Additional Vectors to add to the end of this Vector.\n   */\n  concat(...others) {\n    return new Vector2(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Vector.\n   * @param start The beginning of the specified portion of the Vector.\n   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    return new Vector2(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));\n  }\n  toJSON() {\n    return [...this];\n  }\n  /**\n   * Return a JavaScript Array or TypedArray of the Vector's elements.\n   *\n   * @note If this Vector contains a single Data chunk and the Vector's type is a\n   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this\n   *  method returns a zero-copy slice of the underlying TypedArray values. If there's\n   *  more than one chunk, the resulting TypedArray will be a copy of the data from each\n   *  chunk's underlying TypedArray values.\n   *\n   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.\n   */\n  toArray() {\n    const { type: type2, data, length: length4, stride, ArrayType } = this;\n    switch (type2.typeId) {\n      case Type.Int:\n      case Type.Float:\n      case Type.Decimal:\n      case Type.Time:\n      case Type.Timestamp:\n        switch (data.length) {\n          case 0:\n            return new ArrayType();\n          case 1:\n            return data[0].values.subarray(0, length4 * stride);\n          default:\n            return data.reduce((memo, { values: values2, length: chunk_length }) => {\n              memo.array.set(values2.subarray(0, chunk_length * stride), memo.offset);\n              memo.offset += chunk_length * stride;\n              return memo;\n            }, { array: new ArrayType(length4 * stride), offset: 0 }).array;\n        }\n    }\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Vector.\n   *\n   * @returns A string representation of the Vector.\n   */\n  toString() {\n    return `[${[...this].join(\",\")}]`;\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.numChildren) {\n      return new Vector2(this.data.map(({ children: children2 }) => children2[index3]));\n    }\n    return null;\n  }\n  get isMemoized() {\n    if (DataType.isDictionary(this.type)) {\n      return this.data[0].dictionary.isMemoized;\n    }\n    return false;\n  }\n  /**\n   * Adds memoization to the Vector's {@link get} method. For dictionary\n   * vectors, this method return a vector that memoizes only the dictionary\n   * values.\n   *\n   * Memoization is very useful when decoding a value is expensive such as\n   * Uft8. The memoization creates a cache of the size of the Vector and\n   * therfore increases memory usage.\n   *\n   * @returns A new vector that memoizes calls to {@link get}.\n   */\n  memoize() {\n    if (DataType.isDictionary(this.type)) {\n      const dictionary = new MemoizedVector(this.data[0].dictionary);\n      const newData = this.data.map((data) => {\n        const cloned = data.clone();\n        cloned.dictionary = dictionary;\n        return cloned;\n      });\n      return new Vector2(newData);\n    }\n    return new MemoizedVector(this);\n  }\n  /**\n   * Returns a vector without memoization of the {@link get} method. If this\n   * vector is not memoized, this method returns this vector.\n   *\n   * @returns A a vector without memoization.\n   */\n  unmemoize() {\n    if (DataType.isDictionary(this.type) && this.isMemoized) {\n      const dictionary = this.data[0].dictionary.unmemoize();\n      const newData = this.data.map((data) => {\n        const newData2 = data.clone();\n        newData2.dictionary = dictionary;\n        return newData2;\n      });\n      return new Vector2(newData);\n    }\n    return this;\n  }\n};\n_a2 = Symbol.toStringTag;\nVector2[_a2] = ((proto) => {\n  proto.type = DataType.prototype;\n  proto.data = [];\n  proto.length = 0;\n  proto.stride = 1;\n  proto.numChildren = 0;\n  proto._nullCount = -1;\n  proto._byteLength = -1;\n  proto._offsets = new Uint32Array([0]);\n  proto[Symbol.isConcatSpreadable] = true;\n  const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === \"number\" && T !== Type.NONE);\n  for (const typeId of typeIds) {\n    const get3 = instance2.getVisitFnByTypeId(typeId);\n    const set4 = instance.getVisitFnByTypeId(typeId);\n    const indexOf2 = instance3.getVisitFnByTypeId(typeId);\n    const byteLength = instance5.getVisitFnByTypeId(typeId);\n    visitorsByTypeId[typeId] = { get: get3, set: set4, indexOf: indexOf2, byteLength };\n    vectorPrototypesByTypeId[typeId] = Object.create(proto, {\n      [\"isValid\"]: { value: wrapChunkedCall1(isChunkedValid) },\n      [\"get\"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },\n      [\"set\"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },\n      [\"indexOf\"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },\n      [\"getByteLength\"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }\n    });\n  }\n  return \"Vector\";\n})(Vector2.prototype);\nvar MemoizedVector = class extends Vector2 {\n  constructor(vector2) {\n    super(vector2.data);\n    const get3 = this.get;\n    const set4 = this.set;\n    const slice7 = this.slice;\n    const cache = new Array(this.length);\n    Object.defineProperty(this, \"get\", {\n      value(index3) {\n        const cachedValue = cache[index3];\n        if (cachedValue !== void 0) {\n          return cachedValue;\n        }\n        const value = get3.call(this, index3);\n        cache[index3] = value;\n        return value;\n      }\n    });\n    Object.defineProperty(this, \"set\", {\n      value(index3, value) {\n        set4.call(this, index3, value);\n        cache[index3] = value;\n      }\n    });\n    Object.defineProperty(this, \"slice\", {\n      value: (begin, end) => new MemoizedVector(slice7.call(this, begin, end))\n    });\n    Object.defineProperty(this, \"isMemoized\", { value: true });\n    Object.defineProperty(this, \"unmemoize\", {\n      value: () => new Vector2(this.data)\n    });\n    Object.defineProperty(this, \"memoize\", {\n      value: () => this\n    });\n  }\n};\n\n// node_modules/apache-arrow/builder/valid.mjs\nfunction createIsValidFunction(nullValues) {\n  if (!nullValues || nullValues.length <= 0) {\n    return function isValid(value) {\n      return true;\n    };\n  }\n  let fnBody = \"\";\n  const noNaNs = nullValues.filter((x4) => x4 === x4);\n  if (noNaNs.length > 0) {\n    fnBody = `\n    switch (x) {${noNaNs.map((x4) => `\n        case ${valueToCase(x4)}:`).join(\"\")}\n            return false;\n    }`;\n  }\n  if (nullValues.length !== noNaNs.length) {\n    fnBody = `if (x !== x) return false;\n${fnBody}`;\n  }\n  return new Function(`x`, `${fnBody}\nreturn true;`);\n}\nfunction valueToCase(x4) {\n  if (typeof x4 !== \"bigint\") {\n    return valueToString(x4);\n  } else if (BigIntAvailable) {\n    return `${valueToString(x4)}n`;\n  }\n  return `\"${valueToString(x4)}\"`;\n}\n\n// node_modules/apache-arrow/builder/buffer.mjs\nvar roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;\nvar sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);\nvar BufferBuilder = class {\n  constructor(buffer, stride = 1) {\n    this.buffer = buffer;\n    this.stride = stride;\n    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;\n    this.ArrayType = buffer.constructor;\n    this._resize(this.length = Math.ceil(buffer.length / stride));\n  }\n  get byteLength() {\n    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;\n  }\n  get reservedLength() {\n    return this.buffer.length / this.stride;\n  }\n  get reservedByteLength() {\n    return this.buffer.byteLength;\n  }\n  // @ts-ignore\n  set(index3, value) {\n    return this;\n  }\n  append(value) {\n    return this.set(this.length, value);\n  }\n  reserve(extra) {\n    if (extra > 0) {\n      this.length += extra;\n      const stride = this.stride;\n      const length4 = this.length * stride;\n      const reserved = this.buffer.length;\n      if (length4 >= reserved) {\n        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length4 * 2, this.BYTES_PER_ELEMENT));\n      }\n    }\n    return this;\n  }\n  flush(length4 = this.length) {\n    length4 = roundLengthUpToNearest64Bytes(length4 * this.stride, this.BYTES_PER_ELEMENT);\n    const array4 = sliceOrExtendArray(this.buffer, length4);\n    this.clear();\n    return array4;\n  }\n  clear() {\n    this.length = 0;\n    this._resize(0);\n    return this;\n  }\n  _resize(newLength) {\n    return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);\n  }\n};\nBufferBuilder.prototype.offset = 0;\nvar DataBufferBuilder = class extends BufferBuilder {\n  last() {\n    return this.get(this.length - 1);\n  }\n  get(index3) {\n    return this.buffer[index3];\n  }\n  set(index3, value) {\n    this.reserve(index3 - this.length + 1);\n    this.buffer[index3 * this.stride] = value;\n    return this;\n  }\n};\nvar BitmapBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Uint8Array(0)) {\n    super(data, 1 / 8);\n    this.numValid = 0;\n  }\n  get numInvalid() {\n    return this.length - this.numValid;\n  }\n  get(idx) {\n    return this.buffer[idx >> 3] >> idx % 8 & 1;\n  }\n  set(idx, val) {\n    const { buffer } = this.reserve(idx - this.length + 1);\n    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;\n    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);\n    return this;\n  }\n  clear() {\n    this.numValid = 0;\n    return super.clear();\n  }\n};\nvar OffsetsBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Int32Array(1)) {\n    super(data, 1);\n  }\n  append(value) {\n    return this.set(this.length - 1, value);\n  }\n  set(index3, value) {\n    const offset2 = this.length - 1;\n    const buffer = this.reserve(index3 - offset2 + 1).buffer;\n    if (offset2 < index3++) {\n      buffer.fill(buffer[offset2], offset2, index3);\n    }\n    buffer[index3] = buffer[index3 - 1] + value;\n    return this;\n  }\n  flush(length4 = this.length - 1) {\n    if (length4 > this.length) {\n      this.set(length4 - 1, 0);\n    }\n    return super.flush(length4 + 1);\n  }\n};\n\n// node_modules/apache-arrow/builder.mjs\nvar Builder = class {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  constructor({ \"type\": type2, \"nullValues\": nulls }) {\n    this.length = 0;\n    this.finished = false;\n    this.type = type2;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type2);\n    this._nulls = new BitmapBufferBuilder();\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughDOM(options) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /**\n   * Flush the `Builder` and return a `Vector<T>`.\n   * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n   */\n  toVector() {\n    return new Vector2([this.flush()]);\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get nullCount() {\n    return this._nulls.numInvalid;\n  }\n  get numChildren() {\n    return this.children.length;\n  }\n  /**\n   * @returns The aggregate length (in bytes) of the values that have been written.\n   */\n  get byteLength() {\n    let size = 0;\n    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;\n    _offsets && (size += _offsets.byteLength);\n    _values && (size += _values.byteLength);\n    _nulls && (size += _nulls.byteLength);\n    _typeIds && (size += _typeIds.byteLength);\n    return children2.reduce((size2, child) => size2 + child.byteLength, size);\n  }\n  /**\n   * @returns The aggregate number of rows that have been reserved to write new values.\n   */\n  get reservedLength() {\n    return this._nulls.reservedLength;\n  }\n  /**\n   * @returns The aggregate length (in bytes) that has been reserved to write new values.\n   */\n  get reservedByteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.reservedByteLength);\n    this._values && (size += this._values.reservedByteLength);\n    this._nulls && (size += this._nulls.reservedByteLength);\n    this._typeIds && (size += this._typeIds.reservedByteLength);\n    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);\n  }\n  get valueOffsets() {\n    return this._offsets ? this._offsets.buffer : null;\n  }\n  get values() {\n    return this._values ? this._values.buffer : null;\n  }\n  get nullBitmap() {\n    return this._nulls ? this._nulls.buffer : null;\n  }\n  get typeIds() {\n    return this._typeIds ? this._typeIds.buffer : null;\n  }\n  /**\n   * Appends a value (or null) to this `Builder`.\n   * This is equivalent to `builder.set(builder.length, value)`.\n   * @param {T['TValue'] | TNull } value The value to append.\n   */\n  append(value) {\n    return this.set(this.length, value);\n  }\n  /**\n   * Validates whether a value is valid (true), or null (false)\n   * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n   */\n  isValid(value) {\n    return this._isValid(value);\n  }\n  /**\n   * Write a value (or null-value sentinel) at the supplied index.\n   * If the value matches one of the null-value representations, a 1-bit is\n   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n   * the null `BitmapBufferBuilder`, and the value is passed to\n   * `Builder.prototype.setValue()`.\n   * @param {number} index The index of the value to write.\n   * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n   * @returns {this} The updated `Builder` instance.\n   */\n  set(index3, value) {\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value);\n    }\n    return this;\n  }\n  /**\n   * Write a value to the underlying buffers at the supplied index, bypassing\n   * the null-value check. This is a low-level method that\n   * @param {number} index\n   * @param {T['TValue'] | TNull } value\n   */\n  setValue(index3, value) {\n    this._setValue(this, index3, value);\n  }\n  setValid(index3, valid2) {\n    this.length = this._nulls.set(index3, +valid2).length;\n    return valid2;\n  }\n  // @ts-ignore\n  addChild(child, name = `${this.numChildren}`) {\n    throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n  }\n  /**\n   * Retrieve the child `Builder` at the supplied `index`, or null if no child\n   * exists at that index.\n   * @param {number} index The index of the child `Builder` to retrieve.\n   * @returns {Builder | null} The child Builder at the supplied index or null.\n   */\n  getChildAt(index3) {\n    return this.children[index3] || null;\n  }\n  /**\n   * Commit all the values that have been written to their underlying\n   * ArrayBuffers, including any child Builders if applicable, and reset\n   * the internal `Builder` state.\n   * @returns A `Data<T>` of the buffers and children representing the values written.\n   */\n  flush() {\n    let data;\n    let typeIds;\n    let nullBitmap;\n    let valueOffsets;\n    const { type: type2, length: length4, nullCount, _typeIds, _offsets, _values, _nulls } = this;\n    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {\n      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);\n    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());\n    } else {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);\n    }\n    if (nullCount > 0) {\n      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);\n    }\n    const children2 = this.children.map((child) => child.flush());\n    this.clear();\n    return makeData({\n      type: type2,\n      length: length4,\n      nullCount,\n      children: children2,\n      \"child\": children2[0],\n      data,\n      typeIds,\n      nullBitmap,\n      valueOffsets\n    });\n  }\n  /**\n   * Finalize this `Builder`, and child builders if applicable.\n   * @returns {this} The finalized `Builder` instance.\n   */\n  finish() {\n    this.finished = true;\n    for (const child of this.children)\n      child.finish();\n    return this;\n  }\n  /**\n   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n   * @returns {this} The cleared `Builder` instance.\n   */\n  clear() {\n    var _a5, _b2, _c2, _d2;\n    this.length = 0;\n    (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();\n    (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();\n    (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();\n    (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();\n    for (const child of this.children)\n      child.clear();\n    return this;\n  }\n};\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\nBuilder.prototype._isValid = () => true;\nvar FixedWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n  }\n  setValue(index3, value) {\n    const values2 = this._values;\n    values2.reserve(index3 - values2.length + 1);\n    return super.setValue(index3, value);\n  }\n};\nvar VariableWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._pendingLength = 0;\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  setValue(index3, value) {\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.length);\n    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;\n    pending.set(index3, value);\n  }\n  setValid(index3, isValid) {\n    if (!super.setValid(index3, isValid)) {\n      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index3, void 0);\n      return false;\n    }\n    return true;\n  }\n  clear() {\n    this._pendingLength = 0;\n    this._pending = void 0;\n    return super.clear();\n  }\n  flush() {\n    this._flush();\n    return super.flush();\n  }\n  finish() {\n    this._flush();\n    return super.finish();\n  }\n  _flush() {\n    const pending = this._pending;\n    const pendingLength = this._pendingLength;\n    this._pendingLength = 0;\n    this._pending = void 0;\n    if (pending && pending.size > 0) {\n      this._flushPending(pending, pendingLength);\n    }\n    return this;\n  }\n};\n\n// node_modules/apache-arrow/fb/block.mjs\nvar Block = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * Index to the start of the RecordBlock (note this is past the Message header)\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * Length of the metadata\n   */\n  metaDataLength() {\n    return this.bb.readInt32(this.bb_pos + 8);\n  }\n  /**\n   * Length of the data (this is aligned so there can be a gap between this and\n   * the metadata).\n   */\n  bodyLength() {\n    return this.bb.readInt64(this.bb_pos + 16);\n  }\n  static sizeOf() {\n    return 24;\n  }\n  static createBlock(builder, offset2, metaDataLength, bodyLength) {\n    builder.prep(8, 24);\n    builder.writeInt64(bodyLength);\n    builder.pad(4);\n    builder.writeInt32(metaDataLength);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/flatbuffers/mjs/constants.js\nvar SIZEOF_SHORT = 2;\nvar SIZEOF_INT = 4;\nvar FILE_IDENTIFIER_LENGTH = 4;\nvar SIZE_PREFIX_LENGTH = 4;\n\n// node_modules/flatbuffers/mjs/utils.js\nvar int32 = new Int32Array(2);\nvar float32 = new Float32Array(int32.buffer);\nvar float64 = new Float64Array(int32.buffer);\nvar isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n// node_modules/flatbuffers/mjs/long.js\nvar Long = class {\n  constructor(low, high) {\n    this.low = low | 0;\n    this.high = high | 0;\n  }\n  static create(low, high) {\n    return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);\n  }\n  toFloat64() {\n    return (this.low >>> 0) + this.high * 4294967296;\n  }\n  equals(other) {\n    return this.low == other.low && this.high == other.high;\n  }\n};\nLong.ZERO = new Long(0, 0);\n\n// node_modules/flatbuffers/mjs/encoding.js\nvar Encoding;\n(function(Encoding2) {\n  Encoding2[Encoding2[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n  Encoding2[Encoding2[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n\n// node_modules/flatbuffers/mjs/byte-buffer.js\nvar ByteBuffer = class {\n  /**\n   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n   */\n  constructor(bytes_) {\n    this.bytes_ = bytes_;\n    this.position_ = 0;\n  }\n  /**\n   * Create and allocate a new ByteBuffer with a given size.\n   */\n  static allocate(byte_size) {\n    return new ByteBuffer(new Uint8Array(byte_size));\n  }\n  clear() {\n    this.position_ = 0;\n  }\n  /**\n   * Get the underlying `Uint8Array`.\n   */\n  bytes() {\n    return this.bytes_;\n  }\n  /**\n   * Get the buffer's position.\n   */\n  position() {\n    return this.position_;\n  }\n  /**\n   * Set the buffer's position.\n   */\n  setPosition(position2) {\n    this.position_ = position2;\n  }\n  /**\n   * Get the buffer's capacity.\n   */\n  capacity() {\n    return this.bytes_.length;\n  }\n  readInt8(offset2) {\n    return this.readUint8(offset2) << 24 >> 24;\n  }\n  readUint8(offset2) {\n    return this.bytes_[offset2];\n  }\n  readInt16(offset2) {\n    return this.readUint16(offset2) << 16 >> 16;\n  }\n  readUint16(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;\n  }\n  readInt32(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;\n  }\n  readUint32(offset2) {\n    return this.readInt32(offset2) >>> 0;\n  }\n  readInt64(offset2) {\n    return new Long(this.readInt32(offset2), this.readInt32(offset2 + 4));\n  }\n  readUint64(offset2) {\n    return new Long(this.readUint32(offset2), this.readUint32(offset2 + 4));\n  }\n  readFloat32(offset2) {\n    int32[0] = this.readInt32(offset2);\n    return float32[0];\n  }\n  readFloat64(offset2) {\n    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);\n    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);\n    return float64[0];\n  }\n  writeInt8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeUint8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeInt16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeUint16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeInt32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeUint32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeInt64(offset2, value) {\n    this.writeInt32(offset2, value.low);\n    this.writeInt32(offset2 + 4, value.high);\n  }\n  writeUint64(offset2, value) {\n    this.writeUint32(offset2, value.low);\n    this.writeUint32(offset2 + 4, value.high);\n  }\n  writeFloat32(offset2, value) {\n    float32[0] = value;\n    this.writeInt32(offset2, int32[0]);\n  }\n  writeFloat64(offset2, value) {\n    float64[0] = value;\n    this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);\n    this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);\n  }\n  /**\n   * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n   * schema does not include a file_identifier (likely points at padding or the\n   * start of a the root vtable).\n   */\n  getBufferIdentifier() {\n    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n    }\n    let result = \"\";\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n    }\n    return result;\n  }\n  /**\n   * Look up a field in the vtable, return an offset into the object, or 0 if the\n   * field is not present.\n   */\n  __offset(bb_pos, vtable_offset) {\n    const vtable = bb_pos - this.readInt32(bb_pos);\n    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n  }\n  /**\n   * Initialize any Table-derived type to point to the union at the given offset.\n   */\n  __union(t, offset2) {\n    t.bb_pos = offset2 + this.readInt32(offset2);\n    t.bb = this;\n    return t;\n  }\n  /**\n   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n   * This allocates a new string and converts to wide chars upon each access.\n   *\n   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\n   * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n   * and from UTF-16 when the data will just be packaged back up in another\n   * FlatBuffer later on.\n   *\n   * @param offset\n   * @param opt_encoding Defaults to UTF16_STRING\n   */\n  __string(offset2, opt_encoding) {\n    offset2 += this.readInt32(offset2);\n    const length4 = this.readInt32(offset2);\n    let result = \"\";\n    let i = 0;\n    offset2 += SIZEOF_INT;\n    if (opt_encoding === Encoding.UTF8_BYTES) {\n      return this.bytes_.subarray(offset2, offset2 + length4);\n    }\n    while (i < length4) {\n      let codePoint;\n      const a4 = this.readUint8(offset2 + i++);\n      if (a4 < 192) {\n        codePoint = a4;\n      } else {\n        const b = this.readUint8(offset2 + i++);\n        if (a4 < 224) {\n          codePoint = (a4 & 31) << 6 | b & 63;\n        } else {\n          const c6 = this.readUint8(offset2 + i++);\n          if (a4 < 240) {\n            codePoint = (a4 & 15) << 12 | (b & 63) << 6 | c6 & 63;\n          } else {\n            const d = this.readUint8(offset2 + i++);\n            codePoint = (a4 & 7) << 18 | (b & 63) << 12 | (c6 & 63) << 6 | d & 63;\n          }\n        }\n      }\n      if (codePoint < 65536) {\n        result += String.fromCharCode(codePoint);\n      } else {\n        codePoint -= 65536;\n        result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);\n      }\n    }\n    return result;\n  }\n  /**\n   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n   * if a string then return a new one\n   *\n   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n   * makes the behaviour of __union_with_string different compared to __union\n   */\n  __union_with_string(o, offset2) {\n    if (typeof o === \"string\") {\n      return this.__string(offset2);\n    }\n    return this.__union(o, offset2);\n  }\n  /**\n   * Retrieve the relative offset stored at \"offset\"\n   */\n  __indirect(offset2) {\n    return offset2 + this.readInt32(offset2);\n  }\n  /**\n   * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector(offset2) {\n    return offset2 + this.readInt32(offset2) + SIZEOF_INT;\n  }\n  /**\n   * Get the length of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector_len(offset2) {\n    return this.readInt32(offset2 + this.readInt32(offset2));\n  }\n  __has_identifier(ident) {\n    if (ident.length != FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n    }\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function for generating list for obj api\n   */\n  createScalarList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      if (listAccessor(i) !== null) {\n        ret.push(listAccessor(i));\n      }\n    }\n    return ret;\n  }\n  /**\n   * A helper function for generating list for obj api\n   * @param listAccessor function that accepts an index and return data at that index\n   * @param listLength listLength\n   * @param res result list\n   */\n  createObjList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val.unpack());\n      }\n    }\n    return ret;\n  }\n};\n\n// node_modules/flatbuffers/mjs/builder.js\nvar Builder2 = class {\n  /**\n   * Create a FlatBufferBuilder.\n   */\n  constructor(opt_initial_size) {\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n    let initial_size;\n    if (!opt_initial_size) {\n      initial_size = 1024;\n    } else {\n      initial_size = opt_initial_size;\n    }\n    this.bb = ByteBuffer.allocate(initial_size);\n    this.space = initial_size;\n  }\n  clear() {\n    this.bb.clear();\n    this.space = this.bb.capacity();\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n  }\n  /**\n   * In order to save space, fields that are set to their default value\n   * don't get serialized into the buffer. Forcing defaults provides a\n   * way to manually disable this optimization.\n   *\n   * @param forceDefaults true always serializes default values\n   */\n  forceDefaults(forceDefaults) {\n    this.force_defaults = forceDefaults;\n  }\n  /**\n   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n   * called finish(). The actual data starts at the ByteBuffer's current position,\n   * not necessarily at 0.\n   */\n  dataBuffer() {\n    return this.bb;\n  }\n  /**\n   * Get the bytes representing the FlatBuffer. Only call this after you've\n   * called finish().\n   */\n  asUint8Array() {\n    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n  }\n  /**\n   * Prepare to write an element of `size` after `additional_bytes` have been\n   * written, e.g. if you write a string, you need to align such the int length\n   * field is aligned to 4 bytes, and the string data follows it directly. If all\n   * you need to do is alignment, `additional_bytes` will be 0.\n   *\n   * @param size This is the of the new element to write\n   * @param additional_bytes The padding size\n   */\n  prep(size, additional_bytes) {\n    if (size > this.minalign) {\n      this.minalign = size;\n    }\n    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n    while (this.space < align_size + size + additional_bytes) {\n      const old_buf_size = this.bb.capacity();\n      this.bb = Builder2.growByteBuffer(this.bb);\n      this.space += this.bb.capacity() - old_buf_size;\n    }\n    this.pad(align_size);\n  }\n  pad(byte_size) {\n    for (let i = 0; i < byte_size; i++) {\n      this.bb.writeInt8(--this.space, 0);\n    }\n  }\n  writeInt8(value) {\n    this.bb.writeInt8(this.space -= 1, value);\n  }\n  writeInt16(value) {\n    this.bb.writeInt16(this.space -= 2, value);\n  }\n  writeInt32(value) {\n    this.bb.writeInt32(this.space -= 4, value);\n  }\n  writeInt64(value) {\n    this.bb.writeInt64(this.space -= 8, value);\n  }\n  writeFloat32(value) {\n    this.bb.writeFloat32(this.space -= 4, value);\n  }\n  writeFloat64(value) {\n    this.bb.writeFloat64(this.space -= 8, value);\n  }\n  /**\n   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int8` to add the the buffer.\n   */\n  addInt8(value) {\n    this.prep(1, 0);\n    this.writeInt8(value);\n  }\n  /**\n   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int16` to add the the buffer.\n   */\n  addInt16(value) {\n    this.prep(2, 0);\n    this.writeInt16(value);\n  }\n  /**\n   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int32` to add the the buffer.\n   */\n  addInt32(value) {\n    this.prep(4, 0);\n    this.writeInt32(value);\n  }\n  /**\n   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int64` to add the the buffer.\n   */\n  addInt64(value) {\n    this.prep(8, 0);\n    this.writeInt64(value);\n  }\n  /**\n   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float32` to add the the buffer.\n   */\n  addFloat32(value) {\n    this.prep(4, 0);\n    this.writeFloat32(value);\n  }\n  /**\n   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float64` to add the the buffer.\n   */\n  addFloat64(value) {\n    this.prep(8, 0);\n    this.writeFloat64(value);\n  }\n  addFieldInt8(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt8(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt16(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt16(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt64(voffset, value, defaultValue) {\n    if (this.force_defaults || !value.equals(defaultValue)) {\n      this.addInt64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat64(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldOffset(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addOffset(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n   */\n  addFieldStruct(voffset, value, defaultValue) {\n    if (value != defaultValue) {\n      this.nested(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structures are always stored inline, they need to be created right\n   * where they're used.  You'll get this assertion failure if you\n   * created it elsewhere.\n   */\n  nested(obj) {\n    if (obj != this.offset()) {\n      throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n    }\n  }\n  /**\n   * Should not be creating any other object, string or vector\n   * while an object is being constructed\n   */\n  notNested() {\n    if (this.isNested) {\n      throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n    }\n  }\n  /**\n   * Set the current vtable at `voffset` to the current location in the buffer.\n   */\n  slot(voffset) {\n    if (this.vtable !== null)\n      this.vtable[voffset] = this.offset();\n  }\n  /**\n   * @returns Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.bb.capacity() - this.space;\n  }\n  /**\n   * Doubles the size of the backing ByteBuffer and copies the old data towards\n   * the end of the new buffer (since we build the buffer backwards).\n   *\n   * @param bb The current buffer with the existing data\n   * @returns A new byte buffer with the old data copied\n   * to it. The data is located at the end of the buffer.\n   *\n   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n   * it a uint8Array we need to suppress the type check:\n   * @suppress {checkTypes}\n   */\n  static growByteBuffer(bb2) {\n    const old_buf_size = bb2.capacity();\n    if (old_buf_size & 3221225472) {\n      throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n    }\n    const new_buf_size = old_buf_size << 1;\n    const nbb = ByteBuffer.allocate(new_buf_size);\n    nbb.setPosition(new_buf_size - old_buf_size);\n    nbb.bytes().set(bb2.bytes(), new_buf_size - old_buf_size);\n    return nbb;\n  }\n  /**\n   * Adds on offset, relative to where it will be written.\n   *\n   * @param offset The offset to add.\n   */\n  addOffset(offset2) {\n    this.prep(SIZEOF_INT, 0);\n    this.writeInt32(this.offset() - offset2 + SIZEOF_INT);\n  }\n  /**\n   * Start encoding a new object in the buffer.  Users will not usually need to\n   * call this directly. The FlatBuffers compiler will generate helper methods\n   * that call this method internally.\n   */\n  startObject(numfields) {\n    this.notNested();\n    if (this.vtable == null) {\n      this.vtable = [];\n    }\n    this.vtable_in_use = numfields;\n    for (let i = 0; i < numfields; i++) {\n      this.vtable[i] = 0;\n    }\n    this.isNested = true;\n    this.object_start = this.offset();\n  }\n  /**\n   * Finish off writing the object that is under construction.\n   *\n   * @returns The offset to the object inside `dataBuffer`\n   */\n  endObject() {\n    if (this.vtable == null || !this.isNested) {\n      throw new Error(\"FlatBuffers: endObject called without startObject\");\n    }\n    this.addInt32(0);\n    const vtableloc = this.offset();\n    let i = this.vtable_in_use - 1;\n    for (; i >= 0 && this.vtable[i] == 0; i--) {\n    }\n    const trimmed_size = i + 1;\n    for (; i >= 0; i--) {\n      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n    }\n    const standard_fields = 2;\n    this.addInt16(vtableloc - this.object_start);\n    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n    this.addInt16(len);\n    let existing_vtable = 0;\n    const vt1 = this.space;\n    outer_loop:\n      for (i = 0; i < this.vtables.length; i++) {\n        const vt2 = this.bb.capacity() - this.vtables[i];\n        if (len == this.bb.readInt16(vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existing_vtable = this.vtables[i];\n          break;\n        }\n      }\n    if (existing_vtable) {\n      this.space = this.bb.capacity() - vtableloc;\n      this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n    } else {\n      this.vtables.push(this.offset());\n      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n    }\n    this.isNested = false;\n    return vtableloc;\n  }\n  /**\n   * Finalize a buffer, poiting to the given `root_table`.\n   */\n  finish(root_table, opt_file_identifier, opt_size_prefix) {\n    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n    if (opt_file_identifier) {\n      const file_identifier = opt_file_identifier;\n      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n        throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n      }\n      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n        this.writeInt8(file_identifier.charCodeAt(i));\n      }\n    }\n    this.prep(this.minalign, SIZEOF_INT + size_prefix);\n    this.addOffset(root_table);\n    if (size_prefix) {\n      this.addInt32(this.bb.capacity() - this.space);\n    }\n    this.bb.setPosition(this.space);\n  }\n  /**\n   * Finalize a size prefixed buffer, pointing to the given `root_table`.\n   */\n  finishSizePrefixed(root_table, opt_file_identifier) {\n    this.finish(root_table, opt_file_identifier, true);\n  }\n  /**\n   * This checks a required field has been set in a given table that has\n   * just been constructed.\n   */\n  requiredField(table, field2) {\n    const table_start = this.bb.capacity() - table;\n    const vtable_start = table_start - this.bb.readInt32(table_start);\n    const ok = this.bb.readInt16(vtable_start + field2) != 0;\n    if (!ok) {\n      throw new Error(\"FlatBuffers: field \" + field2 + \" must be set\");\n    }\n  }\n  /**\n   * Start a new array/vector of objects.  Users usually will not call\n   * this directly. The FlatBuffers compiler will create a start/end\n   * method for vector types in generated code.\n   *\n   * @param elem_size The size of each element in the array\n   * @param num_elems The number of elements in the array\n   * @param alignment The alignment of the array\n   */\n  startVector(elem_size, num_elems, alignment) {\n    this.notNested();\n    this.vector_num_elems = num_elems;\n    this.prep(SIZEOF_INT, elem_size * num_elems);\n    this.prep(alignment, elem_size * num_elems);\n  }\n  /**\n   * Finish off the creation of an array and all its elements. The array must be\n   * created with `startVector`.\n   *\n   * @returns The offset at which the newly created array\n   * starts.\n   */\n  endVector() {\n    this.writeInt32(this.vector_num_elems);\n    return this.offset();\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If the string passed has\n   * already been seen, we return the offset of the already written string\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createSharedString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    if (!this.string_maps) {\n      this.string_maps = /* @__PURE__ */ new Map();\n    }\n    if (this.string_maps.has(s2)) {\n      return this.string_maps.get(s2);\n    }\n    const offset2 = this.createString(s2);\n    this.string_maps.set(s2, offset2);\n    return offset2;\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n   * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    let utf8;\n    if (s2 instanceof Uint8Array) {\n      utf8 = s2;\n    } else {\n      utf8 = [];\n      let i = 0;\n      while (i < s2.length) {\n        let codePoint;\n        const a4 = s2.charCodeAt(i++);\n        if (a4 < 55296 || a4 >= 56320) {\n          codePoint = a4;\n        } else {\n          const b = s2.charCodeAt(i++);\n          codePoint = (a4 << 10) + b + (65536 - (55296 << 10) - 56320);\n        }\n        if (codePoint < 128) {\n          utf8.push(codePoint);\n        } else {\n          if (codePoint < 2048) {\n            utf8.push(codePoint >> 6 & 31 | 192);\n          } else {\n            if (codePoint < 65536) {\n              utf8.push(codePoint >> 12 & 15 | 224);\n            } else {\n              utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);\n            }\n            utf8.push(codePoint >> 6 & 63 | 128);\n          }\n          utf8.push(codePoint & 63 | 128);\n        }\n      }\n    }\n    this.addInt8(0);\n    this.startVector(1, utf8.length, 1);\n    this.bb.setPosition(this.space -= utf8.length);\n    for (let i = 0, offset2 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n      bytes[offset2++] = utf8[i];\n    }\n    return this.endVector();\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function to pack an object\n   *\n   * @returns offset of obj\n   */\n  createObjectOffset(obj) {\n    if (obj === null) {\n      return 0;\n    }\n    if (typeof obj === \"string\") {\n      return this.createString(obj);\n    } else {\n      return obj.pack(this);\n    }\n  }\n  /**\n   * A helper function to pack a list of object\n   *\n   * @returns list of offsets of each non null object\n   */\n  createObjectOffsetList(list) {\n    const ret = [];\n    for (let i = 0; i < list.length; ++i) {\n      const val = list[i];\n      if (val !== null) {\n        ret.push(this.createObjectOffset(val));\n      } else {\n        throw new Error(\"FlatBuffers: Argument for createObjectOffsetList cannot contain null.\");\n      }\n    }\n    return ret;\n  }\n  createStructOffsetList(list, startFunc) {\n    startFunc(this, list.length);\n    this.createObjectOffsetList(list);\n    return this.endVector();\n  }\n};\n\n// node_modules/apache-arrow/fb/key-value.mjs\nvar KeyValue = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsKeyValue(bb2, obj) {\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsKeyValue(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  key(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  value(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startKeyValue(builder) {\n    builder.startObject(2);\n  }\n  static addKey(builder, keyOffset) {\n    builder.addFieldOffset(0, keyOffset, 0);\n  }\n  static addValue(builder, valueOffset) {\n    builder.addFieldOffset(1, valueOffset, 0);\n  }\n  static endKeyValue(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createKeyValue(builder, keyOffset, valueOffset) {\n    KeyValue.startKeyValue(builder);\n    KeyValue.addKey(builder, keyOffset);\n    KeyValue.addValue(builder, valueOffset);\n    return KeyValue.endKeyValue(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/metadata-version.mjs\nvar MetadataVersion2;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion2 || (MetadataVersion2 = {}));\n\n// node_modules/apache-arrow/fb/endianness.mjs\nvar Endianness;\n(function(Endianness2) {\n  Endianness2[Endianness2[\"Little\"] = 0] = \"Little\";\n  Endianness2[Endianness2[\"Big\"] = 1] = \"Big\";\n})(Endianness || (Endianness = {}));\n\n// node_modules/apache-arrow/fb/dictionary-kind.mjs\nvar DictionaryKind;\n(function(DictionaryKind2) {\n  DictionaryKind2[DictionaryKind2[\"DenseArray\"] = 0] = \"DenseArray\";\n})(DictionaryKind || (DictionaryKind = {}));\n\n// node_modules/apache-arrow/fb/int.mjs\nvar Int = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInt(bb2, obj) {\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInt(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  isSigned() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startInt(builder) {\n    builder.startObject(2);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(0, bitWidth, 0);\n  }\n  static addIsSigned(builder, isSigned) {\n    builder.addFieldInt8(1, +isSigned, 0);\n  }\n  static endInt(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInt(builder, bitWidth, isSigned) {\n    Int.startInt(builder);\n    Int.addBitWidth(builder, bitWidth);\n    Int.addIsSigned(builder, isSigned);\n    return Int.endInt(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-encoding.mjs\nvar DictionaryEncoding = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryEncoding(bb2, obj) {\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * The known dictionary id in the application where this data is used. In\n   * the file or streaming formats, the dictionary ids are found in the\n   * DictionaryBatch messages\n   */\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * The dictionary indices are constrained to be non-negative integers. If\n   * this field is null, the indices must be signed int32. To maximize\n   * cross-language compatibility and performance, implementations are\n   * recommended to prefer signed integer types over unsigned integer types\n   * and to avoid uint64 indices unless they are required by an application.\n   */\n  indexType(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * By default, dictionaries are not ordered, or the order does not have\n   * semantic meaning. In some statistical, applications, dictionary-encoding\n   * is used to represent ordered categorical data, and we provide a way to\n   * preserve that metadata here\n   */\n  isOrdered() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  dictionaryKind() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;\n  }\n  static startDictionaryEncoding(builder) {\n    builder.startObject(4);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addIndexType(builder, indexTypeOffset) {\n    builder.addFieldOffset(1, indexTypeOffset, 0);\n  }\n  static addIsOrdered(builder, isOrdered2) {\n    builder.addFieldInt8(2, +isOrdered2, 0);\n  }\n  static addDictionaryKind(builder, dictionaryKind) {\n    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n  }\n  static endDictionaryEncoding(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/binary.mjs\nvar Binary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBinary(bb2, obj) {\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBinary(builder) {\n    builder.startObject(0);\n  }\n  static endBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBinary(builder) {\n    Binary2.startBinary(builder);\n    return Binary2.endBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/bool.mjs\nvar Bool2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBool(bb2, obj) {\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBool(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBool(builder) {\n    builder.startObject(0);\n  }\n  static endBool(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBool(builder) {\n    Bool2.startBool(builder);\n    return Bool2.endBool(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/date-unit.mjs\nvar DateUnit2;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit2 || (DateUnit2 = {}));\n\n// node_modules/apache-arrow/fb/date.mjs\nvar Date2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDate(bb2, obj) {\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDate(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit2.MILLISECOND;\n  }\n  static startDate(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, DateUnit2.MILLISECOND);\n  }\n  static endDate(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDate(builder, unit3) {\n    Date2.startDate(builder);\n    Date2.addUnit(builder, unit3);\n    return Date2.endDate(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/decimal.mjs\nvar Decimal2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDecimal(bb2, obj) {\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDecimal(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Total number of decimal digits\n   */\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of digits after the decimal point \".\"\n   */\n  scale() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of bits per value. The only accepted widths are 128 and 256.\n   * We use bitWidth for consistency with Int::bitWidth.\n   */\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;\n  }\n  static startDecimal(builder) {\n    builder.startObject(3);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt32(0, precision, 0);\n  }\n  static addScale(builder, scale3) {\n    builder.addFieldInt32(1, scale3, 0);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(2, bitWidth, 128);\n  }\n  static endDecimal(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDecimal(builder, precision, scale3, bitWidth) {\n    Decimal2.startDecimal(builder);\n    Decimal2.addPrecision(builder, precision);\n    Decimal2.addScale(builder, scale3);\n    Decimal2.addBitWidth(builder, bitWidth);\n    return Decimal2.endDecimal(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time-unit.mjs\nvar TimeUnit2;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit2 || (TimeUnit2 = {}));\n\n// node_modules/apache-arrow/fb/fixed-size-binary.mjs\nvar FixedSizeBinary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeBinary(bb2, obj) {\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of bytes per value\n   */\n  byteWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeBinary(builder) {\n    builder.startObject(1);\n  }\n  static addByteWidth(builder, byteWidth) {\n    builder.addFieldInt32(0, byteWidth, 0);\n  }\n  static endFixedSizeBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeBinary(builder, byteWidth) {\n    FixedSizeBinary2.startFixedSizeBinary(builder);\n    FixedSizeBinary2.addByteWidth(builder, byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/fixed-size-list.mjs\nvar FixedSizeList2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeList(bb2, obj) {\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of list items per value\n   */\n  listSize() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeList(builder) {\n    builder.startObject(1);\n  }\n  static addListSize(builder, listSize) {\n    builder.addFieldInt32(0, listSize, 0);\n  }\n  static endFixedSizeList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeList(builder, listSize) {\n    FixedSizeList2.startFixedSizeList(builder);\n    FixedSizeList2.addListSize(builder, listSize);\n    return FixedSizeList2.endFixedSizeList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/precision.mjs\nvar Precision2;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision2 || (Precision2 = {}));\n\n// node_modules/apache-arrow/fb/floating-point.mjs\nvar FloatingPoint = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFloatingPoint(bb2, obj) {\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFloatingPoint(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision2.HALF;\n  }\n  static startFloatingPoint(builder) {\n    builder.startObject(1);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt16(0, precision, Precision2.HALF);\n  }\n  static endFloatingPoint(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFloatingPoint(builder, precision) {\n    FloatingPoint.startFloatingPoint(builder);\n    FloatingPoint.addPrecision(builder, precision);\n    return FloatingPoint.endFloatingPoint(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/interval-unit.mjs\nvar IntervalUnit2;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit2 || (IntervalUnit2 = {}));\n\n// node_modules/apache-arrow/fb/interval.mjs\nvar Interval = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInterval(bb2, obj) {\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInterval(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit2.YEAR_MONTH;\n  }\n  static startInterval(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, IntervalUnit2.YEAR_MONTH);\n  }\n  static endInterval(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInterval(builder, unit3) {\n    Interval.startInterval(builder);\n    Interval.addUnit(builder, unit3);\n    return Interval.endInterval(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/list.mjs\nvar List2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsList(bb2, obj) {\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startList(builder) {\n    builder.startObject(0);\n  }\n  static endList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createList(builder) {\n    List2.startList(builder);\n    return List2.endList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/map.mjs\nvar Map2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMap(bb2, obj) {\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMap(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Set to true if the keys within each value are sorted\n   */\n  keysSorted() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startMap(builder) {\n    builder.startObject(1);\n  }\n  static addKeysSorted(builder, keysSorted) {\n    builder.addFieldInt8(0, +keysSorted, 0);\n  }\n  static endMap(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createMap(builder, keysSorted) {\n    Map2.startMap(builder);\n    Map2.addKeysSorted(builder, keysSorted);\n    return Map2.endMap(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/null.mjs\nvar Null2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsNull(bb2, obj) {\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsNull(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startNull(builder) {\n    builder.startObject(0);\n  }\n  static endNull(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createNull(builder) {\n    Null2.startNull(builder);\n    return Null2.endNull(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/struct_.mjs\nvar Struct_ = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsStruct_(bb2, obj) {\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsStruct_(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startStruct_(builder) {\n    builder.startObject(0);\n  }\n  static endStruct_(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createStruct_(builder) {\n    Struct_.startStruct_(builder);\n    return Struct_.endStruct_(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time.mjs\nvar Time = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTime(bb2, obj) {\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTime(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;\n  }\n  static startTime(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.MILLISECOND);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(1, bitWidth, 32);\n  }\n  static endTime(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTime(builder, unit3, bitWidth) {\n    Time.startTime(builder);\n    Time.addUnit(builder, unit3);\n    Time.addBitWidth(builder, bitWidth);\n    return Time.endTime(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/timestamp.mjs\nvar Timestamp = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTimestamp(bb2, obj) {\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTimestamp(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.SECOND;\n  }\n  timezone(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startTimestamp(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.SECOND);\n  }\n  static addTimezone(builder, timezoneOffset) {\n    builder.addFieldOffset(1, timezoneOffset, 0);\n  }\n  static endTimestamp(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTimestamp(builder, unit3, timezoneOffset) {\n    Timestamp.startTimestamp(builder);\n    Timestamp.addUnit(builder, unit3);\n    Timestamp.addTimezone(builder, timezoneOffset);\n    return Timestamp.endTimestamp(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/union-mode.mjs\nvar UnionMode2;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode2 || (UnionMode2 = {}));\n\n// node_modules/apache-arrow/fb/union.mjs\nvar Union = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUnion(bb2, obj) {\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUnion(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  mode() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode2.Sparse;\n  }\n  typeIds(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index3 * 4) : 0;\n  }\n  typeIdsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  typeIdsArray() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;\n  }\n  static startUnion(builder) {\n    builder.startObject(2);\n  }\n  static addMode(builder, mode2) {\n    builder.addFieldInt16(0, mode2, UnionMode2.Sparse);\n  }\n  static addTypeIds(builder, typeIdsOffset) {\n    builder.addFieldOffset(1, typeIdsOffset, 0);\n  }\n  static createTypeIdsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt32(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startTypeIdsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endUnion(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUnion(builder, mode2, typeIdsOffset) {\n    Union.startUnion(builder);\n    Union.addMode(builder, mode2);\n    Union.addTypeIds(builder, typeIdsOffset);\n    return Union.endUnion(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/utf8.mjs\nvar Utf82 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUtf8(bb2, obj) {\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUtf8(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startUtf8(builder) {\n    builder.startObject(0);\n  }\n  static endUtf8(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUtf8(builder) {\n    Utf82.startUtf8(builder);\n    return Utf82.endUtf8(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/type.mjs\nvar Type2;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"FloatingPoint\"] = 3] = \"FloatingPoint\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct_\"] = 13] = \"Struct_\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Duration\"] = 18] = \"Duration\";\n  Type3[Type3[\"LargeBinary\"] = 19] = \"LargeBinary\";\n  Type3[Type3[\"LargeUtf8\"] = 20] = \"LargeUtf8\";\n  Type3[Type3[\"LargeList\"] = 21] = \"LargeList\";\n})(Type2 || (Type2 = {}));\n\n// node_modules/apache-arrow/fb/field.mjs\nvar Field = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsField(bb2, obj) {\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsField(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  name(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  /**\n   * Whether or not this field can contain nulls. Should be true in general.\n   */\n  nullable() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  typeType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type2.NONE;\n  }\n  /**\n   * This is the type of the decoded value if the field is dictionary encoded.\n   */\n  // @ts-ignore\n  type(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  /**\n   * Present only if the field is dictionary encoded.\n   */\n  dictionary(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * children apply only to nested data types like Struct, List and Union. For\n   * primitive types children will have length 0.\n   */\n  children(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  childrenLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startField(builder) {\n    builder.startObject(7);\n  }\n  static addName(builder, nameOffset) {\n    builder.addFieldOffset(0, nameOffset, 0);\n  }\n  static addNullable(builder, nullable) {\n    builder.addFieldInt8(1, +nullable, 0);\n  }\n  static addTypeType(builder, typeType) {\n    builder.addFieldInt8(2, typeType, Type2.NONE);\n  }\n  static addType(builder, typeOffset) {\n    builder.addFieldOffset(3, typeOffset, 0);\n  }\n  static addDictionary(builder, dictionaryOffset) {\n    builder.addFieldOffset(4, dictionaryOffset, 0);\n  }\n  static addChildren(builder, childrenOffset) {\n    builder.addFieldOffset(5, childrenOffset, 0);\n  }\n  static createChildrenVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startChildrenVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(6, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endField(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/schema.mjs\nvar Schema = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsSchema(bb2, obj) {\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsSchema(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * endianness of the buffer\n   * it is Little Endian by default\n   * if endianness doesn't match the underlying system then the vectors need to be converted\n   */\n  endianness() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;\n  }\n  fields(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  fieldsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Features used in the stream/file.\n   */\n  features(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index3 * 8) : this.bb.createLong(0, 0);\n  }\n  featuresLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startSchema(builder) {\n    builder.startObject(4);\n  }\n  static addEndianness(builder, endianness) {\n    builder.addFieldInt16(0, endianness, Endianness.Little);\n  }\n  static addFields(builder, fieldsOffset) {\n    builder.addFieldOffset(1, fieldsOffset, 0);\n  }\n  static createFieldsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFieldsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(2, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addFeatures(builder, featuresOffset) {\n    builder.addFieldOffset(3, featuresOffset, 0);\n  }\n  static createFeaturesVector(builder, data) {\n    builder.startVector(8, data.length, 8);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt64(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFeaturesVector(builder, numElems) {\n    builder.startVector(8, numElems, 8);\n  }\n  static endSchema(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishSchemaBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedSchemaBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {\n    Schema.startSchema(builder);\n    Schema.addEndianness(builder, endianness);\n    Schema.addFields(builder, fieldsOffset);\n    Schema.addCustomMetadata(builder, customMetadataOffset);\n    Schema.addFeatures(builder, featuresOffset);\n    return Schema.endSchema(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/footer.mjs\nvar Footer = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFooter(bb2, obj) {\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFooter(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  schema(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  dictionaries(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  dictionariesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  recordBatches(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  recordBatchesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startFooter(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addSchema(builder, schemaOffset) {\n    builder.addFieldOffset(1, schemaOffset, 0);\n  }\n  static addDictionaries(builder, dictionariesOffset) {\n    builder.addFieldOffset(2, dictionariesOffset, 0);\n  }\n  static startDictionariesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addRecordBatches(builder, recordBatchesOffset) {\n    builder.addFieldOffset(3, recordBatchesOffset, 0);\n  }\n  static startRecordBatchesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endFooter(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishFooterBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedFooterBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n};\n\n// node_modules/apache-arrow/schema.mjs\nvar Schema2 = class {\n  constructor(fields = [], metadata, dictionaries) {\n    this.fields = fields || [];\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n    this.dictionaries = dictionaries;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Schema\";\n  }\n  get names() {\n    return this.fields.map((f) => f.name);\n  }\n  toString() {\n    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(\", \")} }>`;\n  }\n  /**\n   * Construct a new Schema containing only specified fields.\n   *\n   * @param fieldNames Names of fields to keep.\n   * @returns A new Schema of fields matching the specified names.\n   */\n  select(fieldNames) {\n    const names = new Set(fieldNames);\n    const fields = this.fields.filter((f) => names.has(f.name));\n    return new Schema2(fields, this.metadata);\n  }\n  /**\n   * Construct a new Schema containing only fields at the specified indices.\n   *\n   * @param fieldIndices Indices of fields to keep.\n   * @returns A new Schema of fields at the specified indices.\n   */\n  selectAt(fieldIndices) {\n    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);\n    return new Schema2(fields, this.metadata);\n  }\n  assign(...args) {\n    const other = args[0] instanceof Schema2 ? args[0] : Array.isArray(args[0]) ? new Schema2(args[0]) : new Schema2(args);\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter((f2) => {\n      const i = curFields.findIndex((f) => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());\n    return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n};\nSchema2.prototype.fields = null;\nSchema2.prototype.metadata = null;\nSchema2.prototype.dictionaries = null;\nvar Field2 = class {\n  constructor(name, type2, nullable = false, metadata) {\n    this.name = name;\n    this.type = type2;\n    this.nullable = nullable;\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n  }\n  /** @nocollapse */\n  static new(...args) {\n    let [name, type2, nullable, metadata] = args;\n    if (args[0] && typeof args[0] === \"object\") {\n      ({ name } = args[0]);\n      type2 === void 0 && (type2 = args[0].type);\n      nullable === void 0 && (nullable = args[0].nullable);\n      metadata === void 0 && (metadata = args[0].metadata);\n    }\n    return new Field2(`${name}`, type2, nullable, metadata);\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Field\";\n  }\n  toString() {\n    return `${this.name}: ${this.type}`;\n  }\n  clone(...args) {\n    let [name, type2, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== \"object\" ? [name = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type: type2 = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];\n    return Field2.new(name, type2, nullable, metadata);\n  }\n};\nField2.prototype.type = null;\nField2.prototype.name = null;\nField2.prototype.nullable = null;\nField2.prototype.metadata = null;\nfunction mergeMaps(m1, m22) {\n  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m22 || /* @__PURE__ */ new Map()]);\n}\nfunction generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        dictionaries.set(type2.id, type2.dictionary);\n      } else if (dictionaries.get(type2.id) !== type2.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      generateDictionaryMap(type2.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n\n// node_modules/apache-arrow/ipc/metadata/file.mjs\nvar Long2 = Long;\nvar Builder3 = Builder2;\nvar ByteBuffer2 = ByteBuffer;\nvar Footer_ = class {\n  constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {\n    this.schema = schema;\n    this.version = version;\n    recordBatches && (this._recordBatches = recordBatches);\n    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer2(toUint8Array(buf));\n    const footer = Footer.getRootAsFooter(buf);\n    const schema = Schema2.decode(footer.schema());\n    return new OffHeapFooter(schema, footer);\n  }\n  /** @nocollapse */\n  static encode(footer) {\n    const b = new Builder3();\n    const schemaOffset = Schema2.encode(b, footer.schema);\n    Footer.startRecordBatchesVector(b, footer.numRecordBatches);\n    for (const rb of [...footer.recordBatches()].slice().reverse()) {\n      FileBlock.encode(b, rb);\n    }\n    const recordBatchesOffset = b.endVector();\n    Footer.startDictionariesVector(b, footer.numDictionaries);\n    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {\n      FileBlock.encode(b, db);\n    }\n    const dictionaryBatchesOffset = b.endVector();\n    Footer.startFooter(b);\n    Footer.addSchema(b, schemaOffset);\n    Footer.addVersion(b, MetadataVersion.V4);\n    Footer.addRecordBatches(b, recordBatchesOffset);\n    Footer.addDictionaries(b, dictionaryBatchesOffset);\n    Footer.finishFooterBuffer(b, Footer.endFooter(b));\n    return b.asUint8Array();\n  }\n  get numRecordBatches() {\n    return this._recordBatches.length;\n  }\n  get numDictionaries() {\n    return this._dictionaryBatches.length;\n  }\n  *recordBatches() {\n    for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {\n      if (block = this.getRecordBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  *dictionaryBatches() {\n    for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {\n      if (block = this.getDictionaryBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  getRecordBatch(index3) {\n    return index3 >= 0 && index3 < this.numRecordBatches && this._recordBatches[index3] || null;\n  }\n  getDictionaryBatch(index3) {\n    return index3 >= 0 && index3 < this.numDictionaries && this._dictionaryBatches[index3] || null;\n  }\n};\nvar OffHeapFooter = class extends Footer_ {\n  constructor(schema, _footer) {\n    super(schema, _footer.version());\n    this._footer = _footer;\n  }\n  get numRecordBatches() {\n    return this._footer.recordBatchesLength();\n  }\n  get numDictionaries() {\n    return this._footer.dictionariesLength();\n  }\n  getRecordBatch(index3) {\n    if (index3 >= 0 && index3 < this.numRecordBatches) {\n      const fileBlock = this._footer.recordBatches(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n  getDictionaryBatch(index3) {\n    if (index3 >= 0 && index3 < this.numDictionaries) {\n      const fileBlock = this._footer.dictionaries(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n};\nvar FileBlock = class {\n  constructor(metaDataLength, bodyLength, offset2) {\n    this.metaDataLength = metaDataLength;\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static decode(block) {\n    return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());\n  }\n  /** @nocollapse */\n  static encode(b, fileBlock) {\n    const { metaDataLength } = fileBlock;\n    const offset2 = new Long2(fileBlock.offset, 0);\n    const bodyLength = new Long2(fileBlock.bodyLength, 0);\n    return Block.createBlock(b, offset2, metaDataLength, bodyLength);\n  }\n};\n\n// node_modules/apache-arrow/io/interfaces.mjs\nvar ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });\nvar ArrowJSON = class {\n  constructor(_json) {\n    this._json = _json;\n  }\n  get schema() {\n    return this._json[\"schema\"];\n  }\n  get batches() {\n    return this._json[\"batches\"] || [];\n  }\n  get dictionaries() {\n    return this._json[\"dictionaries\"] || [];\n  }\n};\nvar ReadableInterop = class {\n  tee() {\n    return this._getDOMStream().tee();\n  }\n  pipe(writable, options) {\n    return this._getNodeStream().pipe(writable, options);\n  }\n  pipeTo(writable, options) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n  pipeThrough(duplex, options) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n  _getDOMStream() {\n    return this._DOMStream || (this._DOMStream = this.toDOMStream());\n  }\n  _getNodeStream() {\n    return this._nodeStream || (this._nodeStream = this.toNodeStream());\n  }\n};\nvar AsyncQueue = class extends ReadableInterop {\n  constructor() {\n    super();\n    this._values = [];\n    this.resolvers = [];\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  write(value) {\n    if (this._ensureOpen()) {\n      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });\n    }\n  }\n  abort(value) {\n    if (this._closedPromiseResolve) {\n      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });\n    }\n  }\n  close() {\n    if (this._closedPromiseResolve) {\n      const { resolvers } = this;\n      while (resolvers.length > 0) {\n        resolvers.shift().resolve(ITERATOR_DONE);\n      }\n      this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  toDOMStream(options) {\n    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  toNodeStream(options) {\n    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  throw(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.abort(_);\n      return ITERATOR_DONE;\n    });\n  }\n  return(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return ITERATOR_DONE;\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(..._args) {\n    if (this._values.length > 0) {\n      return Promise.resolve({ done: false, value: this._values.shift() });\n    } else if (this._error) {\n      return Promise.reject({ done: true, value: this._error.error });\n    } else if (!this._closedPromiseResolve) {\n      return Promise.resolve(ITERATOR_DONE);\n    } else {\n      return new Promise((resolve, reject) => {\n        this.resolvers.push({ resolve, reject });\n      });\n    }\n  }\n  _ensureOpen() {\n    if (this._closedPromiseResolve) {\n      return true;\n    }\n    throw new Error(`AsyncQueue is closed`);\n  }\n};\n\n// node_modules/apache-arrow/io/stream.mjs\nvar AsyncByteQueue = class extends AsyncQueue {\n  write(value) {\n    if ((value = toUint8Array(value)).byteLength > 0) {\n      return super.write(value);\n    }\n  }\n  toString(sync = false) {\n    return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);\n  }\n  toUint8Array(sync = false) {\n    return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {\n      var e_1, _a5;\n      const buffers = [];\n      let byteLength = 0;\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const chunk = _c2.value;\n          buffers.push(chunk);\n          byteLength += chunk.byteLength;\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return joinUint8Arrays(buffers, byteLength)[0];\n    }))();\n  }\n};\nvar ByteStream = class {\n  constructor(source) {\n    if (source) {\n      this.source = new ByteStreamSource(adapters_default.fromIterable(source));\n    }\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar AsyncByteStream = class {\n  constructor(source) {\n    if (source instanceof AsyncByteStream) {\n      this.source = source.source;\n    } else if (source instanceof AsyncByteQueue) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isReadableNodeStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));\n    } else if (isReadableDOMStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));\n    } else if (isFetchResponse(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));\n    } else if (isIterable2(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));\n    } else if (isPromise(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isAsyncIterable(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  get closed() {\n    return this.source.closed;\n  }\n  cancel(reason) {\n    return this.source.cancel(reason);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar ByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n  }\n  cancel(reason) {\n    this.return(reason);\n  }\n  peek(size) {\n    return this.next(size, \"peek\").value;\n  }\n  read(size) {\n    return this.next(size, \"read\").value;\n  }\n  next(size, cmd = \"read\") {\n    return this.source.next({ cmd, size });\n  }\n  throw(value) {\n    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);\n  }\n  return(value) {\n    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);\n  }\n};\nvar AsyncByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(size, cmd = \"read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.next({ cmd, size });\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n};\n\n// node_modules/apache-arrow/io/file.mjs\nvar RandomAccessFile = class extends ByteStream {\n  constructor(buffer, byteLength) {\n    super();\n    this.position = 0;\n    this.buffer = toUint8Array(buffer);\n    this.size = typeof byteLength === \"undefined\" ? this.buffer.byteLength : byteLength;\n  }\n  readInt32(position2) {\n    const { buffer, byteOffset } = this.readAt(position2, 4);\n    return new DataView(buffer, byteOffset).getInt32(0, true);\n  }\n  seek(position2) {\n    this.position = Math.min(position2, this.size);\n    return position2 < this.size;\n  }\n  read(nBytes) {\n    const { buffer, size, position: position2 } = this;\n    if (buffer && position2 < size) {\n      if (typeof nBytes !== \"number\") {\n        nBytes = Number.POSITIVE_INFINITY;\n      }\n      this.position = Math.min(size, position2 + Math.min(size - position2, nBytes));\n      return buffer.subarray(position2, this.position);\n    }\n    return null;\n  }\n  readAt(position2, nBytes) {\n    const buf = this.buffer;\n    const end = Math.min(this.size, position2 + nBytes);\n    return buf ? buf.subarray(position2, end) : new Uint8Array(nBytes);\n  }\n  close() {\n    this.buffer && (this.buffer = null);\n  }\n  throw(value) {\n    this.close();\n    return { done: true, value };\n  }\n  return(value) {\n    this.close();\n    return { done: true, value };\n  }\n};\nvar AsyncRandomAccessFile = class extends AsyncByteStream {\n  constructor(file, byteLength) {\n    super();\n    this.position = 0;\n    this._handle = file;\n    if (typeof byteLength === \"number\") {\n      this.size = byteLength;\n    } else {\n      this._pending = (() => __awaiter(this, void 0, void 0, function* () {\n        this.size = (yield file.stat()).size;\n        delete this._pending;\n      }))();\n    }\n  }\n  readInt32(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { buffer, byteOffset } = yield this.readAt(position2, 4);\n      return new DataView(buffer, byteOffset).getInt32(0, true);\n    });\n  }\n  seek(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      this.position = Math.min(position2, this.size);\n      return position2 < this.size;\n    });\n  }\n  read(nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size, position: position2 } = this;\n      if (file && position2 < size) {\n        if (typeof nBytes !== \"number\") {\n          nBytes = Number.POSITIVE_INFINITY;\n        }\n        let pos = position2, offset2 = 0, bytesRead = 0;\n        const end = Math.min(size, pos + Math.min(size - pos, nBytes));\n        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));\n        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {\n          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));\n        }\n        return buffer;\n      }\n      return null;\n    });\n  }\n  readAt(position2, nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size } = this;\n      if (file && position2 + nBytes < size) {\n        const end = Math.min(size, position2 + nBytes);\n        const buffer = new Uint8Array(end - position2);\n        return (yield file.read(buffer, 0, nBytes, position2)).buffer;\n      }\n      return new Uint8Array(nBytes);\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const f = this._handle;\n      this._handle = null;\n      f && (yield f.close());\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n};\n\n// node_modules/apache-arrow/util/int.mjs\nvar int_exports = {};\n__export(int_exports, {\n  BaseInt64: () => BaseInt64,\n  Int128: () => Int128,\n  Int64: () => Int642,\n  Uint64: () => Uint642\n});\nvar carryBit16 = 1 << 16;\nfunction intAsHex(value) {\n  if (value < 0) {\n    value = 4294967295 + value + 1;\n  }\n  return `0x${value.toString(16)}`;\n}\nvar kInt32DecimalDigits = 8;\nvar kPowersOfTen = [\n  1,\n  10,\n  100,\n  1e3,\n  1e4,\n  1e5,\n  1e6,\n  1e7,\n  1e8\n];\nvar BaseInt64 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return this.buffer[1];\n  }\n  low() {\n    return this.buffer[0];\n  }\n  _times(other) {\n    const L = new Uint32Array([\n      this.buffer[1] >>> 16,\n      this.buffer[1] & 65535,\n      this.buffer[0] >>> 16,\n      this.buffer[0] & 65535\n    ]);\n    const R = new Uint32Array([\n      other.buffer[1] >>> 16,\n      other.buffer[1] & 65535,\n      other.buffer[0] >>> 16,\n      other.buffer[0] & 65535\n    ]);\n    let product = L[3] * R[3];\n    this.buffer[0] = product & 65535;\n    let sum5 = product >>> 16;\n    product = L[2] * R[3];\n    sum5 += product;\n    product = L[3] * R[2] >>> 0;\n    sum5 += product;\n    this.buffer[0] += sum5 << 16;\n    this.buffer[1] = sum5 >>> 0 < product ? carryBit16 : 0;\n    this.buffer[1] += sum5 >>> 16;\n    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;\n    return this;\n  }\n  _plus(other) {\n    const sum5 = this.buffer[0] + other.buffer[0] >>> 0;\n    this.buffer[1] += other.buffer[1];\n    if (sum5 < this.buffer[0] >>> 0) {\n      ++this.buffer[1];\n    }\n    this.buffer[0] = sum5;\n  }\n  lessThan(other) {\n    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];\n  }\n  equals(other) {\n    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n  }\n  greaterThan(other) {\n    return other.lessThan(this);\n  }\n  hex() {\n    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n};\nvar Uint642 = class extends BaseInt64 {\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const length4 = str.length;\n    const out = new Uint642(out_buffer);\n    for (let posn = 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Uint642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Uint642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int642 = class extends BaseInt64 {\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    return this;\n  }\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  lessThan(other) {\n    const this_high = this.buffer[1] << 0;\n    const other_high = other.buffer[1] << 0;\n    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int642(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Int642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int128 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n  }\n  low() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n  }\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    this.buffer[2] = ~this.buffer[2];\n    this.buffer[3] = ~this.buffer[3];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    if (this.buffer[1] == 0) {\n      ++this.buffer[2];\n    }\n    if (this.buffer[2] == 0) {\n      ++this.buffer[3];\n    }\n    return this;\n  }\n  times(other) {\n    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));\n    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));\n    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));\n    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));\n    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));\n    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));\n    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));\n    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));\n    let product = Uint642.multiply(L3, R3);\n    this.buffer[0] = product.low();\n    const sum5 = new Uint642(new Uint32Array([product.high(), 0]));\n    product = Uint642.multiply(L2, R3);\n    sum5.plus(product);\n    product = Uint642.multiply(L3, R2);\n    sum5.plus(product);\n    this.buffer[1] = sum5.low();\n    this.buffer[3] = sum5.lessThan(product) ? 1 : 0;\n    this.buffer[2] = sum5.high();\n    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));\n    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();\n    return this;\n  }\n  plus(other) {\n    const sums = new Uint32Array(4);\n    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;\n    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;\n    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;\n    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;\n    if (sums[0] < this.buffer[0] >>> 0) {\n      ++sums[1];\n    }\n    if (sums[1] < this.buffer[1] >>> 0) {\n      ++sums[2];\n    }\n    if (sums[2] < this.buffer[2] >>> 0) {\n      ++sums[3];\n    }\n    this.buffer[3] = sums[3];\n    this.buffer[2] = sums[2];\n    this.buffer[1] = sums[1];\n    this.buffer[0] = sums[0];\n    return this;\n  }\n  hex() {\n    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(4)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int128(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));\n      const multiple = new Int128(new Uint32Array([kPowersOfTen[group3], 0, 0, 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 4);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n    }\n    return data;\n  }\n};\n\n// node_modules/apache-arrow/visitor/vectorloader.mjs\nvar VectorLoader = class extends Visitor {\n  constructor(bytes, nodes, buffers, dictionaries) {\n    super();\n    this.nodesIndex = -1;\n    this.buffersIndex = -1;\n    this.bytes = bytes;\n    this.nodes = nodes;\n    this.buffers = buffers;\n    this.dictionaries = dictionaries;\n  }\n  visit(node) {\n    return super.visit(node instanceof Field2 ? node.type : node);\n  }\n  visitNull(type2, { length: length4 } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4 });\n  }\n  visitBool(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitInt(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFloat(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitFixedSizeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDate(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTimestamp(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTime(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDecimal(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  visitStruct(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), children: this.visitMany(type2.children) });\n  }\n  visitUnion(type2) {\n    return type2.mode === UnionMode.Sparse ? this.visitSparseUnion(type2) : this.visitDenseUnion(type2);\n  }\n  visitDenseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), valueOffsets: this.readOffsets(type2), children: this.visitMany(type2.children) });\n  }\n  visitSparseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), children: this.visitMany(type2.children) });\n  }\n  visitDictionary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2.indices), dictionary: this.readDictionary(type2) });\n  }\n  visitInterval(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFixedSizeList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), \"child\": this.visit(type2.children[0]) });\n  }\n  visitMap(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  nextFieldNode() {\n    return this.nodes[++this.nodesIndex];\n  }\n  nextBufferRange() {\n    return this.buffers[++this.buffersIndex];\n  }\n  readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {\n    return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);\n  }\n  readOffsets(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readTypeIds(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readData(_type, { length: length4, offset: offset2 } = this.nextBufferRange()) {\n    return this.bytes.subarray(offset2, offset2 + length4);\n  }\n  readDictionary(type2) {\n    return this.dictionaries.get(type2.id);\n  }\n};\nvar JSONVectorLoader = class extends VectorLoader {\n  constructor(sources, nodes, buffers, dictionaries) {\n    super(new Uint8Array(0), nodes, buffers, dictionaries);\n    this.sources = sources;\n  }\n  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {\n    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);\n  }\n  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset2]));\n  }\n  readTypeIds(type2, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, this.sources[offset2]));\n  }\n  readData(type2, { offset: offset2 } = this.nextBufferRange()) {\n    const { sources } = this;\n    if (DataType.isTimestamp(type2)) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if ((DataType.isInt(type2) || DataType.isTime(type2)) && type2.bitWidth === 64) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDate(type2) && type2.unit === DateUnit.MILLISECOND) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDecimal(type2)) {\n      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));\n    } else if (DataType.isBinary(type2) || DataType.isFixedSizeBinary(type2)) {\n      return binaryDataFromJSON(sources[offset2]);\n    } else if (DataType.isBool(type2)) {\n      return packBools(sources[offset2]);\n    } else if (DataType.isUtf8(type2)) {\n      return encodeUtf8(sources[offset2].join(\"\"));\n    }\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, sources[offset2].map((x4) => +x4)));\n  }\n};\nfunction binaryDataFromJSON(values2) {\n  const joined = values2.join(\"\");\n  const data = new Uint8Array(joined.length / 2);\n  for (let i = 0; i < joined.length; i += 2) {\n    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);\n  }\n  return data;\n}\n\n// node_modules/apache-arrow/builder/binary.mjs\nvar BinaryBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, toUint8Array(value));\n  }\n  _flushPending(pending, pendingLength) {\n    const offsets = this._offsets;\n    const data = this._values.reserve(pendingLength).buffer;\n    let offset2 = 0;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        const length4 = value.length;\n        data.set(value, offset2);\n        offsets.set(index3, length4);\n        offset2 += length4;\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/bool.mjs\nvar BoolBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._values = new BitmapBufferBuilder();\n  }\n  setValue(index3, value) {\n    this._values.set(index3, +value);\n  }\n};\n\n// node_modules/apache-arrow/builder/date.mjs\nvar DateBuilder = class extends FixedWidthBuilder {\n};\nDateBuilder.prototype._setValue = setDate;\nvar DateDayBuilder = class extends DateBuilder {\n};\nDateDayBuilder.prototype._setValue = setDateDay;\nvar DateMillisecondBuilder = class extends DateBuilder {\n};\nDateMillisecondBuilder.prototype._setValue = setDateMillisecond;\n\n// node_modules/apache-arrow/builder/decimal.mjs\nvar DecimalBuilder = class extends FixedWidthBuilder {\n};\nDecimalBuilder.prototype._setValue = setDecimal;\n\n// node_modules/apache-arrow/builder/dictionary.mjs\nvar DictionaryBuilder = class extends Builder {\n  constructor({ \"type\": type2, \"nullValues\": nulls, \"dictionaryHashFunction\": hashFn }) {\n    super({ type: new Dictionary(type2.dictionary, type2.indices, type2.id, type2.isOrdered) });\n    this._nulls = null;\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    this.indices = makeBuilder({ \"type\": this.type.indices, \"nullValues\": nulls });\n    this.dictionary = makeBuilder({ \"type\": this.type.dictionary, \"nullValues\": null });\n    if (typeof hashFn === \"function\") {\n      this.valueToKey = hashFn;\n    }\n  }\n  get values() {\n    return this.indices.values;\n  }\n  get nullCount() {\n    return this.indices.nullCount;\n  }\n  get nullBitmap() {\n    return this.indices.nullBitmap;\n  }\n  get byteLength() {\n    return this.indices.byteLength + this.dictionary.byteLength;\n  }\n  get reservedLength() {\n    return this.indices.reservedLength + this.dictionary.reservedLength;\n  }\n  get reservedByteLength() {\n    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;\n  }\n  isValid(value) {\n    return this.indices.isValid(value);\n  }\n  setValid(index3, valid2) {\n    const indices = this.indices;\n    valid2 = indices.setValid(index3, valid2);\n    this.length = indices.length;\n    return valid2;\n  }\n  setValue(index3, value) {\n    const keysToIndices = this._keysToIndices;\n    const key = this.valueToKey(value);\n    let idx = keysToIndices[key];\n    if (idx === void 0) {\n      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;\n    }\n    return this.indices.setValue(index3, idx);\n  }\n  flush() {\n    const type2 = this.type;\n    const prev = this._dictionary;\n    const curr = this.dictionary.toVector();\n    const data = this.indices.flush().clone(type2);\n    data.dictionary = prev ? prev.concat(curr) : curr;\n    this.finished || (this._dictionaryOffset += curr.length);\n    this._dictionary = data.dictionary;\n    this.clear();\n    return data;\n  }\n  finish() {\n    this.indices.finish();\n    this.dictionary.finish();\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    return super.finish();\n  }\n  clear() {\n    this.indices.clear();\n    this.dictionary.clear();\n    return super.clear();\n  }\n  valueToKey(val) {\n    return typeof val === \"string\" ? val : `${val}`;\n  }\n};\n\n// node_modules/apache-arrow/builder/fixedsizebinary.mjs\nvar FixedSizeBinaryBuilder = class extends FixedWidthBuilder {\n};\nFixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;\n\n// node_modules/apache-arrow/builder/fixedsizelist.mjs\nvar FixedSizeListBuilder = class extends Builder {\n  setValue(index3, value) {\n    const [child] = this.children;\n    const start2 = index3 * this.stride;\n    for (let i = -1, n = value.length; ++i < n; ) {\n      child.set(start2 + i, value[i]);\n    }\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"FixedSizeListBuilder can only have one child.\");\n    }\n    const childIndex = this.children.push(child);\n    this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/float.mjs\nvar FloatBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Float16Builder = class extends FloatBuilder {\n  setValue(index3, value) {\n    super.setValue(index3, float64ToUint16(value));\n  }\n};\nvar Float32Builder = class extends FloatBuilder {\n};\nvar Float64Builder = class extends FloatBuilder {\n};\n\n// node_modules/apache-arrow/builder/interval.mjs\nvar IntervalBuilder = class extends FixedWidthBuilder {\n};\nIntervalBuilder.prototype._setValue = setIntervalValue;\nvar IntervalDayTimeBuilder = class extends IntervalBuilder {\n};\nIntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;\nvar IntervalYearMonthBuilder = class extends IntervalBuilder {\n};\nIntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;\n\n// node_modules/apache-arrow/builder/int.mjs\nvar IntBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Int8Builder = class extends IntBuilder {\n};\nvar Int16Builder = class extends IntBuilder {\n};\nvar Int32Builder = class extends IntBuilder {\n};\nvar Int64Builder = class extends IntBuilder {\n};\nvar Uint8Builder = class extends IntBuilder {\n};\nvar Uint16Builder = class extends IntBuilder {\n};\nvar Uint32Builder = class extends IntBuilder {\n};\nvar Uint64Builder = class extends IntBuilder {\n};\n\n// node_modules/apache-arrow/builder/list.mjs\nvar ListBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new List(new Field2(name, child.type, true));\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (typeof value === \"undefined\") {\n        offsets.set(index3, 0);\n      } else {\n        const n = value.length;\n        const start2 = offsets.set(index3, n).buffer[index3];\n        for (let i = -1; ++i < n; ) {\n          child.set(start2 + i, value[i]);\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/map.mjs\nvar MapBuilder = class extends VariableWidthBuilder {\n  set(index3, value) {\n    return super.set(index3, value);\n  }\n  setValue(index3, value) {\n    const row = value instanceof Map ? value : new Map(Object.entries(value));\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.size);\n    this._pendingLength += row.size;\n    pending.set(index3, row);\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        let { [index3]: idx, [index3 + 1]: end } = offsets.set(index3, value.size).buffer;\n        for (const val of value.entries()) {\n          child.set(idx, val);\n          if (++idx >= end)\n            break;\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/null.mjs\nvar NullBuilder = class extends Builder {\n  // @ts-ignore\n  setValue(index3, value) {\n  }\n  setValid(index3, valid2) {\n    this.length = Math.max(index3 + 1, this.length);\n    return valid2;\n  }\n};\n\n// node_modules/apache-arrow/builder/struct.mjs\nvar StructBuilder = class extends Builder {\n  setValue(index3, value) {\n    const { children: children2, type: type2 } = this;\n    switch (Array.isArray(value) || value.constructor) {\n      case true:\n        return type2.children.forEach((_, i) => children2[i].set(index3, value[i]));\n      case Map:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value.get(f.name)));\n      default:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value[f.name]));\n    }\n  }\n  /** @inheritdoc */\n  setValid(index3, valid2) {\n    if (!super.setValid(index3, valid2)) {\n      this.children.forEach((child) => child.setValid(index3, valid2));\n    }\n    return valid2;\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    const childIndex = this.children.push(child);\n    this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/timestamp.mjs\nvar TimestampBuilder = class extends FixedWidthBuilder {\n};\nTimestampBuilder.prototype._setValue = setTimestamp;\nvar TimestampSecondBuilder = class extends TimestampBuilder {\n};\nTimestampSecondBuilder.prototype._setValue = setTimestampSecond;\nvar TimestampMillisecondBuilder = class extends TimestampBuilder {\n};\nTimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;\nvar TimestampMicrosecondBuilder = class extends TimestampBuilder {\n};\nTimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;\nvar TimestampNanosecondBuilder = class extends TimestampBuilder {\n};\nTimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;\n\n// node_modules/apache-arrow/builder/time.mjs\nvar TimeBuilder = class extends FixedWidthBuilder {\n};\nTimeBuilder.prototype._setValue = setTime;\nvar TimeSecondBuilder = class extends TimeBuilder {\n};\nTimeSecondBuilder.prototype._setValue = setTimeSecond;\nvar TimeMillisecondBuilder = class extends TimeBuilder {\n};\nTimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;\nvar TimeMicrosecondBuilder = class extends TimeBuilder {\n};\nTimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;\nvar TimeNanosecondBuilder = class extends TimeBuilder {\n};\nTimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;\n\n// node_modules/apache-arrow/builder/union.mjs\nvar UnionBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);\n    if (typeof options[\"valueToChildTypeId\"] === \"function\") {\n      this._valueToChildTypeId = options[\"valueToChildTypeId\"];\n    }\n  }\n  get typeIdToChildIndex() {\n    return this.type.typeIdToChildIndex;\n  }\n  append(value, childTypeId) {\n    return this.set(this.length, value, childTypeId);\n  }\n  set(index3, value, childTypeId) {\n    if (childTypeId === void 0) {\n      childTypeId = this._valueToChildTypeId(this, value, index3);\n    }\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value, childTypeId);\n    }\n    return this;\n  }\n  setValue(index3, value, childTypeId) {\n    this._typeIds.set(index3, childTypeId);\n    const childIndex = this.type.typeIdToChildIndex[childTypeId];\n    const child = this.children[childIndex];\n    child === null || child === void 0 ? void 0 : child.set(index3, value);\n  }\n  addChild(child, name = `${this.children.length}`) {\n    const childTypeId = this.children.push(child);\n    const { type: { children: children2, mode: mode2, typeIds } } = this;\n    const fields = [...children2, new Field2(name, child.type)];\n    this.type = new Union_(mode2, [...typeIds, childTypeId], fields);\n    return childTypeId;\n  }\n  /** @ignore */\n  // @ts-ignore\n  _valueToChildTypeId(builder, value, offset2) {\n    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \\`childTypeId\\` as the second argument to unionBuilder.append(), or supply a \\`valueToChildTypeId\\` function as part of the UnionBuilder constructor options.`);\n  }\n};\nvar SparseUnionBuilder = class extends UnionBuilder {\n};\nvar DenseUnionBuilder = class extends UnionBuilder {\n  constructor(options) {\n    super(options);\n    this._offsets = new DataBufferBuilder(new Int32Array(0));\n  }\n  /** @ignore */\n  setValue(index3, value, childTypeId) {\n    const id2 = this._typeIds.set(index3, childTypeId).buffer[index3];\n    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);\n    const denseIndex = this._offsets.set(index3, child.length).buffer[index3];\n    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);\n  }\n};\n\n// node_modules/apache-arrow/builder/utf8.mjs\nvar Utf8Builder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, encodeUtf8(value));\n  }\n  // @ts-ignore\n  _flushPending(pending, pendingLength) {\n  }\n};\nUtf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;\n\n// node_modules/apache-arrow/visitor/builderctor.mjs\nvar GetBuilderCtor = class extends Visitor {\n  visitNull() {\n    return NullBuilder;\n  }\n  visitBool() {\n    return BoolBuilder;\n  }\n  visitInt() {\n    return IntBuilder;\n  }\n  visitInt8() {\n    return Int8Builder;\n  }\n  visitInt16() {\n    return Int16Builder;\n  }\n  visitInt32() {\n    return Int32Builder;\n  }\n  visitInt64() {\n    return Int64Builder;\n  }\n  visitUint8() {\n    return Uint8Builder;\n  }\n  visitUint16() {\n    return Uint16Builder;\n  }\n  visitUint32() {\n    return Uint32Builder;\n  }\n  visitUint64() {\n    return Uint64Builder;\n  }\n  visitFloat() {\n    return FloatBuilder;\n  }\n  visitFloat16() {\n    return Float16Builder;\n  }\n  visitFloat32() {\n    return Float32Builder;\n  }\n  visitFloat64() {\n    return Float64Builder;\n  }\n  visitUtf8() {\n    return Utf8Builder;\n  }\n  visitBinary() {\n    return BinaryBuilder;\n  }\n  visitFixedSizeBinary() {\n    return FixedSizeBinaryBuilder;\n  }\n  visitDate() {\n    return DateBuilder;\n  }\n  visitDateDay() {\n    return DateDayBuilder;\n  }\n  visitDateMillisecond() {\n    return DateMillisecondBuilder;\n  }\n  visitTimestamp() {\n    return TimestampBuilder;\n  }\n  visitTimestampSecond() {\n    return TimestampSecondBuilder;\n  }\n  visitTimestampMillisecond() {\n    return TimestampMillisecondBuilder;\n  }\n  visitTimestampMicrosecond() {\n    return TimestampMicrosecondBuilder;\n  }\n  visitTimestampNanosecond() {\n    return TimestampNanosecondBuilder;\n  }\n  visitTime() {\n    return TimeBuilder;\n  }\n  visitTimeSecond() {\n    return TimeSecondBuilder;\n  }\n  visitTimeMillisecond() {\n    return TimeMillisecondBuilder;\n  }\n  visitTimeMicrosecond() {\n    return TimeMicrosecondBuilder;\n  }\n  visitTimeNanosecond() {\n    return TimeNanosecondBuilder;\n  }\n  visitDecimal() {\n    return DecimalBuilder;\n  }\n  visitList() {\n    return ListBuilder;\n  }\n  visitStruct() {\n    return StructBuilder;\n  }\n  visitUnion() {\n    return UnionBuilder;\n  }\n  visitDenseUnion() {\n    return DenseUnionBuilder;\n  }\n  visitSparseUnion() {\n    return SparseUnionBuilder;\n  }\n  visitDictionary() {\n    return DictionaryBuilder;\n  }\n  visitInterval() {\n    return IntervalBuilder;\n  }\n  visitIntervalDayTime() {\n    return IntervalDayTimeBuilder;\n  }\n  visitIntervalYearMonth() {\n    return IntervalYearMonthBuilder;\n  }\n  visitFixedSizeList() {\n    return FixedSizeListBuilder;\n  }\n  visitMap() {\n    return MapBuilder;\n  }\n};\nvar instance6 = new GetBuilderCtor();\n\n// node_modules/apache-arrow/visitor/typecomparator.mjs\nvar TypeComparator = class extends Visitor {\n  compareSchemas(schema, other) {\n    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);\n  }\n  compareManyFields(fields, others) {\n    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));\n  }\n  compareFields(field2, other) {\n    return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);\n  }\n};\nfunction compareConstructor(type2, other) {\n  return other instanceof type2.constructor;\n}\nfunction compareAny(type2, other) {\n  return type2 === other || compareConstructor(type2, other);\n}\nfunction compareInt(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;\n}\nfunction compareFloat(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.precision === other.precision;\n}\nfunction compareFixedSizeBinary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.byteWidth === other.byteWidth;\n}\nfunction compareDate(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareTimestamp(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;\n}\nfunction compareTime(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;\n}\nfunction compareList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareStruct(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareUnion(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareDictionary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance7.visit(type2.indices, other.indices) && instance7.visit(type2.dictionary, other.dictionary);\n}\nfunction compareInterval(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareFixedSizeList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareMap(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nTypeComparator.prototype.visitNull = compareAny;\nTypeComparator.prototype.visitBool = compareAny;\nTypeComparator.prototype.visitInt = compareInt;\nTypeComparator.prototype.visitInt8 = compareInt;\nTypeComparator.prototype.visitInt16 = compareInt;\nTypeComparator.prototype.visitInt32 = compareInt;\nTypeComparator.prototype.visitInt64 = compareInt;\nTypeComparator.prototype.visitUint8 = compareInt;\nTypeComparator.prototype.visitUint16 = compareInt;\nTypeComparator.prototype.visitUint32 = compareInt;\nTypeComparator.prototype.visitUint64 = compareInt;\nTypeComparator.prototype.visitFloat = compareFloat;\nTypeComparator.prototype.visitFloat16 = compareFloat;\nTypeComparator.prototype.visitFloat32 = compareFloat;\nTypeComparator.prototype.visitFloat64 = compareFloat;\nTypeComparator.prototype.visitUtf8 = compareAny;\nTypeComparator.prototype.visitBinary = compareAny;\nTypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;\nTypeComparator.prototype.visitDate = compareDate;\nTypeComparator.prototype.visitDateDay = compareDate;\nTypeComparator.prototype.visitDateMillisecond = compareDate;\nTypeComparator.prototype.visitTimestamp = compareTimestamp;\nTypeComparator.prototype.visitTimestampSecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;\nTypeComparator.prototype.visitTime = compareTime;\nTypeComparator.prototype.visitTimeSecond = compareTime;\nTypeComparator.prototype.visitTimeMillisecond = compareTime;\nTypeComparator.prototype.visitTimeMicrosecond = compareTime;\nTypeComparator.prototype.visitTimeNanosecond = compareTime;\nTypeComparator.prototype.visitDecimal = compareAny;\nTypeComparator.prototype.visitList = compareList;\nTypeComparator.prototype.visitStruct = compareStruct;\nTypeComparator.prototype.visitUnion = compareUnion;\nTypeComparator.prototype.visitDenseUnion = compareUnion;\nTypeComparator.prototype.visitSparseUnion = compareUnion;\nTypeComparator.prototype.visitDictionary = compareDictionary;\nTypeComparator.prototype.visitInterval = compareInterval;\nTypeComparator.prototype.visitIntervalDayTime = compareInterval;\nTypeComparator.prototype.visitIntervalYearMonth = compareInterval;\nTypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;\nTypeComparator.prototype.visitMap = compareMap;\nvar instance7 = new TypeComparator();\nfunction compareSchemas(schema, other) {\n  return instance7.compareSchemas(schema, other);\n}\nfunction compareFields(field2, other) {\n  return instance7.compareFields(field2, other);\n}\nfunction compareTypes(type2, other) {\n  return instance7.visit(type2, other);\n}\n\n// node_modules/apache-arrow/factories.mjs\nfunction makeBuilder(options) {\n  const type2 = options.type;\n  const builder = new (instance6.getVisitFn(type2)())(options);\n  if (type2.children && type2.children.length > 0) {\n    const children2 = options[\"children\"] || [];\n    const defaultOptions = { \"nullValues\": options[\"nullValues\"] };\n    const getChildOptions = Array.isArray(children2) ? (_, i) => children2[i] || defaultOptions : ({ name }) => children2[name] || defaultOptions;\n    for (const [index3, field2] of type2.children.entries()) {\n      const { type: type3 } = field2;\n      const opts = getChildOptions(field2, index3);\n      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type3 })));\n    }\n  }\n  return builder;\n}\n\n// node_modules/apache-arrow/util/recordbatch.mjs\nfunction distributeVectorsIntoRecordBatches(schema, vecs) {\n  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v2) => v2.data.concat()));\n}\nfunction uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {\n  const fields = [...schema.fields];\n  const batches = [];\n  const memo = { numBatches: cols.reduce((n, c6) => Math.max(n, c6.length), 0) };\n  let numBatches = 0, batchLength = 0;\n  let i = -1;\n  const numColumns = cols.length;\n  let child, children2 = [];\n  while (memo.numBatches-- > 0) {\n    for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {\n      children2[i] = child = cols[i].shift();\n      batchLength = Math.min(batchLength, child ? child.length : batchLength);\n    }\n    if (Number.isFinite(batchLength)) {\n      children2 = distributeChildren(fields, batchLength, children2, cols, memo);\n      if (batchLength > 0) {\n        batches[numBatches++] = makeData({\n          type: new Struct(fields),\n          length: batchLength,\n          nullCount: 0,\n          children: children2.slice()\n        });\n      }\n    }\n  }\n  return [\n    schema = schema.assign(fields),\n    batches.map((data) => new RecordBatch(schema, data))\n  ];\n}\nfunction distributeChildren(fields, batchLength, children2, columns, memo) {\n  var _a5;\n  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;\n  for (let i = -1, n = columns.length; ++i < n; ) {\n    const child = children2[i];\n    const length4 = child === null || child === void 0 ? void 0 : child.length;\n    if (length4 >= batchLength) {\n      if (length4 === batchLength) {\n        children2[i] = child;\n      } else {\n        children2[i] = child.slice(0, batchLength);\n        memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));\n      }\n    } else {\n      const field2 = fields[i];\n      fields[i] = field2.clone({ nullable: true });\n      children2[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({\n        type: field2.type,\n        length: batchLength,\n        nullCount: batchLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return children2;\n}\n\n// node_modules/apache-arrow/table.mjs\nvar _a3;\nvar Table = class {\n  constructor(...args) {\n    var _b2, _c2;\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema2([]);\n      this._offsets = [0];\n      return this;\n    }\n    let schema;\n    let offsets;\n    if (args[0] instanceof Schema2) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    const unwrap = (x4) => {\n      if (x4) {\n        if (x4 instanceof RecordBatch) {\n          return [x4];\n        } else if (x4 instanceof Table) {\n          return x4.batches;\n        } else if (x4 instanceof Data) {\n          if (x4.type instanceof Struct) {\n            return [new RecordBatch(new Schema2(x4.type.children), x4)];\n          }\n        } else if (Array.isArray(x4)) {\n          return x4.flatMap((v2) => unwrap(v2));\n        } else if (typeof x4[Symbol.iterator] === \"function\") {\n          return [...x4].flatMap((v2) => unwrap(v2));\n        } else if (typeof x4 === \"object\") {\n          const keys = Object.keys(x4);\n          const vecs = keys.map((k2) => new Vector2([x4[k2]]));\n          const schema2 = new Schema2(keys.map((k2, i) => new Field2(String(k2), vecs[i].type)));\n          const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);\n          return batches2.length === 0 ? [new RecordBatch(x4)] : batches2;\n        }\n      }\n      return [];\n    };\n    const batches = args.flatMap((v2) => unwrap(v2));\n    schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);\n    if (!(schema instanceof Schema2)) {\n      throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n    }\n    for (const batch of batches) {\n      if (!(batch instanceof RecordBatch)) {\n        throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n      }\n      if (!compareSchemas(schema, batch.schema)) {\n        throw new TypeError(\"Table and inner RecordBatch schemas must be equivalent.\");\n      }\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n   */\n  get data() {\n    return this.batches.map(({ data }) => data);\n  }\n  /**\n   * The number of columns in this Table.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this Table.\n   */\n  get numRows() {\n    return this.data.reduce((numRows, data) => numRows + data.length, 0);\n  }\n  /**\n   * The number of null rows in this Table.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   *\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   *\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   *\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   *\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for rows in this Table.\n   */\n  [Symbol.iterator]() {\n    if (this.batches.length > 0) {\n      return instance4.visit(new Vector2(this.data));\n    }\n    return new Array(0)[Symbol.iterator]();\n  }\n  /**\n   * Return a JavaScript Array of the Table rows.\n   *\n   * @returns An Array of Table rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Table rows.\n   *\n   * @returns A string representation of the Table rows.\n   */\n  toString() {\n    return `[\n  ${this.toArray().join(\",\\n  \")}\n]`;\n  }\n  /**\n   * Combines two or more Tables of the same schema.\n   *\n   * @param others Additional Tables to add to the end of this Tables.\n   */\n  concat(...others) {\n    const schema = this.schema;\n    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));\n    return new Table(schema, data.map((data2) => new RecordBatch(schema, data2)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Table.\n   *\n   * @param begin The beginning of the specified portion of the Table.\n   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const schema = this.schema;\n    [begin, end] = clampRange({ length: this.numRows }, begin, end);\n    const data = sliceChunks(this.data, this._offsets, begin, end);\n    return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   *\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   *\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      const data = this.data.map((data2) => data2.children[index3]);\n      if (data.length === 0) {\n        const { type: type2 } = this.schema.fields[index3];\n        const empty4 = makeData({ type: type2, length: 0, nullCount: 0 });\n        data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));\n      }\n      return new Vector2(data);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   *\n   * @param name The name of the child to overwrite.\n   * @returns A new Table with the supplied child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let batches = [...this.batches];\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      const children2 = this.schema.fields.map((_, i) => this.getChildAt(i));\n      [fields[index3], children2[index3]] = [field2, child];\n      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);\n    }\n    return new Table(schema, batches);\n  }\n  /**\n   * Construct a new Table containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new Table of columns matching the specified names.\n   */\n  select(columnNames) {\n    const nameToIndex = this.schema.fields.reduce((m3, f, i) => m3.set(f.name, i), /* @__PURE__ */ new Map());\n    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));\n  }\n  /**\n   * Construct a new Table containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new Table of columns at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n    return new Table(schema, data);\n  }\n  assign(other) {\n    const fields = this.schema.fields;\n    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n      const [indices2, oldToNew2] = memo;\n      const i = fields.findIndex((f) => f.name === f2.name);\n      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);\n      return memo;\n    }, [[], []]);\n    const schema = this.schema.assign(other.schema);\n    const columns = [\n      ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),\n      ...indices.map((i) => other.getChildAt(i))\n    ].filter(Boolean);\n    return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n  }\n};\n_a3 = Symbol.toStringTag;\nTable[_a3] = ((proto) => {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto[\"isValid\"] = wrapChunkedCall1(isChunkedValid);\n  proto[\"get\"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));\n  proto[\"set\"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));\n  proto[\"indexOf\"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));\n  proto[\"getByteLength\"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));\n  return \"Table\";\n})(Table.prototype);\n\n// node_modules/apache-arrow/recordbatch.mjs\nvar _a4;\nvar RecordBatch = class {\n  constructor(...args) {\n    switch (args.length) {\n      case 2: {\n        [this.schema] = args;\n        if (!(this.schema instanceof Schema2)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [\n          ,\n          this.data = makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n          })\n        ] = args;\n        if (!(this.data instanceof Data)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n        break;\n      }\n      case 1: {\n        const [obj] = args;\n        const { fields, children: children2, length: length4 } = Object.keys(obj).reduce((memo, name, i) => {\n          memo.children[i] = obj[name];\n          memo.length = Math.max(memo.length, obj[name].length);\n          memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });\n          return memo;\n        }, {\n          length: 0,\n          fields: new Array(),\n          children: new Array()\n        });\n        const schema = new Schema2(fields);\n        const data = makeData({ type: new Struct(fields), length: length4, children: children2, nullCount: 0 });\n        [this.schema, this.data] = ensureSameLengthData(schema, data.children, length4);\n        break;\n      }\n      default:\n        throw new TypeError(\"RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.\");\n    }\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n  }\n  /**\n   * The number of columns in this RecordBatch.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this RecordBatch.\n   */\n  get numRows() {\n    return this.data.length;\n  }\n  /**\n   * The number of null rows in this RecordBatch.\n   */\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  isValid(index3) {\n    return this.data.getValid(index3);\n  }\n  /**\n   * Get a row by position.\n   * @param index The index of the element to read.\n   */\n  get(index3) {\n    return instance2.visit(this.data, index3);\n  }\n  /**\n   * Set a row by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  set(index3, value) {\n    return instance.visit(this.data, index3, value);\n  }\n  /**\n   * Retrieve the index of the first occurrence of a row in an RecordBatch.\n   * @param element The row to locate in the RecordBatch.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  indexOf(element, offset2) {\n    return instance3.visit(this.data, element, offset2);\n  }\n  /**\n   * Get the size (in bytes) of a row by index.\n   * @param index The row index for which to compute the byteLength.\n   */\n  getByteLength(index3) {\n    return instance5.visit(this.data, index3);\n  }\n  /**\n   * Iterator for rows in this RecordBatch.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(new Vector2([this.data]));\n  }\n  /**\n   * Return a JavaScript Array of the RecordBatch rows.\n   * @returns An Array of RecordBatch rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Combines two or more RecordBatch of the same schema.\n   * @param others Additional RecordBatch to add to the end of this RecordBatch.\n   */\n  concat(...others) {\n    return new Table(this.schema, [this, ...others]);\n  }\n  /**\n   * Return a zero-copy sub-section of this RecordBatch.\n   * @param start The beginning of the specified portion of the RecordBatch.\n   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const [slice7] = new Vector2([this.data]).slice(begin, end).data;\n    return new RecordBatch(this.schema, slice7);\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      return new Vector2([this.data.children[index3]]);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   * @param name The name of the child to overwrite.\n   * @returns A new RecordBatch with the new child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let data = this.data;\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const children2 = data.children.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      [fields[index3], children2[index3]] = [field2, child.data[0]];\n      schema = new Schema2(fields, new Map(this.schema.metadata));\n      data = makeData({ type: new Struct(fields), children: children2 });\n    }\n    return new RecordBatch(schema, data);\n  }\n  /**\n   * Construct a new RecordBatch containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new RecordBatch of columns matching the specified names.\n   */\n  select(columnNames) {\n    const schema = this.schema.select(columnNames);\n    const type2 = new Struct(schema.fields);\n    const children2 = [];\n    for (const name of columnNames) {\n      const index3 = this.schema.fields.findIndex((f) => f.name === name);\n      if (~index3) {\n        children2[index3] = this.data.children[index3];\n      }\n    }\n    return new RecordBatch(schema, makeData({ type: type2, length: this.numRows, children: children2 }));\n  }\n  /**\n   * Construct a new RecordBatch containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new RecordBatch of columns matching at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n    const subset2 = makeData({ type: new Struct(schema.fields), length: this.numRows, children: children2 });\n    return new RecordBatch(schema, subset2);\n  }\n};\n_a4 = Symbol.toStringTag;\nRecordBatch[_a4] = ((proto) => {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return \"RecordBatch\";\n})(RecordBatch.prototype);\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max5, col) => Math.max(max5, col.length), 0)) {\n  var _b2;\n  const fields = [...schema.fields];\n  const children2 = [...chunks];\n  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  for (const [idx, field2] of schema.fields.entries()) {\n    const chunk = chunks[idx];\n    if (!chunk || chunk.length !== maxLength) {\n      fields[idx] = field2.clone({ nullable: true });\n      children2[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({\n        type: field2.type,\n        length: maxLength,\n        nullCount: maxLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return [\n    schema.assign(fields),\n    makeData({ type: new Struct(fields), length: maxLength, children: children2 })\n  ];\n}\nfunction collectDictionaries(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    const data = children2[i];\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type2.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type2.id) !== data.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      collectDictionaries(type2.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\nvar _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {\n  constructor(schema) {\n    const children2 = schema.fields.map((f) => makeData({ type: f.type }));\n    const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children: children2 });\n    super(schema, data);\n  }\n};\n\n// node_modules/apache-arrow/fb/body-compression-method.mjs\nvar BodyCompressionMethod;\n(function(BodyCompressionMethod2) {\n  BodyCompressionMethod2[BodyCompressionMethod2[\"BUFFER\"] = 0] = \"BUFFER\";\n})(BodyCompressionMethod || (BodyCompressionMethod = {}));\n\n// node_modules/apache-arrow/fb/compression-type.mjs\nvar CompressionType;\n(function(CompressionType2) {\n  CompressionType2[CompressionType2[\"LZ4_FRAME\"] = 0] = \"LZ4_FRAME\";\n  CompressionType2[CompressionType2[\"ZSTD\"] = 1] = \"ZSTD\";\n})(CompressionType || (CompressionType = {}));\n\n// node_modules/apache-arrow/fb/body-compression.mjs\nvar BodyCompression = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBodyCompression(bb2, obj) {\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBodyCompression(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Compressor library.\n   * For LZ4_FRAME, each compressed buffer must consist of a single frame.\n   */\n  codec() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;\n  }\n  /**\n   * Indicates the way the record batch body was compressed\n   */\n  method() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;\n  }\n  static startBodyCompression(builder) {\n    builder.startObject(2);\n  }\n  static addCodec(builder, codec) {\n    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);\n  }\n  static addMethod(builder, method) {\n    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);\n  }\n  static endBodyCompression(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBodyCompression(builder, codec, method) {\n    BodyCompression.startBodyCompression(builder);\n    BodyCompression.addCodec(builder, codec);\n    BodyCompression.addMethod(builder, method);\n    return BodyCompression.endBodyCompression(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/buffer.mjs\nvar Buffer2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The relative offset into the shared memory page where the bytes for this\n   * buffer starts\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The absolute length (in bytes) of the memory buffer. The memory is found\n   * from offset (inclusive) to offset + length (non-inclusive). When building\n   * messages using the encapsulated IPC message, padding bytes may be written\n   * after a buffer, but such padding bytes do not need to be accounted for in\n   * the size here.\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createBuffer(builder, offset2, length4) {\n    builder.prep(8, 16);\n    builder.writeInt64(length4);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/field-node.mjs\nvar FieldNode = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The number of value slots in the Arrow array at this level of a nested\n   * tree\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The number of observed nulls. Fields with null_count == 0 may choose not\n   * to write their physical validity bitmap out as a materialized buffer,\n   * instead setting the length of the bitmap buffer to 0.\n   */\n  nullCount() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createFieldNode(builder, length4, null_count) {\n    builder.prep(8, 16);\n    builder.writeInt64(null_count);\n    builder.writeInt64(length4);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/record-batch.mjs\nvar RecordBatch2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsRecordBatch(bb2, obj) {\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsRecordBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * number of records / rows. The arrays in the batch should all have this\n   * length\n   */\n  length() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * Nodes correspond to the pre-ordered flattened logical schema\n   */\n  nodes(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  nodesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Buffers correspond to the pre-ordered flattened buffer tree\n   *\n   * The number of buffers appended to this list depends on the schema. For\n   * example, most primitive arrays will have 2 buffers, 1 for the validity\n   * bitmap and 1 for the values. For struct arrays, there will only be a\n   * single buffer for the validity (nulls) bitmap\n   */\n  buffers(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  buffersLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Optional compression of the message body\n   */\n  compression(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  static startRecordBatch(builder) {\n    builder.startObject(4);\n  }\n  static addLength(builder, length4) {\n    builder.addFieldInt64(0, length4, builder.createLong(0, 0));\n  }\n  static addNodes(builder, nodesOffset) {\n    builder.addFieldOffset(1, nodesOffset, 0);\n  }\n  static startNodesVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addBuffers(builder, buffersOffset) {\n    builder.addFieldOffset(2, buffersOffset, 0);\n  }\n  static startBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addCompression(builder, compressionOffset) {\n    builder.addFieldOffset(3, compressionOffset, 0);\n  }\n  static endRecordBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-batch.mjs\nvar DictionaryBatch = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryBatch(bb2, obj) {\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  data(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * If isDelta is true the values in the dictionary are to be appended to a\n   * dictionary with the indicated id. If isDelta is false this dictionary\n   * should replace the existing dictionary.\n   */\n  isDelta() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startDictionaryBatch(builder) {\n    builder.startObject(3);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addData(builder, dataOffset) {\n    builder.addFieldOffset(1, dataOffset, 0);\n  }\n  static addIsDelta(builder, isDelta) {\n    builder.addFieldInt8(2, +isDelta, 0);\n  }\n  static endDictionaryBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/message-header.mjs\nvar MessageHeader2;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader2 || (MessageHeader2 = {}));\n\n// node_modules/apache-arrow/fb/message.mjs\nvar Message = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMessage(bb2, obj) {\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMessage(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  headerType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader2.NONE;\n  }\n  // @ts-ignore\n  header(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  bodyLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startMessage(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addHeaderType(builder, headerType) {\n    builder.addFieldInt8(1, headerType, MessageHeader2.NONE);\n  }\n  static addHeader(builder, headerOffset) {\n    builder.addFieldOffset(2, headerOffset, 0);\n  }\n  static addBodyLength(builder, bodyLength) {\n    builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endMessage(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishMessageBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedMessageBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {\n    Message.startMessage(builder);\n    Message.addVersion(builder, version);\n    Message.addHeaderType(builder, headerType);\n    Message.addHeader(builder, headerOffset);\n    Message.addBodyLength(builder, bodyLength);\n    Message.addCustomMetadata(builder, customMetadataOffset);\n    return Message.endMessage(builder);\n  }\n};\n\n// node_modules/apache-arrow/visitor/typeassembler.mjs\nvar Long3 = Long;\nvar TypeAssembler = class extends Visitor {\n  visit(node, builder) {\n    return node == null || builder == null ? void 0 : super.visit(node, builder);\n  }\n  visitNull(_node, b) {\n    Null2.startNull(b);\n    return Null2.endNull(b);\n  }\n  visitInt(node, b) {\n    Int.startInt(b);\n    Int.addBitWidth(b, node.bitWidth);\n    Int.addIsSigned(b, node.isSigned);\n    return Int.endInt(b);\n  }\n  visitFloat(node, b) {\n    FloatingPoint.startFloatingPoint(b);\n    FloatingPoint.addPrecision(b, node.precision);\n    return FloatingPoint.endFloatingPoint(b);\n  }\n  visitBinary(_node, b) {\n    Binary2.startBinary(b);\n    return Binary2.endBinary(b);\n  }\n  visitBool(_node, b) {\n    Bool2.startBool(b);\n    return Bool2.endBool(b);\n  }\n  visitUtf8(_node, b) {\n    Utf82.startUtf8(b);\n    return Utf82.endUtf8(b);\n  }\n  visitDecimal(node, b) {\n    Decimal2.startDecimal(b);\n    Decimal2.addScale(b, node.scale);\n    Decimal2.addPrecision(b, node.precision);\n    Decimal2.addBitWidth(b, node.bitWidth);\n    return Decimal2.endDecimal(b);\n  }\n  visitDate(node, b) {\n    Date2.startDate(b);\n    Date2.addUnit(b, node.unit);\n    return Date2.endDate(b);\n  }\n  visitTime(node, b) {\n    Time.startTime(b);\n    Time.addUnit(b, node.unit);\n    Time.addBitWidth(b, node.bitWidth);\n    return Time.endTime(b);\n  }\n  visitTimestamp(node, b) {\n    const timezone = node.timezone && b.createString(node.timezone) || void 0;\n    Timestamp.startTimestamp(b);\n    Timestamp.addUnit(b, node.unit);\n    if (timezone !== void 0) {\n      Timestamp.addTimezone(b, timezone);\n    }\n    return Timestamp.endTimestamp(b);\n  }\n  visitInterval(node, b) {\n    Interval.startInterval(b);\n    Interval.addUnit(b, node.unit);\n    return Interval.endInterval(b);\n  }\n  visitList(_node, b) {\n    List2.startList(b);\n    return List2.endList(b);\n  }\n  visitStruct(_node, b) {\n    Struct_.startStruct_(b);\n    return Struct_.endStruct_(b);\n  }\n  visitUnion(node, b) {\n    Union.startTypeIdsVector(b, node.typeIds.length);\n    const typeIds = Union.createTypeIdsVector(b, node.typeIds);\n    Union.startUnion(b);\n    Union.addMode(b, node.mode);\n    Union.addTypeIds(b, typeIds);\n    return Union.endUnion(b);\n  }\n  visitDictionary(node, b) {\n    const indexType = this.visit(node.indices, b);\n    DictionaryEncoding.startDictionaryEncoding(b);\n    DictionaryEncoding.addId(b, new Long3(node.id, 0));\n    DictionaryEncoding.addIsOrdered(b, node.isOrdered);\n    if (indexType !== void 0) {\n      DictionaryEncoding.addIndexType(b, indexType);\n    }\n    return DictionaryEncoding.endDictionaryEncoding(b);\n  }\n  visitFixedSizeBinary(node, b) {\n    FixedSizeBinary2.startFixedSizeBinary(b);\n    FixedSizeBinary2.addByteWidth(b, node.byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(b);\n  }\n  visitFixedSizeList(node, b) {\n    FixedSizeList2.startFixedSizeList(b);\n    FixedSizeList2.addListSize(b, node.listSize);\n    return FixedSizeList2.endFixedSizeList(b);\n  }\n  visitMap(node, b) {\n    Map2.startMap(b);\n    Map2.addKeysSorted(b, node.keysSorted);\n    return Map2.endMap(b);\n  }\n};\nvar instance8 = new TypeAssembler();\n\n// node_modules/apache-arrow/ipc/metadata/json.mjs\nfunction schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema[\"customMetadata\"]), dictionaries);\n}\nfunction recordBatchFromJSON(b) {\n  return new RecordBatch3(b[\"count\"], fieldNodesFromJSON(b[\"columns\"]), buffersFromJSON(b[\"columns\"]));\n}\nfunction dictionaryBatchFromJSON(b) {\n  return new DictionaryBatch2(recordBatchFromJSON(b[\"data\"]), b[\"id\"], b[\"isDelta\"]);\n}\nfunction schemaFieldsFromJSON(_schema, dictionaries) {\n  return (_schema[\"fields\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldChildrenFromJSON(_field, dictionaries) {\n  return (_field[\"children\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldNodesFromJSON(xs) {\n  return (xs || []).reduce((fieldNodes, column2) => [\n    ...fieldNodes,\n    new FieldNode2(column2[\"count\"], nullCountFromJSON(column2[\"VALIDITY\"])),\n    ...fieldNodesFromJSON(column2[\"children\"])\n  ], []);\n}\nfunction buffersFromJSON(xs, buffers = []) {\n  for (let i = -1, n = (xs || []).length; ++i < n; ) {\n    const column2 = xs[i];\n    column2[\"VALIDITY\"] && buffers.push(new BufferRegion(buffers.length, column2[\"VALIDITY\"].length));\n    column2[\"TYPE\"] && buffers.push(new BufferRegion(buffers.length, column2[\"TYPE\"].length));\n    column2[\"OFFSET\"] && buffers.push(new BufferRegion(buffers.length, column2[\"OFFSET\"].length));\n    column2[\"DATA\"] && buffers.push(new BufferRegion(buffers.length, column2[\"DATA\"].length));\n    buffers = buffersFromJSON(column2[\"children\"], buffers);\n  }\n  return buffers;\n}\nfunction nullCountFromJSON(validity) {\n  return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);\n}\nfunction fieldFromJSON(_field, dictionaries) {\n  let id2;\n  let keys;\n  let field2;\n  let dictMeta;\n  let type2;\n  let dictType;\n  if (!dictionaries || !(dictMeta = _field[\"dictionary\"])) {\n    type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n    field2 = new Field2(_field[\"name\"], type2, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else if (!dictionaries.has(id2 = dictMeta[\"id\"])) {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictionaries.set(id2, type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  }\n  return field2 || null;\n}\nfunction customMetadataFromJSON(_metadata) {\n  return new Map(Object.entries(_metadata || {}));\n}\nfunction indexTypeFromJSON(_type) {\n  return new Int_(_type[\"isSigned\"], _type[\"bitWidth\"]);\n}\nfunction typeFromJSON(f, children2) {\n  const typeId = f[\"type\"][\"name\"];\n  switch (typeId) {\n    case \"NONE\":\n      return new Null();\n    case \"null\":\n      return new Null();\n    case \"binary\":\n      return new Binary();\n    case \"utf8\":\n      return new Utf8();\n    case \"bool\":\n      return new Bool();\n    case \"list\":\n      return new List((children2 || [])[0]);\n    case \"struct\":\n      return new Struct(children2 || []);\n    case \"struct_\":\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case \"int\": {\n      const t = f[\"type\"];\n      return new Int_(t[\"isSigned\"], t[\"bitWidth\"]);\n    }\n    case \"floatingpoint\": {\n      const t = f[\"type\"];\n      return new Float(Precision[t[\"precision\"]]);\n    }\n    case \"decimal\": {\n      const t = f[\"type\"];\n      return new Decimal(t[\"scale\"], t[\"precision\"], t[\"bitWidth\"]);\n    }\n    case \"date\": {\n      const t = f[\"type\"];\n      return new Date_(DateUnit[t[\"unit\"]]);\n    }\n    case \"time\": {\n      const t = f[\"type\"];\n      return new Time_(TimeUnit[t[\"unit\"]], t[\"bitWidth\"]);\n    }\n    case \"timestamp\": {\n      const t = f[\"type\"];\n      return new Timestamp_(TimeUnit[t[\"unit\"]], t[\"timezone\"]);\n    }\n    case \"interval\": {\n      const t = f[\"type\"];\n      return new Interval_(IntervalUnit[t[\"unit\"]]);\n    }\n    case \"union\": {\n      const t = f[\"type\"];\n      return new Union_(UnionMode[t[\"mode\"]], t[\"typeIds\"] || [], children2 || []);\n    }\n    case \"fixedsizebinary\": {\n      const t = f[\"type\"];\n      return new FixedSizeBinary(t[\"byteWidth\"]);\n    }\n    case \"fixedsizelist\": {\n      const t = f[\"type\"];\n      return new FixedSizeList(t[\"listSize\"], (children2 || [])[0]);\n    }\n    case \"map\": {\n      const t = f[\"type\"];\n      return new Map_((children2 || [])[0], t[\"keysSorted\"]);\n    }\n  }\n  throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n\n// node_modules/apache-arrow/ipc/metadata/message.mjs\nvar Long4 = Long;\nvar Builder4 = Builder2;\nvar ByteBuffer3 = ByteBuffer;\nvar Message2 = class {\n  constructor(bodyLength, version, headerType, header) {\n    this._version = version;\n    this._headerType = headerType;\n    this.body = new Uint8Array(0);\n    header && (this._createHeader = () => header);\n    this._bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static fromJSON(msg, headerType) {\n    const message = new Message2(0, MetadataVersion.V4, headerType);\n    message._createHeader = messageHeaderFromJSON(msg, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer3(toUint8Array(buf));\n    const _message = Message.getRootAsMessage(buf);\n    const bodyLength = _message.bodyLength();\n    const version = _message.version();\n    const headerType = _message.headerType();\n    const message = new Message2(bodyLength, version, headerType);\n    message._createHeader = decodeMessageHeader(_message, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static encode(message) {\n    const b = new Builder4();\n    let headerOffset = -1;\n    if (message.isSchema()) {\n      headerOffset = Schema2.encode(b, message.header());\n    } else if (message.isRecordBatch()) {\n      headerOffset = RecordBatch3.encode(b, message.header());\n    } else if (message.isDictionaryBatch()) {\n      headerOffset = DictionaryBatch2.encode(b, message.header());\n    }\n    Message.startMessage(b);\n    Message.addVersion(b, MetadataVersion.V4);\n    Message.addHeader(b, headerOffset);\n    Message.addHeaderType(b, message.headerType);\n    Message.addBodyLength(b, new Long4(message.bodyLength, 0));\n    Message.finishMessageBuffer(b, Message.endMessage(b));\n    return b.asUint8Array();\n  }\n  /** @nocollapse */\n  static from(header, bodyLength = 0) {\n    if (header instanceof Schema2) {\n      return new Message2(0, MetadataVersion.V4, MessageHeader.Schema, header);\n    }\n    if (header instanceof RecordBatch3) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);\n    }\n    if (header instanceof DictionaryBatch2) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);\n    }\n    throw new Error(`Unrecognized Message header: ${header}`);\n  }\n  get type() {\n    return this.headerType;\n  }\n  get version() {\n    return this._version;\n  }\n  get headerType() {\n    return this._headerType;\n  }\n  get bodyLength() {\n    return this._bodyLength;\n  }\n  header() {\n    return this._createHeader();\n  }\n  isSchema() {\n    return this.headerType === MessageHeader.Schema;\n  }\n  isRecordBatch() {\n    return this.headerType === MessageHeader.RecordBatch;\n  }\n  isDictionaryBatch() {\n    return this.headerType === MessageHeader.DictionaryBatch;\n  }\n};\nvar RecordBatch3 = class {\n  constructor(length4, nodes, buffers) {\n    this._nodes = nodes;\n    this._buffers = buffers;\n    this._length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get length() {\n    return this._length;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n};\nvar DictionaryBatch2 = class {\n  constructor(data, id2, isDelta = false) {\n    this._data = data;\n    this._isDelta = isDelta;\n    this._id = typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get id() {\n    return this._id;\n  }\n  get data() {\n    return this._data;\n  }\n  get isDelta() {\n    return this._isDelta;\n  }\n  get length() {\n    return this.data.length;\n  }\n  get nodes() {\n    return this.data.nodes;\n  }\n  get buffers() {\n    return this.data.buffers;\n  }\n};\nvar BufferRegion = class {\n  constructor(offset2, length4) {\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n};\nvar FieldNode2 = class {\n  constructor(length4, nullCount) {\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n    this.nullCount = typeof nullCount === \"number\" ? nullCount : nullCount.low;\n  }\n};\nfunction messageHeaderFromJSON(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.fromJSON(message);\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.fromJSON(message);\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.fromJSON(message);\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nfunction decodeMessageHeader(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.decode(message.header(new Schema()));\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nField2[\"encode\"] = encodeField;\nField2[\"decode\"] = decodeField;\nField2[\"fromJSON\"] = fieldFromJSON;\nSchema2[\"encode\"] = encodeSchema;\nSchema2[\"decode\"] = decodeSchema;\nSchema2[\"fromJSON\"] = schemaFromJSON;\nRecordBatch3[\"encode\"] = encodeRecordBatch;\nRecordBatch3[\"decode\"] = decodeRecordBatch;\nRecordBatch3[\"fromJSON\"] = recordBatchFromJSON;\nDictionaryBatch2[\"encode\"] = encodeDictionaryBatch;\nDictionaryBatch2[\"decode\"] = decodeDictionaryBatch;\nDictionaryBatch2[\"fromJSON\"] = dictionaryBatchFromJSON;\nFieldNode2[\"encode\"] = encodeFieldNode;\nFieldNode2[\"decode\"] = decodeFieldNode;\nBufferRegion[\"encode\"] = encodeBufferRegion;\nBufferRegion[\"decode\"] = decodeBufferRegion;\nfunction decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  const fields = decodeSchemaFields(_schema, dictionaries);\n  return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);\n}\nfunction decodeRecordBatch(batch, version = MetadataVersion.V4) {\n  if (batch.compression() !== null) {\n    throw new Error(\"Record batch compression not implemented\");\n  }\n  return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));\n}\nfunction decodeDictionaryBatch(batch, version = MetadataVersion.V4) {\n  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());\n}\nfunction decodeBufferRegion(b) {\n  return new BufferRegion(b.offset(), b.length());\n}\nfunction decodeFieldNode(f) {\n  return new FieldNode2(f.length(), f.nullCount());\n}\nfunction decodeFieldNodes(batch) {\n  const nodes = [];\n  for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {\n    if (f = batch.nodes(i)) {\n      nodes[++j] = FieldNode2.decode(f);\n    }\n  }\n  return nodes;\n}\nfunction decodeBuffers(batch, version) {\n  const bufferRegions = [];\n  for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {\n    if (b = batch.buffers(i)) {\n      if (version < MetadataVersion.V4) {\n        b.bb_pos += 8 * (i + 1);\n      }\n      bufferRegions[++j] = BufferRegion.decode(b);\n    }\n  }\n  return bufferRegions;\n}\nfunction decodeSchemaFields(schema, dictionaries) {\n  const fields = [];\n  for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {\n    if (f = schema.fields(i)) {\n      fields[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return fields;\n}\nfunction decodeFieldChildren(field2, dictionaries) {\n  const children2 = [];\n  for (let f, i = -1, j = -1, n = field2.childrenLength(); ++i < n; ) {\n    if (f = field2.children(i)) {\n      children2[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return children2;\n}\nfunction decodeField(f, dictionaries) {\n  let id2;\n  let field2;\n  let type2;\n  let keys;\n  let dictType;\n  let dictMeta;\n  if (!dictionaries || !(dictMeta = f.dictionary())) {\n    type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries));\n    field2 = new Field2(f.name(), type2, f.nullable(), decodeCustomMetadata(f));\n  } else if (!dictionaries.has(id2 = dictMeta.id().low)) {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictionaries.set(id2, type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  } else {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  }\n  return field2 || null;\n}\nfunction decodeCustomMetadata(parent) {\n  const data = /* @__PURE__ */ new Map();\n  if (parent) {\n    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {\n      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {\n        data.set(key, entry.value());\n      }\n    }\n  }\n  return data;\n}\nfunction decodeIndexType(_type) {\n  return new Int_(_type.isSigned(), _type.bitWidth());\n}\nfunction decodeFieldType(f, children2) {\n  const typeId = f.typeType();\n  switch (typeId) {\n    case Type2[\"NONE\"]:\n      return new Null();\n    case Type2[\"Null\"]:\n      return new Null();\n    case Type2[\"Binary\"]:\n      return new Binary();\n    case Type2[\"Utf8\"]:\n      return new Utf8();\n    case Type2[\"Bool\"]:\n      return new Bool();\n    case Type2[\"List\"]:\n      return new List((children2 || [])[0]);\n    case Type2[\"Struct_\"]:\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case Type2[\"Int\"]: {\n      const t = f.type(new Int());\n      return new Int_(t.isSigned(), t.bitWidth());\n    }\n    case Type2[\"FloatingPoint\"]: {\n      const t = f.type(new FloatingPoint());\n      return new Float(t.precision());\n    }\n    case Type2[\"Decimal\"]: {\n      const t = f.type(new Decimal2());\n      return new Decimal(t.scale(), t.precision(), t.bitWidth());\n    }\n    case Type2[\"Date\"]: {\n      const t = f.type(new Date2());\n      return new Date_(t.unit());\n    }\n    case Type2[\"Time\"]: {\n      const t = f.type(new Time());\n      return new Time_(t.unit(), t.bitWidth());\n    }\n    case Type2[\"Timestamp\"]: {\n      const t = f.type(new Timestamp());\n      return new Timestamp_(t.unit(), t.timezone());\n    }\n    case Type2[\"Interval\"]: {\n      const t = f.type(new Interval());\n      return new Interval_(t.unit());\n    }\n    case Type2[\"Union\"]: {\n      const t = f.type(new Union());\n      return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);\n    }\n    case Type2[\"FixedSizeBinary\"]: {\n      const t = f.type(new FixedSizeBinary2());\n      return new FixedSizeBinary(t.byteWidth());\n    }\n    case Type2[\"FixedSizeList\"]: {\n      const t = f.type(new FixedSizeList2());\n      return new FixedSizeList(t.listSize(), (children2 || [])[0]);\n    }\n    case Type2[\"Map\"]: {\n      const t = f.type(new Map2());\n      return new Map_((children2 || [])[0], t.keysSorted());\n    }\n  }\n  throw new Error(`Unrecognized type: \"${Type2[typeId]}\" (${typeId})`);\n}\nfunction encodeSchema(b, schema) {\n  const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));\n  Schema.startFieldsVector(b, fieldOffsets.length);\n  const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);\n  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  Schema.startSchema(b);\n  Schema.addFields(b, fieldsVectorOffset);\n  Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);\n  if (metadataOffset !== -1) {\n    Schema.addCustomMetadata(b, metadataOffset);\n  }\n  return Schema.endSchema(b);\n}\nfunction encodeField(b, field2) {\n  let nameOffset = -1;\n  let typeOffset = -1;\n  let dictionaryOffset = -1;\n  const type2 = field2.type;\n  let typeId = field2.typeId;\n  if (!DataType.isDictionary(type2)) {\n    typeOffset = instance8.visit(type2, b);\n  } else {\n    typeId = type2.dictionary.typeId;\n    dictionaryOffset = instance8.visit(type2, b);\n    typeOffset = instance8.visit(type2.dictionary, b);\n  }\n  const childOffsets = (type2.children || []).map((f) => Field2.encode(b, f));\n  const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);\n  const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field2.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  if (field2.name) {\n    nameOffset = b.createString(field2.name);\n  }\n  Field.startField(b);\n  Field.addType(b, typeOffset);\n  Field.addTypeType(b, typeId);\n  Field.addChildren(b, childrenVectorOffset);\n  Field.addNullable(b, !!field2.nullable);\n  if (nameOffset !== -1) {\n    Field.addName(b, nameOffset);\n  }\n  if (dictionaryOffset !== -1) {\n    Field.addDictionary(b, dictionaryOffset);\n  }\n  if (metadataOffset !== -1) {\n    Field.addCustomMetadata(b, metadataOffset);\n  }\n  return Field.endField(b);\n}\nfunction encodeRecordBatch(b, recordBatch) {\n  const nodes = recordBatch.nodes || [];\n  const buffers = recordBatch.buffers || [];\n  RecordBatch2.startNodesVector(b, nodes.length);\n  for (const n of nodes.slice().reverse())\n    FieldNode2.encode(b, n);\n  const nodesVectorOffset = b.endVector();\n  RecordBatch2.startBuffersVector(b, buffers.length);\n  for (const b_ of buffers.slice().reverse())\n    BufferRegion.encode(b, b_);\n  const buffersVectorOffset = b.endVector();\n  RecordBatch2.startRecordBatch(b);\n  RecordBatch2.addLength(b, new Long4(recordBatch.length, 0));\n  RecordBatch2.addNodes(b, nodesVectorOffset);\n  RecordBatch2.addBuffers(b, buffersVectorOffset);\n  return RecordBatch2.endRecordBatch(b);\n}\nfunction encodeDictionaryBatch(b, dictionaryBatch) {\n  const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);\n  DictionaryBatch.startDictionaryBatch(b);\n  DictionaryBatch.addId(b, new Long4(dictionaryBatch.id, 0));\n  DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);\n  DictionaryBatch.addData(b, dataOffset);\n  return DictionaryBatch.endDictionaryBatch(b);\n}\nfunction encodeFieldNode(b, node) {\n  return FieldNode.createFieldNode(b, new Long4(node.length, 0), new Long4(node.nullCount, 0));\n}\nfunction encodeBufferRegion(b, node) {\n  return Buffer2.createBuffer(b, new Long4(node.offset, 0), new Long4(node.length, 0));\n}\nvar platformIsLittleEndian = (() => {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(\n    0,\n    256,\n    true\n    /* littleEndian */\n  );\n  return new Int16Array(buffer)[0] === 256;\n})();\n\n// node_modules/apache-arrow/ipc/message.mjs\nvar invalidMessageType = (type2) => `Expected ${MessageHeader[type2]} Message in stream, but was null or length 0.`;\nvar nullMessage = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader[type2]} Message is null or length 0.`;\nvar invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\nvar invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\nvar MessageReader = class {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    let r;\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 && /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n  readSchema(throwIfNull = false) {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb2 = buf && new ByteBuffer(buf);\n    const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n    return { done: len === 0, value: len };\n  }\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return { done: false, value: Message2.decode(buf) };\n  }\n};\nvar AsyncMessageReader = class {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if ((r = yield this.readMetadata(r.value)).done) {\n        return ITERATOR_DONE;\n      }\n      return r;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.throw(value);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.return(value);\n    });\n  }\n  readMessage(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.next()).done) {\n        return null;\n      }\n      if (type2 != null && r.value.headerType !== type2) {\n        throw new Error(invalidMessageType(type2));\n      }\n      return r.value;\n    });\n  }\n  readMessageBody(bodyLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (bodyLength <= 0) {\n        return new Uint8Array(0);\n      }\n      const buf = toUint8Array(yield this.source.read(bodyLength));\n      if (buf.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n      }\n      return (\n        /* 1. */\n        buf.byteOffset % 8 === 0 && /* 2. */\n        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n      );\n    });\n  }\n  readSchema(throwIfNull = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type2 = MessageHeader.Schema;\n      const message = yield this.readMessage(type2);\n      const schema = message === null || message === void 0 ? void 0 : message.header();\n      if (throwIfNull && !schema) {\n        throw new Error(nullMessage(type2));\n      }\n      return schema;\n    });\n  }\n  readMetadataLength() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(PADDING);\n      const bb2 = buf && new ByteBuffer(buf);\n      const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n      return { done: len === 0, value: len };\n    });\n  }\n  readMetadata(metadataLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(metadataLength);\n      if (!buf) {\n        return ITERATOR_DONE;\n      }\n      if (buf.byteLength < metadataLength) {\n        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n      }\n      return { done: false, value: Message2.decode(buf) };\n    });\n  }\n};\nvar JSONMessageReader = class extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n  next() {\n    const { _json } = this;\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);\n      return { done: false, value: message };\n    }\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch[\"data\"][\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return { done: false, value: message };\n    }\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch[\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);\n      return { done: false, value: message };\n    }\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column2) => [\n        ...buffers,\n        ...column2[\"VALIDITY\"] && [column2[\"VALIDITY\"]] || [],\n        ...column2[\"TYPE\"] && [column2[\"TYPE\"]] || [],\n        ...column2[\"OFFSET\"] && [column2[\"OFFSET\"]] || [],\n        ...column2[\"DATA\"] && [column2[\"DATA\"]] || [],\n        ...flattenDataSources(column2[\"children\"])\n      ], []);\n    }\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readSchema() {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (!message || !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n};\nvar PADDING = 4;\nvar MAGIC_STR = \"ARROW1\";\nvar MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1) {\n  MAGIC[i] = MAGIC_STR.codePointAt(i);\n}\nfunction checkForMagicArrowString(buffer, index3 = 0) {\n  for (let i = -1, n = MAGIC.length; ++i < n; ) {\n    if (MAGIC[i] !== buffer[index3 + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nvar magicLength = MAGIC.length;\nvar magicAndPadding = magicLength + PADDING;\nvar magicX2AndPadding = magicLength * 2 + PADDING;\n\n// node_modules/apache-arrow/ipc/reader.mjs\nvar RecordBatchReader = class extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n  get closed() {\n    return this._impl.closed;\n  }\n  get schema() {\n    return this._impl.schema;\n  }\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n  isSync() {\n    return this._impl.isSync();\n  }\n  isAsync() {\n    return this._impl.isAsync();\n  }\n  isFile() {\n    return this._impl.isFile();\n  }\n  isStream() {\n    return this._impl.isStream();\n  }\n  next() {\n    return this._impl.next();\n  }\n  throw(value) {\n    return this._impl.throw(value);\n  }\n  return(value) {\n    return this._impl.return(value);\n  }\n  cancel() {\n    return this._impl.cancel();\n  }\n  reset(schema) {\n    this._impl.reset(schema);\n    this._DOMStream = void 0;\n    this._nodeStream = void 0;\n    return this;\n  }\n  open(options) {\n    const opening = this._impl.open(options);\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n  readRecordBatch(index3) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index3) : null;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n  toDOMStream() {\n    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });\n  }\n  toNodeStream() {\n    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (() => __awaiter(this, void 0, void 0, function* () {\n        return yield RecordBatchReader.from(yield source);\n      }))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n    return readAllAsync(source);\n  }\n};\nvar RecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    return [...this];\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return __asyncGenerator(this, arguments, function* _a5() {\n      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));\n    });\n  }\n};\nvar AsyncRecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    var e_1, _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const batches = new Array();\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const batch = _c2.value;\n          batches.push(batch);\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return batches;\n    });\n  }\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n};\nvar RecordBatchFileReader = class extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar RecordBatchReaderImpl = class {\n  constructor(dictionaries = /* @__PURE__ */ new Map()) {\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n  isSync() {\n    return false;\n  }\n  isAsync() {\n    return false;\n  }\n  isFile() {\n    return false;\n  }\n  isStream() {\n    return false;\n  }\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = /* @__PURE__ */ new Map();\n    return this;\n  }\n  _loadRecordBatch(header, body) {\n    const children2 = this._loadVectors(header, body, this.schema.fields);\n    const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children: children2 });\n    return new RecordBatch(this.schema, data);\n  }\n  _loadDictionaryBatch(header, body) {\n    const { id: id2, isDelta } = header;\n    const { dictionaries, schema } = this;\n    const dictionary = dictionaries.get(id2);\n    if (isDelta || !dictionary) {\n      const type2 = schema.dictionaries.get(id2);\n      const data = this._loadVectors(header.data, body, [type2]);\n      return (dictionary && isDelta ? dictionary.concat(new Vector2(data)) : new Vector2(data)).memoize();\n    }\n    return dictionary.memoize();\n  }\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nvar RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n  isSync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n    return this;\n  }\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message;\n    const { _reader: reader } = this;\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return { done: false, value: recordBatch };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n    }\n    return this.return();\n  }\n  _readNextMessageAndValidate(type2) {\n    return this._reader.readMessage(type2);\n  }\n};\nvar AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n  isAsync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && (this.closed = true)) {\n        yield this.reset()._reader.return();\n        this._reader = null;\n        this.dictionaries = null;\n      }\n    });\n  }\n  open(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed) {\n        this.autoDestroy = shouldAutoDestroy(this, options);\n        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {\n          yield this.cancel();\n        }\n      }\n      return this;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.throw(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.return(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return ITERATOR_DONE;\n      }\n      let message;\n      const { _reader: reader } = this;\n      while (message = yield this._readNextMessageAndValidate()) {\n        if (message.isSchema()) {\n          yield this.reset(message.header());\n        } else if (message.isRecordBatch()) {\n          this._recordBatchIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return { done: false, value: recordBatch };\n        } else if (message.isDictionaryBatch()) {\n          this._dictionaryIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n      if (this.schema && this._recordBatchIndex === 0) {\n        this._recordBatchIndex++;\n        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n      }\n      return yield this.return();\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this._reader.readMessage(type2);\n    });\n  }\n};\nvar RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isSync() {\n    return true;\n  }\n  isFile() {\n    return true;\n  }\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n    return super.open(options);\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      this.open();\n    }\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n  }\n  _readFooter() {\n    const { _handle } = this;\n    const offset2 = _handle.size - magicAndPadding;\n    const length4 = _handle.readInt32(offset2);\n    const buffer = _handle.readAt(offset2 - length4, length4);\n    return Footer_.decode(buffer);\n  }\n  _readNextMessageAndValidate(type2) {\n    var _a5;\n    if (!this._footer) {\n      this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type2);\n      }\n    }\n    return null;\n  }\n};\nvar AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source, ...rest) {\n    const byteLength = typeof rest[0] !== \"number\" ? rest.shift() : void 0;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isFile() {\n    return true;\n  }\n  isAsync() {\n    return true;\n  }\n  open(options) {\n    const _super = Object.create(null, {\n      open: { get: () => super.open }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && !this._footer) {\n        this.schema = (this._footer = yield this._readFooter()).schema;\n        for (const block of this._footer.dictionaryBatches()) {\n          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));\n        }\n      }\n      return yield _super.open.call(this, options);\n    });\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return null;\n      }\n      if (!this._footer) {\n        yield this.open();\n      }\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);\n        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return recordBatch;\n        }\n      }\n      return null;\n    });\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);\n        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n    });\n  }\n  _readFooter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { _handle } = this;\n      _handle._pending && (yield _handle._pending);\n      const offset2 = _handle.size - magicAndPadding;\n      const length4 = yield _handle.readInt32(offset2);\n      const buffer = yield _handle.readAt(offset2 - length4, length4);\n      return Footer_.decode(buffer);\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._footer) {\n        yield this.open();\n      }\n      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n        const block = this._footer.getRecordBatch(this._recordBatchIndex);\n        if (block && (yield this._handle.seek(block.offset))) {\n          return yield this._reader.readMessage(type2);\n        }\n      }\n      return null;\n    });\n  }\n};\nvar RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options[\"autoDestroy\"] === \"boolean\" ? options[\"autoDestroy\"] : self[\"autoDestroy\"];\n}\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n  try {\n    if (!reader.open({ autoDestroy: false }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\nfunction readAllAsync(source) {\n  return __asyncGenerator(this, arguments, function* readAllAsync_1() {\n    const reader = yield __await(RecordBatchReader.from(source));\n    try {\n      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {\n        do {\n          yield yield __await(reader);\n        } while (!(yield __await(reader.reset().open())).closed);\n      }\n    } finally {\n      yield __await(reader.cancel());\n    }\n  });\n}\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {\n  }()));\n}\nfunction fromAsyncByteStream(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const bytes = yield source.peek(magicLength + 7 & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {\n      return __asyncGenerator(this, arguments, function* () {\n      });\n    }()));\n  });\n}\nfunction fromFileHandle(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const { size } = yield source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n  });\n}\n\n// node_modules/apache-arrow/visitor/vectorassembler.mjs\nvar VectorAssembler = class extends Visitor {\n  constructor() {\n    super();\n    this._byteLength = 0;\n    this._nodes = [];\n    this._buffers = [];\n    this._bufferRegions = [];\n  }\n  /** @nocollapse */\n  static assemble(...args) {\n    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);\n    const assembler = new VectorAssembler();\n    assembler.visitMany(unwrap(args));\n    return assembler;\n  }\n  visit(data) {\n    if (data instanceof Vector2) {\n      this.visitMany(data.data);\n      return this;\n    }\n    const { type: type2 } = data;\n    if (!DataType.isDictionary(type2)) {\n      const { length: length4, nullCount } = data;\n      if (length4 > 2147483647) {\n        throw new RangeError(\"Cannot write arrays larger than 2^31 - 1 in length\");\n      }\n      if (!DataType.isNull(type2)) {\n        addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length4, data.nullBitmap));\n      }\n      this.nodes.push(new FieldNode2(length4, nullCount));\n    }\n    return super.visit(data);\n  }\n  visitNull(_null) {\n    return this;\n  }\n  visitDictionary(data) {\n    return this.visit(data.clone(data.type.indices));\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferRegions() {\n    return this._bufferRegions;\n  }\n};\nfunction addBuffer(values2) {\n  const byteLength = values2.byteLength + 7 & ~7;\n  this.buffers.push(values2);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\nfunction assembleUnion(data) {\n  const { type: type2, length: length4, typeIds, valueOffsets } = data;\n  addBuffer.call(this, typeIds);\n  if (type2.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, data);\n  } else if (type2.mode === UnionMode.Dense) {\n    if (data.offset <= 0) {\n      addBuffer.call(this, valueOffsets);\n      return assembleNestedVector.call(this, data);\n    } else {\n      const maxChildTypeId = typeIds.reduce((x4, y4) => Math.max(x4, y4), typeIds[0]);\n      const childLengths = new Int32Array(maxChildTypeId + 1);\n      const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      const shiftedOffsets = new Int32Array(length4);\n      const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets);\n      for (let typeId, shift, index3 = -1; ++index3 < length4; ) {\n        if ((shift = childOffsets[typeId = typeIds[index3]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index3] = unshiftedOffsets[index3] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      for (let child, childIndex = -1, numChildren = type2.children.length; ++childIndex < numChildren; ) {\n        if (child = data.children[childIndex]) {\n          const typeId = type2.typeIds[childIndex];\n          const childLength = Math.min(length4, childLengths[typeId]);\n          this.visit(child.slice(childOffsets[typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction assembleBoolVector(data) {\n  let values2;\n  if (data.nullCount >= data.length) {\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values2 = data.values) instanceof Uint8Array) {\n    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values2));\n  }\n  return addBuffer.call(this, packBools(data.values));\n}\nfunction assembleFlatVector(data) {\n  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\nfunction assembleFlatListVector(data) {\n  const { length: length4, values: values2, valueOffsets } = data;\n  const firstOffset = valueOffsets[0];\n  const lastOffset = valueOffsets[length4];\n  const byteLength = Math.min(lastOffset - firstOffset, values2.byteLength - firstOffset);\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets));\n  addBuffer.call(this, values2.subarray(firstOffset, firstOffset + byteLength));\n  return this;\n}\nfunction assembleListVector(data) {\n  const { length: length4, valueOffsets } = data;\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length4, valueOffsets));\n  }\n  return this.visit(data.children[0]);\n}\nfunction assembleNestedVector(data) {\n  return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n\n// node_modules/apache-arrow/ipc/writer.mjs\nvar RecordBatchWriter = class extends ReadableInterop {\n  constructor(options) {\n    super();\n    this._position = 0;\n    this._started = false;\n    this._sink = new AsyncByteQueue();\n    this._schema = null;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    isObject2(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });\n    this._autoDestroy = typeof options.autoDestroy === \"boolean\" ? options.autoDestroy : true;\n    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === \"boolean\" ? options.writeLegacyIpcFormat : false;\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  toString(sync = false) {\n    return this._sink.toString(sync);\n  }\n  toUint8Array(sync = false) {\n    return this._sink.toUint8Array(sync);\n  }\n  writeAll(input) {\n    if (isPromise(input)) {\n      return input.then((x4) => this.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(this, input);\n    }\n    return writeAll(this, input);\n  }\n  get closed() {\n    return this._sink.closed;\n  }\n  [Symbol.asyncIterator]() {\n    return this._sink[Symbol.asyncIterator]();\n  }\n  toDOMStream(options) {\n    return this._sink.toDOMStream(options);\n  }\n  toNodeStream(options) {\n    return this._sink.toNodeStream(options);\n  }\n  close() {\n    return this.reset()._sink.close();\n  }\n  abort(reason) {\n    return this.reset()._sink.abort(reason);\n  }\n  finish() {\n    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);\n    return this;\n  }\n  reset(sink = this._sink, schema = null) {\n    if (sink === this._sink || sink instanceof AsyncByteQueue) {\n      this._sink = sink;\n    } else {\n      this._sink = new AsyncByteQueue();\n      if (sink && isWritableDOMStream(sink)) {\n        this.toDOMStream({ type: \"bytes\" }).pipeTo(sink);\n      } else if (sink && isWritableNodeStream(sink)) {\n        this.toNodeStream({ objectMode: false }).pipe(sink);\n      }\n    }\n    if (this._started && this._schema) {\n      this._writeFooter(this._schema);\n    }\n    this._started = false;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    if (!schema || !compareSchemas(schema, this._schema)) {\n      if (schema == null) {\n        this._position = 0;\n        this._schema = null;\n      } else {\n        this._started = true;\n        this._schema = schema;\n        this._writeSchema(schema);\n      }\n    }\n    return this;\n  }\n  write(payload) {\n    let schema = null;\n    if (!this._sink) {\n      throw new Error(`RecordBatchWriter is closed`);\n    } else if (payload == null) {\n      return this.finish() && void 0;\n    } else if (payload instanceof Table && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    }\n    if (schema && !compareSchemas(schema, this._schema)) {\n      if (this._started && this._autoDestroy) {\n        return this.close();\n      }\n      this.reset(this._sink, schema);\n    }\n    if (payload instanceof RecordBatch) {\n      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {\n        this._writeRecordBatch(payload);\n      }\n    } else if (payload instanceof Table) {\n      this.writeAll(payload.batches);\n    } else if (isIterable2(payload)) {\n      this.writeAll(payload);\n    }\n  }\n  _writeMessage(message, alignment = 8) {\n    const a4 = alignment - 1;\n    const buffer = Message2.encode(message);\n    const flatbufferSize = buffer.byteLength;\n    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;\n    const alignedSize = flatbufferSize + prefixSize + a4 & ~a4;\n    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;\n    if (message.headerType === MessageHeader.RecordBatch) {\n      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    } else if (message.headerType === MessageHeader.DictionaryBatch) {\n      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    }\n    if (!this._writeLegacyIpcFormat) {\n      this._write(Int32Array.of(-1));\n    }\n    this._write(Int32Array.of(alignedSize - prefixSize));\n    if (flatbufferSize > 0) {\n      this._write(buffer);\n    }\n    return this._writePadding(nPaddingBytes);\n  }\n  _write(chunk) {\n    if (this._started) {\n      const buffer = toUint8Array(chunk);\n      if (buffer && buffer.byteLength > 0) {\n        this._sink.write(buffer);\n        this._position += buffer.byteLength;\n      }\n    }\n    return this;\n  }\n  _writeSchema(schema) {\n    return this._writeMessage(Message2.from(schema));\n  }\n  // @ts-ignore\n  _writeFooter(schema) {\n    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));\n  }\n  _writeMagic() {\n    return this._write(MAGIC);\n  }\n  _writePadding(nBytes) {\n    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;\n  }\n  _writeRecordBatch(batch) {\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);\n    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);\n    const message = Message2.from(recordBatch, byteLength);\n    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeDictionaryBatch(dictionary, id2, isDelta = false) {\n    this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector2([dictionary]));\n    const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);\n    const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);\n    const message = Message2.from(dictionaryBatch, byteLength);\n    return this._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeBodyBuffers(buffers) {\n    let buffer;\n    let size, padding;\n    for (let i = -1, n = buffers.length; ++i < n; ) {\n      if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {\n        this._write(buffer);\n        if ((padding = (size + 7 & ~7) - size) > 0) {\n          this._writePadding(padding);\n        }\n      }\n    }\n    return this;\n  }\n  _writeDictionaries(batch) {\n    for (let [id2, dictionary] of batch.dictionaries) {\n      let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;\n      if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {\n        for (const data of dictionary.data) {\n          this._writeDictionaryBatch(data, id2, offset2 > 0);\n          offset2 += data.length;\n        }\n      }\n    }\n    return this;\n  }\n};\nvar RecordBatchStreamWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input, options) {\n    const writer = new RecordBatchStreamWriter(options);\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n};\nvar RecordBatchFileWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input) {\n    const writer = new RecordBatchFileWriter();\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n  constructor() {\n    super();\n    this._autoDestroy = true;\n  }\n  // @ts-ignore\n  _writeSchema(schema) {\n    return this._writeMagic()._writePadding(2);\n  }\n  _writeFooter(schema) {\n    const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));\n    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();\n  }\n};\nfunction writeAll(writer, input) {\n  let chunks = input;\n  if (input instanceof Table) {\n    chunks = input.batches;\n    writer.reset(void 0, input.schema);\n  }\n  for (const batch of chunks) {\n    writer.write(batch);\n  }\n  return writer.finish();\n}\nfunction writeAllAsync(writer, batches) {\n  var batches_1, batches_1_1;\n  var e_1, _a5;\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      for (batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done; ) {\n        const batch = batches_1_1.value;\n        writer.write(batch);\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (batches_1_1 && !batches_1_1.done && (_a5 = batches_1.return))\n          yield _a5.call(batches_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return writer.finish();\n  });\n}\n\n// node_modules/apache-arrow/io/whatwg/iterable.mjs\nfunction toDOMStream(source, options) {\n  if (isAsyncIterable(source)) {\n    return asyncIterableAsReadableDOMStream(source, options);\n  }\n  if (isIterable2(source)) {\n    return iterableAsReadableDOMStream(source, options);\n  }\n  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);\n}\nfunction iterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      next(controller, it || (it = source[Symbol.iterator]()));\n    },\n    pull(controller) {\n      it ? next(controller, it) : controller.close();\n    },\n    cancel() {\n      ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    let buf;\n    let r = null;\n    let size = controller.desiredSize || null;\n    while (!(r = it2.next(bm ? size : null)).done) {\n      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n        size != null && bm && (size = size - buf.byteLength + 1);\n        r.value = buf;\n      }\n      controller.enqueue(r.value);\n      if (size != null && --size <= 0) {\n        return;\n      }\n    }\n    controller.close();\n  }\n}\nfunction asyncIterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, it || (it = source[Symbol.asyncIterator]()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        it ? yield next(controller, it) : controller.close();\n      });\n    },\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);\n      });\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf;\n      let r = null;\n      let size = controller.desiredSize || null;\n      while (!(r = yield it2.next(bm ? size : null)).done) {\n        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n          size != null && bm && (size = size - buf.byteLength + 1);\n          r.value = buf;\n        }\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/builder.mjs\nfunction builderThroughDOMStream(options) {\n  return new BuilderTransform(options);\n}\nvar BuilderTransform = class {\n  constructor(options) {\n    this._numChunks = 0;\n    this._finished = false;\n    this._bufferedSize = 0;\n    const { [\"readableStrategy\"]: readableStrategy, [\"writableStrategy\"]: writableStrategy, [\"queueingStrategy\"]: queueingStrategy = \"count\" } = options, builderOptions = __rest(options, [\"readableStrategy\", \"writableStrategy\", \"queueingStrategy\"]);\n    this._controller = null;\n    this._builder = makeBuilder(builderOptions);\n    this._getSize = queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength;\n    const { [\"highWaterMark\"]: readableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);\n    const { [\"highWaterMark\"]: writableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);\n    this[\"readable\"] = new ReadableStream({\n      [\"cancel\"]: () => {\n        this._builder.clear();\n      },\n      [\"pull\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      },\n      [\"start\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      }\n    }, {\n      \"highWaterMark\": readableHighWaterMark,\n      \"size\": queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength\n    });\n    this[\"writable\"] = new WritableStream({\n      [\"abort\"]: () => {\n        this._builder.clear();\n      },\n      [\"write\"]: () => {\n        this._maybeFlush(this._builder, this._controller);\n      },\n      [\"close\"]: () => {\n        this._maybeFlush(this._builder.finish(), this._controller);\n      }\n    }, {\n      \"highWaterMark\": writableHighWaterMark,\n      \"size\": (value) => this._writeValueAndReturnChunkSize(value)\n    });\n  }\n  _writeValueAndReturnChunkSize(value) {\n    const bufferedSize = this._bufferedSize;\n    this._bufferedSize = this._getSize(this._builder.append(value));\n    return this._bufferedSize - bufferedSize;\n  }\n  _maybeFlush(builder, controller) {\n    if (controller == null) {\n      return;\n    }\n    if (this._bufferedSize >= controller.desiredSize) {\n      ++this._numChunks && this._enqueue(controller, builder.toVector());\n    }\n    if (builder.finished) {\n      if (builder.length > 0 || this._numChunks === 0) {\n        ++this._numChunks && this._enqueue(controller, builder.toVector());\n      }\n      if (!this._finished && (this._finished = true)) {\n        this._enqueue(controller, null);\n      }\n    }\n  }\n  _enqueue(controller, chunk) {\n    this._bufferedSize = 0;\n    this._controller = null;\n    chunk == null ? controller.close() : controller.enqueue(chunk);\n  }\n};\nvar chunkLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;\n};\nvar chunkByteLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;\n};\n\n// node_modules/apache-arrow/io/whatwg/reader.mjs\nfunction recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {\n  const queue = new AsyncByteQueue();\n  let reader = null;\n  const readable = new ReadableStream({\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield queue.close();\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, reader || (reader = yield open()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        reader ? yield next(controller, reader) : controller.close();\n      });\n    }\n  });\n  return { writable: new WritableStream(queue, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, writableStrategy)), readable };\n  function open() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);\n    });\n  }\n  function next(controller, reader2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let size = controller.desiredSize;\n      let r = null;\n      while (!(r = yield reader2.next()).done) {\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/writer.mjs\nfunction recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {\n  const writer = new this(writableStrategy);\n  const reader = new AsyncByteStream(writer);\n  const readable = new ReadableStream({\n    // type: 'bytes',\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield reader.cancel();\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    }\n  }, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, readableStrategy));\n  return { writable: new WritableStream(writer, writableStrategy), readable };\n  function next(controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf = null;\n      let size = controller.desiredSize;\n      while (buf = yield reader.read(size || null)) {\n        controller.enqueue(buf);\n        if (size != null && (size -= buf.byteLength) <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/ipc/serialization.mjs\nfunction tableFromIPC(input) {\n  const reader = RecordBatchReader.from(input);\n  if (isPromise(reader)) {\n    return reader.then((reader2) => tableFromIPC(reader2));\n  }\n  if (reader.isAsync()) {\n    return reader.readAll().then((xs) => new Table(xs));\n  }\n  return new Table(reader.readAll());\n}\n\n// node_modules/apache-arrow/Arrow.mjs\nvar util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {\n  compareSchemas,\n  compareFields,\n  compareTypes\n});\n\n// node_modules/apache-arrow/Arrow.dom.mjs\nadapters_default.toDOMStream = toDOMStream;\nBuilder[\"throughDOM\"] = builderThroughDOMStream;\nRecordBatchReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchFileReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchStreamReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchFileWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchStreamWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\n\n// js/parsing.js\nfunction parse_spec(code, data) {\n  if (code === null) {\n    return null;\n  }\n  if (Array.isArray(code)) {\n    return code.map((d) => parse_spec(d, data));\n  }\n  if (typeof code === \"string\" || code instanceof String) {\n    return code;\n  }\n  if (Object.entries(code).length == 0) {\n    return code;\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame\") {\n    return tableFromIPC(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame-ref\") {\n    return tableFromIPC(data[code[\"value\"]]);\n  }\n  if (code[\"pyobsplot-type\"] == \"function\") {\n    let fun = get_fun(code[\"module\"], code[\"method\"]);\n    return fun.call(null, ...parse_spec(code[\"args\"], data));\n  }\n  if (code[\"pyobsplot-type\"] == \"function-object\") {\n    return get_fun(code[\"module\"], code[\"method\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"js\") {\n    let indirect_eval = eval;\n    return indirect_eval(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"datetime\") {\n    return new Date(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson\") {\n    return code[\"value\"];\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson-ref\") {\n    return data[code[\"value\"]];\n  }\n  let ret = {};\n  for (const [key, value] of Object.entries(code)) {\n    ret[key] = parse_spec(value, data);\n  }\n  return ret;\n}\nfunction get_fun(mod, method) {\n  let fun;\n  switch (mod) {\n    case \"Plot\":\n      fun = dist_exports[method];\n      break;\n    case \"d3\":\n      fun = src_exports[method];\n      break;\n    case \"Math\":\n      fun = Math[method];\n      break;\n    default:\n      throw new Error(`Invalid module: ${mod}`);\n  }\n  if (fun === void 0) {\n    throw new Error(`${mod}.${method} is not defined`);\n  }\n  return fun;\n}\n\n// js/index.js\nfunction render(view) {\n  let spec = () => view.model.get(\"spec\");\n  view.el.appendChild(generate_plot(spec()));\n  view.model.on(\"change:spec\", () => _onValueChanged(view, view.el));\n}\nfunction generate_plot(spec) {\n  let plot2 = document.createElement(\"div\");\n  plot2.classList.add(\"pyobsplot-plot\");\n  let out;\n  try {\n    out = parse_spec(spec[\"code\"], spec[\"data\"]);\n    if (spec[\"code\"][\"pyobsplot-type\"] == \"function\") {\n      if (!(out instanceof Element)) {\n        out = out.plot();\n      }\n    } else {\n      out = plot(out);\n    }\n  } catch (error) {\n    out = document.createElement(\"pre\");\n    out.classList.add(\"pyobsplot-error\");\n    out.textContent = error;\n  }\n  plot2.appendChild(out);\n  return plot2;\n}\nfunction _onValueChanged(view, el) {\n  let plot2 = el.querySelector(\".pyobsplot-plot\");\n  el.removeChild(plot2);\n  let spec = () => view.model.get(\"spec\");\n  el.appendChild(generate_plot(spec()));\n}\nexport {\n  render\n};\n","_model_module":"anywidget","_model_module_version":"0.2.0","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"0.2.0","_view_name":"AnyView","layout":"IPY_MODEL_c296008f5ec44c789ffab6488a81c437","spec":{"code":{"args":[{"pyobsplot-type":"DataFrame-ref","value":0},{"x":"flipper_length_mm"}],"method":"auto","module":"Plot","pyobsplot-type":"function"},"data":[null]},"tabbable":null,"tooltip":null}},"3eddd96661a541bba1e558c4a5f2001a":{"buffers":[{"data":"QVJST1cxAAD/////sAEAABAAAAAAAAoADAAGAAUACAAKAAAAAAEEAAwAAAAIAAgAAAAEAAgAAAAEAAAABwAAAFABAAAUAQAA1AAAAJwAAABgAAAALAAAAAQAAADc/v//AAABBRAAAAAUAAAABAAAAAAAAAADAAAAc2V4AMj+//8A////AAABAxAAAAAcAAAABAAAAAAAAAALAAAAYm9keV9tYXNzX2cAXv///wAAAQAw////AAABAxAAAAAkAAAABAAAAAAAAAARAAAAZmxpcHBlcl9sZW5ndGhfbW0AAACW////AAABAGj///8AAAEDEAAAACAAAAAEAAAAAAAAAA8AAABjdWxtZW5fZGVwdGhfbW0Ayv///wAAAQCc////AAABAxAAAAAoAAAABAAAAAAAAAAQAAAAY3VsbWVuX2xlbmd0aF9tbQAABgAIAAYABgAAAAAAAQDY////AAABBRAAAAAYAAAABAAAAAAAAAAGAAAAaXNsYW5kAADI////EAAUAAgABgAHAAwAAAAQABAAAAAAAAEFEAAAABwAAAAEAAAAAAAAAAcAAABzcGVjaWVzAAQABAAEAAAAAAAAAP/////YAQAAFAAAAAAAAAAMABYABgAFAAgADAAMAAAAAAMEABgAAAB4PQAAAAAAAAAACgAYAAwABAAIAAoAAAAsAQAAEAAAAFgBAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkBQAAAAAAAGgFAAAAAAAA3AgAAAAAAABIDgAAAAAAAAAAAAAAAAAASA4AAAAAAABkBQAAAAAAALATAAAAAAAAMAgAAAAAAADgGwAAAAAAAAAAAAAAAAAA4BsAAAAAAABgBQAAAAAAAEAhAAAAAAAAAAAAAAAAAABAIQAAAAAAAGAFAAAAAAAAoCYAAAAAAAAAAAAAAAAAAKAmAAAAAAAAYAUAAAAAAAAALAAAAAAAAAAAAAAAAAAAACwAAAAAAABgBQAAAAAAAGAxAAAAAAAAKwAAAAAAAACQMQAAAAAAAGQFAAAAAAAA+DYAAAAAAAB+BgAAAAAAAAAAAAAHAAAAWAEAAAAAAAAAAAAAAAAAAFgBAAAAAAAAAAAAAAAAAABYAQAAAAAAAAAAAAAAAAAAWAEAAAAAAAAAAAAAAAAAAFgBAAAAAAAAAAAAAAAAAABYAQAAAAAAAAAAAAAAAAAAWAEAAAAAAAALAAAAAAAAAAAAAAAGAAAADAAAABIAAAAYAAAAHgAAACQAAAAqAAAAMAAAADYAAAA8AAAAQgAAAEgAAABOAAAAVAAAAFoAAABgAAAAZgAAAGwAAAByAAAAeAAAAH4AAACEAAAAigAAAJAAAACWAAAAnAAAAKIAAACoAAAArgAAALQAAAC6AAAAwAAAAMYAAADMAAAA0gAAANgAAADeAAAA5AAAAOoAAADwAAAA9gAAAPwAAAACAQAACAEAAA4BAAAUAQAAGgEAACABAAAmAQAALAEAADIBAAA4AQAAPgEAAEQBAABKAQAAUAEAAFYBAABcAQAAYgEAAGgBAABuAQAAdAEAAHoBAACAAQAAhgEAAIwBAACSAQAAmAEAAJ4BAACkAQAAqgEAALABAAC2AQAAvAEAAMIBAADIAQAAzgEAANQBAADaAQAA4AEAAOYBAADsAQAA8gEAAPgBAAD+AQAABAIAAAoCAAAQAgAAFgIAABwCAAAiAgAAKAIAAC4CAAA0AgAAOgIAAEACAABGAgAATAIAAFICAABYAgAAXgIAAGQCAABqAgAAcAIAAHYCAAB8AgAAggIAAIgCAACOAgAAlAIAAJoCAACgAgAApgIAAKwCAACyAgAAuAIAAL4CAADEAgAAygIAANACAADWAgAA3AIAAOICAADoAgAA7gIAAPQCAAD6AgAAAAMAAAYDAAAMAwAAEgMAABgDAAAeAwAAJAMAACoDAAAwAwAANgMAADwDAABCAwAASAMAAE4DAABUAwAAWgMAAGADAABmAwAAbAMAAHIDAAB4AwAAfgMAAIQDAACKAwAAkAMAAJkDAACiAwAAqwMAALQDAAC9AwAAxgMAAM8DAADYAwAA4QMAAOoDAADzAwAA/AMAAAUEAAAOBAAAFwQAACAEAAApBAAAMgQAADsEAABEBAAATQQAAFYEAABfBAAAaAQAAHEEAAB6BAAAgwQAAIwEAACVBAAAngQAAKcEAACwBAAAuQQAAMIEAADLBAAA1AQAAN0EAADmBAAA7wQAAPgEAAABBQAACgUAABMFAAAcBQAAJQUAAC4FAAA3BQAAQAUAAEkFAABSBQAAWwUAAGQFAABtBQAAdgUAAH8FAACIBQAAkQUAAJoFAACjBQAArAUAALUFAAC+BQAAxwUAANAFAADZBQAA4gUAAOsFAAD0BQAA+gUAAAAGAAAGBgAADAYAABIGAAAYBgAAHgYAACQGAAAqBgAAMAYAADYGAAA8BgAAQgYAAEgGAABOBgAAVAYAAFoGAABgBgAAZgYAAGwGAAByBgAAeAYAAH4GAACEBgAAigYAAJAGAACWBgAAnAYAAKIGAACoBgAArgYAALQGAAC6BgAAwAYAAMYGAADMBgAA0gYAANgGAADeBgAA5AYAAOoGAADwBgAA9gYAAPwGAAACBwAACAcAAA4HAAAUBwAAGgcAACAHAAAmBwAALAcAADIHAAA4BwAAPgcAAEQHAABKBwAAUAcAAFYHAABcBwAAYgcAAGgHAABuBwAAdAcAAHoHAACABwAAhgcAAIwHAACSBwAAmAcAAJ4HAACkBwAAqgcAALAHAAC2BwAAvAcAAMIHAADIBwAAzgcAANQHAADaBwAA4AcAAOYHAADsBwAA8gcAAPgHAAD+BwAABAgAAAoIAAAQCAAAFggAABwIAAAiCAAAKAgAAC4IAAA0CAAAOggAAEAIAABGCAAATAgAAFIIAABYCAAAXggAAGQIAABqCAAAcAgAAHYIAAB8CAAAgggAAIgIAACOCAAAlAgAAJoIAACgCAAApggAAKwIAACyCAAAuAgAAL4IAADECAAAyggAANAIAADWCAAA3AgAAAAAAABBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVBZGVsaWVDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBDaGluc3RyYXBHZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b29HZW50b28AAAAAAAAAAAkAAAASAAAAGwAAACQAAAAtAAAANgAAAD8AAABIAAAAUQAAAFoAAABjAAAAbAAAAHUAAAB+AAAAhwAAAJAAAACZAAAAogAAAKsAAAC0AAAAugAAAMAAAADGAAAAzAAAANIAAADYAAAA3gAAAOQAAADqAAAA8AAAAPUAAAD6AAAA/wAAAAQBAAAJAQAADgEAABMBAAAYAQAAHQEAACIBAAAnAQAALAEAADEBAAA2AQAAOwEAAEABAABFAQAASgEAAE8BAABUAQAAWgEAAGABAABmAQAAbAEAAHIBAAB4AQAAfgEAAIQBAACKAQAAkAEAAJYBAACcAQAAogEAAKgBAACuAQAAtAEAALoBAADAAQAAyQEAANIBAADbAQAA5AEAAO0BAAD2AQAA/wEAAAgCAAARAgAAGgIAACMCAAAsAgAANQIAAD4CAABHAgAAUAIAAFUCAABaAgAAXwIAAGQCAABpAgAAbgIAAHMCAAB4AgAAfQIAAIICAACHAgAAjAIAAJECAACWAgAAmwIAAKACAACmAgAArAIAALICAAC4AgAAvgIAAMQCAADKAgAA0AIAANYCAADcAgAA4gIAAOgCAADuAgAA9AIAAPoCAAAAAwAACQMAABIDAAAbAwAAJAMAAC0DAAA2AwAAPwMAAEgDAABRAwAAWgMAAGMDAABsAwAAdQMAAH4DAACHAwAAkAMAAJUDAACaAwAAnwMAAKQDAACpAwAArgMAALMDAAC4AwAAvQMAAMIDAADHAwAAzAMAANEDAADWAwAA2wMAAOADAADlAwAA6gMAAO8DAAD0AwAA+QMAAP4DAAADBAAACAQAAA0EAAASBAAAFwQAABwEAAAhBAAAJgQAACsEAAAwBAAANQQAADoEAAA/BAAARAQAAEkEAABOBAAAUwQAAFgEAABdBAAAYgQAAGcEAABsBAAAcQQAAHYEAAB7BAAAgAQAAIUEAACKBAAAjwQAAJQEAACZBAAAngQAAKMEAACoBAAArQQAALIEAAC3BAAAvAQAAMEEAADGBAAAywQAANAEAADVBAAA2gQAAN8EAADkBAAA6QQAAO4EAADzBAAA+AQAAP0EAAACBQAABwUAAAwFAAARBQAAFgUAABsFAAAgBQAAJQUAACoFAAAvBQAANAUAADkFAAA+BQAAQwUAAEgFAABOBQAAVAUAAFoFAABgBQAAZgUAAGwFAAByBQAAeAUAAH4FAACEBQAAigUAAJAFAACWBQAAnAUAAKIFAACoBQAArgUAALQFAAC6BQAAwAUAAMYFAADMBQAA0gUAANgFAADeBQAA5AUAAOoFAADwBQAA9gUAAPwFAAACBgAACAYAAA4GAAAUBgAAGgYAACAGAAAmBgAALAYAADIGAAA4BgAAPgYAAEQGAABKBgAAUAYAAFYGAABcBgAAYgYAAGgGAABuBgAAdAYAAHoGAACABgAAhgYAAIwGAACSBgAAmAYAAJ4GAACkBgAAqgYAALAGAAC2BgAAvAYAAMIGAADIBgAAzgYAANQGAADaBgAA4AYAAOYGAADsBgAA8gYAAPgGAAD+BgAABAcAAAoHAAAQBwAAFgcAABwHAAAiBwAAKAcAAC4HAAA0BwAAOgcAAEAHAABGBwAATAcAAFIHAABYBwAAXgcAAGQHAABqBwAAcAcAAHYHAAB8BwAAggcAAIgHAACOBwAAlAcAAJoHAACgBwAApgcAAKwHAACyBwAAuAcAAL4HAADEBwAAygcAANAHAADWBwAA3AcAAOIHAADoBwAA7gcAAPQHAAD6BwAAAAgAAAYIAAAMCAAAEggAABgIAAAeCAAAJAgAACoIAAAwCAAAAAAAAFRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlbkJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1CaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VUb3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5Ub3JnZXJzZW5EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZVRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlbkRyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lZmYcQgAAHkIzMyFCAADAf83MEkIzMx1CmpkbQs3MHEJmZghCAAAoQjMzF0IzMxdCZmYkQmZmGkJmZgpCZmYSQs3MGkIAACpCmpkJQgAAOEIzMxdCzcwWQpqZD0LNzBhCMzMbQjMzDUJmZiJCAAAiQpqZF0IAACJCAAAeQs3MFEIAAB5CmpkjQpqZEULNzBxCMzMbQs3MKEJmZhZCMzMfQgAAEkIzMyNCAAAQQmZmMEIAABRCZmYeQmZmJEIAABZCAAAQQjMzKUJmZh5CZmYgQgAADEIAAChCAAAKQpqZJUIAABxCZmYiQgAAEkJmZhZCzcwOQjMzJUJmZhZCZmYkQpqZEUJmZiZCAAAOQmZmJEKamQ9CMzMnQgAABkLNzB5CZmYeQjMzN0IAAA5CMzMrQpqZI0LNzBRCzcwQQmZmKEJmZgpCmpkrQs3MEkJmZgxCMzMVQjMzJUIzMxFCmpkTQjMzGUKamRtCzcwOQmZmJEIAAAhCZmYeQs3MEEIzMyNCZmYYQjMzIUJmZgRCzcwsQgAADEIAACRCzcwWQjMzF0KamRdCzcweQmZmGkLNzBhCZmYYQs3MLEJmZhhCZmY2Qs3MHkLNzChCZmYeQs3MKkJmZhpCMzMVQs3MDkJmZiRCzcwQQs3MFkLNzCBCmpklQs3MDEJmZiJCMzMbQgAAJkIAABxCZmYwQgAAGkJmZixCMzMTQgAAFkJmZhhCZmYkQmZmDkLNzCBCAAAUQs3MHkLNzCBCZmYiQmZmAELNzCJCMzMVQgAAHELNzBxCZmYSQgAAEEIzMxdCAAAQQgAAJkIAADpCAABIQjMzTUKamTVCzcxSQs3MNEJmZjhCMzNNQgAAOEIzM01CZmY6Qs3MTkIAADxCAABQQpqZN0IAAEpCMzNJQgAAaEKamTlCzcxEQpqZKUIAAEJCzcwsQmZmSkLNzDpCAABQQgAASkIAAEZCmpk5QjMzU0KamSNCzcxYQgAAKkIAAExCzcxGQgAAPkJmZj5CAABQQpqZO0IAAFZCAABEQs3MOEKamUtCAAA2QpqZS0IzM0tCZmZIQgAAREIAAE5CMzNHQmZmQEKamU1Czcw2Qs3MSkIAACpCzcxQQs3MNEIzM0VCzcxIQmZmNkKamU9CMzM7Qs3MNkIzM19CAAAuQmZmRkIzM0tCzcxIQmZmOEIAAEhCzcxCQgAASEJmZj5CAAA6QpqZNULNzDpCMzMtQjMzO0KamSNCAABEQgAANkKamUFCMzM3QjMzRUIAAChCzcxEQs3MOELNzEJCzcxIQmZmNEIAADpCMzM5QpqZK0JmZjhCAAAyQjMzP0LNzEBCAABIQjMzPUIzMytCZmY0QmZmbkJmZkRCmplBQmZmKkKamTFCAAAwQs3MQkLNzCpCZmZGQjMzNUJmZkZCAABKQmZmLkIAADZCAABKQpqZM0LNzDRCZmY6QgAAQkJmZjRCZmZIQgAAOkIAADRCMzMvQgAANkLNzCxCmplJQjMzNULNzDhCzcw2QjMzWUIzMzdCMzNHQs3MOEIAAEZCAAAuQs3MSkLNzD5Cmpk5Qs3MQEIAADpCmpk5QmZmQkIAAD5CZmZMQs3MNELNzDRCZmZEQgAAUkKamT1CAABIQpqZM0IzM0tCmpktQjMzTUIAAD5CZmZQQgAAPkLNzFBCAAA2QgAARkIAADJCMzNLQpqZRUKamTtCmplBQmZmTEIAAEJCmplfQs3MPEJmZkRCMzM9QjMzO0LNzCZCmplVQjMzLUJmZkBCAABKQjMzR0IAAC5CAABOQs3MOEJmZlxCAAAyQjMzQ0LNzDxCAADAfzMzO0KamUlCzcw0QpqZR0KamZVBMzOLQQAAkEEAAMB/ZmaaQc3MpEFmZo5BzcycQc3MkEGamaFBzcyIQWZmikHNzIxBmpmpQc3MqEFmZo5BAACYQZqZpUEzM5NBAACsQWZmkkGamZVBmpmZQc3MkEGamYlBMzOXQc3MlEEzM49BzcyUQTMzl0GamYVBzcyQQWZmjkEzM5dBAACIQc3MqEEAAKBBAACUQWZmmkHNzJhBAACQQTMzk0EAAJRBmpmdQTMzh0FmZpZBAACYQTMzl0EzM49BmpmpQZqZjUEzM5dBMzOPQQAAnEHNzJBBzcyUQQAAjEFmZpZBzcyEQc3MmEEzM4dBzcyoQQAAiEGamZFBzcyIQQAAkEGamYFBzcyYQc3MhEEzM5tBAACYQTMzk0GamYlBMzOXQQAAjEEAAJRBZmaGQTMzm0HNzIBBzcyYQZqZiUHNzIxBZmaWQTMzm0FmZo5BZmaiQQAAnEHNzJRBmpmZQWZmlkEAAJBBzcyQQc3MiEHNzJBBZmaKQTMzl0HNzJRBAACUQc3MgEEAAJRBMzOPQQAAoEEAAIBBAACgQc3MlEEzM5dBmpmJQQAAoEEAAIhBAACYQQAAhEFmZqJBmpmNQQAAnEGamaVBZmaSQQAAiEEAAKRBAACIQc3MlEGamYlBZmaeQQAAiEEAAJRBZmZ+QQAAmEHNzIxBZmaSQc3MiEEAAJBBMzOPQZqZmUEAAJRBAACUQc3MjEEAAIxBAACMQc3MoEEAAIRBMzOPQc3MiEGamYlBAAB4QQAAiEFmZoZBmpmVQc3MlEEzM5NBZmaOQc3MkEHNzIhBAACUQTMzj0EAAJxBmpmZQZqZlUFmZp5BZmaOQZqZkUGamZFBMzOXQTMzn0FmZo5BZmaiQWZmikHNzJBBzcyIQc3MnEEAAKBBZmaOQc3MlEGamZFBZmaKQQAAjEHNzIRBMzObQTMzj0EAAJhBMzOTQQAAmEFmZo5BAACgQc3MhEFmZqZBmpmFQWZmlkHNzJRBZmaGQWZmkkGamaVBzcyEQTMzn0EAAJxBAACMQc3MmEEAAIhBMzOPQQAAlEEzM49BzcycQZqZlUFmZopBMzODQQAAmEFmZopBmpmdQWZmikFmZpZBzcyEQTMzn0FmZpZBMzObQQAAnEEAAIRBAACIQWZmnkHNzJBBmpmRQQAAmEGamZVBMzNTQWZmgkGamWFBMzNzQQAAaEEAAFhBmplpQc3MdEFmZlZBZmZ2QTMzW0HNzIBBMzNbQZqZaUGamWlBMzN7QQAAWEEzM3NBAABoQZqZcUHNzGRBAABoQQAAaEHNzHxBmplRQZqZcUHNzGRBAABwQc3MZEHNzHRBzcx0QTMzY0EAAGhBAACIQc3MbEFmZoJBMzNbQWZmikGamVlBMzN7QTMzW0EAAIBBMzNbQQAAcEFmZn5BZmZeQWZmXkFmZn5BzcxUQc3MfEEzM2NBmplhQWZmZkEAAHBBZmZmQWZmdkFmZl5BAABwQQAAaEHNzHRBzcxcQWZmbkFmZl5BMzN7QTMzY0FmZoZBZmZmQZqZgUEzM2NBAABwQQAAcEGamXlBmpl5Qc3MbEEAAHBBAACAQTMzY0FmZoJBzcxcQTMzg0EAAGhBmpl5QZqZaUFmZn5BzcxcQWZmikFmZmZBMzNjQQAAYEEAAIhBAABwQc3MiEEAAGhBzcyAQTMza0EzM3tBzcx8QZqZaUFmZmZBAACEQQAAcEEAAIhBAAB4QQAAcEHNzFxBzcyAQTMza0HNzHxBAABgQZqZcUEzM3NBZmZ+QTMzc0FmZoJBmplhQQAAgEEzM3tBmpmBQTMzW0EAAMB/zcxkQTMze0HNzGxBzcyAQQAANUMAADpDAABDQwAAwH8AAEFDAAA+QwAANUMAAENDAABBQwAAPkMAADpDAAA0QwAANkMAAD9DAABGQwAAOUMAAENDAABFQwAAOEMAAEJDAAAuQwAANEMAAD1DAAA5QwAANEMAADtDAAA3QwAAO0MAACxDAAA0QwAAMkMAADJDAAA8QwAAOEMAAENDAABEQwAAPkMAADRDAAA1QwAAOEMAADZDAABDQwAAOkMAAERDAAA5QwAAPkMAADZDAAAzQwAAPkMAAD9DAAA6QwAAPEMAAD5DAABIQwAAO0MAAD9DAAA6QwAAQUMAADVDAABCQwAAOUMAAENDAAA5QwAAQEMAADhDAABAQwAAQ0MAADxDAAA+QwAARkMAAD5DAAA+QwAAREMAAEVDAAA+QwAAQ0MAAD9DAAA4QwAAO0MAAENDAAA9QwAAREMAADtDAABBQwAAP0MAAEJDAAA+QwAAPUMAAD1DAAA+QwAASkMAAE1DAAA5QwAAOkMAADtDAABQQwAAPkMAAERDAAAyQwAAQEMAAEBDAABLQwAAN0MAAD5DAABBQwAAOEMAAEdDAAA+QwAANUMAAEVDAABGQwAAP0MAAEFDAABFQwAAP0MAAERDAAA8QwAAR0MAAD1DAAA9QwAAO0MAAEZDAAAwQwAASkMAADpDAABHQwAAP0MAAENDAAA/QwAAUkMAAD5DAABFQwAAQUMAAEdDAAA7QwAAPkMAAD9DAABIQwAAOUMAAEFDAABBQwAAO0MAADxDAAA+QwAAQEMAADlDAAA+QwAAOEMAAENDAABBQwAAO0MAAElDAABAQwAAREMAAEFDAAA8QwAARUMAAEZDAAAyQwAARUMAAENDAABGQwAAQUMAAEJDAAA5QwAASUMAAD5DAABJQwAARUMAADVDAAA+QwAAQ0MAADVDAAA/QwAAO0MAAEFDAABDQwAARUMAAEhDAABIQwAAP0MAAE1DAAA7QwAASUMAADtDAABLQwAAQ0MAAEdDAABDQwAAUkMAAEBDAABNQwAAUkMAADtDAABEQwAAREMAAERDAABJQwAAPkMAAFRDAAA7QwAARkMAAEdDAABJQwAAQUMAAEtDAAA7QwAARUMAAD9DAABLQwAASkMAAEJDAABOQwAAPUMAAENDAABPQwAASkMAAEFDAABSQwAARkMAAFNDAABmQwAAUkMAAFpDAABXQwAAUkMAAFNDAABbQwAAUUMAAFdDAABWQwAAWEMAAFZDAABVQwAAUkMAAFlDAABSQwAAXUMAAFFDAABeQwAAWkMAAFdDAABVQwAAV0MAAFdDAABXQwAAWEMAAFdDAABSQwAAXEMAAF5DAABRQwAAT0MAAGZDAABcQwAAXEMAAFVDAABbQwAAUEMAAFBDAABQQwAAYUMAAFJDAABYQwAAXkMAAFlDAABSQwAAYUMAAFVDAABXQwAAUkMAAFxDAABSQwAAYUMAAFlDAABcQwAAUEMAAFxDAABQQwAAYEMAAFBDAABdQwAAVkMAAGdDAABbQwAAZkMAAFZDAABlQwAAXEMAAF9DAABYQwAAXUMAAF1DAABZQwAAWEMAAGZDAABRQwAAXEMAAFdDAABfQwAAVEMAAF1DAABUQwAAYEMAAFRDAABkQwAAWkMAAFpDAABUQwAAZkMAAFpDAABkQwAAVEMAAGBDAABWQwAAYkMAAFhDAABeQwAAS0MAAGFDAABbQwAAZEMAAFdDAABkQwAAWEMAAFdDAABSQwAAW0MAAFBDAABRQwAAWEMAAGVDAABVQwAAZkMAAFlDAABmQwAAWUMAAF5DAABWQwAAwH8AAFdDAABeQwAAVEMAAFVDAGBqRQCAbUUAIEtFAADAfwCgV0UAIGRFAJBiRQAYkkUAMFlFANCERQBATkUAQGdFAABIRQCAbUUAgIlFAEBnRQCgV0UAoIxFANBPRQBAg0UAgFRFAABhRQCAbUUA4HZFAIBtRQCAbUUA4F1FAABIRQDgREUA4HZFACBLRQDAc0UAQE5FAMBzRQDQT0UAsIFFAOB2RQDgXUUAQE5FAFCRRQDgREUAwHNFAMBBRQCAiUUAgDtFAMCPRQAQVkUA8DlFAKBXRQCwgUUAwFpFAGCGRQCgV0UAIH1FAEA1RQBAZ0UA4F1FAIBtRQAgMkUAYGpFAOBERQCAiUUAAGFFACB9RQAgMkUA4HZFAGBRRQAggEUAoD5FABCLRQAAYUUAwHNFAOBdRQCwgUUAQGdFANCERQBAZ0UAwHNFAOBdRQAAekUAAEhFAOCSRQCAbUUAQINFAGBRRQDgXUUAgG1FAMBaRQDgdkUAAGFFAOBdRQBghkUAgFRFABCLRQBATkUAYIZFAEBnRQDwh0UAQDVFACCARQDQaEUAqJNFADBARQDQhEUA0DZFAOBdRQBgakUAwHNFAHBGRQA4lUUAEG9FAMCPRQAASEUAmIVFAMBzRQCwfkUAQDVFAPBrRQBgUUUA0E9FAOBERQDAWkUAoFdFADByRQCgPkUAAHpFALBMRQBghkUAoD5FAAB6RQDQT0UAwFpFAMBaRQDYi0UAEFZFAMBzRQBwRkUAcHhFAIBURQDQhEUAgFRFADBZRQCgPkUA0GhFAIA7RQAgZEUA0IRFADBZRQCgV0UAYGpFAEBnRQAAekUAwFpFAMBzRQAgZEUAUFxFANBoRQDgdkUAIEtFAGBqRQCwgUUAQGdFAIBtRQDwa0UAQGdFACB9RQBwX0UAIH1FAEBORQBAZ0UAoFdFAICJRQAAYUUAgFRFAEA1RQCAbUUAQE5FALCBRQCAVEUAgG1FAEBnRQAwjkUAAEhFAGCGRQBgUUUAIIBFAABhRQDAc0UAoHBFAACWRQDAKEUAoIxFAOB2RQAgZEUA4F1FAMBaRQCwZUUAEItFAIBURQBghkUAIEtFALBlRQDQT0UA4HZFAABhRQAgfUUAYFFFAKBXRQAgS0UAIH1FAIBtRQBQXEUA4HZFACBkRQAgZEUAAHpFAIBURQDwa0UAIIBFAPBrRQCgjEUAILJFABCLRQAgskUAwKhFADCORQAAlkUAgKJFAICJRQDwoEUAUJFFAHCtRQBQkUUA0LZFAECDRQDQtkUAsIFFAODERQAAlkUAMKdFACCyRQBAnEUAgIlFANCdRQBAnEUAYJ9FACCARQCQsEUAwI9FAHCtRQAQpEUA4JJFANCdRQAQvUUA8KBFAMCoRQCwmkUAEKRFAPCHRQAwp0UA4HZFACCyRQBghkUAcJRFAHCtRQAgmUUAQINFAMCoRQBgn0UAoKVFAJCXRQCgpUUAgIlFAECcRQAgmUUA0J1FAGCGRQBAnEUAEItFAHCtRQBAg0UAoKVFAICJRQCQsEUA4JJFACCyRQBQkUUAQLVFAOCSRQBwrUUAcJRFAECcRQBgn0UAgKJFAOCSRQBAtUUAwI9FAIC7RQBwlEUA8LlFAIiQRQBQqkUAqJNFADCnRQBwlEUAAK9FAMCPRQCgpUUAWJhFAHCtRQCwmkUAwKhFAHCURQCQsEUAkJdFAICiRQDomUUAWJhFAIiQRQAQpEUAkJdFAACvRQB4m0UA4KtFAKiTRQDgq0UA4JJFAOCrRQD4jkUA4KtFAECcRQDwuUUAUJFFAOCrRQC4iEUA0LZFAFiYRQCAu0UA6JlFAADAfwCQl0UAsLNFAICiRQDAqEX38P///3////////////////////////////////+//////7//////7//2AAAAAAAAAAAABAAAAAoAAAAQAAAAEAAAABYAAAAaAAAAIAAAACQAAAAkAAAAJAAAACQAAAAkAAAAKgAAAC4AAAAyAAAAOAAAAD4AAABCAAAASAAAAEwAAABSAAAAVgAAAFwAAABgAAAAZAAAAGoAAABuAAAAdAAAAHoAAAB+AAAAhAAAAIgAAACOAAAAkgAAAJgAAACcAAAAoAAAAKYAAACsAAAAsAAAALYAAAC6AAAAwAAAAMQAAADKAAAAzgAAANIAAADSAAAA2AAAANwAAADiAAAA5gAAAOwAAADwAAAA9gAAAPoAAAAAAQAABAEAAAoBAAAOAQAAFAEAABgBAAAeAQAAIgEAACgBAAAsAQAAMgEAADYBAAA8AQAAQAEAAEYBAABKAQAAUAEAAFQBAABaAQAAXgEAAGQBAABoAQAAbgEAAHIBAAB4AQAAfAEAAIIBAACGAQAAjAEAAJABAACUAQAAmgEAAJ4BAACkAQAAqgEAAK4BAAC0AQAAuAEAAL4BAADCAQAAyAEAAMwBAADSAQAA1gEAANwBAADgAQAA5gEAAOoBAADwAQAA9AEAAPoBAAD+AQAABAIAAAgCAAAOAgAAEgIAABgCAAAcAgAAIgIAACYCAAAsAgAAMAIAADYCAAA6AgAAQAIAAEQCAABKAgAATgIAAFQCAABYAgAAXgIAAGICAABoAgAAbAIAAHICAAB2AgAAfAIAAIACAACGAgAAigIAAJACAACUAgAAmgIAAJ4CAACkAgAAqAIAAK4CAACyAgAAuAIAALwCAADAAgAAxgIAAMwCAADQAgAA1gIAANoCAADgAgAA5AIAAOgCAADuAgAA8gIAAPgCAAD+AgAAAgMAAAgDAAAMAwAAEgMAABYDAAAcAwAAIAMAACYDAAAqAwAALgMAADQDAAA6AwAAPgMAAEQDAABIAwAATgMAAFIDAABYAwAAXAMAAGIDAABmAwAAbAMAAHADAAB2AwAAegMAAIADAACEAwAAiAMAAI4DAACUAwAAmAMAAJ4DAACiAwAApgMAAKwDAACwAwAAtgMAALwDAADAAwAAxgMAAMoDAADOAwAA1AMAANoDAADeAwAA5AMAAOgDAADuAwAA8gMAAPgDAAD8AwAAAAQAAAYEAAAKBAAAEAQAABYEAAAaBAAAIAQAACQEAAAoBAAALgQAADQEAAA4BAAAPgQAAEIEAABGBAAATAQAAFIEAABWBAAAXAQAAGAEAABmBAAAagQAAHAEAAB0BAAAegQAAH4EAACEBAAAiAQAAI4EAACSBAAAlgQAAJwEAACiBAAApgQAAKwEAACwBAAAsAQAALQEAAC6BAAAvgQAAMIEAADIBAAAzgQAANIEAADYBAAA3AQAAOIEAADmBAAA7AQAAPAEAAD2BAAA+gQAAAAFAAAEBQAACAUAAA4FAAAUBQAAGAUAAB4FAAAiBQAAKAUAACwFAAAyBQAANgUAADwFAABABQAARgUAAEoFAABQBQAAVAUAAFoFAABeBQAAZAUAAGgFAABuBQAAcgUAAHIFAAB2BQAAfAUAAIAFAACGBQAAigUAAI4FAACUBQAAmgUAAJ4FAACkBQAAqAUAAK4FAACyBQAAuAUAALwFAADCBQAAxgUAAMwFAADQBQAA1gUAANoFAADgBQAA5AUAAOoFAADuBQAA9AUAAPgFAAD+BQAAAgYAAAYGAAAMBgAAEgYAABYGAAAcBgAAIAYAACYGAAAqBgAAKgYAAC4GAAA0BgAAOAYAAD4GAABCBgAASAYAAEwGAABSBgAAVgYAAFwGAABgBgAAYAYAAGQGAABqBgAAagYAAHAGAAB0BgAAegYAAH4GAAAAAAAATUFMRUZFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFAAD/////AAAAABAAAAAMABQABgAIAAwAEAAMAAAAAAAEADgAAAAoAAAABAAAAAEAAADAAQAAAAAAAOABAAAAAAAAeD0AAAAAAAAAAAAAAAAAAAgACAAAAAQACAAAAAQAAAAHAAAAUAEAABQBAADUAAAAnAAAAGAAAAAsAAAABAAAANz+//8AAAEFEAAAABQAAAAEAAAAAAAAAAMAAABzZXgAyP7//wD///8AAAEDEAAAABwAAAAEAAAAAAAAAAsAAABib2R5X21hc3NfZwBe////AAABADD///8AAAEDEAAAACQAAAAEAAAAAAAAABEAAABmbGlwcGVyX2xlbmd0aF9tbQAAAJb///8AAAEAaP///wAAAQMQAAAAIAAAAAQAAAAAAAAADwAAAGN1bG1lbl9kZXB0aF9tbQDK////AAABAJz///8AAAEDEAAAACgAAAAEAAAAAAAAABAAAABjdWxtZW5fbGVuZ3RoX21tAAAGAAgABgAGAAAAAAABANj///8AAAEFEAAAABgAAAAEAAAAAAAAAAYAAABpc2xhbmQAAMj///8QABQACAAGAAcADAAAABAAEAAAAAAAAQUQAAAAHAAAAAQAAAAAAAAABwAAAHNwZWNpZXMABAAEAAQAAADYAQAAQVJST1cx","encoding":"base64","path":["spec","data",0]}],"model_module":"anywidget","model_module_version":"0.2.0","model_name":"AnyModel","state":{"_anywidget_id":"pyobsplot.widget.Obsplot","_css":"/* js/styles.css */\n.counter-button {\n  background-color: #ea580c;\n}\n.counter-button:hover {\n  background-color: #0000FF;\n}\n.pyobsplot-plot {\n  color: #000;\n  background-color: white;\n}\n.pyobsplot-error {\n  color: #CC0000;\n  padding-left: 1em;\n}\n.pyobsplot-error::before {\n  content: \"\\26a0  \";\n}\n","_dom_classes":[],"_esm":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/binary-search-bounds/search-bounds.js\nvar require_search_bounds = __commonJS({\n  \"node_modules/binary-search-bounds/search-bounds.js\"(exports, module) {\n    \"use strict\";\n    function ge(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p >= 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function gt(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p > 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function lt(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p < 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function le(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p <= 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function eq(a4, y4, c6, l, h) {\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p === 0) {\n          return m3;\n        }\n        if (p <= 0) {\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return -1;\n    }\n    function norm(a4, y4, c6, l, h, f) {\n      if (typeof c6 === \"function\") {\n        return f(a4, y4, c6, l === void 0 ? 0 : l | 0, h === void 0 ? a4.length - 1 : h | 0);\n      }\n      return f(a4, y4, void 0, c6 === void 0 ? 0 : c6 | 0, l === void 0 ? a4.length - 1 : l | 0);\n    }\n    module.exports = {\n      ge: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, ge);\n      },\n      gt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, gt);\n      },\n      lt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, lt);\n      },\n      le: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, le);\n      },\n      eq: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, eq);\n      }\n    };\n  }\n});\n\n// node_modules/interval-tree-1d/interval-tree.js\nvar require_interval_tree = __commonJS({\n  \"node_modules/interval-tree-1d/interval-tree.js\"(exports, module) {\n    \"use strict\";\n    var bounds = require_search_bounds();\n    var NOT_FOUND = 0;\n    var SUCCESS = 1;\n    var EMPTY = 2;\n    module.exports = createWrapper;\n    function IntervalTreeNode(mid3, left2, right2, leftPoints, rightPoints) {\n      this.mid = mid3;\n      this.left = left2;\n      this.right = right2;\n      this.leftPoints = leftPoints;\n      this.rightPoints = rightPoints;\n      this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;\n    }\n    var proto = IntervalTreeNode.prototype;\n    function copy3(a4, b) {\n      a4.mid = b.mid;\n      a4.left = b.left;\n      a4.right = b.right;\n      a4.leftPoints = b.leftPoints;\n      a4.rightPoints = b.rightPoints;\n      a4.count = b.count;\n    }\n    function rebuild(node, intervals) {\n      var ntree = createIntervalTree(intervals);\n      node.mid = ntree.mid;\n      node.left = ntree.left;\n      node.right = ntree.right;\n      node.leftPoints = ntree.leftPoints;\n      node.rightPoints = ntree.rightPoints;\n      node.count = ntree.count;\n    }\n    function rebuildWithInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      intervals.push(interval2);\n      rebuild(node, intervals);\n    }\n    function rebuildWithoutInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      var idx = intervals.indexOf(interval2);\n      if (idx < 0) {\n        return NOT_FOUND;\n      }\n      intervals.splice(idx, 1);\n      rebuild(node, intervals);\n      return SUCCESS;\n    }\n    proto.intervals = function(result) {\n      result.push.apply(result, this.leftPoints);\n      if (this.left) {\n        this.left.intervals(result);\n      }\n      if (this.right) {\n        this.right.intervals(result);\n      }\n      return result;\n    };\n    proto.insert = function(interval2) {\n      var weight = this.count - this.leftPoints.length;\n      this.count += 1;\n      if (interval2[1] < this.mid) {\n        if (this.left) {\n          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.left.insert(interval2);\n          }\n        } else {\n          this.left = createIntervalTree([interval2]);\n        }\n      } else if (interval2[0] > this.mid) {\n        if (this.right) {\n          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.right.insert(interval2);\n          }\n        } else {\n          this.right = createIntervalTree([interval2]);\n        }\n      } else {\n        var l = bounds.ge(this.leftPoints, interval2, compareBegin);\n        var r = bounds.ge(this.rightPoints, interval2, compareEnd);\n        this.leftPoints.splice(l, 0, interval2);\n        this.rightPoints.splice(r, 0, interval2);\n      }\n    };\n    proto.remove = function(interval2) {\n      var weight = this.count - this.leftPoints;\n      if (interval2[1] < this.mid) {\n        if (!this.left) {\n          return NOT_FOUND;\n        }\n        var rw = this.right ? this.right.count : 0;\n        if (4 * rw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.left.remove(interval2);\n        if (r === EMPTY) {\n          this.left = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else if (interval2[0] > this.mid) {\n        if (!this.right) {\n          return NOT_FOUND;\n        }\n        var lw = this.left ? this.left.count : 0;\n        if (4 * lw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.right.remove(interval2);\n        if (r === EMPTY) {\n          this.right = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else {\n        if (this.count === 1) {\n          if (this.leftPoints[0] === interval2) {\n            return EMPTY;\n          } else {\n            return NOT_FOUND;\n          }\n        }\n        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {\n          if (this.left && this.right) {\n            var p = this;\n            var n = this.left;\n            while (n.right) {\n              p = n;\n              n = n.right;\n            }\n            if (p === this) {\n              n.right = this.right;\n            } else {\n              var l = this.left;\n              var r = this.right;\n              p.count -= n.count;\n              p.right = n.left;\n              n.left = l;\n              n.right = r;\n            }\n            copy3(this, n);\n            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\n          } else if (this.left) {\n            copy3(this, this.left);\n          } else {\n            copy3(this, this.right);\n          }\n          return SUCCESS;\n        }\n        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {\n          if (this.leftPoints[l][0] !== interval2[0]) {\n            break;\n          }\n          if (this.leftPoints[l] === interval2) {\n            this.count -= 1;\n            this.leftPoints.splice(l, 1);\n            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {\n              if (this.rightPoints[r][1] !== interval2[1]) {\n                break;\n              } else if (this.rightPoints[r] === interval2) {\n                this.rightPoints.splice(r, 1);\n                return SUCCESS;\n              }\n            }\n          }\n        }\n        return NOT_FOUND;\n      }\n    };\n    function reportLeftRange(arr, hi, cb) {\n      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRightRange(arr, lo, cb) {\n      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRange(arr, cb) {\n      for (var i = 0; i < arr.length; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    proto.queryPoint = function(x4, cb) {\n      if (x4 < this.mid) {\n        if (this.left) {\n          var r = this.left.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportLeftRange(this.leftPoints, x4, cb);\n      } else if (x4 > this.mid) {\n        if (this.right) {\n          var r = this.right.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportRightRange(this.rightPoints, x4, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    proto.queryInterval = function(lo, hi, cb) {\n      if (lo < this.mid && this.left) {\n        var r = this.left.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi > this.mid && this.right) {\n        var r = this.right.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi < this.mid) {\n        return reportLeftRange(this.leftPoints, hi, cb);\n      } else if (lo > this.mid) {\n        return reportRightRange(this.rightPoints, lo, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    function compareNumbers(a4, b) {\n      return a4 - b;\n    }\n    function compareBegin(a4, b) {\n      var d = a4[0] - b[0];\n      if (d) {\n        return d;\n      }\n      return a4[1] - b[1];\n    }\n    function compareEnd(a4, b) {\n      var d = a4[1] - b[1];\n      if (d) {\n        return d;\n      }\n      return a4[0] - b[0];\n    }\n    function createIntervalTree(intervals) {\n      if (intervals.length === 0) {\n        return null;\n      }\n      var pts = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        pts.push(intervals[i][0], intervals[i][1]);\n      }\n      pts.sort(compareNumbers);\n      var mid3 = pts[pts.length >> 1];\n      var leftIntervals = [];\n      var rightIntervals = [];\n      var centerIntervals = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        var s2 = intervals[i];\n        if (s2[1] < mid3) {\n          leftIntervals.push(s2);\n        } else if (mid3 < s2[0]) {\n          rightIntervals.push(s2);\n        } else {\n          centerIntervals.push(s2);\n        }\n      }\n      var leftPoints = centerIntervals;\n      var rightPoints = centerIntervals.slice();\n      leftPoints.sort(compareBegin);\n      rightPoints.sort(compareEnd);\n      return new IntervalTreeNode(\n        mid3,\n        createIntervalTree(leftIntervals),\n        createIntervalTree(rightIntervals),\n        leftPoints,\n        rightPoints\n      );\n    }\n    function IntervalTree2(root3) {\n      this.root = root3;\n    }\n    var tproto = IntervalTree2.prototype;\n    tproto.insert = function(interval2) {\n      if (this.root) {\n        this.root.insert(interval2);\n      } else {\n        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);\n      }\n    };\n    tproto.remove = function(interval2) {\n      if (this.root) {\n        var r = this.root.remove(interval2);\n        if (r === EMPTY) {\n          this.root = null;\n        }\n        return r !== NOT_FOUND;\n      }\n      return false;\n    };\n    tproto.queryPoint = function(p, cb) {\n      if (this.root) {\n        return this.root.queryPoint(p, cb);\n      }\n    };\n    tproto.queryInterval = function(lo, hi, cb) {\n      if (lo <= hi && this.root) {\n        return this.root.queryInterval(lo, hi, cb);\n      }\n    };\n    Object.defineProperty(tproto, \"count\", {\n      get: function() {\n        if (this.root) {\n          return this.root.count;\n        }\n        return 0;\n      }\n    });\n    Object.defineProperty(tproto, \"intervals\", {\n      get: function() {\n        if (this.root) {\n          return this.root.intervals([]);\n        }\n        return [];\n      }\n    });\n    function createWrapper(intervals) {\n      if (!intervals || intervals.length === 0) {\n        return new IntervalTree2(null);\n      }\n      return new IntervalTree2(createIntervalTree(intervals));\n    }\n  }\n});\n\n// node_modules/@observablehq/plot/dist/index.js\nvar dist_exports = {};\n__export(dist_exports, {\n  Area: () => Area,\n  Arrow: () => Arrow,\n  BarX: () => BarX,\n  BarY: () => BarY,\n  Cell: () => Cell,\n  Contour: () => Contour,\n  Density: () => Density,\n  Dot: () => Dot,\n  Frame: () => Frame,\n  Geo: () => Geo,\n  Hexgrid: () => Hexgrid,\n  Image: () => Image2,\n  Line: () => Line,\n  Link: () => Link,\n  Mark: () => Mark,\n  Raster: () => Raster,\n  Rect: () => Rect,\n  RuleX: () => RuleX,\n  RuleY: () => RuleY,\n  Text: () => Text,\n  TickX: () => TickX,\n  TickY: () => TickY,\n  Vector: () => Vector,\n  area: () => area,\n  areaX: () => areaX,\n  areaY: () => areaY,\n  arrow: () => arrow,\n  auto: () => auto,\n  autoSpec: () => autoSpec,\n  axisFx: () => axisFx,\n  axisFy: () => axisFy,\n  axisX: () => axisX,\n  axisY: () => axisY,\n  barX: () => barX,\n  barY: () => barY,\n  bin: () => bin2,\n  binX: () => binX,\n  binY: () => binY,\n  boxX: () => boxX,\n  boxY: () => boxY,\n  cell: () => cell,\n  cellX: () => cellX,\n  cellY: () => cellY,\n  centroid: () => centroid,\n  circle: () => circle,\n  cluster: () => cluster,\n  column: () => column,\n  contour: () => contour,\n  delaunayLink: () => delaunayLink,\n  delaunayMesh: () => delaunayMesh,\n  density: () => density,\n  dodgeX: () => dodgeX,\n  dodgeY: () => dodgeY,\n  dot: () => dot,\n  dotX: () => dotX,\n  dotY: () => dotY,\n  filter: () => filter3,\n  formatIsoDate: () => formatIsoDate,\n  formatMonth: () => formatMonth,\n  formatWeekday: () => formatWeekday,\n  frame: () => frame2,\n  geo: () => geo,\n  geoCentroid: () => geoCentroid,\n  graticule: () => graticule2,\n  gridFx: () => gridFx,\n  gridFy: () => gridFy,\n  gridX: () => gridX,\n  gridY: () => gridY,\n  group: () => group2,\n  groupX: () => groupX,\n  groupY: () => groupY,\n  groupZ: () => groupZ,\n  hexagon: () => hexagon,\n  hexbin: () => hexbin,\n  hexgrid: () => hexgrid,\n  hull: () => hull,\n  identity: () => identity6,\n  image: () => image,\n  initializer: () => initializer,\n  interpolateNearest: () => interpolateNearest,\n  interpolateNone: () => interpolateNone,\n  interpolatorBarycentric: () => interpolatorBarycentric,\n  interpolatorRandomWalk: () => interpolatorRandomWalk,\n  legend: () => legend,\n  line: () => line,\n  lineX: () => lineX,\n  lineY: () => lineY,\n  linearRegressionX: () => linearRegressionX,\n  linearRegressionY: () => linearRegressionY,\n  link: () => link3,\n  map: () => map5,\n  mapX: () => mapX,\n  mapY: () => mapY,\n  marks: () => marks,\n  normalize: () => normalize3,\n  normalizeX: () => normalizeX,\n  normalizeY: () => normalizeY,\n  plot: () => plot,\n  raster: () => raster,\n  rect: () => rect,\n  rectX: () => rectX,\n  rectY: () => rectY,\n  reverse: () => reverse2,\n  ruleX: () => ruleX,\n  ruleY: () => ruleY,\n  scale: () => scale2,\n  select: () => select,\n  selectFirst: () => selectFirst,\n  selectLast: () => selectLast,\n  selectMaxX: () => selectMaxX,\n  selectMaxY: () => selectMaxY,\n  selectMinX: () => selectMinX,\n  selectMinY: () => selectMinY,\n  shuffle: () => shuffle2,\n  sort: () => sort2,\n  sphere: () => sphere,\n  spike: () => spike,\n  stackX: () => stackX,\n  stackX1: () => stackX1,\n  stackX2: () => stackX2,\n  stackY: () => stackY,\n  stackY1: () => stackY1,\n  stackY2: () => stackY2,\n  text: () => text,\n  textX: () => textX,\n  textY: () => textY,\n  tickX: () => tickX,\n  tickY: () => tickY,\n  transform: () => basic,\n  tree: () => tree,\n  treeLink: () => treeLink,\n  treeNode: () => treeNode,\n  valueof: () => valueof,\n  vector: () => vector,\n  vectorX: () => vectorX,\n  vectorY: () => vectorY,\n  voronoi: () => voronoi,\n  voronoiMesh: () => voronoiMesh,\n  window: () => window2,\n  windowX: () => windowX,\n  windowY: () => windowY\n});\n\n// node_modules/d3/src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  Adder: () => Adder,\n  Delaunay: () => Delaunay,\n  FormatSpecifier: () => FormatSpecifier,\n  InternMap: () => InternMap,\n  InternSet: () => InternSet,\n  Node: () => Node2,\n  Path: () => Path,\n  Voronoi: () => Voronoi,\n  ZoomTransform: () => Transform,\n  active: () => active_default,\n  arc: () => arc_default,\n  area: () => area_default5,\n  areaRadial: () => areaRadial_default,\n  ascending: () => ascending,\n  autoType: () => autoType,\n  axisBottom: () => axisBottom,\n  axisLeft: () => axisLeft,\n  axisRight: () => axisRight,\n  axisTop: () => axisTop,\n  bin: () => bin,\n  bisect: () => bisect_default,\n  bisectCenter: () => bisectCenter,\n  bisectLeft: () => bisectLeft,\n  bisectRight: () => bisectRight,\n  bisector: () => bisector,\n  blob: () => blob_default,\n  blur: () => blur,\n  blur2: () => blur2,\n  blurImage: () => blurImage,\n  brush: () => brush_default,\n  brushSelection: () => brushSelection,\n  brushX: () => brushX,\n  brushY: () => brushY,\n  buffer: () => buffer_default,\n  chord: () => chord_default,\n  chordDirected: () => chordDirected,\n  chordTranspose: () => chordTranspose,\n  cluster: () => cluster_default,\n  color: () => color,\n  contourDensity: () => density_default,\n  contours: () => contours_default,\n  count: () => count,\n  create: () => create_default,\n  creator: () => creator_default,\n  cross: () => cross,\n  csv: () => csv2,\n  csvFormat: () => csvFormat,\n  csvFormatBody: () => csvFormatBody,\n  csvFormatRow: () => csvFormatRow,\n  csvFormatRows: () => csvFormatRows,\n  csvFormatValue: () => csvFormatValue,\n  csvParse: () => csvParse,\n  csvParseRows: () => csvParseRows,\n  cubehelix: () => cubehelix,\n  cumsum: () => cumsum,\n  curveBasis: () => basis_default2,\n  curveBasisClosed: () => basisClosed_default2,\n  curveBasisOpen: () => basisOpen_default,\n  curveBumpX: () => bumpX,\n  curveBumpY: () => bumpY,\n  curveBundle: () => bundle_default,\n  curveCardinal: () => cardinal_default,\n  curveCardinalClosed: () => cardinalClosed_default,\n  curveCardinalOpen: () => cardinalOpen_default,\n  curveCatmullRom: () => catmullRom_default,\n  curveCatmullRomClosed: () => catmullRomClosed_default,\n  curveCatmullRomOpen: () => catmullRomOpen_default,\n  curveLinear: () => linear_default,\n  curveLinearClosed: () => linearClosed_default,\n  curveMonotoneX: () => monotoneX,\n  curveMonotoneY: () => monotoneY,\n  curveNatural: () => natural_default,\n  curveStep: () => step_default,\n  curveStepAfter: () => stepAfter,\n  curveStepBefore: () => stepBefore,\n  descending: () => descending,\n  deviation: () => deviation,\n  difference: () => difference,\n  disjoint: () => disjoint,\n  dispatch: () => dispatch_default,\n  drag: () => drag_default,\n  dragDisable: () => nodrag_default,\n  dragEnable: () => yesdrag,\n  dsv: () => dsv,\n  dsvFormat: () => dsv_default,\n  easeBack: () => backInOut,\n  easeBackIn: () => backIn,\n  easeBackInOut: () => backInOut,\n  easeBackOut: () => backOut,\n  easeBounce: () => bounceOut,\n  easeBounceIn: () => bounceIn,\n  easeBounceInOut: () => bounceInOut,\n  easeBounceOut: () => bounceOut,\n  easeCircle: () => circleInOut,\n  easeCircleIn: () => circleIn,\n  easeCircleInOut: () => circleInOut,\n  easeCircleOut: () => circleOut,\n  easeCubic: () => cubicInOut,\n  easeCubicIn: () => cubicIn,\n  easeCubicInOut: () => cubicInOut,\n  easeCubicOut: () => cubicOut,\n  easeElastic: () => elasticOut,\n  easeElasticIn: () => elasticIn,\n  easeElasticInOut: () => elasticInOut,\n  easeElasticOut: () => elasticOut,\n  easeExp: () => expInOut,\n  easeExpIn: () => expIn,\n  easeExpInOut: () => expInOut,\n  easeExpOut: () => expOut,\n  easeLinear: () => linear2,\n  easePoly: () => polyInOut,\n  easePolyIn: () => polyIn,\n  easePolyInOut: () => polyInOut,\n  easePolyOut: () => polyOut,\n  easeQuad: () => quadInOut,\n  easeQuadIn: () => quadIn,\n  easeQuadInOut: () => quadInOut,\n  easeQuadOut: () => quadOut,\n  easeSin: () => sinInOut,\n  easeSinIn: () => sinIn,\n  easeSinInOut: () => sinInOut,\n  easeSinOut: () => sinOut,\n  every: () => every,\n  extent: () => extent,\n  fcumsum: () => fcumsum,\n  filter: () => filter,\n  flatGroup: () => flatGroup,\n  flatRollup: () => flatRollup,\n  forceCenter: () => center_default,\n  forceCollide: () => collide_default,\n  forceLink: () => link_default,\n  forceManyBody: () => manyBody_default,\n  forceRadial: () => radial_default,\n  forceSimulation: () => simulation_default,\n  forceX: () => x_default2,\n  forceY: () => y_default2,\n  format: () => format,\n  formatDefaultLocale: () => defaultLocale,\n  formatLocale: () => locale_default,\n  formatPrefix: () => formatPrefix,\n  formatSpecifier: () => formatSpecifier,\n  fsum: () => fsum,\n  geoAlbers: () => albers_default,\n  geoAlbersUsa: () => albersUsa_default,\n  geoArea: () => area_default2,\n  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,\n  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,\n  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,\n  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,\n  geoBounds: () => bounds_default,\n  geoCentroid: () => centroid_default,\n  geoCircle: () => circle_default,\n  geoClipAntimeridian: () => antimeridian_default,\n  geoClipCircle: () => circle_default2,\n  geoClipExtent: () => extent_default2,\n  geoClipRectangle: () => clipRectangle,\n  geoConicConformal: () => conicConformal_default,\n  geoConicConformalRaw: () => conicConformalRaw,\n  geoConicEqualArea: () => conicEqualArea_default,\n  geoConicEqualAreaRaw: () => conicEqualAreaRaw,\n  geoConicEquidistant: () => conicEquidistant_default,\n  geoConicEquidistantRaw: () => conicEquidistantRaw,\n  geoContains: () => contains_default2,\n  geoDistance: () => distance_default,\n  geoEqualEarth: () => equalEarth_default,\n  geoEqualEarthRaw: () => equalEarthRaw,\n  geoEquirectangular: () => equirectangular_default,\n  geoEquirectangularRaw: () => equirectangularRaw,\n  geoGnomonic: () => gnomonic_default,\n  geoGnomonicRaw: () => gnomonicRaw,\n  geoGraticule: () => graticule,\n  geoGraticule10: () => graticule10,\n  geoIdentity: () => identity_default4,\n  geoInterpolate: () => interpolate_default2,\n  geoLength: () => length_default,\n  geoMercator: () => mercator_default,\n  geoMercatorRaw: () => mercatorRaw,\n  geoNaturalEarth1: () => naturalEarth1_default,\n  geoNaturalEarth1Raw: () => naturalEarth1Raw,\n  geoOrthographic: () => orthographic_default,\n  geoOrthographicRaw: () => orthographicRaw,\n  geoPath: () => path_default,\n  geoProjection: () => projection,\n  geoProjectionMutator: () => projectionMutator,\n  geoRotation: () => rotation_default,\n  geoStereographic: () => stereographic_default,\n  geoStereographicRaw: () => stereographicRaw,\n  geoStream: () => stream_default,\n  geoTransform: () => transform_default,\n  geoTransverseMercator: () => transverseMercator_default,\n  geoTransverseMercatorRaw: () => transverseMercatorRaw,\n  gray: () => gray,\n  greatest: () => greatest,\n  greatestIndex: () => greatestIndex,\n  group: () => group,\n  groupSort: () => groupSort,\n  groups: () => groups,\n  hcl: () => hcl,\n  hierarchy: () => hierarchy,\n  histogram: () => bin,\n  hsl: () => hsl,\n  html: () => html,\n  image: () => image_default,\n  index: () => index,\n  indexes: () => indexes,\n  interpolate: () => value_default,\n  interpolateArray: () => array_default,\n  interpolateBasis: () => basis_default,\n  interpolateBasisClosed: () => basisClosed_default,\n  interpolateBlues: () => Blues_default,\n  interpolateBrBG: () => BrBG_default,\n  interpolateBuGn: () => BuGn_default,\n  interpolateBuPu: () => BuPu_default,\n  interpolateCividis: () => cividis_default,\n  interpolateCool: () => cool,\n  interpolateCubehelix: () => cubehelix_default,\n  interpolateCubehelixDefault: () => cubehelix_default2,\n  interpolateCubehelixLong: () => cubehelixLong,\n  interpolateDate: () => date_default,\n  interpolateDiscrete: () => discrete_default,\n  interpolateGnBu: () => GnBu_default,\n  interpolateGreens: () => Greens_default,\n  interpolateGreys: () => Greys_default,\n  interpolateHcl: () => hcl_default,\n  interpolateHclLong: () => hclLong,\n  interpolateHsl: () => hsl_default,\n  interpolateHslLong: () => hslLong,\n  interpolateHue: () => hue_default,\n  interpolateInferno: () => inferno,\n  interpolateLab: () => lab2,\n  interpolateMagma: () => magma,\n  interpolateNumber: () => number_default,\n  interpolateNumberArray: () => numberArray_default,\n  interpolateObject: () => object_default,\n  interpolateOrRd: () => OrRd_default,\n  interpolateOranges: () => Oranges_default,\n  interpolatePRGn: () => PRGn_default,\n  interpolatePiYG: () => PiYG_default,\n  interpolatePlasma: () => plasma,\n  interpolatePuBu: () => PuBu_default,\n  interpolatePuBuGn: () => PuBuGn_default,\n  interpolatePuOr: () => PuOr_default,\n  interpolatePuRd: () => PuRd_default,\n  interpolatePurples: () => Purples_default,\n  interpolateRainbow: () => rainbow_default,\n  interpolateRdBu: () => RdBu_default,\n  interpolateRdGy: () => RdGy_default,\n  interpolateRdPu: () => RdPu_default,\n  interpolateRdYlBu: () => RdYlBu_default,\n  interpolateRdYlGn: () => RdYlGn_default,\n  interpolateReds: () => Reds_default,\n  interpolateRgb: () => rgb_default,\n  interpolateRgbBasis: () => rgbBasis,\n  interpolateRgbBasisClosed: () => rgbBasisClosed,\n  interpolateRound: () => round_default,\n  interpolateSinebow: () => sinebow_default,\n  interpolateSpectral: () => Spectral_default,\n  interpolateString: () => string_default,\n  interpolateTransformCss: () => interpolateTransformCss,\n  interpolateTransformSvg: () => interpolateTransformSvg,\n  interpolateTurbo: () => turbo_default,\n  interpolateViridis: () => viridis_default,\n  interpolateWarm: () => warm,\n  interpolateYlGn: () => YlGn_default,\n  interpolateYlGnBu: () => YlGnBu_default,\n  interpolateYlOrBr: () => YlOrBr_default,\n  interpolateYlOrRd: () => YlOrRd_default,\n  interpolateZoom: () => zoom_default,\n  interrupt: () => interrupt_default,\n  intersection: () => intersection,\n  interval: () => interval_default,\n  isoFormat: () => isoFormat_default,\n  isoParse: () => isoParse_default,\n  json: () => json_default,\n  lab: () => lab,\n  lch: () => lch,\n  least: () => least,\n  leastIndex: () => leastIndex,\n  line: () => line_default2,\n  lineRadial: () => lineRadial_default,\n  link: () => link2,\n  linkHorizontal: () => linkHorizontal,\n  linkRadial: () => linkRadial,\n  linkVertical: () => linkVertical,\n  local: () => local,\n  map: () => map2,\n  matcher: () => matcher_default,\n  max: () => max,\n  maxIndex: () => maxIndex,\n  mean: () => mean,\n  median: () => median,\n  medianIndex: () => medianIndex,\n  merge: () => merge,\n  min: () => min,\n  minIndex: () => minIndex,\n  mode: () => mode,\n  namespace: () => namespace_default,\n  namespaces: () => namespaces_default,\n  nice: () => nice,\n  now: () => now,\n  pack: () => pack_default,\n  packEnclose: () => enclose_default,\n  packSiblings: () => siblings_default,\n  pairs: () => pairs,\n  partition: () => partition_default,\n  path: () => path,\n  pathRound: () => pathRound,\n  permute: () => permute,\n  pie: () => pie_default,\n  piecewise: () => piecewise,\n  pointRadial: () => pointRadial_default,\n  pointer: () => pointer_default,\n  pointers: () => pointers_default,\n  polygonArea: () => area_default4,\n  polygonCentroid: () => centroid_default3,\n  polygonContains: () => contains_default3,\n  polygonHull: () => hull_default,\n  polygonLength: () => length_default2,\n  precisionFixed: () => precisionFixed_default,\n  precisionPrefix: () => precisionPrefix_default,\n  precisionRound: () => precisionRound_default,\n  quadtree: () => quadtree,\n  quantile: () => quantile,\n  quantileIndex: () => quantileIndex,\n  quantileSorted: () => quantileSorted,\n  quantize: () => quantize_default,\n  quickselect: () => quickselect,\n  radialArea: () => areaRadial_default,\n  radialLine: () => lineRadial_default,\n  randomBates: () => bates_default,\n  randomBernoulli: () => bernoulli_default,\n  randomBeta: () => beta_default,\n  randomBinomial: () => binomial_default,\n  randomCauchy: () => cauchy_default,\n  randomExponential: () => exponential_default,\n  randomGamma: () => gamma_default,\n  randomGeometric: () => geometric_default,\n  randomInt: () => int_default,\n  randomIrwinHall: () => irwinHall_default,\n  randomLcg: () => lcg,\n  randomLogNormal: () => logNormal_default,\n  randomLogistic: () => logistic_default,\n  randomNormal: () => normal_default,\n  randomPareto: () => pareto_default,\n  randomPoisson: () => poisson_default,\n  randomUniform: () => uniform_default,\n  randomWeibull: () => weibull_default,\n  range: () => range,\n  rank: () => rank,\n  reduce: () => reduce,\n  reverse: () => reverse,\n  rgb: () => rgb,\n  ribbon: () => ribbon_default,\n  ribbonArrow: () => ribbonArrow,\n  rollup: () => rollup,\n  rollups: () => rollups,\n  scaleBand: () => band,\n  scaleDiverging: () => diverging,\n  scaleDivergingLog: () => divergingLog,\n  scaleDivergingPow: () => divergingPow,\n  scaleDivergingSqrt: () => divergingSqrt,\n  scaleDivergingSymlog: () => divergingSymlog,\n  scaleIdentity: () => identity4,\n  scaleImplicit: () => implicit,\n  scaleLinear: () => linear3,\n  scaleLog: () => log2,\n  scaleOrdinal: () => ordinal,\n  scalePoint: () => point,\n  scalePow: () => pow3,\n  scaleQuantile: () => quantile2,\n  scaleQuantize: () => quantize,\n  scaleRadial: () => radial,\n  scaleSequential: () => sequential,\n  scaleSequentialLog: () => sequentialLog,\n  scaleSequentialPow: () => sequentialPow,\n  scaleSequentialQuantile: () => sequentialQuantile,\n  scaleSequentialSqrt: () => sequentialSqrt,\n  scaleSequentialSymlog: () => sequentialSymlog,\n  scaleSqrt: () => sqrt2,\n  scaleSymlog: () => symlog,\n  scaleThreshold: () => threshold,\n  scaleTime: () => time,\n  scaleUtc: () => utcTime,\n  scan: () => scan,\n  schemeAccent: () => Accent_default,\n  schemeBlues: () => scheme22,\n  schemeBrBG: () => scheme,\n  schemeBuGn: () => scheme10,\n  schemeBuPu: () => scheme11,\n  schemeCategory10: () => category10_default,\n  schemeDark2: () => Dark2_default,\n  schemeGnBu: () => scheme12,\n  schemeGreens: () => scheme23,\n  schemeGreys: () => scheme24,\n  schemeOrRd: () => scheme13,\n  schemeOranges: () => scheme27,\n  schemePRGn: () => scheme2,\n  schemePaired: () => Paired_default,\n  schemePastel1: () => Pastel1_default,\n  schemePastel2: () => Pastel2_default,\n  schemePiYG: () => scheme3,\n  schemePuBu: () => scheme15,\n  schemePuBuGn: () => scheme14,\n  schemePuOr: () => scheme4,\n  schemePuRd: () => scheme16,\n  schemePurples: () => scheme25,\n  schemeRdBu: () => scheme5,\n  schemeRdGy: () => scheme6,\n  schemeRdPu: () => scheme17,\n  schemeRdYlBu: () => scheme7,\n  schemeRdYlGn: () => scheme8,\n  schemeReds: () => scheme26,\n  schemeSet1: () => Set1_default,\n  schemeSet2: () => Set2_default,\n  schemeSet3: () => Set3_default,\n  schemeSpectral: () => scheme9,\n  schemeTableau10: () => Tableau10_default,\n  schemeYlGn: () => scheme19,\n  schemeYlGnBu: () => scheme18,\n  schemeYlOrBr: () => scheme20,\n  schemeYlOrRd: () => scheme21,\n  select: () => select_default2,\n  selectAll: () => selectAll_default2,\n  selection: () => selection_default,\n  selector: () => selector_default,\n  selectorAll: () => selectorAll_default,\n  shuffle: () => shuffle_default,\n  shuffler: () => shuffler,\n  some: () => some,\n  sort: () => sort,\n  stack: () => stack_default,\n  stackOffsetDiverging: () => diverging_default,\n  stackOffsetExpand: () => expand_default,\n  stackOffsetNone: () => none_default,\n  stackOffsetSilhouette: () => silhouette_default,\n  stackOffsetWiggle: () => wiggle_default,\n  stackOrderAppearance: () => appearance_default,\n  stackOrderAscending: () => ascending_default2,\n  stackOrderDescending: () => descending_default2,\n  stackOrderInsideOut: () => insideOut_default,\n  stackOrderNone: () => none_default2,\n  stackOrderReverse: () => reverse_default,\n  stratify: () => stratify_default,\n  style: () => styleValue,\n  subset: () => subset,\n  sum: () => sum,\n  superset: () => superset,\n  svg: () => svg,\n  symbol: () => Symbol2,\n  symbolAsterisk: () => asterisk_default,\n  symbolCircle: () => circle_default3,\n  symbolCross: () => cross_default2,\n  symbolDiamond: () => diamond_default,\n  symbolDiamond2: () => diamond2_default,\n  symbolPlus: () => plus_default,\n  symbolSquare: () => square_default,\n  symbolSquare2: () => square2_default,\n  symbolStar: () => star_default,\n  symbolTimes: () => times_default,\n  symbolTriangle: () => triangle_default,\n  symbolTriangle2: () => triangle2_default,\n  symbolWye: () => wye_default,\n  symbolX: () => times_default,\n  symbols: () => symbolsFill,\n  symbolsFill: () => symbolsFill,\n  symbolsStroke: () => symbolsStroke,\n  text: () => text_default3,\n  thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,\n  thresholdScott: () => thresholdScott,\n  thresholdSturges: () => thresholdSturges,\n  tickFormat: () => tickFormat,\n  tickIncrement: () => tickIncrement,\n  tickStep: () => tickStep,\n  ticks: () => ticks,\n  timeDay: () => timeDay,\n  timeDays: () => timeDays,\n  timeFormat: () => timeFormat,\n  timeFormatDefaultLocale: () => defaultLocale2,\n  timeFormatLocale: () => formatLocale,\n  timeFriday: () => timeFriday,\n  timeFridays: () => timeFridays,\n  timeHour: () => timeHour,\n  timeHours: () => timeHours,\n  timeInterval: () => timeInterval,\n  timeMillisecond: () => millisecond,\n  timeMilliseconds: () => milliseconds,\n  timeMinute: () => timeMinute,\n  timeMinutes: () => timeMinutes,\n  timeMonday: () => timeMonday,\n  timeMondays: () => timeMondays,\n  timeMonth: () => timeMonth,\n  timeMonths: () => timeMonths,\n  timeParse: () => timeParse,\n  timeSaturday: () => timeSaturday,\n  timeSaturdays: () => timeSaturdays,\n  timeSecond: () => second,\n  timeSeconds: () => seconds,\n  timeSunday: () => timeSunday,\n  timeSundays: () => timeSundays,\n  timeThursday: () => timeThursday,\n  timeThursdays: () => timeThursdays,\n  timeTickInterval: () => timeTickInterval,\n  timeTicks: () => timeTicks,\n  timeTuesday: () => timeTuesday,\n  timeTuesdays: () => timeTuesdays,\n  timeWednesday: () => timeWednesday,\n  timeWednesdays: () => timeWednesdays,\n  timeWeek: () => timeSunday,\n  timeWeeks: () => timeSundays,\n  timeYear: () => timeYear,\n  timeYears: () => timeYears,\n  timeout: () => timeout_default,\n  timer: () => timer,\n  timerFlush: () => timerFlush,\n  transition: () => transition,\n  transpose: () => transpose,\n  tree: () => tree_default,\n  treemap: () => treemap_default,\n  treemapBinary: () => binary_default,\n  treemapDice: () => dice_default,\n  treemapResquarify: () => resquarify_default,\n  treemapSlice: () => slice_default,\n  treemapSliceDice: () => sliceDice_default,\n  treemapSquarify: () => squarify_default,\n  tsv: () => tsv2,\n  tsvFormat: () => tsvFormat,\n  tsvFormatBody: () => tsvFormatBody,\n  tsvFormatRow: () => tsvFormatRow,\n  tsvFormatRows: () => tsvFormatRows,\n  tsvFormatValue: () => tsvFormatValue,\n  tsvParse: () => tsvParse,\n  tsvParseRows: () => tsvParseRows,\n  union: () => union,\n  unixDay: () => unixDay,\n  unixDays: () => unixDays,\n  utcDay: () => utcDay,\n  utcDays: () => utcDays,\n  utcFormat: () => utcFormat,\n  utcFriday: () => utcFriday,\n  utcFridays: () => utcFridays,\n  utcHour: () => utcHour,\n  utcHours: () => utcHours,\n  utcMillisecond: () => millisecond,\n  utcMilliseconds: () => milliseconds,\n  utcMinute: () => utcMinute,\n  utcMinutes: () => utcMinutes,\n  utcMonday: () => utcMonday,\n  utcMondays: () => utcMondays,\n  utcMonth: () => utcMonth,\n  utcMonths: () => utcMonths,\n  utcParse: () => utcParse,\n  utcSaturday: () => utcSaturday,\n  utcSaturdays: () => utcSaturdays,\n  utcSecond: () => second,\n  utcSeconds: () => seconds,\n  utcSunday: () => utcSunday,\n  utcSundays: () => utcSundays,\n  utcThursday: () => utcThursday,\n  utcThursdays: () => utcThursdays,\n  utcTickInterval: () => utcTickInterval,\n  utcTicks: () => utcTicks,\n  utcTuesday: () => utcTuesday,\n  utcTuesdays: () => utcTuesdays,\n  utcWednesday: () => utcWednesday,\n  utcWednesdays: () => utcWednesdays,\n  utcWeek: () => utcSunday,\n  utcWeeks: () => utcSundays,\n  utcYear: () => utcYear,\n  utcYears: () => utcYears,\n  variance: () => variance,\n  window: () => window_default,\n  xml: () => xml_default,\n  zip: () => zip,\n  zoom: () => zoom_default2,\n  zoomIdentity: () => identity5,\n  zoomTransform: () => transform\n});\n\n// node_modules/d3-array/src/ascending.js\nfunction ascending(a4, b) {\n  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/descending.js\nfunction descending(a4, b) {\n  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/bisector.js\nfunction bisector(f) {\n  let compare1, compare2, delta;\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x4) => ascending(f(d), x4);\n    delta = (d, x4) => f(d) - x4;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n  function left2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) < 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function right2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) <= 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function center2(a4, x4, lo = 0, hi = a4.length) {\n    const i = left2(a4, x4, lo, hi - 1);\n    return i > lo && delta(a4[i - 1], x4) > -delta(a4[i], x4) ? i - 1 : i;\n  }\n  return { left: left2, center: center2, right: right2 };\n}\nfunction zero() {\n  return 0;\n}\n\n// node_modules/d3-array/src/number.js\nfunction number(x4) {\n  return x4 === null ? NaN : +x4;\n}\nfunction* numbers(values2, valueof2) {\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n\n// node_modules/d3-array/src/bisect.js\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\nvar bisectCenter = bisector(number).center;\nvar bisect_default = bisectRight;\n\n// node_modules/d3-array/src/blur.js\nfunction blur(values2, r) {\n  if (!((r = +r) >= 0))\n    throw new RangeError(\"invalid r\");\n  let length4 = values2.length;\n  if (!((length4 = Math.floor(length4)) >= 0))\n    throw new RangeError(\"invalid length\");\n  if (!length4 || !r)\n    return values2;\n  const blur3 = blurf(r);\n  const temp = values2.slice();\n  blur3(values2, temp, 0, length4, 1);\n  blur3(temp, values2, 0, length4, 1);\n  blur3(values2, temp, 0, length4, 1);\n  return values2;\n}\nvar blur2 = Blur2(blurf);\nvar blurImage = Blur2(blurfImage);\nfunction Blur2(blur3) {\n  return function(data, rx, ry = rx) {\n    if (!((rx = +rx) >= 0))\n      throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0))\n      throw new RangeError(\"invalid ry\");\n    let { data: values2, width, height } = data;\n    if (!((width = Math.floor(width)) >= 0))\n      throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0))\n      throw new RangeError(\"invalid height\");\n    if (!width || !height || !rx && !ry)\n      return data;\n    const blurx = rx && blur3(rx);\n    const blury = ry && blur3(ry);\n    const temp = values2.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    }\n    return data;\n  };\n}\nfunction blurh(blur3, T, S, w, h) {\n  for (let y4 = 0, n = w * h; y4 < n; ) {\n    blur3(T, S, y4, y4 += w, 1);\n  }\n}\nfunction blurv(blur3, T, S, w, h) {\n  for (let x4 = 0, n = w * h; x4 < w; ++x4) {\n    blur3(T, S, x4, x4 + n, w);\n  }\n}\nfunction blurfImage(radius2) {\n  const blur3 = blurf(radius2);\n  return (T, S, start2, stop, step) => {\n    start2 <<= 2, stop <<= 2, step <<= 2;\n    blur3(T, S, start2 + 0, stop + 0, step);\n    blur3(T, S, start2 + 1, stop + 1, step);\n    blur3(T, S, start2 + 2, stop + 2, step);\n    blur3(T, S, start2 + 3, stop + 3, step);\n  };\n}\nfunction blurf(radius2) {\n  const radius0 = Math.floor(radius2);\n  if (radius0 === radius2)\n    return bluri(radius2);\n  const t = radius2 - radius0;\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius0 * S[start2];\n    const s0 = step * radius0;\n    const s1 = s0 + step;\n    for (let i = start2, j = start2 + s0; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s0)];\n      T[i] = (sum5 + t * (S[Math.max(start2, i - s1)] + S[Math.min(stop, i + s1)])) / w;\n      sum5 -= S[Math.max(start2, i - s0)];\n    }\n  };\n}\nfunction bluri(radius2) {\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius2 * S[start2];\n    const s2 = step * radius2;\n    for (let i = start2, j = start2 + s2; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s2)];\n      T[i] = sum5 / w;\n      sum5 -= S[Math.max(start2, i - s2)];\n    }\n  };\n}\n\n// node_modules/d3-array/src/count.js\nfunction count(values2, valueof2) {\n  let count3 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  }\n  return count3;\n}\n\n// node_modules/d3-array/src/cross.js\nfunction length(array4) {\n  return array4.length | 0;\n}\nfunction empty(length4) {\n  return !(length4 > 0);\n}\nfunction arrayify(values2) {\n  return typeof values2 !== \"object\" || \"length\" in values2 ? values2 : Array.from(values2);\n}\nfunction reducer(reduce2) {\n  return (values2) => reduce2(...values2);\n}\nfunction cross(...values2) {\n  const reduce2 = typeof values2[values2.length - 1] === \"function\" && reducer(values2.pop());\n  values2 = values2.map(arrayify);\n  const lengths = values2.map(length);\n  const j = values2.length - 1;\n  const index3 = new Array(j + 1).fill(0);\n  const product = [];\n  if (j < 0 || lengths.some(empty))\n    return product;\n  while (true) {\n    product.push(index3.map((j2, i2) => values2[i2][j2]));\n    let i = j;\n    while (++index3[i] === lengths[i]) {\n      if (i === 0)\n        return reduce2 ? product.map(reduce2) : product;\n      index3[i--] = 0;\n    }\n  }\n}\n\n// node_modules/d3-array/src/cumsum.js\nfunction cumsum(values2, valueof2) {\n  var sum5 = 0, index3 = 0;\n  return Float64Array.from(values2, valueof2 === void 0 ? (v2) => sum5 += +v2 || 0 : (v2) => sum5 += +valueof2(v2, index3++, values2) || 0);\n}\n\n// node_modules/d3-array/src/variance.js\nfunction variance(values2, valueof2) {\n  let count3 = 0;\n  let delta;\n  let mean2 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  }\n  if (count3 > 1)\n    return sum5 / (count3 - 1);\n}\n\n// node_modules/d3-array/src/deviation.js\nfunction deviation(values2, valueof2) {\n  const v2 = variance(values2, valueof2);\n  return v2 ? Math.sqrt(v2) : v2;\n}\n\n// node_modules/d3-array/src/extent.js\nfunction extent(values2, valueof2) {\n  let min4;\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  }\n  return [min4, max5];\n}\n\n// node_modules/d3-array/src/fsum.js\nvar Adder = class {\n  constructor() {\n    this._partials = new Float64Array(32);\n    this._n = 0;\n  }\n  add(x4) {\n    const p = this._partials;\n    let i = 0;\n    for (let j = 0; j < this._n && j < 32; j++) {\n      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);\n      if (lo)\n        p[i++] = lo;\n      x4 = hi;\n    }\n    p[i] = x4;\n    this._n = i + 1;\n    return this;\n  }\n  valueOf() {\n    const p = this._partials;\n    let n = this._n, x4, y4, lo, hi = 0;\n    if (n > 0) {\n      hi = p[--n];\n      while (n > 0) {\n        x4 = hi;\n        y4 = p[--n];\n        hi = x4 + y4;\n        lo = y4 - (hi - x4);\n        if (lo)\n          break;\n      }\n      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {\n        y4 = lo * 2;\n        x4 = hi + y4;\n        if (y4 == x4 - hi)\n          hi = x4;\n      }\n    }\n    return hi;\n  }\n};\nfunction fsum(values2, valueof2) {\n  const adder = new Adder();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        adder.add(value);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        adder.add(value);\n      }\n    }\n  }\n  return +adder;\n}\nfunction fcumsum(values2, valueof2) {\n  const adder = new Adder();\n  let index3 = -1;\n  return Float64Array.from(\n    values2,\n    valueof2 === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof2(v2, ++index3, values2) || 0)\n  );\n}\n\n// node_modules/internmap/src/index.js\nvar InternMap = class extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (entries != null)\n      for (const [key2, value] of entries)\n        this.set(key2, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n};\nvar InternSet = class extends Set {\n  constructor(values2, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (values2 != null)\n      for (const value of values2)\n        this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n};\nfunction intern_get({ _intern, _key }, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\nfunction intern_set({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key))\n    return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\nfunction intern_delete({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/identity.js\nfunction identity(x4) {\n  return x4;\n}\n\n// node_modules/d3-array/src/group.js\nfunction group(values2, ...keys) {\n  return nest(values2, identity, identity, keys);\n}\nfunction groups(values2, ...keys) {\n  return nest(values2, Array.from, identity, keys);\n}\nfunction flatten(groups2, keys) {\n  for (let i = 1, n = keys.length; i < n; ++i) {\n    groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));\n  }\n  return groups2;\n}\nfunction flatGroup(values2, ...keys) {\n  return flatten(groups(values2, ...keys), keys);\n}\nfunction flatRollup(values2, reduce2, ...keys) {\n  return flatten(rollups(values2, reduce2, ...keys), keys);\n}\nfunction rollup(values2, reduce2, ...keys) {\n  return nest(values2, identity, reduce2, keys);\n}\nfunction rollups(values2, reduce2, ...keys) {\n  return nest(values2, Array.from, reduce2, keys);\n}\nfunction index(values2, ...keys) {\n  return nest(values2, identity, unique, keys);\n}\nfunction indexes(values2, ...keys) {\n  return nest(values2, Array.from, unique, keys);\n}\nfunction unique(values2) {\n  if (values2.length !== 1)\n    throw new Error(\"duplicate key\");\n  return values2[0];\n}\nfunction nest(values2, map6, reduce2, keys) {\n  return function regroup(values3, i) {\n    if (i >= keys.length)\n      return reduce2(values3);\n    const groups2 = new InternMap();\n    const keyof3 = keys[i++];\n    let index3 = -1;\n    for (const value of values3) {\n      const key = keyof3(value, ++index3, values3);\n      const group3 = groups2.get(key);\n      if (group3)\n        group3.push(value);\n      else\n        groups2.set(key, [value]);\n    }\n    for (const [key, values4] of groups2) {\n      groups2.set(key, regroup(values4, i));\n    }\n    return map6(groups2);\n  }(values2, 0);\n}\n\n// node_modules/d3-array/src/permute.js\nfunction permute(source, keys) {\n  return Array.from(keys, (key) => source[key]);\n}\n\n// node_modules/d3-array/src/sort.js\nfunction sort(values2, ...F) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  values2 = Array.from(values2);\n  let [f] = F;\n  if (f && f.length !== 2 || F.length > 1) {\n    const index3 = Uint32Array.from(values2, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map((f2) => values2.map(f2));\n      index3.sort((i, j) => {\n        for (const f2 of F) {\n          const c6 = ascendingDefined(f2[i], f2[j]);\n          if (c6)\n            return c6;\n        }\n      });\n    } else {\n      f = values2.map(f);\n      index3.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values2, index3);\n  }\n  return values2.sort(compareDefined(f));\n}\nfunction compareDefined(compare = ascending) {\n  if (compare === ascending)\n    return ascendingDefined;\n  if (typeof compare !== \"function\")\n    throw new TypeError(\"compare is not a function\");\n  return (a4, b) => {\n    const x4 = compare(a4, b);\n    if (x4 || x4 === 0)\n      return x4;\n    return (compare(b, b) === 0) - (compare(a4, a4) === 0);\n  };\n}\nfunction ascendingDefined(a4, b) {\n  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);\n}\n\n// node_modules/d3-array/src/groupSort.js\nfunction groupSort(values2, reduce2, key) {\n  return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);\n}\n\n// node_modules/d3-array/src/array.js\nvar array = Array.prototype;\nvar slice = array.slice;\nvar map = array.map;\n\n// node_modules/d3-array/src/constant.js\nfunction constant(x4) {\n  return () => x4;\n}\n\n// node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\nfunction tickSpec(start2, stop, count3) {\n  const step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;\n  let i1, i2, inc2;\n  if (power < 0) {\n    inc2 = Math.pow(10, -power) / factor;\n    i1 = Math.round(start2 * inc2);\n    i2 = Math.round(stop * inc2);\n    if (i1 / inc2 < start2)\n      ++i1;\n    if (i2 / inc2 > stop)\n      --i2;\n    inc2 = -inc2;\n  } else {\n    inc2 = Math.pow(10, power) * factor;\n    i1 = Math.round(start2 / inc2);\n    i2 = Math.round(stop / inc2);\n    if (i1 * inc2 < start2)\n      ++i1;\n    if (i2 * inc2 > stop)\n      --i2;\n  }\n  if (i2 < i1 && 0.5 <= count3 && count3 < 2)\n    return tickSpec(start2, stop, count3 * 2);\n  return [i1, i2, inc2];\n}\nfunction ticks(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  if (!(count3 > 0))\n    return [];\n  if (start2 === stop)\n    return [start2];\n  const reverse3 = stop < start2, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);\n  if (!(i2 >= i1))\n    return [];\n  const n = i2 - i1 + 1, ticks2 = new Array(n);\n  if (reverse3) {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) * inc2;\n  } else {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) * inc2;\n  }\n  return ticks2;\n}\nfunction tickIncrement(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  return tickSpec(start2, stop, count3)[2];\n}\nfunction tickStep(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  const reverse3 = stop < start2, inc2 = reverse3 ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);\n  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);\n}\n\n// node_modules/d3-array/src/nice.js\nfunction nice(start2, stop, count3) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start2, stop, count3);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start2, stop];\n    } else if (step > 0) {\n      start2 = Math.floor(start2 / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start2 = Math.ceil(start2 * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n\n// node_modules/d3-array/src/threshold/sturges.js\nfunction thresholdSturges(values2) {\n  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);\n}\n\n// node_modules/d3-array/src/bin.js\nfunction bin() {\n  var value = identity, domain = extent, threshold2 = thresholdSturges;\n  function histogram(data) {\n    if (!Array.isArray(data))\n      data = Array.from(data);\n    var i, n = data.length, x4, step, values2 = new Array(n);\n    for (i = 0; i < n; ++i) {\n      values2[i] = value(data[i], i, data);\n    }\n    var xz = domain(values2), x06 = xz[0], x12 = xz[1], tz = threshold2(values2, x06, x12);\n    if (!Array.isArray(tz)) {\n      const max5 = x12, tn = +tz;\n      if (domain === extent)\n        [x06, x12] = nice(x06, x12, tn);\n      tz = ticks(x06, x12, tn);\n      if (tz[0] <= x06)\n        step = tickIncrement(x06, x12, tn);\n      if (tz[tz.length - 1] >= x12) {\n        if (max5 >= x12 && domain === extent) {\n          const step2 = tickIncrement(x06, x12, tn);\n          if (isFinite(step2)) {\n            if (step2 > 0) {\n              x12 = (Math.floor(x12 / step2) + 1) * step2;\n            } else if (step2 < 0) {\n              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n    var m3 = tz.length, a4 = 0, b = m3;\n    while (tz[a4] <= x06)\n      ++a4;\n    while (tz[b - 1] > x12)\n      --b;\n    if (a4 || b < m3)\n      tz = tz.slice(a4, b), m3 = b - a4;\n    var bins = new Array(m3 + 1), bin3;\n    for (i = 0; i <= m3; ++i) {\n      bin3 = bins[i] = [];\n      bin3.x0 = i > 0 ? tz[i - 1] : x06;\n      bin3.x1 = i < m3 ? tz[i] : x12;\n    }\n    if (isFinite(step)) {\n      if (step > 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            bins[Math.min(m3, Math.floor((x4 - x06) / step))].push(data[i]);\n          }\n        }\n      } else if (step < 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            const j = Math.floor((x06 - x4) * step);\n            bins[Math.min(m3, j + (tz[j] <= x4))].push(data[i]);\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n          bins[bisect_default(tz, x4, 0, m3)].push(data[i]);\n        }\n      }\n    }\n    return bins;\n  }\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;\n  };\n  return histogram;\n}\n\n// node_modules/d3-array/src/max.js\nfunction max(values2, valueof2) {\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/maxIndex.js\nfunction maxIndex(values2, valueof2) {\n  let max5;\n  let maxIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  }\n  return maxIndex2;\n}\n\n// node_modules/d3-array/src/min.js\nfunction min(values2, valueof2) {\n  let min4;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/minIndex.js\nfunction minIndex(values2, valueof2) {\n  let min4;\n  let minIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  }\n  return minIndex2;\n}\n\n// node_modules/d3-array/src/quickselect.js\nfunction quickselect(array4, k2, left2 = 0, right2 = Infinity, compare) {\n  k2 = Math.floor(k2);\n  left2 = Math.floor(Math.max(0, left2));\n  right2 = Math.floor(Math.min(array4.length - 1, right2));\n  if (!(left2 <= k2 && k2 <= right2))\n    return array4;\n  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);\n  while (right2 > left2) {\n    if (right2 - left2 > 600) {\n      const n = right2 - left2 + 1;\n      const m3 = k2 - left2 + 1;\n      const z = Math.log(n);\n      const s2 = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));\n      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));\n      quickselect(array4, k2, newLeft, newRight, compare);\n    }\n    const t = array4[k2];\n    let i = left2;\n    let j = right2;\n    swap(array4, left2, k2);\n    if (compare(array4[right2], t) > 0)\n      swap(array4, left2, right2);\n    while (i < j) {\n      swap(array4, i, j), ++i, --j;\n      while (compare(array4[i], t) < 0)\n        ++i;\n      while (compare(array4[j], t) > 0)\n        --j;\n    }\n    if (compare(array4[left2], t) === 0)\n      swap(array4, left2, j);\n    else\n      ++j, swap(array4, j, right2);\n    if (j <= k2)\n      left2 = j + 1;\n    if (k2 <= j)\n      right2 = j - 1;\n  }\n  return array4;\n}\nfunction swap(array4, i, j) {\n  const t = array4[i];\n  array4[i] = array4[j];\n  array4[j] = t;\n}\n\n// node_modules/d3-array/src/greatest.js\nfunction greatest(values2, compare = ascending) {\n  let max5;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let maxValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {\n        max5 = element;\n        maxValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, max5) > 0 : compare(value, value) === 0) {\n        max5 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/quantile.js\nfunction quantile(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return min(values2);\n  if (p >= 1)\n    return max(values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileSorted(values2, p, valueof2 = number) {\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return +valueof2(values2[0], 0, values2);\n  if (p >= 1)\n    return +valueof2(values2[n - 1], n - 1, values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileIndex(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return minIndex(values2);\n  if (p >= 1)\n    return maxIndex(values2);\n  var n, i = Math.floor((n - 1) * p), order = (i2, j) => ascendingDefined(values2[i2], values2[j]), index3 = quickselect(Uint32Array.from(values2, (_, i2) => i2), i, 0, n - 1, order);\n  return greatest(index3.subarray(0, i + 1), (i2) => values2[i2]);\n}\n\n// node_modules/d3-array/src/threshold/freedmanDiaconis.js\nfunction thresholdFreedmanDiaconis(values2, min4, max5) {\n  const c6 = count(values2), d = quantile(values2, 0.75) - quantile(values2, 0.25);\n  return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;\n}\n\n// node_modules/d3-array/src/threshold/scott.js\nfunction thresholdScott(values2, min4, max5) {\n  const c6 = count(values2), d = deviation(values2);\n  return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;\n}\n\n// node_modules/d3-array/src/mean.js\nfunction mean(values2, valueof2) {\n  let count3 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  }\n  if (count3)\n    return sum5 / count3;\n}\n\n// node_modules/d3-array/src/median.js\nfunction median(values2, valueof2) {\n  return quantile(values2, 0.5, valueof2);\n}\nfunction medianIndex(values2, valueof2) {\n  return quantileIndex(values2, 0.5, valueof2);\n}\n\n// node_modules/d3-array/src/merge.js\nfunction* flatten2(arrays) {\n  for (const array4 of arrays) {\n    yield* array4;\n  }\n}\nfunction merge(arrays) {\n  return Array.from(flatten2(arrays));\n}\n\n// node_modules/d3-array/src/mode.js\nfunction mode(values2, valueof2) {\n  const counts = new InternMap();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  }\n  let modeValue;\n  let modeCount = 0;\n  for (const [value, count3] of counts) {\n    if (count3 > modeCount) {\n      modeCount = count3;\n      modeValue = value;\n    }\n  }\n  return modeValue;\n}\n\n// node_modules/d3-array/src/pairs.js\nfunction pairs(values2, pairof = pair) {\n  const pairs2 = [];\n  let previous;\n  let first2 = false;\n  for (const value of values2) {\n    if (first2)\n      pairs2.push(pairof(previous, value));\n    previous = value;\n    first2 = true;\n  }\n  return pairs2;\n}\nfunction pair(a4, b) {\n  return [a4, b];\n}\n\n// node_modules/d3-array/src/range.js\nfunction range(start2, stop, step) {\n  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;\n  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range5 = new Array(n);\n  while (++i < n) {\n    range5[i] = start2 + i * step;\n  }\n  return range5;\n}\n\n// node_modules/d3-array/src/rank.js\nfunction rank(values2, valueof2 = ascending) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  let V = Array.from(values2);\n  const R = new Float64Array(V.length);\n  if (valueof2.length !== 2)\n    V = V.map(valueof2), valueof2 = ascending;\n  const compareIndex = (i, j) => valueof2(V[i], V[j]);\n  let k2, r;\n  values2 = Uint32Array.from(V, (_, i) => i);\n  values2.sort(valueof2 === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));\n  values2.forEach((j, i) => {\n    const c6 = compareIndex(j, k2 === void 0 ? j : k2);\n    if (c6 >= 0) {\n      if (k2 === void 0 || c6 > 0)\n        k2 = j, r = i;\n      R[j] = r;\n    } else {\n      R[j] = NaN;\n    }\n  });\n  return R;\n}\n\n// node_modules/d3-array/src/least.js\nfunction least(values2, compare = ascending) {\n  let min4;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let minValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {\n        min4 = element;\n        minValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, min4) < 0 : compare(value, value) === 0) {\n        min4 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/leastIndex.js\nfunction leastIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return minIndex(values2, compare);\n  let minValue;\n  let min4 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n      minValue = value;\n      min4 = index3;\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/greatestIndex.js\nfunction greatestIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return maxIndex(values2, compare);\n  let maxValue;\n  let max5 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {\n      maxValue = value;\n      max5 = index3;\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/scan.js\nfunction scan(values2, compare) {\n  const index3 = leastIndex(values2, compare);\n  return index3 < 0 ? void 0 : index3;\n}\n\n// node_modules/d3-array/src/shuffle.js\nvar shuffle_default = shuffler(Math.random);\nfunction shuffler(random) {\n  return function shuffle3(array4, i0 = 0, i1 = array4.length) {\n    let m3 = i1 - (i0 = +i0);\n    while (m3) {\n      const i = random() * m3-- | 0, t = array4[m3 + i0];\n      array4[m3 + i0] = array4[i + i0];\n      array4[i + i0] = t;\n    }\n    return array4;\n  };\n}\n\n// node_modules/d3-array/src/sum.js\nfunction sum(values2, valueof2) {\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        sum5 += value;\n      }\n    }\n  }\n  return sum5;\n}\n\n// node_modules/d3-array/src/transpose.js\nfunction transpose(matrix) {\n  if (!(n = matrix.length))\n    return [];\n  for (var i = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i < m3; ) {\n    for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose2;\n}\nfunction length2(d) {\n  return d.length;\n}\n\n// node_modules/d3-array/src/zip.js\nfunction zip() {\n  return transpose(arguments);\n}\n\n// node_modules/d3-array/src/every.js\nfunction every(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (!test(value, ++index3, values2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/some.js\nfunction some(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// node_modules/d3-array/src/filter.js\nfunction filter(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  const array4 = [];\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      array4.push(value);\n    }\n  }\n  return array4;\n}\n\n// node_modules/d3-array/src/map.js\nfunction map2(values2, mapper) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  if (typeof mapper !== \"function\")\n    throw new TypeError(\"mapper is not a function\");\n  return Array.from(values2, (value, index3) => mapper(value, index3, values2));\n}\n\n// node_modules/d3-array/src/reduce.js\nfunction reduce(values2, reducer2, value) {\n  if (typeof reducer2 !== \"function\")\n    throw new TypeError(\"reducer is not a function\");\n  const iterator = values2[Symbol.iterator]();\n  let done, next, index3 = -1;\n  if (arguments.length < 3) {\n    ({ done, value } = iterator.next());\n    if (done)\n      return;\n    ++index3;\n  }\n  while ({ done, value: next } = iterator.next(), !done) {\n    value = reducer2(value, next, ++index3, values2);\n  }\n  return value;\n}\n\n// node_modules/d3-array/src/reverse.js\nfunction reverse(values2) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  return Array.from(values2).reverse();\n}\n\n// node_modules/d3-array/src/difference.js\nfunction difference(values2, ...others) {\n  values2 = new InternSet(values2);\n  for (const other of others) {\n    for (const value of other) {\n      values2.delete(value);\n    }\n  }\n  return values2;\n}\n\n// node_modules/d3-array/src/disjoint.js\nfunction disjoint(values2, other) {\n  const iterator = other[Symbol.iterator](), set4 = new InternSet();\n  for (const v2 of values2) {\n    if (set4.has(v2))\n      return false;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        break;\n      if (Object.is(v2, value))\n        return false;\n      set4.add(value);\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/intersection.js\nfunction intersection(values2, ...others) {\n  values2 = new InternSet(values2);\n  others = others.map(set);\n  out:\n    for (const value of values2) {\n      for (const other of others) {\n        if (!other.has(value)) {\n          values2.delete(value);\n          continue out;\n        }\n      }\n    }\n  return values2;\n}\nfunction set(values2) {\n  return values2 instanceof InternSet ? values2 : new InternSet(values2);\n}\n\n// node_modules/d3-array/src/superset.js\nfunction superset(values2, other) {\n  const iterator = values2[Symbol.iterator](), set4 = /* @__PURE__ */ new Set();\n  for (const o of other) {\n    const io = intern(o);\n    if (set4.has(io))\n      continue;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        return false;\n      const ivalue = intern(value);\n      set4.add(ivalue);\n      if (Object.is(io, ivalue))\n        break;\n    }\n  }\n  return true;\n}\nfunction intern(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/subset.js\nfunction subset(values2, other) {\n  return superset(other, values2);\n}\n\n// node_modules/d3-array/src/union.js\nfunction union(...others) {\n  const set4 = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set4.add(o);\n    }\n  }\n  return set4;\n}\n\n// node_modules/d3-axis/src/identity.js\nfunction identity_default(x4) {\n  return x4;\n}\n\n// node_modules/d3-axis/src/axis.js\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon = 1e-6;\nfunction translateX(x4) {\n  return \"translate(\" + x4 + \",0)\";\n}\nfunction translateY(y4) {\n  return \"translate(0,\" + y4 + \")\";\n}\nfunction number2(scale3) {\n  return (d) => +scale3(d);\n}\nfunction center(scale3, offset2) {\n  offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;\n  if (scale3.round())\n    offset2 = Math.round(offset2);\n  return (d) => +scale3(d) + offset2;\n}\nfunction entering() {\n  return !this.__axis;\n}\nfunction axis(orient, scale3) {\n  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x4 = orient === left || orient === right ? \"x\" : \"y\", transform2 = orient === top || orient === bottom ? translateX : translateY;\n  function axis2(context) {\n    var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues, format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range5 = scale3.range(), range0 = +range5[0] + offset2, range1 = +range5[range5.length - 1] + offset2, position2 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(\".domain\").data([null]), tick = selection2.selectAll(\".tick\").data(values2, scale3).order(), tickExit = tick.exit(), tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"), line2 = tick.select(\"line\"), text2 = tick.select(\"text\");\n    path2 = path2.merge(path2.enter().insert(\"path\", \".tick\").attr(\"class\", \"domain\").attr(\"stroke\", \"currentColor\"));\n    tick = tick.merge(tickEnter);\n    line2 = line2.merge(tickEnter.append(\"line\").attr(\"stroke\", \"currentColor\").attr(x4 + \"2\", k2 * tickSizeInner));\n    text2 = text2.merge(tickEnter.append(\"text\").attr(\"fill\", \"currentColor\").attr(x4, k2 * spacing).attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n    if (context !== selection2) {\n      path2 = path2.transition(context);\n      tick = tick.transition(context);\n      line2 = line2.transition(context);\n      text2 = text2.transition(context);\n      tickExit = tickExit.transition(context).attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute(\"transform\");\n      });\n      tickEnter.attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        var p = this.parentNode.__axis;\n        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);\n      });\n    }\n    tickExit.remove();\n    path2.attr(\"d\", orient === left || orient === right ? tickSizeOuter ? \"M\" + k2 * tickSizeOuter + \",\" + range0 + \"H\" + offset2 + \"V\" + range1 + \"H\" + k2 * tickSizeOuter : \"M\" + offset2 + \",\" + range0 + \"V\" + range1 : tickSizeOuter ? \"M\" + range0 + \",\" + k2 * tickSizeOuter + \"V\" + offset2 + \"H\" + range1 + \"V\" + k2 * tickSizeOuter : \"M\" + range0 + \",\" + offset2 + \"H\" + range1);\n    tick.attr(\"opacity\", 1).attr(\"transform\", function(d) {\n      return transform2(position2(d) + offset2);\n    });\n    line2.attr(x4 + \"2\", k2 * tickSizeInner);\n    text2.attr(x4, k2 * spacing).text(format3);\n    selection2.filter(entering).attr(\"fill\", \"none\").attr(\"font-size\", 10).attr(\"font-family\", \"sans-serif\").attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n    selection2.each(function() {\n      this.__axis = position2;\n    });\n  }\n  axis2.scale = function(_) {\n    return arguments.length ? (scale3 = _, axis2) : scale3;\n  };\n  axis2.ticks = function() {\n    return tickArguments = Array.from(arguments), axis2;\n  };\n  axis2.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();\n  };\n  axis2.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();\n  };\n  axis2.tickFormat = function(_) {\n    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;\n  };\n  axis2.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;\n  };\n  axis2.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;\n  };\n  axis2.offset = function(_) {\n    return arguments.length ? (offset2 = +_, axis2) : offset2;\n  };\n  return axis2;\n}\nfunction axisTop(scale3) {\n  return axis(top, scale3);\n}\nfunction axisRight(scale3) {\n  return axis(right, scale3);\n}\nfunction axisBottom(scale3) {\n  return axis(bottom, scale3);\n}\nfunction axisLeft(scale3) {\n  return axis(left, scale3);\n}\n\n// node_modules/d3-dispatch/src/dispatch.js\nvar noop = { value: () => {\n} };\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || t in _ || /[\\s.]/.test(t))\n      throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\nfunction Dispatch(_) {\n  this._ = _;\n}\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t))\n      throw new Error(\"unknown type: \" + t);\n    return { type: t, name };\n  });\n}\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._, T = parseTypenames(typename + \"\", _), t, i = -1, n = T.length;\n    if (arguments.length < 2) {\n      while (++i < n)\n        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))\n          return t;\n      return;\n    }\n    if (callback != null && typeof callback !== \"function\")\n      throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type)\n        _[t] = set2(_[t], typename.name, callback);\n      else if (callback == null)\n        for (t in _)\n          _[t] = set2(_[t], typename.name, null);\n    }\n    return this;\n  },\n  copy: function() {\n    var copy3 = {}, _ = this._;\n    for (var t in _)\n      copy3[t] = _[t].slice();\n    return new Dispatch(copy3);\n  },\n  call: function(type2, that) {\n    if ((n = arguments.length - 2) > 0)\n      for (var args = new Array(n), i = 0, n, t; i < n; ++i)\n        args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  },\n  apply: function(type2, that, args) {\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  }\n};\nfunction get(type2, name) {\n  for (var i = 0, n = type2.length, c6; i < n; ++i) {\n    if ((c6 = type2[i]).name === name) {\n      return c6.value;\n    }\n  }\n}\nfunction set2(type2, name, callback) {\n  for (var i = 0, n = type2.length; i < n; ++i) {\n    if (type2[i].name === name) {\n      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null)\n    type2.push({ name, value: callback });\n  return type2;\n}\nvar dispatch_default = dispatch;\n\n// node_modules/d3-selection/src/namespaces.js\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\nvar namespaces_default = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\n// node_modules/d3-selection/src/namespace.js\nfunction namespace_default(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\")\n    name = name.slice(i + 1);\n  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;\n}\n\n// node_modules/d3-selection/src/creator.js\nfunction creatorInherit(name) {\n  return function() {\n    var document2 = this.ownerDocument, uri = this.namespaceURI;\n    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);\n  };\n}\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\nfunction creator_default(name) {\n  var fullname = namespace_default(name);\n  return (fullname.local ? creatorFixed : creatorInherit)(fullname);\n}\n\n// node_modules/d3-selection/src/selector.js\nfunction none() {\n}\nfunction selector_default(selector) {\n  return selector == null ? none : function() {\n    return this.querySelector(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/select.js\nfunction select_default(select2) {\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/array.js\nfunction array2(x4) {\n  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-selection/src/selectorAll.js\nfunction empty2() {\n  return [];\n}\nfunction selectorAll_default(selector) {\n  return selector == null ? empty2 : function() {\n    return this.querySelectorAll(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectAll.js\nfunction arrayAll(select2) {\n  return function() {\n    return array2(select2.apply(this, arguments));\n  };\n}\nfunction selectAll_default(select2) {\n  if (typeof select2 === \"function\")\n    select2 = arrayAll(select2);\n  else\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        subgroups.push(select2.call(node, node.__data__, i, group3));\n        parents.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, parents);\n}\n\n// node_modules/d3-selection/src/matcher.js\nfunction matcher_default(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n}\nfunction childMatcher(selector) {\n  return function(node) {\n    return node.matches(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectChild.js\nvar find = Array.prototype.find;\nfunction childFind(match) {\n  return function() {\n    return find.call(this.children, match);\n  };\n}\nfunction childFirst() {\n  return this.firstElementChild;\n}\nfunction selectChild_default(match) {\n  return this.select(match == null ? childFirst : childFind(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/selectChildren.js\nvar filter2 = Array.prototype.filter;\nfunction children() {\n  return Array.from(this.children);\n}\nfunction childrenFilter(match) {\n  return function() {\n    return filter2.call(this.children, match);\n  };\n}\nfunction selectChildren_default(match) {\n  return this.selectAll(match == null ? children : childrenFilter(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/filter.js\nfunction filter_default(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/sparse.js\nfunction sparse_default(update) {\n  return new Array(update.length);\n}\n\n// node_modules/d3-selection/src/selection/enter.js\nfunction enter_default() {\n  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);\n}\nfunction EnterNode(parent, datum2) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum2;\n}\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) {\n    return this._parent.insertBefore(child, this._next);\n  },\n  insertBefore: function(child, next) {\n    return this._parent.insertBefore(child, next);\n  },\n  querySelector: function(selector) {\n    return this._parent.querySelector(selector);\n  },\n  querySelectorAll: function(selector) {\n    return this._parent.querySelectorAll(selector);\n  }\n};\n\n// node_modules/d3-selection/src/constant.js\nfunction constant_default(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-selection/src/selection/data.js\nfunction bindIndex(parent, group3, enter, update, exit, data) {\n  var i = 0, node, groupLength = group3.length, dataLength = data.length;\n  for (; i < dataLength; ++i) {\n    if (node = group3[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      exit[i] = node;\n    }\n  }\n}\nfunction bindKey(parent, group3, enter, update, exit, data, key) {\n  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\nfunction datum(node) {\n  return node.__data__;\n}\nfunction data_default(value, key) {\n  if (!arguments.length)\n    return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;\n  if (typeof value !== \"function\")\n    value = constant_default(value);\n  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {\n    var parent = parents[j], group3 = groups2[j], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1)\n          i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength)\n          ;\n        previous._next = next || null;\n      }\n    }\n  }\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data ? data : Array.from(data);\n}\n\n// node_modules/d3-selection/src/selection/exit.js\nfunction exit_default() {\n  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);\n}\n\n// node_modules/d3-selection/src/selection/join.js\nfunction join_default(onenter, onupdate, onexit) {\n  var enter = this.enter(), update = this, exit = this.exit();\n  if (typeof onenter === \"function\") {\n    enter = onenter(enter);\n    if (enter)\n      enter = enter.selection();\n  } else {\n    enter = enter.append(onenter + \"\");\n  }\n  if (onupdate != null) {\n    update = onupdate(update);\n    if (update)\n      update = update.selection();\n  }\n  if (onexit == null)\n    exit.remove();\n  else\n    onexit(exit);\n  return enter && update ? enter.merge(update).order() : update;\n}\n\n// node_modules/d3-selection/src/selection/merge.js\nfunction merge_default(context) {\n  var selection2 = context.selection ? context.selection() : context;\n  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Selection(merges, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/order.js\nfunction order_default() {\n  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {\n    for (var group3 = groups2[j], i = group3.length - 1, next = group3[i], node; --i >= 0; ) {\n      if (node = group3[i]) {\n        if (next && node.compareDocumentPosition(next) ^ 4)\n          next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/sort.js\nfunction sort_default(compare) {\n  if (!compare)\n    compare = ascending2;\n  function compareNode(a4, b) {\n    return a4 && b ? compare(a4.__data__, b.__data__) : !a4 - !b;\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n  return new Selection(sortgroups, this._parents).order();\n}\nfunction ascending2(a4, b) {\n  return a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-selection/src/selection/call.js\nfunction call_default() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/nodes.js\nfunction nodes_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-selection/src/selection/node.js\nfunction node_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length; i < n; ++i) {\n      var node = group3[i];\n      if (node)\n        return node;\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-selection/src/selection/size.js\nfunction size_default() {\n  let size = 0;\n  for (const node of this)\n    ++size;\n  return size;\n}\n\n// node_modules/d3-selection/src/selection/empty.js\nfunction empty_default() {\n  return !this.node();\n}\n\n// node_modules/d3-selection/src/selection/each.js\nfunction each_default(callback) {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        callback.call(node, node.__data__, i, group3);\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/attr.js\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\nfunction attrFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttribute(name);\n    else\n      this.setAttribute(name, v2);\n  };\n}\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttributeNS(fullname.space, fullname.local);\n    else\n      this.setAttributeNS(fullname.space, fullname.local, v2);\n  };\n}\nfunction attr_default(name, value) {\n  var fullname = namespace_default(name);\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);\n  }\n  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === \"function\" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));\n}\n\n// node_modules/d3-selection/src/window.js\nfunction window_default(node) {\n  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;\n}\n\n// node_modules/d3-selection/src/selection/style.js\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.style.removeProperty(name);\n    else\n      this.style.setProperty(name, v2, priority);\n  };\n}\nfunction style_default(name, value, priority) {\n  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === \"function\" ? styleFunction : styleConstant)(name, value, priority == null ? \"\" : priority)) : styleValue(this.node(), name);\n}\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\n// node_modules/d3-selection/src/selection/property.js\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\nfunction propertyFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      delete this[name];\n    else\n      this[name] = v2;\n  };\n}\nfunction property_default(name, value) {\n  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === \"function\" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];\n}\n\n// node_modules/d3-selection/src/selection/classed.js\nfunction classArray(string2) {\n  return string2.trim().split(/^|\\s+/);\n}\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.add(names[i]);\n}\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.remove(names[i]);\n}\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\nfunction classed_default(name, value) {\n  var names = classArray(name + \"\");\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n)\n      if (!list.contains(names[i]))\n        return false;\n    return true;\n  }\n  return this.each((typeof value === \"function\" ? classedFunction : value ? classedTrue : classedFalse)(names, value));\n}\n\n// node_modules/d3-selection/src/selection/text.js\nfunction textRemove() {\n  this.textContent = \"\";\n}\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.textContent = v2 == null ? \"\" : v2;\n  };\n}\nfunction text_default(value) {\n  return arguments.length ? this.each(value == null ? textRemove : (typeof value === \"function\" ? textFunction : textConstant)(value)) : this.node().textContent;\n}\n\n// node_modules/d3-selection/src/selection/html.js\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\nfunction htmlFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.innerHTML = v2 == null ? \"\" : v2;\n  };\n}\nfunction html_default(value) {\n  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === \"function\" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;\n}\n\n// node_modules/d3-selection/src/selection/raise.js\nfunction raise() {\n  if (this.nextSibling)\n    this.parentNode.appendChild(this);\n}\nfunction raise_default() {\n  return this.each(raise);\n}\n\n// node_modules/d3-selection/src/selection/lower.js\nfunction lower() {\n  if (this.previousSibling)\n    this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\nfunction lower_default() {\n  return this.each(lower);\n}\n\n// node_modules/d3-selection/src/selection/append.js\nfunction append_default(name) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name);\n  return this.select(function() {\n    return this.appendChild(create3.apply(this, arguments));\n  });\n}\n\n// node_modules/d3-selection/src/selection/insert.js\nfunction constantNull() {\n  return null;\n}\nfunction insert_default(name, before) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name), select2 = before == null ? constantNull : typeof before === \"function\" ? before : selector_default(before);\n  return this.select(function() {\n    return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);\n  });\n}\n\n// node_modules/d3-selection/src/selection/remove.js\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent)\n    parent.removeChild(this);\n}\nfunction remove_default() {\n  return this.each(remove);\n}\n\n// node_modules/d3-selection/src/selection/clone.js\nfunction selection_cloneShallow() {\n  var clone = this.cloneNode(false), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction selection_cloneDeep() {\n  var clone = this.cloneNode(true), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction clone_default(deep) {\n  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);\n}\n\n// node_modules/d3-selection/src/selection/datum.js\nfunction datum_default(value) {\n  return arguments.length ? this.property(\"__data__\", value) : this.node().__data__;\n}\n\n// node_modules/d3-selection/src/selection/on.js\nfunction contextListener(listener) {\n  return function(event) {\n    listener.call(this, event, this.__data__);\n  };\n}\nfunction parseTypenames2(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    return { type: t, name };\n  });\n}\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on)\n      return;\n    for (var j = 0, i = -1, m3 = on.length, o; j < m3; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.options);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i)\n      on.length = i;\n    else\n      delete this.__on;\n  };\n}\nfunction onAdd(typename, value, options) {\n  return function() {\n    var on = this.__on, o, listener = contextListener(value);\n    if (on)\n      for (var j = 0, m3 = on.length; j < m3; ++j) {\n        if ((o = on[j]).type === typename.type && o.name === typename.name) {\n          this.removeEventListener(o.type, o.listener, o.options);\n          this.addEventListener(o.type, o.listener = listener, o.options = options);\n          o.value = value;\n          return;\n        }\n      }\n    this.addEventListener(typename.type, listener, options);\n    o = { type: typename.type, name: typename.name, value, listener, options };\n    if (!on)\n      this.__on = [o];\n    else\n      on.push(o);\n  };\n}\nfunction on_default(typename, value, options) {\n  var typenames = parseTypenames2(typename + \"\"), i, n = typenames.length, t;\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on)\n      for (var j = 0, m3 = on.length, o; j < m3; ++j) {\n        for (i = 0, o = on[j]; i < n; ++i) {\n          if ((t = typenames[i]).type === o.type && t.name === o.name) {\n            return o.value;\n          }\n        }\n      }\n    return;\n  }\n  on = value ? onAdd : onRemove;\n  for (i = 0; i < n; ++i)\n    this.each(on(typenames[i], value, options));\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/dispatch.js\nfunction dispatchEvent(node, type2, params) {\n  var window3 = window_default(node), event = window3.CustomEvent;\n  if (typeof event === \"function\") {\n    event = new event(type2, params);\n  } else {\n    event = window3.document.createEvent(\"Event\");\n    if (params)\n      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;\n    else\n      event.initEvent(type2, false, false);\n  }\n  node.dispatchEvent(event);\n}\nfunction dispatchConstant(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params);\n  };\n}\nfunction dispatchFunction(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params.apply(this, arguments));\n  };\n}\nfunction dispatch_default2(type2, params) {\n  return this.each((typeof params === \"function\" ? dispatchFunction : dispatchConstant)(type2, params));\n}\n\n// node_modules/d3-selection/src/selection/iterator.js\nfunction* iterator_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        yield node;\n    }\n  }\n}\n\n// node_modules/d3-selection/src/selection/index.js\nvar root = [null];\nfunction Selection(groups2, parents) {\n  this._groups = groups2;\n  this._parents = parents;\n}\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\nfunction selection_selection() {\n  return this;\n}\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: select_default,\n  selectAll: selectAll_default,\n  selectChild: selectChild_default,\n  selectChildren: selectChildren_default,\n  filter: filter_default,\n  data: data_default,\n  enter: enter_default,\n  exit: exit_default,\n  join: join_default,\n  merge: merge_default,\n  selection: selection_selection,\n  order: order_default,\n  sort: sort_default,\n  call: call_default,\n  nodes: nodes_default,\n  node: node_default,\n  size: size_default,\n  empty: empty_default,\n  each: each_default,\n  attr: attr_default,\n  style: style_default,\n  property: property_default,\n  classed: classed_default,\n  text: text_default,\n  html: html_default,\n  raise: raise_default,\n  lower: lower_default,\n  append: append_default,\n  insert: insert_default,\n  remove: remove_default,\n  clone: clone_default,\n  datum: datum_default,\n  on: on_default,\n  dispatch: dispatch_default2,\n  [Symbol.iterator]: iterator_default\n};\nvar selection_default = selection;\n\n// node_modules/d3-selection/src/select.js\nfunction select_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);\n}\n\n// node_modules/d3-selection/src/create.js\nfunction create_default(name) {\n  return select_default2(creator_default(name).call(document.documentElement));\n}\n\n// node_modules/d3-selection/src/local.js\nvar nextId = 0;\nfunction local() {\n  return new Local();\n}\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id2 = this._;\n    while (!(id2 in node))\n      if (!(node = node.parentNode))\n        return;\n    return node[id2];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\n// node_modules/d3-selection/src/sourceEvent.js\nfunction sourceEvent_default(event) {\n  let sourceEvent;\n  while (sourceEvent = event.sourceEvent)\n    event = sourceEvent;\n  return event;\n}\n\n// node_modules/d3-selection/src/pointer.js\nfunction pointer_default(event, node) {\n  event = sourceEvent_default(event);\n  if (node === void 0)\n    node = event.currentTarget;\n  if (node) {\n    var svg2 = node.ownerSVGElement || node;\n    if (svg2.createSVGPoint) {\n      var point6 = svg2.createSVGPoint();\n      point6.x = event.clientX, point6.y = event.clientY;\n      point6 = point6.matrixTransform(node.getScreenCTM().inverse());\n      return [point6.x, point6.y];\n    }\n    if (node.getBoundingClientRect) {\n      var rect2 = node.getBoundingClientRect();\n      return [event.clientX - rect2.left - node.clientLeft, event.clientY - rect2.top - node.clientTop];\n    }\n  }\n  return [event.pageX, event.pageY];\n}\n\n// node_modules/d3-selection/src/pointers.js\nfunction pointers_default(events, node) {\n  if (events.target) {\n    events = sourceEvent_default(events);\n    if (node === void 0)\n      node = events.currentTarget;\n    events = events.touches || [events];\n  }\n  return Array.from(events, (event) => pointer_default(event, node));\n}\n\n// node_modules/d3-selection/src/selectAll.js\nfunction selectAll_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array2(selector)], root);\n}\n\n// node_modules/d3-drag/src/noevent.js\nvar nonpassive = { passive: false };\nvar nonpassivecapture = { capture: true, passive: false };\nfunction nopropagation(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-drag/src/nodrag.js\nfunction nodrag_default(view) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", noevent_default, nonpassivecapture);\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", noevent_default, nonpassivecapture);\n  } else {\n    root3.__noselect = root3.style.MozUserSelect;\n    root3.style.MozUserSelect = \"none\";\n  }\n}\nfunction yesdrag(view, noclick) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection2.on(\"click.drag\", noevent_default, nonpassivecapture);\n    setTimeout(function() {\n      selection2.on(\"click.drag\", null);\n    }, 0);\n  }\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", null);\n  } else {\n    root3.style.MozUserSelect = root3.__noselect;\n    delete root3.__noselect;\n  }\n}\n\n// node_modules/d3-drag/src/constant.js\nvar constant_default2 = (x4) => () => x4;\n\n// node_modules/d3-drag/src/event.js\nfunction DragEvent(type2, {\n  sourceEvent,\n  subject,\n  target,\n  identifier,\n  active,\n  x: x4,\n  y: y4,\n  dx,\n  dy,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    subject: { value: subject, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    identifier: { value: identifier, enumerable: true, configurable: true },\n    active: { value: active, enumerable: true, configurable: true },\n    x: { value: x4, enumerable: true, configurable: true },\n    y: { value: y4, enumerable: true, configurable: true },\n    dx: { value: dx, enumerable: true, configurable: true },\n    dy: { value: dy, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// node_modules/d3-drag/src/drag.js\nfunction defaultFilter(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultContainer() {\n  return this.parentNode;\n}\nfunction defaultSubject(event, d) {\n  return d == null ? { x: event.x, y: event.y } : d;\n}\nfunction defaultTouchable() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction drag_default() {\n  var filter4 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default(\"start\", \"drag\", \"end\"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;\n  function drag(selection2) {\n    selection2.on(\"mousedown.drag\", mousedowned).filter(touchable).on(\"touchstart.drag\", touchstarted).on(\"touchmove.drag\", touchmoved, nonpassive).on(\"touchend.drag touchcancel.drag\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  function mousedowned(event, d) {\n    if (touchending || !filter4.call(this, event, d))\n      return;\n    var gesture = beforestart(this, container.call(this, event, d), event, d, \"mouse\");\n    if (!gesture)\n      return;\n    select_default2(event.view).on(\"mousemove.drag\", mousemoved, nonpassivecapture).on(\"mouseup.drag\", mouseupped, nonpassivecapture);\n    nodrag_default(event.view);\n    nopropagation(event);\n    mousemoving = false;\n    mousedownx = event.clientX;\n    mousedowny = event.clientY;\n    gesture(\"start\", event);\n  }\n  function mousemoved(event) {\n    noevent_default(event);\n    if (!mousemoving) {\n      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\", event);\n  }\n  function mouseupped(event) {\n    select_default2(event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(event.view, mousemoving);\n    noevent_default(event);\n    gestures.mouse(\"end\", event);\n  }\n  function touchstarted(event, d) {\n    if (!filter4.call(this, event, d))\n      return;\n    var touches = event.changedTouches, c6 = container.call(this, event, d), n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(this, c6, event, d, touches[i].identifier, touches[i])) {\n        nopropagation(event);\n        gesture(\"start\", event, touches[i]);\n      }\n    }\n  }\n  function touchmoved(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        noevent_default(event);\n        gesture(\"drag\", event, touches[i]);\n      }\n    }\n  }\n  function touchended(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, 500);\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        nopropagation(event);\n        gesture(\"end\", event, touches[i]);\n      }\n    }\n  }\n  function beforestart(that, container2, event, d, identifier, touch) {\n    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s2;\n    if ((s2 = subject.call(that, new DragEvent(\"beforestart\", {\n      sourceEvent: event,\n      target: drag,\n      identifier,\n      active,\n      x: p[0],\n      y: p[1],\n      dx: 0,\n      dy: 0,\n      dispatch: dispatch2\n    }), d)) == null)\n      return;\n    dx = s2.x - p[0] || 0;\n    dy = s2.y - p[1] || 0;\n    return function gesture(type2, event2, touch2) {\n      var p02 = p, n;\n      switch (type2) {\n        case \"start\":\n          gestures[identifier] = gesture, n = active++;\n          break;\n        case \"end\":\n          delete gestures[identifier], --active;\n        case \"drag\":\n          p = pointer_default(touch2 || event2, container2), n = active;\n          break;\n      }\n      dispatch2.call(\n        type2,\n        that,\n        new DragEvent(type2, {\n          sourceEvent: event2,\n          subject: s2,\n          target: drag,\n          identifier,\n          active: n,\n          x: p[0] + dx,\n          y: p[1] + dy,\n          dx: p[0] - p02[0],\n          dy: p[1] - p02[1],\n          dispatch: dispatch2\n        }),\n        d\n      );\n    };\n  }\n  drag.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : filter4;\n  };\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant_default2(_), drag) : container;\n  };\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant_default2(_), drag) : subject;\n  };\n  drag.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : touchable;\n  };\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n  return drag;\n}\n\n// node_modules/d3-color/src/define.js\nfunction define_default(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition)\n    prototype[key] = definition[key];\n  return prototype;\n}\n\n// node_modules/d3-color/src/color.js\nfunction Color() {\n}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\";\nvar reN = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\";\nvar reP = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\";\nvar reHex = /^#([0-9a-f]{3,8})$/;\nvar reRgbInteger = new RegExp(`^rgb\\\\(${reI},${reI},${reI}\\\\)$`);\nvar reRgbPercent = new RegExp(`^rgb\\\\(${reP},${reP},${reP}\\\\)$`);\nvar reRgbaInteger = new RegExp(`^rgba\\\\(${reI},${reI},${reI},${reN}\\\\)$`);\nvar reRgbaPercent = new RegExp(`^rgba\\\\(${reP},${reP},${reP},${reN}\\\\)$`);\nvar reHslPercent = new RegExp(`^hsl\\\\(${reN},${reP},${reP}\\\\)$`);\nvar reHslaPercent = new RegExp(`^hsla\\\\(${reN},${reP},${reP},${reN}\\\\)$`);\nvar named = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\ndefine_default(Color, color, {\n  copy(channels) {\n    return Object.assign(new this.constructor(), this, channels);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: color_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: color_formatHex,\n  formatHex8: color_formatHex8,\n  formatHsl: color_formatHsl,\n  formatRgb: color_formatRgb,\n  toString: color_formatRgb\n});\nfunction color_formatHex() {\n  return this.rgb().formatHex();\n}\nfunction color_formatHex8() {\n  return this.rgb().formatHex8();\n}\nfunction color_formatHsl() {\n  return hslConvert(this).formatHsl();\n}\nfunction color_formatRgb() {\n  return this.rgb().formatRgb();\n}\nfunction color(format3) {\n  var m3, l;\n  format3 = (format3 + \"\").trim().toLowerCase();\n  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);\n}\nfunction rgba(r, g, b, a4) {\n  if (a4 <= 0)\n    r = g = b = NaN;\n  return new Rgb(r, g, b, a4);\n}\nfunction rgbConvert(o) {\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Rgb();\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity2) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Rgb(r, g, b, opacity2) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Rgb, rgb, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: rgb_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: rgb_formatHex,\n  formatHex8: rgb_formatHex8,\n  formatRgb: rgb_formatRgb,\n  toString: rgb_formatRgb\n}));\nfunction rgb_formatHex() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;\n}\nfunction rgb_formatHex8() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction rgb_formatRgb() {\n  const a4 = clampa(this.opacity);\n  return `${a4 === 1 ? \"rgb(\" : \"rgba(\"}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? \")\" : `, ${a4})`}`;\n}\nfunction clampa(opacity2) {\n  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));\n}\nfunction clampi(value) {\n  return Math.max(0, Math.min(255, Math.round(value) || 0));\n}\nfunction hex(value) {\n  value = clampi(value);\n  return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\nfunction hsla(h, s2, l, a4) {\n  if (a4 <= 0)\n    h = s2 = l = NaN;\n  else if (l <= 0 || l >= 1)\n    h = s2 = NaN;\n  else if (s2 <= 0)\n    h = NaN;\n  return new Hsl(h, s2, l, a4);\n}\nfunction hslConvert(o) {\n  if (o instanceof Hsl)\n    return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Hsl();\n  if (o instanceof Hsl)\n    return o;\n  o = o.rgb();\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s2 = max5 - min4, l = (max5 + min4) / 2;\n  if (s2) {\n    if (r === max5)\n      h = (g - b) / s2 + (g < b) * 6;\n    else if (g === max5)\n      h = (b - r) / s2 + 2;\n    else\n      h = (r - g) / s2 + 4;\n    s2 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;\n    h *= 60;\n  } else {\n    s2 = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s2, l, o.opacity);\n}\nfunction hsl(h, s2, l, opacity2) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hsl(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Hsl, hsl, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),\n      hsl2rgb(h, m1, m22),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  formatHsl() {\n    const a4 = clampa(this.opacity);\n    return `${a4 === 1 ? \"hsl(\" : \"hsla(\"}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? \")\" : `, ${a4})`}`;\n  }\n}));\nfunction clamph(value) {\n  value = (value || 0) % 360;\n  return value < 0 ? value + 360 : value;\n}\nfunction clampt(value) {\n  return Math.max(0, Math.min(1, value || 0));\n}\nfunction hsl2rgb(h, m1, m22) {\n  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;\n}\n\n// node_modules/d3-color/src/math.js\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\n\n// node_modules/d3-color/src/lab.js\nvar K = 18;\nvar Xn = 0.96422;\nvar Yn = 1;\nvar Zn = 0.82521;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\nfunction labConvert(o) {\n  if (o instanceof Lab)\n    return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl)\n    return hcl2lab(o);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x4, z;\n  if (r === g && g === b)\n    x4 = z = y4;\n  else {\n    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n  }\n  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);\n}\nfunction gray(l, opacity2) {\n  return new Lab(l, 0, 0, opacity2 == null ? 1 : opacity2);\n}\nfunction lab(l, a4, b, opacity2) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Lab(l, a4, b, opacity2) {\n  this.l = +l;\n  this.a = +a4;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Lab, lab, extend(Color, {\n  brighter(k2) {\n    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  darker(k2) {\n    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  rgb() {\n    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;\n    x4 = Xn * lab2xyz(x4);\n    y4 = Yn * lab2xyz(y4);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),\n      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),\n      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),\n      this.opacity\n    );\n  }\n}));\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\nfunction lrgb2rgb(x4) {\n  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);\n}\nfunction rgb2lrgb(x4) {\n  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);\n}\nfunction hclConvert(o) {\n  if (o instanceof Hcl)\n    return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab))\n    o = labConvert(o);\n  if (o.a === 0 && o.b === 0)\n    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);\n  var h = Math.atan2(o.b, o.a) * degrees;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\nfunction lch(l, c6, h, opacity2) {\n  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction hcl(h, c6, l, opacity2) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hcl(h, c6, l, opacity2) {\n  this.h = +h;\n  this.c = +c6;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\nfunction hcl2lab(o) {\n  if (isNaN(o.h))\n    return new Lab(o.l, 0, 0, o.opacity);\n  var h = o.h * radians;\n  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n}\ndefine_default(Hcl, hcl, extend(Color, {\n  brighter(k2) {\n    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  darker(k2) {\n    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  rgb() {\n    return hcl2lab(this).rgb();\n  }\n}));\n\n// node_modules/d3-color/src/cubehelix.js\nvar A = -0.14861;\nvar B = 1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = 1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix)\n    return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);\n}\nfunction cubehelix(h, s2, l, opacity2) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Cubehelix(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Cubehelix, cubehelix, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);\n    return new Rgb(\n      255 * (l + a4 * (A * cosh2 + B * sinh2)),\n      255 * (l + a4 * (C * cosh2 + D * sinh2)),\n      255 * (l + a4 * (E * cosh2)),\n      this.opacity\n    );\n  }\n}));\n\n// node_modules/d3-interpolate/src/basis.js\nfunction basis(t13, v0, v1, v2, v3) {\n  var t22 = t13 * t13, t32 = t22 * t13;\n  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;\n}\nfunction basis_default(values2) {\n  var n = values2.length - 1;\n  return function(t) {\n    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/basisClosed.js\nfunction basisClosed_default(values2) {\n  var n = values2.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/constant.js\nvar constant_default3 = (x4) => () => x4;\n\n// node_modules/d3-interpolate/src/color.js\nfunction linear(a4, d) {\n  return function(t) {\n    return a4 + t * d;\n  };\n}\nfunction exponential(a4, b, y4) {\n  return a4 = Math.pow(a4, y4), b = Math.pow(b, y4) - a4, y4 = 1 / y4, function(t) {\n    return Math.pow(a4 + t * b, y4);\n  };\n}\nfunction hue(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b : a4);\n}\nfunction gamma(y4) {\n  return (y4 = +y4) === 1 ? nogamma : function(a4, b) {\n    return b - a4 ? exponential(a4, b, y4) : constant_default3(isNaN(a4) ? b : a4);\n  };\n}\nfunction nogamma(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b : a4);\n}\n\n// node_modules/d3-interpolate/src/rgb.js\nvar rgb_default = function rgbGamma(y4) {\n  var color3 = gamma(y4);\n  function rgb2(start2, end) {\n    var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.r = r(t);\n      start2.g = g(t);\n      start2.b = b(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  }\n  rgb2.gamma = rgbGamma;\n  return rgb2;\n}(1);\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;\n    for (i = 0; i < n; ++i) {\n      color3 = rgb(colors[i]);\n      r[i] = color3.r || 0;\n      g[i] = color3.g || 0;\n      b[i] = color3.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color3.opacity = 1;\n    return function(t) {\n      color3.r = r(t);\n      color3.g = g(t);\n      color3.b = b(t);\n      return color3 + \"\";\n    };\n  };\n}\nvar rgbBasis = rgbSpline(basis_default);\nvar rgbBasisClosed = rgbSpline(basisClosed_default);\n\n// node_modules/d3-interpolate/src/numberArray.js\nfunction numberArray_default(a4, b) {\n  if (!b)\n    b = [];\n  var n = a4 ? Math.min(b.length, a4.length) : 0, c6 = b.slice(), i;\n  return function(t) {\n    for (i = 0; i < n; ++i)\n      c6[i] = a4[i] * (1 - t) + b[i] * t;\n    return c6;\n  };\n}\nfunction isNumberArray(x4) {\n  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);\n}\n\n// node_modules/d3-interpolate/src/array.js\nfunction array_default(a4, b) {\n  return (isNumberArray(b) ? numberArray_default : genericArray)(a4, b);\n}\nfunction genericArray(a4, b) {\n  var nb = b ? b.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x4 = new Array(na), c6 = new Array(nb), i;\n  for (i = 0; i < na; ++i)\n    x4[i] = value_default(a4[i], b[i]);\n  for (; i < nb; ++i)\n    c6[i] = b[i];\n  return function(t) {\n    for (i = 0; i < na; ++i)\n      c6[i] = x4[i](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/date.js\nfunction date_default(a4, b) {\n  var d = /* @__PURE__ */ new Date();\n  return a4 = +a4, b = +b, function(t) {\n    return d.setTime(a4 * (1 - t) + b * t), d;\n  };\n}\n\n// node_modules/d3-interpolate/src/number.js\nfunction number_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return a4 * (1 - t) + b * t;\n  };\n}\n\n// node_modules/d3-interpolate/src/object.js\nfunction object_default(a4, b) {\n  var i = {}, c6 = {}, k2;\n  if (a4 === null || typeof a4 !== \"object\")\n    a4 = {};\n  if (b === null || typeof b !== \"object\")\n    b = {};\n  for (k2 in b) {\n    if (k2 in a4) {\n      i[k2] = value_default(a4[k2], b[k2]);\n    } else {\n      c6[k2] = b[k2];\n    }\n  }\n  return function(t) {\n    for (k2 in i)\n      c6[k2] = i[k2](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/string.js\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\nfunction zero2(b) {\n  return function() {\n    return b;\n  };\n}\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\nfunction string_default(a4, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];\n  a4 = a4 + \"\", b = b + \"\";\n  while ((am = reA.exec(a4)) && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) {\n      bs = b.slice(bi, bs);\n      if (s2[i])\n        s2[i] += bs;\n      else\n        s2[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) {\n      if (s2[i])\n        s2[i] += bm;\n      else\n        s2[++i] = bm;\n    } else {\n      s2[++i] = null;\n      q.push({ i, x: number_default(am, bm) });\n    }\n    bi = reB.lastIndex;\n  }\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s2[i])\n      s2[i] += bs;\n    else\n      s2[++i] = bs;\n  }\n  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {\n    for (var i2 = 0, o; i2 < b; ++i2)\n      s2[(o = q[i2]).i] = o.x(t);\n    return s2.join(\"\");\n  });\n}\n\n// node_modules/d3-interpolate/src/value.js\nfunction value_default(a4, b) {\n  var t = typeof b, c6;\n  return b == null || t === \"boolean\" ? constant_default3(b) : (t === \"number\" ? number_default : t === \"string\" ? (c6 = color(b)) ? (b = c6, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object_default : number_default)(a4, b);\n}\n\n// node_modules/d3-interpolate/src/discrete.js\nfunction discrete_default(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\n// node_modules/d3-interpolate/src/hue.js\nfunction hue_default(a4, b) {\n  var i = hue(+a4, +b);\n  return function(t) {\n    var x4 = i(t);\n    return x4 - 360 * Math.floor(x4 / 360);\n  };\n}\n\n// node_modules/d3-interpolate/src/round.js\nfunction round_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return Math.round(a4 * (1 - t) + b * t);\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/decompose.js\nvar degrees2 = 180 / Math.PI;\nvar identity2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\nfunction decompose_default(a4, b, c6, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a4 * a4 + b * b))\n    a4 /= scaleX, b /= scaleX;\n  if (skewX = a4 * c6 + b * d)\n    c6 -= a4 * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c6 * c6 + d * d))\n    c6 /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a4 * d < b * c6)\n    a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a4) * degrees2,\n    skewX: Math.atan(skewX) * degrees2,\n    scaleX,\n    scaleY\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/parse.js\nvar svgNode;\nfunction parseCss(value) {\n  const m3 = new (typeof DOMMatrix === \"function\" ? DOMMatrix : WebKitCSSMatrix)(value + \"\");\n  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);\n}\nfunction parseSvg(value) {\n  if (value == null)\n    return identity2;\n  if (!svgNode)\n    svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate()))\n    return identity2;\n  value = value.matrix;\n  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\n// node_modules/d3-interpolate/src/transform/index.js\nfunction interpolateTransform(parse2, pxComma, pxParen, degParen) {\n  function pop(s2) {\n    return s2.length ? s2.pop() + \" \" : \"\";\n  }\n  function translate(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb || yb) {\n      s2.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n  function rotate(a4, b, s2, q) {\n    if (a4 !== b) {\n      if (a4 - b > 180)\n        b += 360;\n      else if (b - a4 > 180)\n        a4 += 360;\n      q.push({ i: s2.push(pop(s2) + \"rotate(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"rotate(\" + b + degParen);\n    }\n  }\n  function skewX(a4, b, s2, q) {\n    if (a4 !== b) {\n      q.push({ i: s2.push(pop(s2) + \"skewX(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"skewX(\" + b + degParen);\n    }\n  }\n  function scale3(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(pop(s2) + \"scale(\", null, \",\", null, \")\");\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb !== 1 || yb !== 1) {\n      s2.push(pop(s2) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n  return function(a4, b) {\n    var s2 = [], q = [];\n    a4 = parse2(a4), b = parse2(b);\n    translate(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);\n    rotate(a4.rotate, b.rotate, s2, q);\n    skewX(a4.skewX, b.skewX, s2, q);\n    scale3(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);\n    a4 = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n)\n        s2[(o = q[i]).i] = o.x(t);\n      return s2.join(\"\");\n    };\n  };\n}\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\n// node_modules/d3-interpolate/src/zoom.js\nvar epsilon2 = 1e-12;\nfunction cosh(x4) {\n  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;\n}\nfunction sinh(x4) {\n  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;\n}\nfunction tanh(x4) {\n  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);\n}\nvar zoom_default = function zoomRho(rho, rho2, rho4) {\n  function zoom(p02, p1) {\n    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < epsilon2) {\n      S = Math.log(w1 / w0) / rho;\n      i = function(t) {\n        return [\n          ux0 + t * dx,\n          uy0 + t * dy,\n          w0 * Math.exp(rho * t * S)\n        ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);\n      S = (r1 - r0) / rho;\n      i = function(t) {\n        var s2 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));\n        return [\n          ux0 + u4 * dx,\n          uy0 + u4 * dy,\n          w0 * coshr0 / cosh(rho * s2 + r0)\n        ];\n      };\n    }\n    i.duration = S * 1e3 * rho / Math.SQRT2;\n    return i;\n  }\n  zoom.rho = function(_) {\n    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;\n    return zoomRho(_1, _2, _4);\n  };\n  return zoom;\n}(Math.SQRT2, 2, 4);\n\n// node_modules/d3-interpolate/src/hsl.js\nfunction hsl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.s = s2(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hsl_default = hsl2(hue);\nvar hslLong = hsl2(nogamma);\n\n// node_modules/d3-interpolate/src/lab.js\nfunction lab2(start2, end) {\n  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n  return function(t) {\n    start2.l = l(t);\n    start2.a = a4(t);\n    start2.b = b(t);\n    start2.opacity = opacity2(t);\n    return start2 + \"\";\n  };\n}\n\n// node_modules/d3-interpolate/src/hcl.js\nfunction hcl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.c = c6(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hcl_default = hcl2(hue);\nvar hclLong = hcl2(nogamma);\n\n// node_modules/d3-interpolate/src/cubehelix.js\nfunction cubehelix2(hue2) {\n  return function cubehelixGamma(y4) {\n    y4 = +y4;\n    function cubehelix3(start2, end) {\n      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n      return function(t) {\n        start2.h = h(t);\n        start2.s = s2(t);\n        start2.l = l(Math.pow(t, y4));\n        start2.opacity = opacity2(t);\n        return start2 + \"\";\n      };\n    }\n    cubehelix3.gamma = cubehelixGamma;\n    return cubehelix3;\n  }(1);\n}\nvar cubehelix_default = cubehelix2(hue);\nvar cubehelixLong = cubehelix2(nogamma);\n\n// node_modules/d3-interpolate/src/piecewise.js\nfunction piecewise(interpolate, values2) {\n  if (values2 === void 0)\n    values2 = interpolate, interpolate = value_default;\n  var i = 0, n = values2.length - 1, v2 = values2[0], I = new Array(n < 0 ? 0 : n);\n  while (i < n)\n    I[i] = interpolate(v2, v2 = values2[++i]);\n  return function(t) {\n    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));\n    return I[i2](t - i2);\n  };\n}\n\n// node_modules/d3-interpolate/src/quantize.js\nfunction quantize_default(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i)\n    samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n\n// node_modules/d3-timer/src/timer.js\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1e3;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {\n  setTimeout(f, 17);\n};\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\nfunction clearNow() {\n  clockNow = 0;\n}\nfunction Timer() {\n  this._call = this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time2) {\n    if (typeof callback !== \"function\")\n      throw new TypeError(\"callback is not a function\");\n    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail)\n        taskTail._next = this;\n      else\n        taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time2;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction timer(callback, delay, time2) {\n  var t = new Timer();\n  t.restart(callback, delay, time2);\n  return t;\n}\nfunction timerFlush() {\n  now();\n  ++frame;\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0)\n      t._call.call(void 0, e);\n    t = t._next;\n  }\n  --frame;\n}\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\nfunction poke() {\n  var now2 = clock.now(), delay = now2 - clockLast;\n  if (delay > pokeDelay)\n    clockSkew -= delay, clockLast = now2;\n}\nfunction nap() {\n  var t03, t13 = taskHead, t22, time2 = Infinity;\n  while (t13) {\n    if (t13._call) {\n      if (time2 > t13._time)\n        time2 = t13._time;\n      t03 = t13, t13 = t13._next;\n    } else {\n      t22 = t13._next, t13._next = null;\n      t13 = t03 ? t03._next = t22 : taskHead = t22;\n    }\n  }\n  taskTail = t03;\n  sleep(time2);\n}\nfunction sleep(time2) {\n  if (frame)\n    return;\n  if (timeout)\n    timeout = clearTimeout(timeout);\n  var delay = time2 - clockNow;\n  if (delay > 24) {\n    if (time2 < Infinity)\n      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);\n    if (interval)\n      interval = clearInterval(interval);\n  } else {\n    if (!interval)\n      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\n// node_modules/d3-timer/src/timeout.js\nfunction timeout_default(callback, delay, time2) {\n  var t = new Timer();\n  delay = delay == null ? 0 : +delay;\n  t.restart((elapsed) => {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time2);\n  return t;\n}\n\n// node_modules/d3-timer/src/interval.js\nfunction interval_default(callback, delay, time2) {\n  var t = new Timer(), total = delay;\n  if (delay == null)\n    return t.restart(callback, delay, time2), t;\n  t._restart = t.restart;\n  t.restart = function(callback2, delay2, time3) {\n    delay2 = +delay2, time3 = time3 == null ? now() : +time3;\n    t._restart(function tick(elapsed) {\n      elapsed += total;\n      t._restart(tick, total += delay2, time3);\n      callback2(elapsed);\n    }, delay2, time3);\n  };\n  t.restart(callback, delay, time2);\n  return t;\n}\n\n// node_modules/d3-transition/src/transition/schedule.js\nvar emptyOn = dispatch_default(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\nfunction schedule_default(node, name, id2, index3, group3, timing) {\n  var schedules = node.__transition;\n  if (!schedules)\n    node.__transition = {};\n  else if (id2 in schedules)\n    return;\n  create(node, id2, {\n    name,\n    index: index3,\n    // For context during callback.\n    group: group3,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nfunction init(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > CREATED)\n    throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nfunction set3(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > STARTED)\n    throw new Error(\"too late; already running\");\n  return schedule;\n}\nfunction get2(node, id2) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id2]))\n    throw new Error(\"transition not found\");\n  return schedule;\n}\nfunction create(node, id2, self) {\n  var schedules = node.__transition, tween;\n  schedules[id2] = self;\n  self.timer = timer(schedule, 0, self.time);\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start2, self.delay, self.time);\n    if (self.delay <= elapsed)\n      start2(elapsed - self.delay);\n  }\n  function start2(elapsed) {\n    var i, j, n, o;\n    if (self.state !== SCHEDULED)\n      return stop();\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name)\n        continue;\n      if (o.state === STARTED)\n        return timeout_default(start2);\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } else if (+i < id2) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n    timeout_default(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING)\n      return;\n    self.state = STARTED;\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id2];\n    for (var i in schedules)\n      return;\n    delete node.__transition;\n  }\n}\n\n// node_modules/d3-transition/src/interrupt.js\nfunction interrupt_default(node, name) {\n  var schedules = node.__transition, schedule, active, empty4 = true, i;\n  if (!schedules)\n    return;\n  name = name == null ? null : name + \"\";\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) {\n      empty4 = false;\n      continue;\n    }\n    active = schedule.state > STARTING && schedule.state < ENDING;\n    schedule.state = ENDED;\n    schedule.timer.stop();\n    schedule.on.call(active ? \"interrupt\" : \"cancel\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n  if (empty4)\n    delete node.__transition;\n}\n\n// node_modules/d3-transition/src/selection/interrupt.js\nfunction interrupt_default2(name) {\n  return this.each(function() {\n    interrupt_default(this, name);\n  });\n}\n\n// node_modules/d3-transition/src/transition/tween.js\nfunction tweenRemove(id2, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tweenFunction(id2, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n)\n        tween1.push(t);\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tween_default(name, value) {\n  var id2 = this._id;\n  name += \"\";\n  if (arguments.length < 2) {\n    var tween = get2(this.node(), id2).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));\n}\nfunction tweenValue(transition2, name, value) {\n  var id2 = transition2._id;\n  transition2.each(function() {\n    var schedule = set3(this, id2);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n  return function(node) {\n    return get2(node, id2).value[name];\n  };\n}\n\n// node_modules/d3-transition/src/transition/interpolate.js\nfunction interpolate_default(a4, b) {\n  var c6;\n  return (typeof b === \"number\" ? number_default : b instanceof color ? rgb_default : (c6 = color(b)) ? (b = c6, rgb_default) : string_default)(a4, b);\n}\n\n// node_modules/d3-transition/src/transition/attr.js\nfunction attrRemove2(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS2(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttribute(name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrConstantNS2(fullname, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttributeNS(fullname.space, fullname.local);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttribute(name);\n    string0 = this.getAttribute(name);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attrFunctionNS2(fullname, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttributeNS(fullname.space, fullname.local);\n    string0 = this.getAttributeNS(fullname.space, fullname.local);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attr_default2(name, value) {\n  var fullname = namespace_default(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate_default;\n  return this.attrTween(name, typeof value === \"function\" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, \"attr.\" + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));\n}\n\n// node_modules/d3-transition/src/transition/attrTween.js\nfunction attrInterpolate(name, i) {\n  return function(t) {\n    this.setAttribute(name, i.call(this, t));\n  };\n}\nfunction attrInterpolateNS(fullname, i) {\n  return function(t) {\n    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));\n  };\n}\nfunction attrTweenNS(fullname, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolateNS(fullname, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween(name, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolate(name, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween_default(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  var fullname = namespace_default(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n}\n\n// node_modules/d3-transition/src/transition/delay.js\nfunction delayFunction(id2, value) {\n  return function() {\n    init(this, id2).delay = +value.apply(this, arguments);\n  };\n}\nfunction delayConstant(id2, value) {\n  return value = +value, function() {\n    init(this, id2).delay = value;\n  };\n}\nfunction delay_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;\n}\n\n// node_modules/d3-transition/src/transition/duration.js\nfunction durationFunction(id2, value) {\n  return function() {\n    set3(this, id2).duration = +value.apply(this, arguments);\n  };\n}\nfunction durationConstant(id2, value) {\n  return value = +value, function() {\n    set3(this, id2).duration = value;\n  };\n}\nfunction duration_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;\n}\n\n// node_modules/d3-transition/src/transition/ease.js\nfunction easeConstant(id2, value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    set3(this, id2).ease = value;\n  };\n}\nfunction ease_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;\n}\n\n// node_modules/d3-transition/src/transition/easeVarying.js\nfunction easeVarying(id2, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (typeof v2 !== \"function\")\n      throw new Error();\n    set3(this, id2).ease = v2;\n  };\n}\nfunction easeVarying_default(value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.each(easeVarying(this._id, value));\n}\n\n// node_modules/d3-transition/src/transition/filter.js\nfunction filter_default2(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/merge.js\nfunction merge_default2(transition2) {\n  if (transition2._id !== this._id)\n    throw new Error();\n  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Transition(merges, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/on.js\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0)\n      t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\nfunction onFunction(id2, name, listener) {\n  var on0, on1, sit = start(name) ? init : set3;\n  return function() {\n    var schedule = sit(this, id2), on = schedule.on;\n    if (on !== on0)\n      (on1 = (on0 = on).copy()).on(name, listener);\n    schedule.on = on1;\n  };\n}\nfunction on_default2(name, listener) {\n  var id2 = this._id;\n  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));\n}\n\n// node_modules/d3-transition/src/transition/remove.js\nfunction removeFunction(id2) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition)\n      if (+i !== id2)\n        return;\n    if (parent)\n      parent.removeChild(this);\n  };\n}\nfunction remove_default2() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n}\n\n// node_modules/d3-transition/src/transition/select.js\nfunction select_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selectAll.js\nfunction selectAll_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {\n          if (child = children2[k2]) {\n            schedule_default(child, name, id2, k2, children2, inherit3);\n          }\n        }\n        subgroups.push(children2);\n        parents.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selection.js\nvar Selection2 = selection_default.prototype.constructor;\nfunction selection_default2() {\n  return new Selection2(this._groups, this._parents);\n}\n\n// node_modules/d3-transition/src/transition/style.js\nfunction styleNull(name, interpolate) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);\n  };\n}\nfunction styleRemove2(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = styleValue(this, name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction styleFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + \"\";\n    if (value1 == null)\n      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction styleMaybeRemove(id2, name) {\n  var on0, on1, listener0, key = \"style.\" + name, event = \"end.\" + key, remove2;\n  return function() {\n    var schedule = set3(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;\n    if (on !== on0 || listener0 !== listener)\n      (on1 = (on0 = on).copy()).on(event, listener0 = listener);\n    schedule.on = on1;\n  };\n}\nfunction style_default2(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate_default;\n  return value == null ? this.styleTween(name, styleNull(name, i)).on(\"end.style.\" + name, styleRemove2(name)) : typeof value === \"function\" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, \"style.\" + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on(\"end.style.\" + name, null);\n}\n\n// node_modules/d3-transition/src/transition/styleTween.js\nfunction styleInterpolate(name, i, priority) {\n  return function(t) {\n    this.style.setProperty(name, i.call(this, t), priority);\n  };\n}\nfunction styleTween(name, value, priority) {\n  var t, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t = (i0 = i) && styleInterpolate(name, i, priority);\n    return t;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction styleTween_default(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n}\n\n// node_modules/d3-transition/src/transition/text.js\nfunction textConstant2(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction2(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\nfunction text_default2(value) {\n  return this.tween(\"text\", typeof value === \"function\" ? textFunction2(tweenValue(this, \"text\", value)) : textConstant2(value == null ? \"\" : value + \"\"));\n}\n\n// node_modules/d3-transition/src/transition/textTween.js\nfunction textInterpolate(i) {\n  return function(t) {\n    this.textContent = i.call(this, t);\n  };\n}\nfunction textTween(value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && textInterpolate(i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction textTween_default(value) {\n  var key = \"text\";\n  if (arguments.length < 1)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, textTween(value));\n}\n\n// node_modules/d3-transition/src/transition/transition.js\nfunction transition_default() {\n  var name = this._name, id0 = this._id, id1 = newId();\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        var inherit3 = get2(node, id0);\n        schedule_default(node, name, id1, i, group3, {\n          time: inherit3.time + inherit3.delay + inherit3.duration,\n          delay: 0,\n          duration: inherit3.duration,\n          ease: inherit3.ease\n        });\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id1);\n}\n\n// node_modules/d3-transition/src/transition/end.js\nfunction end_default() {\n  var on0, on1, that = this, id2 = that._id, size = that.size();\n  return new Promise(function(resolve, reject) {\n    var cancel = { value: reject }, end = { value: function() {\n      if (--size === 0)\n        resolve();\n    } };\n    that.each(function() {\n      var schedule = set3(this, id2), on = schedule.on;\n      if (on !== on0) {\n        on1 = (on0 = on).copy();\n        on1._.cancel.push(cancel);\n        on1._.interrupt.push(cancel);\n        on1._.end.push(end);\n      }\n      schedule.on = on1;\n    });\n    if (size === 0)\n      resolve();\n  });\n}\n\n// node_modules/d3-transition/src/transition/index.js\nvar id = 0;\nfunction Transition(groups2, parents, name, id2) {\n  this._groups = groups2;\n  this._parents = parents;\n  this._name = name;\n  this._id = id2;\n}\nfunction transition(name) {\n  return selection_default().transition(name);\n}\nfunction newId() {\n  return ++id;\n}\nvar selection_prototype = selection_default.prototype;\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: select_default3,\n  selectAll: selectAll_default3,\n  selectChild: selection_prototype.selectChild,\n  selectChildren: selection_prototype.selectChildren,\n  filter: filter_default2,\n  merge: merge_default2,\n  selection: selection_default2,\n  transition: transition_default,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: on_default2,\n  attr: attr_default2,\n  attrTween: attrTween_default,\n  style: style_default2,\n  styleTween: styleTween_default,\n  text: text_default2,\n  textTween: textTween_default,\n  remove: remove_default2,\n  tween: tween_default,\n  delay: delay_default,\n  duration: duration_default,\n  ease: ease_default,\n  easeVarying: easeVarying_default,\n  end: end_default,\n  [Symbol.iterator]: selection_prototype[Symbol.iterator]\n};\n\n// node_modules/d3-ease/src/linear.js\nvar linear2 = (t) => +t;\n\n// node_modules/d3-ease/src/quad.js\nfunction quadIn(t) {\n  return t * t;\n}\nfunction quadOut(t) {\n  return t * (2 - t);\n}\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\n// node_modules/d3-ease/src/poly.js\nvar exponent = 3;\nvar polyIn = function custom(e) {\n  e = +e;\n  function polyIn2(t) {\n    return Math.pow(t, e);\n  }\n  polyIn2.exponent = custom;\n  return polyIn2;\n}(exponent);\nvar polyOut = function custom2(e) {\n  e = +e;\n  function polyOut2(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n  polyOut2.exponent = custom2;\n  return polyOut2;\n}(exponent);\nvar polyInOut = function custom3(e) {\n  e = +e;\n  function polyInOut2(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n  polyInOut2.exponent = custom3;\n  return polyInOut2;\n}(exponent);\n\n// node_modules/d3-ease/src/sin.js\nvar pi = Math.PI;\nvar halfPi = pi / 2;\nfunction sinIn(t) {\n  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);\n}\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\n// node_modules/d3-ease/src/math.js\nfunction tpmt(x4) {\n  return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;\n}\n\n// node_modules/d3-ease/src/exp.js\nfunction expIn(t) {\n  return tpmt(1 - +t);\n}\nfunction expOut(t) {\n  return 1 - tpmt(t);\n}\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;\n}\n\n// node_modules/d3-ease/src/circle.js\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/bounce.js\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/back.js\nvar overshoot = 1.70158;\nvar backIn = function custom4(s2) {\n  s2 = +s2;\n  function backIn2(t) {\n    return (t = +t) * t * (s2 * (t - 1) + t);\n  }\n  backIn2.overshoot = custom4;\n  return backIn2;\n}(overshoot);\nvar backOut = function custom5(s2) {\n  s2 = +s2;\n  function backOut2(t) {\n    return --t * t * ((t + 1) * s2 + t) + 1;\n  }\n  backOut2.overshoot = custom5;\n  return backOut2;\n}(overshoot);\nvar backInOut = function custom6(s2) {\n  s2 = +s2;\n  function backInOut2(t) {\n    return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;\n  }\n  backInOut2.overshoot = custom6;\n  return backInOut2;\n}(overshoot);\n\n// node_modules/d3-ease/src/elastic.js\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\nvar elasticIn = function custom7(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticIn2(t) {\n    return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);\n  }\n  elasticIn2.amplitude = function(a5) {\n    return custom7(a5, p * tau);\n  };\n  elasticIn2.period = function(p2) {\n    return custom7(a4, p2);\n  };\n  return elasticIn2;\n}(amplitude, period);\nvar elasticOut = function custom8(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticOut2(t) {\n    return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);\n  }\n  elasticOut2.amplitude = function(a5) {\n    return custom8(a5, p * tau);\n  };\n  elasticOut2.period = function(p2) {\n    return custom8(a4, p2);\n  };\n  return elasticOut2;\n}(amplitude, period);\nvar elasticInOut = function custom9(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticInOut2(t) {\n    return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;\n  }\n  elasticInOut2.amplitude = function(a5) {\n    return custom9(a5, p * tau);\n  };\n  elasticInOut2.period = function(p2) {\n    return custom9(a4, p2);\n  };\n  return elasticInOut2;\n}(amplitude, period);\n\n// node_modules/d3-transition/src/selection/transition.js\nvar defaultTiming = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\nfunction inherit(node, id2) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id2])) {\n    if (!(node = node.parentNode)) {\n      throw new Error(`transition ${id2} not found`);\n    }\n  }\n  return timing;\n}\nfunction transition_default2(name) {\n  var id2, timing;\n  if (name instanceof Transition) {\n    id2 = name._id, name = name._name;\n  } else {\n    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        schedule_default(node, name, id2, i, group3, timing || inherit(node, id2));\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/selection/index.js\nselection_default.prototype.interrupt = interrupt_default2;\nselection_default.prototype.transition = transition_default2;\n\n// node_modules/d3-transition/src/active.js\nvar root2 = [null];\nfunction active_default(node, name) {\n  var schedules = node.__transition, schedule, i;\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n        return new Transition([[node]], root2, name, +i);\n      }\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-brush/src/constant.js\nvar constant_default4 = (x4) => () => x4;\n\n// node_modules/d3-brush/src/event.js\nfunction BrushEvent(type2, {\n  sourceEvent,\n  target,\n  selection: selection2,\n  mode: mode2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    selection: { value: selection2, enumerable: true, configurable: true },\n    mode: { value: mode2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-brush/src/noevent.js\nfunction nopropagation2(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default2(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-brush/src/brush.js\nvar MODE_DRAG = { name: \"drag\" };\nvar MODE_SPACE = { name: \"space\" };\nvar MODE_HANDLE = { name: \"handle\" };\nvar MODE_CENTER = { name: \"center\" };\nvar { abs, max: max2, min: min2 } = Math;\nfunction number1(e) {\n  return [+e[0], +e[1]];\n}\nfunction number22(e) {\n  return [number1(e[0]), number1(e[1])];\n}\nvar X = {\n  name: \"x\",\n  handles: [\"w\", \"e\"].map(type),\n  input: function(x4, e) {\n    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][0], xy[1][0]];\n  }\n};\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y4, e) {\n    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][1], xy[1][1]];\n  }\n};\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"w\", \"e\", \"s\", \"nw\", \"ne\", \"sw\", \"se\"].map(type),\n  input: function(xy) {\n    return xy == null ? null : number22(xy);\n  },\n  output: function(xy) {\n    return xy;\n  }\n};\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\nvar signsX = {\n  overlay: 1,\n  selection: 1,\n  n: null,\n  e: 1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: 1,\n  se: 1,\n  sw: -1\n};\nvar signsY = {\n  overlay: 1,\n  selection: 1,\n  n: -1,\n  e: null,\n  s: 1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: 1,\n  sw: 1\n};\nfunction type(t) {\n  return { type: t };\n}\nfunction defaultFilter2(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultExtent() {\n  var svg2 = this.ownerSVGElement || this;\n  if (svg2.hasAttribute(\"viewBox\")) {\n    svg2 = svg2.viewBox.baseVal;\n    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];\n  }\n  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];\n}\nfunction defaultTouchable2() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction local2(node) {\n  while (!node.__brush)\n    if (!(node = node.parentNode))\n      return;\n  return node.__brush;\n}\nfunction empty3(extent3) {\n  return extent3[0][0] === extent3[1][0] || extent3[0][1] === extent3[1][1];\n}\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\nfunction brushX() {\n  return brush(X);\n}\nfunction brushY() {\n  return brush(Y);\n}\nfunction brush_default() {\n  return brush(XY);\n}\nfunction brush(dim) {\n  var extent3 = defaultExtent, filter4 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default(\"start\", \"brush\", \"end\"), handleSize = 6, touchending;\n  function brush2(group3) {\n    var overlay = group3.property(\"__brush\", initialize).selectAll(\".overlay\").data([type(\"overlay\")]);\n    overlay.enter().append(\"rect\").attr(\"class\", \"overlay\").attr(\"pointer-events\", \"all\").attr(\"cursor\", cursors.overlay).merge(overlay).each(function() {\n      var extent4 = local2(this).extent;\n      select_default2(this).attr(\"x\", extent4[0][0]).attr(\"y\", extent4[0][1]).attr(\"width\", extent4[1][0] - extent4[0][0]).attr(\"height\", extent4[1][1] - extent4[0][1]);\n    });\n    group3.selectAll(\".selection\").data([type(\"selection\")]).enter().append(\"rect\").attr(\"class\", \"selection\").attr(\"cursor\", cursors.selection).attr(\"fill\", \"#777\").attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"#fff\").attr(\"shape-rendering\", \"crispEdges\");\n    var handle = group3.selectAll(\".handle\").data(dim.handles, function(d) {\n      return d.type;\n    });\n    handle.exit().remove();\n    handle.enter().append(\"rect\").attr(\"class\", function(d) {\n      return \"handle handle--\" + d.type;\n    }).attr(\"cursor\", function(d) {\n      return cursors[d.type];\n    });\n    group3.each(redraw).attr(\"fill\", \"none\").attr(\"pointer-events\", \"all\").on(\"mousedown.brush\", started).filter(touchable).on(\"touchstart.brush\", started).on(\"touchmove.brush\", touchmoved).on(\"touchend.brush touchcancel.brush\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  brush2.move = function(group3, selection2, event) {\n    if (group3.tween) {\n      group3.on(\"start.brush\", function(event2) {\n        emitter(this, arguments).beforestart().start(event2);\n      }).on(\"interrupt.brush end.brush\", function(event2) {\n        emitter(this, arguments).end(event2);\n      }).tween(\"brush\", function() {\n        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(this, arguments) : selection2, state.extent), i = value_default(selection0, selection1);\n        function tween(t) {\n          state.selection = t === 1 && selection1 === null ? null : i(t);\n          redraw.call(that);\n          emit.brush();\n        }\n        return selection0 !== null && selection1 !== null ? tween : tween(1);\n      });\n    } else {\n      group3.each(function() {\n        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();\n        interrupt_default(that);\n        state.selection = selection1 === null ? null : selection1;\n        redraw.call(that);\n        emit.start(event).brush(event).end(event);\n      });\n    }\n  };\n  brush2.clear = function(group3, event) {\n    brush2.move(group3, null, event);\n  };\n  function redraw() {\n    var group3 = select_default2(this), selection2 = local2(this).selection;\n    if (selection2) {\n      group3.selectAll(\".selection\").style(\"display\", null).attr(\"x\", selection2[0][0]).attr(\"y\", selection2[0][1]).attr(\"width\", selection2[1][0] - selection2[0][0]).attr(\"height\", selection2[1][1] - selection2[0][1]);\n      group3.selectAll(\".handle\").style(\"display\", null).attr(\"x\", function(d) {\n        return d.type[d.type.length - 1] === \"e\" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;\n      }).attr(\"y\", function(d) {\n        return d.type[0] === \"s\" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;\n      }).attr(\"width\", function(d) {\n        return d.type === \"n\" || d.type === \"s\" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;\n      }).attr(\"height\", function(d) {\n        return d.type === \"e\" || d.type === \"w\" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;\n      });\n    } else {\n      group3.selectAll(\".selection,.handle\").style(\"display\", \"none\").attr(\"x\", null).attr(\"y\", null).attr(\"width\", null).attr(\"height\", null);\n    }\n  }\n  function emitter(that, args, clean) {\n    var emit = that.__brush.emitter;\n    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);\n  }\n  function Emitter(that, args, clean) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n    this.clean = clean;\n  }\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1)\n        this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function(event, mode2) {\n      if (this.starting)\n        this.starting = false, this.emit(\"start\", event, mode2);\n      else\n        this.emit(\"brush\", event);\n      return this;\n    },\n    brush: function(event, mode2) {\n      this.emit(\"brush\", event, mode2);\n      return this;\n    },\n    end: function(event, mode2) {\n      if (--this.active === 0)\n        delete this.state.emitter, this.emit(\"end\", event, mode2);\n      return this;\n    },\n    emit: function(type2, event, mode2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new BrushEvent(type2, {\n          sourceEvent: event,\n          target: brush2,\n          selection: dim.output(this.state.selection),\n          mode: mode2,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function started(event) {\n    if (touchending && !event.touches)\n      return;\n    if (!filter4.apply(this, arguments))\n      return;\n    var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = \"overlay\" : type2) === \"selection\" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local2(that), extent4 = state.extent, selection2 = state.selection, W = extent4[0][0], w0, w1, N = extent4[0][1], n0, n1, E2 = extent4[1][0], e0, e1, S = extent4[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {\n      const i = t.identifier;\n      t = pointer_default(t, that);\n      t.point0 = t.slice();\n      t.identifier = i;\n      return t;\n    });\n    interrupt_default(that);\n    var emit = emitter(that, arguments, true).beforestart();\n    if (type2 === \"overlay\") {\n      if (selection2)\n        moving = true;\n      const pts = [points[0], points[1] || points[0]];\n      state.selection = selection2 = [[\n        w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),\n        n0 = dim === X ? N : min2(pts[0][1], pts[1][1])\n      ], [\n        e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),\n        s0 = dim === X ? S : max2(pts[0][1], pts[1][1])\n      ]];\n      if (points.length > 1)\n        move(event);\n    } else {\n      w0 = selection2[0][0];\n      n0 = selection2[0][1];\n      e0 = selection2[1][0];\n      s0 = selection2[1][1];\n    }\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n    var group3 = select_default2(that).attr(\"pointer-events\", \"none\");\n    var overlay = group3.selectAll(\".overlay\").attr(\"cursor\", cursors[type2]);\n    if (event.touches) {\n      emit.moved = moved;\n      emit.ended = ended;\n    } else {\n      var view = select_default2(event.view).on(\"mousemove.brush\", moved, true).on(\"mouseup.brush\", ended, true);\n      if (keys)\n        view.on(\"keydown.brush\", keydowned, true).on(\"keyup.brush\", keyupped, true);\n      nodrag_default(event.view);\n    }\n    redraw.call(that);\n    emit.start(event, mode2.name);\n    function moved(event2) {\n      for (const p of event2.changedTouches || [event2]) {\n        for (const d of points)\n          if (d.identifier === p.identifier)\n            d.cur = pointer_default(p, that);\n      }\n      if (shifting && !lockX && !lockY && points.length === 1) {\n        const point6 = points[0];\n        if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))\n          lockY = true;\n        else\n          lockX = true;\n      }\n      for (const point6 of points)\n        if (point6.cur)\n          point6[0] = point6.cur[0], point6[1] = point6.cur[1];\n      moving = true;\n      noevent_default2(event2);\n      move(event2);\n    }\n    function move(event2) {\n      const point6 = points[0], point0 = point6.point0;\n      var t;\n      dx = point6[0] - point0[0];\n      dy = point6[1] - point0[1];\n      switch (mode2) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX)\n            dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY)\n            dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (points[1]) {\n            if (signX)\n              w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;\n            if (signY)\n              n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;\n          } else {\n            if (signX < 0)\n              dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;\n            else if (signX > 0)\n              dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;\n            if (signY < 0)\n              dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n            else if (signY > 0)\n              dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          }\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX)\n            w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));\n          if (signY)\n            n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));\n          break;\n        }\n      }\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type2 in flipX)\n          overlay.attr(\"cursor\", cursors[type2 = flipX[type2]]);\n      }\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type2 in flipY)\n          overlay.attr(\"cursor\", cursors[type2 = flipY[type2]]);\n      }\n      if (state.selection)\n        selection2 = state.selection;\n      if (lockX)\n        w1 = selection2[0][0], e1 = selection2[1][0];\n      if (lockY)\n        n1 = selection2[0][1], s1 = selection2[1][1];\n      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush(event2, mode2.name);\n      }\n    }\n    function ended(event2) {\n      nopropagation2(event2);\n      if (event2.touches) {\n        if (event2.touches.length)\n          return;\n        if (touchending)\n          clearTimeout(touchending);\n        touchending = setTimeout(function() {\n          touchending = null;\n        }, 500);\n      } else {\n        yesdrag(event2.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group3.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection)\n        selection2 = state.selection;\n      if (empty3(selection2))\n        state.selection = null, redraw.call(that);\n      emit.end(event2, mode2.name);\n    }\n    function keydowned(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          shifting = signX && signY;\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_HANDLE) {\n            if (signX)\n              e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY)\n              s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode2 = MODE_CENTER;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1 - dx;\n            else if (signX > 0)\n              w0 = w1 - dx;\n            if (signY < 0)\n              s0 = s1 - dy;\n            else if (signY > 0)\n              n0 = n1 - dy;\n            mode2 = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n    function keyupped(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move(event2);\n          }\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1;\n            else if (signX > 0)\n              w0 = w1;\n            if (signY < 0)\n              s0 = s1;\n            else if (signY > 0)\n              n0 = n1;\n            mode2 = MODE_HANDLE;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_SPACE) {\n            if (event2.altKey) {\n              if (signX)\n                e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY)\n                s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode2 = MODE_CENTER;\n            } else {\n              if (signX < 0)\n                e0 = e1;\n              else if (signX > 0)\n                w0 = w1;\n              if (signY < 0)\n                s0 = s1;\n              else if (signY > 0)\n                n0 = n1;\n              mode2 = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type2]);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n  }\n  function touchmoved(event) {\n    emitter(this, arguments).moved(event);\n  }\n  function touchended(event) {\n    emitter(this, arguments).ended(event);\n  }\n  function initialize() {\n    var state = this.__brush || { selection: null };\n    state.extent = number22(extent3.apply(this, arguments));\n    state.dim = dim;\n    return state;\n  }\n  brush2.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default4(number22(_)), brush2) : extent3;\n  };\n  brush2.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : filter4;\n  };\n  brush2.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : touchable;\n  };\n  brush2.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush2) : handleSize;\n  };\n  brush2.keyModifiers = function(_) {\n    return arguments.length ? (keys = !!_, brush2) : keys;\n  };\n  brush2.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush2 : value;\n  };\n  return brush2;\n}\n\n// node_modules/d3-chord/src/math.js\nvar abs2 = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi2 = Math.PI;\nvar halfPi2 = pi2 / 2;\nvar tau2 = pi2 * 2;\nvar max3 = Math.max;\nvar epsilon3 = 1e-12;\n\n// node_modules/d3-chord/src/chord.js\nfunction range2(i, j) {\n  return Array.from({ length: j - i }, (_, k2) => i + k2);\n}\nfunction compareValue(compare) {\n  return function(a4, b) {\n    return compare(\n      a4.source.value + a4.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\nfunction chord_default() {\n  return chord(false, false);\n}\nfunction chordTranspose() {\n  return chord(false, true);\n}\nfunction chordDirected() {\n  return chord(true, false);\n}\nfunction chord(directed, transpose2) {\n  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;\n  function chord2(matrix) {\n    var n = matrix.length, groupSums = new Array(n), groupIndex2 = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;\n    matrix = Float64Array.from({ length: n * n }, transpose2 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);\n    for (let i = 0; i < n; ++i) {\n      let x4 = 0;\n      for (let j = 0; j < n; ++j)\n        x4 += matrix[i * n + j] + directed * matrix[j * n + i];\n      k2 += groupSums[i] = x4;\n    }\n    k2 = max3(0, tau2 - padAngle * n) / k2;\n    dx = k2 ? padAngle : tau2 / n;\n    {\n      let x4 = 0;\n      if (sortGroups)\n        groupIndex2.sort((a4, b) => sortGroups(groupSums[a4], groupSums[b]));\n      for (const i of groupIndex2) {\n        const x06 = x4;\n        if (directed) {\n          const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(a4 < 0 ? -matrix[~a4 * n + i] : matrix[i * n + a4], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            if (j < 0) {\n              const chord3 = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[~j * n + i] * k2, value: matrix[~j * n + i] };\n            } else {\n              const chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        } else {\n          const subgroupIndex = range2(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(matrix[i * n + a4], matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            let chord3;\n            if (i < j) {\n              chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            } else {\n              chord3 = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n              if (i === j)\n                chord3.source = chord3.target;\n            }\n            if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {\n              const source = chord3.source;\n              chord3.source = chord3.target;\n              chord3.target = source;\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        }\n        x4 += dx;\n      }\n    }\n    chords = Object.values(chords);\n    chords.groups = groups2;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n  chord2.padAngle = function(_) {\n    return arguments.length ? (padAngle = max3(0, _), chord2) : padAngle;\n  };\n  chord2.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord2) : sortGroups;\n  };\n  chord2.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;\n  };\n  chord2.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;\n  };\n  return chord2;\n}\n\n// node_modules/d3-path/src/path.js\nvar pi3 = Math.PI;\nvar tau3 = 2 * pi3;\nvar epsilon4 = 1e-6;\nvar tauEpsilon = tau3 - epsilon4;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new Error(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append;\n  const k2 = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n    }\n  };\n}\nvar Path = class {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x4, y4) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x4, y4) {\n    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  quadraticCurveTo(x12, y12, x4, y4) {\n    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  bezierCurveTo(x12, y12, x22, y22, x4, y4) {\n    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arcTo(x12, y12, x22, y22, r) {\n    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x12},${this._y1 = y12}`;\n    } else if (!(l01_2 > epsilon4))\n      ;\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {\n      this._append`L${this._x1 = x12},${this._y1 = y12}`;\n    } else {\n      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;\n      if (Math.abs(t01 - 1) > epsilon4) {\n        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;\n      }\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;\n    }\n  }\n  arc(x4, y4, r, a0, a1, ccw) {\n    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;\n    if (this._x1 === null) {\n      this._append`M${x06},${y06}`;\n    } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {\n      this._append`L${x06},${y06}`;\n    }\n    if (!r)\n      return;\n    if (da2 < 0)\n      da2 = da2 % tau3 + tau3;\n    if (da2 > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;\n    } else if (da2 > epsilon4) {\n      this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x4, y4, w, h) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n};\nfunction path() {\n  return new Path();\n}\npath.prototype = Path.prototype;\nfunction pathRound(digits = 3) {\n  return new Path(+digits);\n}\n\n// node_modules/d3-chord/src/array.js\nvar slice2 = Array.prototype.slice;\n\n// node_modules/d3-chord/src/constant.js\nfunction constant_default5(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-chord/src/ribbon.js\nfunction defaultSource(d) {\n  return d.source;\n}\nfunction defaultTarget(d) {\n  return d.target;\n}\nfunction defaultRadius(d) {\n  return d.radius;\n}\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\nfunction defaultPadAngle() {\n  return 0;\n}\nfunction defaultArrowheadRadius() {\n  return 10;\n}\nfunction ribbon(headRadius) {\n  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;\n  function ribbon2() {\n    var buffer, s2 = source.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;\n    if (!context)\n      context = buffer = path();\n    if (ap > epsilon3) {\n      if (abs2(sa1 - sa0) > ap * 2 + epsilon3)\n        sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);\n      else\n        sa0 = sa1 = (sa0 + sa1) / 2;\n      if (abs2(ta1 - ta0) > ap * 2 + epsilon3)\n        ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);\n      else\n        ta0 = ta1 = (ta0 + ta1) / 2;\n    }\n    context.moveTo(sr * cos(sa0), sr * sin(sa0));\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) {\n      if (headRadius) {\n        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;\n        context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));\n        context.lineTo(tr * cos(ta2), tr * sin(ta2));\n        context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));\n      } else {\n        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n        context.arc(0, 0, tr, ta0, ta1);\n      }\n    }\n    context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  if (headRadius)\n    ribbon2.headRadius = function(_) {\n      return arguments.length ? (headRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : headRadius;\n    };\n  ribbon2.radius = function(_) {\n    return arguments.length ? (sourceRadius = targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.sourceRadius = function(_) {\n    return arguments.length ? (sourceRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.targetRadius = function(_) {\n    return arguments.length ? (targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : targetRadius;\n  };\n  ribbon2.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : startAngle;\n  };\n  ribbon2.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : endAngle;\n  };\n  ribbon2.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : padAngle;\n  };\n  ribbon2.source = function(_) {\n    return arguments.length ? (source = _, ribbon2) : source;\n  };\n  ribbon2.target = function(_) {\n    return arguments.length ? (target = _, ribbon2) : target;\n  };\n  ribbon2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;\n  };\n  return ribbon2;\n}\nfunction ribbon_default() {\n  return ribbon();\n}\nfunction ribbonArrow() {\n  return ribbon(defaultArrowheadRadius);\n}\n\n// node_modules/d3-contour/src/array.js\nvar array3 = Array.prototype;\nvar slice3 = array3.slice;\n\n// node_modules/d3-contour/src/ascending.js\nfunction ascending_default(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/d3-contour/src/area.js\nfunction area_default(ring) {\n  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n)\n    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area2;\n}\n\n// node_modules/d3-contour/src/constant.js\nvar constant_default6 = (x4) => () => x4;\n\n// node_modules/d3-contour/src/contains.js\nfunction contains_default(ring, hole) {\n  var i = -1, n = hole.length, c6;\n  while (++i < n)\n    if (c6 = ringContains(ring, hole[i]))\n      return c6;\n  return 0;\n}\nfunction ringContains(ring, point6) {\n  var x4 = point6[0], y4 = point6[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi7 = ring[i], xi = pi7[0], yi = pi7[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi7, pj, point6))\n      return 0;\n    if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)\n      contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a4, b, c6) {\n  var i;\n  return collinear(a4, b, c6) && within(a4[i = +(a4[0] === b[0])], c6[i], b[i]);\n}\nfunction collinear(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b[1] - a4[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\n// node_modules/d3-contour/src/noop.js\nfunction noop_default() {\n}\n\n// node_modules/d3-contour/src/contours.js\nvar cases = [\n  [],\n  [[[1, 1.5], [0.5, 1]]],\n  [[[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [0.5, 1]]],\n  [[[1, 0.5], [1.5, 1]]],\n  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],\n  [[[1, 0.5], [1, 1.5]]],\n  [[[1, 0.5], [0.5, 1]]],\n  [[[0.5, 1], [1, 0.5]]],\n  [[[1, 1.5], [1, 0.5]]],\n  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [1, 0.5]]],\n  [[[0.5, 1], [1.5, 1]]],\n  [[[1, 1.5], [1.5, 1]]],\n  [[[0.5, 1], [1, 1.5]]],\n  []\n];\nfunction contours_default() {\n  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;\n  function contours(values2) {\n    var tz = threshold2(values2);\n    if (!Array.isArray(tz)) {\n      const e = extent(values2, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1])\n        tz.pop();\n      while (tz[1] < e[0])\n        tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending_default);\n    }\n    return tz.map((value) => contour2(values2, value));\n  }\n  function contour2(values2, value) {\n    const v2 = value == null ? NaN : +value;\n    if (isNaN(v2))\n      throw new Error(`invalid value: ${value}`);\n    var polygons = [], holes = [];\n    isorings(values2, v2, function(ring) {\n      smooth(ring, values2, v2);\n      if (area_default(ring) > 0)\n        polygons.push([ring]);\n      else\n        holes.push(ring);\n    });\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: \"MultiPolygon\",\n      value,\n      coordinates: polygons\n    };\n  }\n  function isorings(values2, value, callback) {\n    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x4, y4, t03, t13, t22, t32;\n    x4 = y4 = -1;\n    t13 = above(values2[0], value);\n    cases[t13 << 1].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t03 = t13, t13 = above(values2[x4 + 1], value);\n      cases[t03 | t13 << 1].forEach(stitch);\n    }\n    cases[t13 << 0].forEach(stitch);\n    while (++y4 < dy - 1) {\n      x4 = -1;\n      t13 = above(values2[y4 * dx + dx], value);\n      t22 = above(values2[y4 * dx], value);\n      cases[t13 << 1 | t22 << 2].forEach(stitch);\n      while (++x4 < dx - 1) {\n        t03 = t13, t13 = above(values2[y4 * dx + dx + x4 + 1], value);\n        t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);\n      }\n      cases[t13 | t22 << 3].forEach(stitch);\n    }\n    x4 = -1;\n    t22 = values2[y4 * dx] >= value;\n    cases[t22 << 2].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n      cases[t22 << 2 | t32 << 3].forEach(stitch);\n    }\n    cases[t22 << 3].forEach(stitch);\n    function stitch(line2) {\n      var start2 = [line2[0][0] + x4, line2[0][1] + y4], end = [line2[1][0] + x4, line2[1][1] + y4], startIndex = index3(start2), endIndex = index3(end), f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start2);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };\n      }\n    }\n  }\n  function index3(point6) {\n    return point6[0] * 2 + point6[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values2, value) {\n    ring.forEach(function(point6) {\n      var x4 = point6[0], y4 = point6[1], xt = x4 | 0, yt = y4 | 0, v1 = valid(values2[yt * dx + xt]);\n      if (x4 > 0 && x4 < dx && xt === x4) {\n        point6[0] = smooth1(x4, valid(values2[yt * dx + xt - 1]), v1, value);\n      }\n      if (y4 > 0 && y4 < dy && yt === y4) {\n        point6[1] = smooth1(y4, valid(values2[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n  contours.contour = contour2;\n  contours.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold2;\n  };\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction finite(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction above(x4, value) {\n  return x4 == null ? false : +x4 >= value;\n}\nfunction valid(v2) {\n  return v2 == null || isNaN(v2 = +v2) ? -Infinity : v2;\n}\nfunction smooth1(x4, v0, v1, value) {\n  const a4 = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a4) || isFinite(b) ? a4 / b : Math.sign(a4) / Math.sign(b);\n  return isNaN(d) ? x4 : x4 + d - 0.5;\n}\n\n// node_modules/d3-contour/src/density.js\nfunction defaultX(d) {\n  return d[0];\n}\nfunction defaultY(d) {\n  return d[1];\n}\nfunction defaultWeight() {\n  return 1;\n}\nfunction density_default() {\n  var x4 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m3 = dy + o * 2 >> k2, threshold2 = constant_default6(20);\n  function grid(data) {\n    var values2 = new Float32Array(n * m3), pow2k = Math.pow(2, -k2), i = -1;\n    for (const d of data) {\n      var xi = (x4(d, ++i, data) + o) * pow2k, yi = (y4(d, i, data) + o) * pow2k, wi = +weight(d, i, data);\n      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m3) {\n        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;\n        values2[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;\n        values2[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;\n        values2[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;\n        values2[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;\n      }\n    }\n    blur2({ data: values2, width: n, height: m3 }, r * pow2k);\n    return values2;\n  }\n  function density2(data) {\n    var values2 = grid(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k2);\n    if (!Array.isArray(tz)) {\n      tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);\n    }\n    return contours_default().size([n, m3]).thresholds(tz.map((d) => d * pow4k))(values2).map((c6, i) => (c6.value = +tz[i], transform2(c6)));\n  }\n  density2.contours = function(data) {\n    var values2 = grid(data), contours = contours_default().size([n, m3]), pow4k = Math.pow(2, 2 * k2), contour2 = (value) => {\n      value = +value;\n      var c6 = transform2(contours.contour(values2, value * pow4k));\n      c6.value = value;\n      return c6;\n    };\n    Object.defineProperty(contour2, \"max\", { get: () => max(values2) / pow4k });\n    return contour2;\n  };\n  function transform2(geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  }\n  function transformPolygon(coordinates2) {\n    coordinates2.forEach(transformRing);\n  }\n  function transformRing(coordinates2) {\n    coordinates2.forEach(transformPoint);\n  }\n  function transformPoint(coordinates2) {\n    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;\n    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;\n  }\n  function resize() {\n    o = r * 3;\n    n = dx + o * 2 >> k2;\n    m3 = dy + o * 2 >> k2;\n    return density2;\n  }\n  density2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : x4;\n  };\n  density2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : y4;\n  };\n  density2.weight = function(_) {\n    return arguments.length ? (weight = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : weight;\n  };\n  density2.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = +_[0], _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, resize();\n  };\n  density2.cellSize = function(_) {\n    if (!arguments.length)\n      return 1 << k2;\n    if (!((_ = +_) >= 1))\n      throw new Error(\"invalid cell size\");\n    return k2 = Math.floor(Math.log(_) / Math.LN2), resize();\n  };\n  density2.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density2) : threshold2;\n  };\n  density2.bandwidth = function(_) {\n    if (!arguments.length)\n      return Math.sqrt(r * (r + 1));\n    if (!((_ = +_) >= 0))\n      throw new Error(\"invalid bandwidth\");\n    return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();\n  };\n  return density2;\n}\n\n// node_modules/robust-predicates/esm/util.js\nvar epsilon5 = 11102230246251565e-32;\nvar splitter = 134217729;\nvar resulterrbound = (3 + 8 * epsilon5) * epsilon5;\nfunction sum2(elen, e, flen, f, h) {\n  let Q, Qnew, hh, bvirt;\n  let enow = e[0];\n  let fnow = f[0];\n  let eindex = 0;\n  let findex = 0;\n  if (fnow > enow === fnow > -enow) {\n    Q = enow;\n    enow = e[++eindex];\n  } else {\n    Q = fnow;\n    fnow = f[++findex];\n  }\n  let hindex = 0;\n  if (eindex < elen && findex < flen) {\n    if (fnow > enow === fnow > -enow) {\n      Qnew = enow + Q;\n      hh = Q - (Qnew - enow);\n      enow = e[++eindex];\n    } else {\n      Qnew = fnow + Q;\n      hh = Q - (Qnew - fnow);\n      fnow = f[++findex];\n    }\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n    while (eindex < elen && findex < flen) {\n      if (fnow > enow === fnow > -enow) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n      } else {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n      }\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n    }\n  }\n  while (eindex < elen) {\n    Qnew = Q + enow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (enow - bvirt);\n    enow = e[++eindex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  while (findex < flen) {\n    Qnew = Q + fnow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n    fnow = f[++findex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  if (Q !== 0 || hindex === 0) {\n    h[hindex++] = Q;\n  }\n  return hindex;\n}\nfunction estimate(elen, e) {\n  let Q = e[0];\n  for (let i = 1; i < elen; i++)\n    Q += e[i];\n  return Q;\n}\nfunction vec(n) {\n  return new Float64Array(n);\n}\n\n// node_modules/robust-predicates/esm/orient2d.js\nvar ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;\nvar ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;\nvar ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;\nvar B2 = vec(4);\nvar C1 = vec(8);\nvar C2 = vec(12);\nvar D2 = vec(16);\nvar u = vec(4);\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n  let acxtail, acytail, bcxtail, bcytail;\n  let bvirt, c6, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t13, t03, u33;\n  const acx = ax - cx;\n  const bcx = bx - cx;\n  const acy = ay - cy;\n  const bcy = by - cy;\n  s1 = acx * bcy;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcx;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  B2[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  B2[3] = u33;\n  let det = estimate(4, B2);\n  let errbound = ccwerrboundB * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return det;\n  }\n  bvirt = ax - acx;\n  acxtail = ax - (acx + bvirt) + (bvirt - cx);\n  bvirt = bx - bcx;\n  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n  bvirt = ay - acy;\n  acytail = ay - (acy + bvirt) + (bvirt - cy);\n  bvirt = by - bcy;\n  bcytail = by - (bcy + bvirt) + (bvirt - cy);\n  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n    return det;\n  }\n  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n  if (det >= errbound || -det >= errbound)\n    return det;\n  s1 = acxtail * bcy;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcx;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C1len = sum2(4, B2, 4, u, C1);\n  s1 = acx * bcytail;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcxtail;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C2len = sum2(C1len, C1, 4, u, C2);\n  s1 = acxtail * bcytail;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcxtail;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const Dlen = sum2(C2len, C2, 4, u, D2);\n  return D2[Dlen - 1];\n}\nfunction orient2d(ax, ay, bx, by, cx, cy) {\n  const detleft = (ay - cy) * (bx - cx);\n  const detright = (ax - cx) * (by - cy);\n  const det = detleft - detright;\n  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)\n    return det;\n  const detsum = Math.abs(detleft + detright);\n  if (Math.abs(det) >= ccwerrboundA * detsum)\n    return det;\n  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\n// node_modules/robust-predicates/esm/orient3d.js\nvar o3derrboundA = (7 + 56 * epsilon5) * epsilon5;\nvar o3derrboundB = (3 + 28 * epsilon5) * epsilon5;\nvar o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;\nvar bc = vec(4);\nvar ca = vec(4);\nvar ab = vec(4);\nvar at_b = vec(4);\nvar at_c = vec(4);\nvar bt_c = vec(4);\nvar bt_a = vec(4);\nvar ct_a = vec(4);\nvar ct_b = vec(4);\nvar bct = vec(8);\nvar cat = vec(8);\nvar abt = vec(8);\nvar u2 = vec(4);\nvar _8 = vec(8);\nvar _8b = vec(8);\nvar _16 = vec(8);\nvar _12 = vec(12);\nvar fin = vec(192);\nvar fin2 = vec(192);\n\n// node_modules/robust-predicates/esm/incircle.js\nvar iccerrboundA = (10 + 96 * epsilon5) * epsilon5;\nvar iccerrboundB = (4 + 48 * epsilon5) * epsilon5;\nvar iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;\nvar bc2 = vec(4);\nvar ca2 = vec(4);\nvar ab2 = vec(4);\nvar aa = vec(4);\nvar bb = vec(4);\nvar cc = vec(4);\nvar u3 = vec(4);\nvar v = vec(4);\nvar axtbc = vec(8);\nvar aytbc = vec(8);\nvar bxtca = vec(8);\nvar bytca = vec(8);\nvar cxtab = vec(8);\nvar cytab = vec(8);\nvar abt2 = vec(8);\nvar bct2 = vec(8);\nvar cat2 = vec(8);\nvar abtt = vec(4);\nvar bctt = vec(4);\nvar catt = vec(4);\nvar _82 = vec(8);\nvar _162 = vec(16);\nvar _16b = vec(16);\nvar _16c = vec(16);\nvar _32 = vec(32);\nvar _32b = vec(32);\nvar _48 = vec(48);\nvar _64 = vec(64);\nvar fin3 = vec(1152);\nvar fin22 = vec(1152);\n\n// node_modules/robust-predicates/esm/insphere.js\nvar isperrboundA = (16 + 224 * epsilon5) * epsilon5;\nvar isperrboundB = (5 + 72 * epsilon5) * epsilon5;\nvar isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;\nvar ab3 = vec(4);\nvar bc3 = vec(4);\nvar cd = vec(4);\nvar de = vec(4);\nvar ea = vec(4);\nvar ac = vec(4);\nvar bd = vec(4);\nvar ce = vec(4);\nvar da = vec(4);\nvar eb = vec(4);\nvar abc = vec(24);\nvar bcd = vec(24);\nvar cde = vec(24);\nvar dea = vec(24);\nvar eab = vec(24);\nvar abd = vec(24);\nvar bce = vec(24);\nvar cda = vec(24);\nvar deb = vec(24);\nvar eac = vec(24);\nvar adet = vec(1152);\nvar bdet = vec(1152);\nvar cdet = vec(1152);\nvar ddet = vec(1152);\nvar edet = vec(1152);\nvar abdet = vec(2304);\nvar cddet = vec(2304);\nvar cdedet = vec(3456);\nvar deter = vec(5760);\nvar _83 = vec(8);\nvar _8b2 = vec(8);\nvar _8c = vec(8);\nvar _163 = vec(16);\nvar _24 = vec(24);\nvar _482 = vec(48);\nvar _48b = vec(48);\nvar _96 = vec(96);\nvar _192 = vec(192);\nvar _384x = vec(384);\nvar _384y = vec(384);\nvar _384z = vec(384);\nvar _768 = vec(768);\nvar xdet = vec(96);\nvar ydet = vec(96);\nvar zdet = vec(96);\nvar fin4 = vec(1152);\n\n// node_modules/delaunator/index.js\nvar EPSILON = Math.pow(2, -52);\nvar EDGE_STACK = new Uint32Array(512);\nvar Delaunator = class {\n  static from(points, getX = defaultGetX, getY = defaultGetY) {\n    const n = points.length;\n    const coords = new Float64Array(n * 2);\n    for (let i = 0; i < n; i++) {\n      const p = points[i];\n      coords[2 * i] = getX(p);\n      coords[2 * i + 1] = getY(p);\n    }\n    return new Delaunator(coords);\n  }\n  constructor(coords) {\n    const n = coords.length >> 1;\n    if (n > 0 && typeof coords[0] !== \"number\")\n      throw new Error(\"Expected coords to contain numbers.\");\n    this.coords = coords;\n    const maxTriangles = Math.max(2 * n - 5, 0);\n    this._triangles = new Uint32Array(maxTriangles * 3);\n    this._halfedges = new Int32Array(maxTriangles * 3);\n    this._hashSize = Math.ceil(Math.sqrt(n));\n    this._hullPrev = new Uint32Array(n);\n    this._hullNext = new Uint32Array(n);\n    this._hullTri = new Uint32Array(n);\n    this._hullHash = new Int32Array(this._hashSize).fill(-1);\n    this._ids = new Uint32Array(n);\n    this._dists = new Float64Array(n);\n    this.update();\n  }\n  update() {\n    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;\n    const n = coords.length >> 1;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY2 = -Infinity;\n    for (let i = 0; i < n; i++) {\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (x4 < minX)\n        minX = x4;\n      if (y4 < minY)\n        minY = y4;\n      if (x4 > maxX)\n        maxX = x4;\n      if (y4 > maxY2)\n        maxY2 = y4;\n      this._ids[i] = i;\n    }\n    const cx = (minX + maxX) / 2;\n    const cy = (minY + maxY2) / 2;\n    let minDist = Infinity;\n    let i0, i1, i2;\n    for (let i = 0; i < n; i++) {\n      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist) {\n        i0 = i;\n        minDist = d;\n      }\n    }\n    const i0x = coords[2 * i0];\n    const i0y = coords[2 * i0 + 1];\n    minDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0)\n        continue;\n      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist && d > 0) {\n        i1 = i;\n        minDist = d;\n      }\n    }\n    let i1x = coords[2 * i1];\n    let i1y = coords[2 * i1 + 1];\n    let minRadius = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0 || i === i1)\n        continue;\n      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n      if (r < minRadius) {\n        i2 = i;\n        minRadius = r;\n      }\n    }\n    let i2x = coords[2 * i2];\n    let i2y = coords[2 * i2 + 1];\n    if (minRadius === Infinity) {\n      for (let i = 0; i < n; i++) {\n        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];\n      }\n      quicksort(this._ids, this._dists, 0, n - 1);\n      const hull2 = new Uint32Array(n);\n      let j = 0;\n      for (let i = 0, d0 = -Infinity; i < n; i++) {\n        const id2 = this._ids[i];\n        if (this._dists[id2] > d0) {\n          hull2[j++] = id2;\n          d0 = this._dists[id2];\n        }\n      }\n      this.hull = hull2.subarray(0, j);\n      this.triangles = new Uint32Array(0);\n      this.halfedges = new Uint32Array(0);\n      return;\n    }\n    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n      const i = i1;\n      const x4 = i1x;\n      const y4 = i1y;\n      i1 = i2;\n      i1x = i2x;\n      i1y = i2y;\n      i2 = i;\n      i2x = x4;\n      i2y = y4;\n    }\n    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n    this._cx = center2.x;\n    this._cy = center2.y;\n    for (let i = 0; i < n; i++) {\n      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);\n    }\n    quicksort(this._ids, this._dists, 0, n - 1);\n    this._hullStart = i0;\n    let hullSize = 3;\n    hullNext[i0] = hullPrev[i2] = i1;\n    hullNext[i1] = hullPrev[i0] = i2;\n    hullNext[i2] = hullPrev[i1] = i0;\n    hullTri[i0] = 0;\n    hullTri[i1] = 1;\n    hullTri[i2] = 2;\n    hullHash.fill(-1);\n    hullHash[this._hashKey(i0x, i0y)] = i0;\n    hullHash[this._hashKey(i1x, i1y)] = i1;\n    hullHash[this._hashKey(i2x, i2y)] = i2;\n    this.trianglesLen = 0;\n    this._addTriangle(i0, i1, i2, -1, -1, -1);\n    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {\n      const i = this._ids[k2];\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (k2 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)\n        continue;\n      xp = x4;\n      yp = y4;\n      if (i === i0 || i === i1 || i === i2)\n        continue;\n      let start2 = 0;\n      for (let j = 0, key = this._hashKey(x4, y4); j < this._hashSize; j++) {\n        start2 = hullHash[(key + j) % this._hashSize];\n        if (start2 !== -1 && start2 !== hullNext[start2])\n          break;\n      }\n      start2 = hullPrev[start2];\n      let e = start2, q;\n      while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n        e = q;\n        if (e === start2) {\n          e = -1;\n          break;\n        }\n      }\n      if (e === -1)\n        continue;\n      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n      hullTri[i] = this._legalize(t + 2);\n      hullTri[e] = t;\n      hullSize++;\n      let n2 = hullNext[e];\n      while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);\n        hullTri[i] = this._legalize(t + 2);\n        hullNext[n2] = n2;\n        hullSize--;\n        n2 = q;\n      }\n      if (e === start2) {\n        while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n          this._legalize(t + 2);\n          hullTri[q] = t;\n          hullNext[e] = e;\n          hullSize--;\n          e = q;\n        }\n      }\n      this._hullStart = hullPrev[i] = e;\n      hullNext[e] = hullPrev[n2] = i;\n      hullNext[i] = n2;\n      hullHash[this._hashKey(x4, y4)] = i;\n      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n    }\n    this.hull = new Uint32Array(hullSize);\n    for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n      this.hull[i] = e;\n      e = hullNext[e];\n    }\n    this.triangles = this._triangles.subarray(0, this.trianglesLen);\n    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n  }\n  _hashKey(x4, y4) {\n    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;\n  }\n  _legalize(a4) {\n    const { _triangles: triangles, _halfedges: halfedges, coords } = this;\n    let i = 0;\n    let ar = 0;\n    while (true) {\n      const b = halfedges[a4];\n      const a0 = a4 - a4 % 3;\n      ar = a0 + (a4 + 2) % 3;\n      if (b === -1) {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n        continue;\n      }\n      const b02 = b - b % 3;\n      const al = a0 + (a4 + 1) % 3;\n      const bl = b02 + (b + 2) % 3;\n      const p02 = triangles[ar];\n      const pr = triangles[a4];\n      const pl = triangles[al];\n      const p1 = triangles[bl];\n      const illegal = inCircle(\n        coords[2 * p02],\n        coords[2 * p02 + 1],\n        coords[2 * pr],\n        coords[2 * pr + 1],\n        coords[2 * pl],\n        coords[2 * pl + 1],\n        coords[2 * p1],\n        coords[2 * p1 + 1]\n      );\n      if (illegal) {\n        triangles[a4] = p1;\n        triangles[b] = p02;\n        const hbl = halfedges[bl];\n        if (hbl === -1) {\n          let e = this._hullStart;\n          do {\n            if (this._hullTri[e] === bl) {\n              this._hullTri[e] = a4;\n              break;\n            }\n            e = this._hullPrev[e];\n          } while (e !== this._hullStart);\n        }\n        this._link(a4, hbl);\n        this._link(b, halfedges[ar]);\n        this._link(ar, bl);\n        const br = b02 + (b + 1) % 3;\n        if (i < EDGE_STACK.length) {\n          EDGE_STACK[i++] = br;\n        }\n      } else {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n      }\n    }\n    return ar;\n  }\n  _link(a4, b) {\n    this._halfedges[a4] = b;\n    if (b !== -1)\n      this._halfedges[b] = a4;\n  }\n  // add a new triangle given vertex indices and adjacent half-edge ids\n  _addTriangle(i0, i1, i2, a4, b, c6) {\n    const t = this.trianglesLen;\n    this._triangles[t] = i0;\n    this._triangles[t + 1] = i1;\n    this._triangles[t + 2] = i2;\n    this._link(t, a4);\n    this._link(t + 1, b);\n    this._link(t + 2, c6);\n    this.trianglesLen += 3;\n    return t;\n  }\n};\nfunction pseudoAngle(dx, dy) {\n  const p = dx / (Math.abs(dx) + Math.abs(dy));\n  return (dy > 0 ? 3 - p : 1 + p) / 4;\n}\nfunction dist(ax, ay, bx, by) {\n  const dx = ax - bx;\n  const dy = ay - by;\n  return dx * dx + dy * dy;\n}\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n  const dx = ax - px;\n  const dy = ay - py;\n  const ex = bx - px;\n  const ey = by - py;\n  const fx = cx - px;\n  const fy = cy - py;\n  const ap = dx * dx + dy * dy;\n  const bp = ex * ex + ey * ey;\n  const cp = fx * fx + fy * fy;\n  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n}\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = (ey * bl - dy * cl) * d;\n  const y4 = (dx * cl - ex * bl) * d;\n  return x4 * x4 + y4 * y4;\n}\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = ax + (ey * bl - dy * cl) * d;\n  const y4 = ay + (dx * cl - ex * bl) * d;\n  return { x: x4, y: y4 };\n}\nfunction quicksort(ids, dists, left2, right2) {\n  if (right2 - left2 <= 20) {\n    for (let i = left2 + 1; i <= right2; i++) {\n      const temp = ids[i];\n      const tempDist = dists[temp];\n      let j = i - 1;\n      while (j >= left2 && dists[ids[j]] > tempDist)\n        ids[j + 1] = ids[j--];\n      ids[j + 1] = temp;\n    }\n  } else {\n    const median2 = left2 + right2 >> 1;\n    let i = left2 + 1;\n    let j = right2;\n    swap2(ids, median2, i);\n    if (dists[ids[left2]] > dists[ids[right2]])\n      swap2(ids, left2, right2);\n    if (dists[ids[i]] > dists[ids[right2]])\n      swap2(ids, i, right2);\n    if (dists[ids[left2]] > dists[ids[i]])\n      swap2(ids, left2, i);\n    const temp = ids[i];\n    const tempDist = dists[temp];\n    while (true) {\n      do\n        i++;\n      while (dists[ids[i]] < tempDist);\n      do\n        j--;\n      while (dists[ids[j]] > tempDist);\n      if (j < i)\n        break;\n      swap2(ids, i, j);\n    }\n    ids[left2 + 1] = ids[j];\n    ids[j] = temp;\n    if (right2 - i + 1 >= j - left2) {\n      quicksort(ids, dists, i, right2);\n      quicksort(ids, dists, left2, j - 1);\n    } else {\n      quicksort(ids, dists, left2, j - 1);\n      quicksort(ids, dists, i, right2);\n    }\n  }\n}\nfunction swap2(arr, i, j) {\n  const tmp2 = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp2;\n}\nfunction defaultGetX(p) {\n  return p[0];\n}\nfunction defaultGetY(p) {\n  return p[1];\n}\n\n// node_modules/d3-delaunay/src/path.js\nvar epsilon6 = 1e-6;\nvar Path2 = class {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n  }\n  moveTo(x4, y4) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x4, y4) {\n    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arc(x4, y4, r) {\n    x4 = +x4, y4 = +y4, r = +r;\n    const x06 = x4 + r;\n    const y06 = y4;\n    if (r < 0)\n      throw new Error(\"negative radius\");\n    if (this._x1 === null)\n      this._ += `M${x06},${y06}`;\n    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)\n      this._ += \"L\" + x06 + \",\" + y06;\n    if (!r)\n      return;\n    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;\n  }\n  rect(x4, y4, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n};\n\n// node_modules/d3-delaunay/src/polygon.js\nvar Polygon = class {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n};\n\n// node_modules/d3-delaunay/src/voronoi.js\nvar Voronoi = class {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))\n      throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const { delaunay: { points, hull: hull2, triangles }, vectors } = this;\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {\n      const t13 = triangles[i] * 2;\n      const t22 = triangles[i + 1] * 2;\n      const t32 = triangles[i + 2] * 2;\n      const x13 = points[t13];\n      const y13 = points[t13 + 1];\n      const x22 = points[t22];\n      const y22 = points[t22 + 1];\n      const x32 = points[t32];\n      const y32 = points[t32 + 1];\n      const dx = x22 - x13;\n      const dy = y22 - y13;\n      const ex = x32 - x13;\n      const ey = y32 - y13;\n      const ab4 = (dx * ey - dy * ex) * 2;\n      if (Math.abs(ab4) < 1e-9) {\n        let a4 = 1e9;\n        const r = triangles[0] * 2;\n        a4 *= Math.sign((points[r] - x13) * ey - (points[r + 1] - y13) * ex);\n        x4 = (x13 + x32) / 2 - a4 * ey;\n        y4 = (y13 + y32) / 2 + a4 * ex;\n      } else {\n        const d = 1 / ab4;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x4 = x13 + (ey * bl - dy * cl) * d;\n        y4 = y13 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x4;\n      circumcenters[j + 1] = y4;\n    }\n    let h = hull2[hull2.length - 1];\n    let p02, p1 = h * 4;\n    let x06, x12 = points[2 * h];\n    let y06, y12 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull2.length; ++i) {\n      h = hull2[i];\n      p02 = p1, x06 = x12, y06 = y12;\n      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];\n      vectors[p02 + 2] = vectors[p1] = y06 - y12;\n      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { delaunay: { halfedges, inedges, hull: hull2 }, circumcenters, vectors } = this;\n    if (hull2.length <= 1)\n      return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull2[hull2.length - 1];\n    for (let i = 0; i < hull2.length; ++i) {\n      h0 = h1, h1 = hull2[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x4 = circumcenters[t];\n      const y4 = circumcenters[t + 1];\n      const v2 = h0 * 4;\n      const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);\n      if (p)\n        this._renderSegment(x4, y4, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const points = this._clip(i);\n    if (points === null || !points.length)\n      return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)\n      n -= 2;\n    for (let i2 = 2; i2 < n; i2 += 2) {\n      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])\n        context.lineTo(points[i2], points[i2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const { delaunay: { points } } = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell2 = this.cellPolygon(i);\n      if (cell2)\n        cell2.index = i, yield cell2;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon();\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x06, y06, x12, y12, context) {\n    let S;\n    const c0 = this._regioncode(x06, y06);\n    const c1 = this._regioncode(x12, y12);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x06, y06);\n      context.lineTo(x12, y12);\n    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x4, y4) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return false;\n    return this.delaunay._step(i, x4, y4) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci)\n      for (const j of this.delaunay.neighbors(i)) {\n        const cj = this._clip(j);\n        if (cj)\n          loop:\n            for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {\n                  yield j;\n                  break loop;\n                }\n              }\n            }\n      }\n  }\n  _cell(i) {\n    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return null;\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null)\n      return null;\n    const { vectors: V } = this;\n    const v2 = i * 4;\n    return V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points);\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x06, y06, x12 = points[n - 2], y12 = points[n - 1];\n    let c0, c1 = this._regioncode(x12, y12);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x12, y12);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P)\n          P.push(x12, y12);\n        else\n          P = [x12, y12];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)\n            continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)\n            continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1)\n            this._edge(i, e0, e1, P, P.length);\n          if (P)\n            P.push(sx0, sy0);\n          else\n            P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1)\n          this._edge(i, e0, e1, P, P.length);\n        if (P)\n          P.push(sx1, sy1);\n        else\n          P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1)\n        this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x06, y06, x12, y12, c0, c1) {\n    while (true) {\n      if (c0 === 0 && c1 === 0)\n        return [x06, y06, x12, y12];\n      if (c0 & c1)\n        return null;\n      let x4, y4, c6 = c0 || c1;\n      if (c6 & 8)\n        x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;\n      else if (c6 & 4)\n        x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;\n      else if (c6 & 2)\n        y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;\n      else\n        y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;\n      if (c0)\n        x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);\n      else\n        x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0))\n      P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))\n      P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1)\n          j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x4, y4;\n      switch (e0) {\n        case 5:\n          e0 = 4;\n          continue;\n        case 4:\n          e0 = 6, x4 = this.xmax, y4 = this.ymin;\n          break;\n        case 6:\n          e0 = 2;\n          continue;\n        case 2:\n          e0 = 10, x4 = this.xmax, y4 = this.ymax;\n          break;\n        case 10:\n          e0 = 8;\n          continue;\n        case 8:\n          e0 = 9, x4 = this.xmin, y4 = this.ymax;\n          break;\n        case 9:\n          e0 = 1;\n          continue;\n        case 1:\n          e0 = 5, x4 = this.xmin, y4 = this.ymin;\n          break;\n      }\n      if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {\n        P.splice(j, 0, x4, y4), j += 2;\n      }\n    }\n    if (P.length > 4) {\n      for (let i2 = 0; i2 < P.length; i2 += 2) {\n        const j2 = (i2 + 2) % P.length, k2 = (i2 + 4) % P.length;\n        if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])\n          P.splice(j2, 2), i2 -= 2;\n      }\n    }\n    return j;\n  }\n  _project(x06, y06, vx, vy) {\n    let t = Infinity, c6, x4, y4;\n    if (vy < 0) {\n      if (y06 <= this.ymin)\n        return null;\n      if ((c6 = (this.ymin - y06) / vy) < t)\n        y4 = this.ymin, x4 = x06 + (t = c6) * vx;\n    } else if (vy > 0) {\n      if (y06 >= this.ymax)\n        return null;\n      if ((c6 = (this.ymax - y06) / vy) < t)\n        y4 = this.ymax, x4 = x06 + (t = c6) * vx;\n    }\n    if (vx > 0) {\n      if (x06 >= this.xmax)\n        return null;\n      if ((c6 = (this.xmax - x06) / vx) < t)\n        x4 = this.xmax, y4 = y06 + (t = c6) * vy;\n    } else if (vx < 0) {\n      if (x06 <= this.xmin)\n        return null;\n      if ((c6 = (this.xmin - x06) / vx) < t)\n        x4 = this.xmin, y4 = y06 + (t = c6) * vy;\n    }\n    return [x4, y4];\n  }\n  _edgecode(x4, y4) {\n    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);\n  }\n  _regioncode(x4, y4) {\n    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);\n  }\n};\n\n// node_modules/d3-delaunay/src/delaunay.js\nvar tau4 = 2 * Math.PI;\nvar pow = Math.pow;\nfunction pointX(p) {\n  return p[0];\n}\nfunction pointY(p) {\n  return p[1];\n}\nfunction collinear2(d) {\n  const { triangles, coords } = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a4 = 2 * triangles[i], b = 2 * triangles[i + 1], c6 = 2 * triangles[i + 2], cross2 = (coords[c6] - coords[a4]) * (coords[b + 1] - coords[a4 + 1]) - (coords[b] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);\n    if (cross2 > 1e-10)\n      return false;\n  }\n  return true;\n}\nfunction jitter(x4, y4, r) {\n  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];\n}\nvar Delaunay = class {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n    if (d.hull && d.hull.length > 2 && collinear2(d)) {\n      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull2 = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1)\n        inedges[p] = e;\n    }\n    for (let i = 0, n = hull2.length; i < n; ++i) {\n      hullIndex[hull2[i]] = i;\n    }\n    if (hull2.length <= 2 && hull2.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull2[0];\n      inedges[hull2[0]] = 1;\n      if (hull2.length === 2) {\n        inedges[hull2[1]] = 0;\n        this.triangles[1] = hull2[1];\n        this.triangles[2] = hull2[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;\n    if (collinear3) {\n      const l = collinear3.indexOf(i);\n      if (l > 0)\n        yield collinear3[l - 1];\n      if (l < collinear3.length - 1)\n        yield collinear3[l + 1];\n      return;\n    }\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return;\n    let e = e0, p02 = -1;\n    do {\n      yield p02 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        return;\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (p !== p02)\n          yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x4, y4, i = 0) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return -1;\n    const i0 = i;\n    let c6;\n    while ((c6 = this._step(i, x4, y4)) >= 0 && c6 !== i && c6 !== i0)\n      i = c6;\n    return c6;\n  }\n  _step(i, x4, y4) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, points } = this;\n    if (inedges[i] === -1 || !points.length)\n      return (i + 1) % (points.length >> 1);\n    let c6 = i;\n    let dc = pow(x4 - points[i * 2], 2) + pow(y4 - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x4 - points[t * 2], 2) + pow(y4 - points[t * 2 + 1], 2);\n      if (dt < dc)\n        dc = dt, c6 = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (e !== t) {\n          if (pow(x4 - points[e * 2], 2) + pow(y4 - points[e * 2 + 1], 2) < dc)\n            return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c6;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, halfedges, triangles } = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === void 0 && (!context || typeof context.moveTo !== \"function\"))\n      r = context, context = null;\n    r = r == void 0 ? 2 : +r;\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points } = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x4 = points[i], y4 = points[i + 1];\n      context.moveTo(x4 + r, y4);\n      context.arc(x4, y4, r, 0, tau4);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { hull: hull2, points } = this;\n    const h = hull2[0] * 2, n = hull2.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h2 = 2 * hull2[i];\n      context.lineTo(points[h2], points[h2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon();\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, triangles } = this;\n    const t03 = triangles[i *= 3] * 2;\n    const t13 = triangles[i + 1] * 2;\n    const t22 = triangles[i + 2] * 2;\n    context.moveTo(points[t03], points[t03 + 1]);\n    context.lineTo(points[t13], points[t13 + 1]);\n    context.lineTo(points[t22], points[t22 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const { triangles } = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon();\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n};\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array4 = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array4[i * 2] = fx.call(that, p, i, points);\n    array4[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array4;\n}\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n\n// node_modules/d3-dsv/src/dsv.js\nvar EOL = {};\nvar EOF = {};\nvar QUOTE = 34;\nvar NEWLINE = 10;\nvar RETURN = 13;\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + '] || \"\"';\n  }).join(\",\") + \"}\");\n}\nfunction customConverter(columns, f) {\n  var object2 = objectConverter(columns);\n  return function(row, i) {\n    return f(object2(row), i, columns);\n  };\n}\nfunction inferColumns(rows) {\n  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];\n  rows.forEach(function(row) {\n    for (var column2 in row) {\n      if (!(column2 in columnSet)) {\n        columns.push(columnSet[column2] = column2);\n      }\n    }\n  });\n  return columns;\n}\nfunction pad(value, width) {\n  var s2 = value + \"\", length4 = s2.length;\n  return length4 < width ? new Array(width - length4 + 1).join(0) + s2 : s2;\n}\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6) : year > 9999 ? \"+\" + pad(year, 6) : pad(year, 4);\n}\nfunction formatDate(date2) {\n  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();\n  return isNaN(date2) ? \"Invalid Date\" : formatYear(date2.getUTCFullYear(), 4) + \"-\" + pad(date2.getUTCMonth() + 1, 2) + \"-\" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \".\" + pad(milliseconds2, 3) + \"Z\" : seconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \"Z\" : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\" : \"\");\n}\nfunction dsv_default(delimiter) {\n  var reFormat = new RegExp('[\"' + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0);\n  function parse2(text2, f) {\n    var convert, columns, rows = parseRows(text2, function(row, i) {\n      if (convert)\n        return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n  function parseRows(text2, f) {\n    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;\n    if (text2.charCodeAt(N - 1) === NEWLINE)\n      --N;\n    if (text2.charCodeAt(N - 1) === RETURN)\n      --N;\n    function token() {\n      if (eof)\n        return EOF;\n      if (eol)\n        return eol = false, EOL;\n      var i, j = I, c6;\n      if (text2.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)\n          ;\n        if ((i = I) >= N)\n          eof = true;\n        else if ((c6 = text2.charCodeAt(I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        }\n        return text2.slice(j + 1, i - 1).replace(/\"\"/g, '\"');\n      }\n      while (I < N) {\n        if ((c6 = text2.charCodeAt(i = I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        } else if (c6 !== DELIMITER)\n          continue;\n        return text2.slice(j, i);\n      }\n      return eof = true, text2.slice(j, N);\n    }\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF)\n        row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null)\n        continue;\n      rows.push(row);\n    }\n    return rows;\n  }\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column2) {\n        return formatValue(row[column2]);\n      }).join(delimiter);\n    });\n  }\n  function format3(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n  function formatBody(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n  function formatValue(value) {\n    return value == null ? \"\" : value instanceof Date ? formatDate(value) : reFormat.test(value += \"\") ? '\"' + value.replace(/\"/g, '\"\"') + '\"' : value;\n  }\n  return {\n    parse: parse2,\n    parseRows,\n    format: format3,\n    formatBody,\n    formatRows,\n    formatRow,\n    formatValue\n  };\n}\n\n// node_modules/d3-dsv/src/csv.js\nvar csv = dsv_default(\",\");\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatBody = csv.formatBody;\nvar csvFormatRows = csv.formatRows;\nvar csvFormatRow = csv.formatRow;\nvar csvFormatValue = csv.formatValue;\n\n// node_modules/d3-dsv/src/tsv.js\nvar tsv = dsv_default(\"\t\");\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatBody = tsv.formatBody;\nvar tsvFormatRows = tsv.formatRows;\nvar tsvFormatRow = tsv.formatRow;\nvar tsvFormatValue = tsv.formatValue;\n\n// node_modules/d3-dsv/src/autoType.js\nfunction autoType(object2) {\n  for (var key in object2) {\n    var value = object2[key].trim(), number7, m3;\n    if (!value)\n      value = null;\n    else if (value === \"true\")\n      value = true;\n    else if (value === \"false\")\n      value = false;\n    else if (value === \"NaN\")\n      value = NaN;\n    else if (!isNaN(number7 = +value))\n      value = number7;\n    else if (m3 = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n      if (fixtz && !!m3[4] && !m3[7])\n        value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n      value = new Date(value);\n    } else\n      continue;\n    object2[key] = value;\n  }\n  return object2;\n}\nvar fixtz = (/* @__PURE__ */ new Date(\"2019-01-01T00:00\")).getHours() || (/* @__PURE__ */ new Date(\"2019-07-01T00:00\")).getHours();\n\n// node_modules/d3-fetch/src/blob.js\nfunction responseBlob(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.blob();\n}\nfunction blob_default(input, init2) {\n  return fetch(input, init2).then(responseBlob);\n}\n\n// node_modules/d3-fetch/src/buffer.js\nfunction responseArrayBuffer(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.arrayBuffer();\n}\nfunction buffer_default(input, init2) {\n  return fetch(input, init2).then(responseArrayBuffer);\n}\n\n// node_modules/d3-fetch/src/text.js\nfunction responseText(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.text();\n}\nfunction text_default3(input, init2) {\n  return fetch(input, init2).then(responseText);\n}\n\n// node_modules/d3-fetch/src/dsv.js\nfunction dsvParse(parse2) {\n  return function(input, init2, row) {\n    if (arguments.length === 2 && typeof init2 === \"function\")\n      row = init2, init2 = void 0;\n    return text_default3(input, init2).then(function(response) {\n      return parse2(response, row);\n    });\n  };\n}\nfunction dsv(delimiter, input, init2, row) {\n  if (arguments.length === 3 && typeof init2 === \"function\")\n    row = init2, init2 = void 0;\n  var format3 = dsv_default(delimiter);\n  return text_default3(input, init2).then(function(response) {\n    return format3.parse(response, row);\n  });\n}\nvar csv2 = dsvParse(csvParse);\nvar tsv2 = dsvParse(tsvParse);\n\n// node_modules/d3-fetch/src/image.js\nfunction image_default(input, init2) {\n  return new Promise(function(resolve, reject) {\n    var image2 = new Image();\n    for (var key in init2)\n      image2[key] = init2[key];\n    image2.onerror = reject;\n    image2.onload = function() {\n      resolve(image2);\n    };\n    image2.src = input;\n  });\n}\n\n// node_modules/d3-fetch/src/json.js\nfunction responseJson(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  if (response.status === 204 || response.status === 205)\n    return;\n  return response.json();\n}\nfunction json_default(input, init2) {\n  return fetch(input, init2).then(responseJson);\n}\n\n// node_modules/d3-fetch/src/xml.js\nfunction parser(type2) {\n  return (input, init2) => text_default3(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));\n}\nvar xml_default = parser(\"application/xml\");\nvar html = parser(\"text/html\");\nvar svg = parser(\"image/svg+xml\");\n\n// node_modules/d3-force/src/center.js\nfunction center_default(x4, y4) {\n  var nodes, strength = 1;\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force() {\n    var i, n = nodes.length, node, sx = 0, sy = 0;\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n    for (sx = (sx / n - x4) * strength, sy = (sy / n - y4) * strength, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  return force;\n}\n\n// node_modules/d3-quadtree/src/add.js\nfunction add_default(d) {\n  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);\n  return add(this.cover(x4, y4), x4, y4, d);\n}\nfunction add(tree2, x4, y4, d) {\n  if (isNaN(x4) || isNaN(y4))\n    return tree2;\n  var parent, node = tree2._root, leaf = { data: d }, x06 = tree2._x0, y06 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;\n  if (!node)\n    return tree2._root = leaf, tree2;\n  while (node.length) {\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n    if (parent = node, !(node = node[i = bottom2 << 1 | right2]))\n      return parent[i] = leaf, tree2;\n  }\n  xp = +tree2._x.call(null, node.data);\n  yp = +tree2._y.call(null, node.data);\n  if (x4 === xp && y4 === yp)\n    return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));\n  return parent[j] = node, parent[i] = leaf, tree2;\n}\nfunction addAll(data) {\n  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))\n      continue;\n    xz[i] = x4;\n    yz[i] = y4;\n    if (x4 < x06)\n      x06 = x4;\n    if (x4 > x12)\n      x12 = x4;\n    if (y4 < y06)\n      y06 = y4;\n    if (y4 > y12)\n      y12 = y4;\n  }\n  if (x06 > x12 || y06 > y12)\n    return this;\n  this.cover(x06, y06).cover(x12, y12);\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/cover.js\nfunction cover_default(x4, y4) {\n  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))\n    return this;\n  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;\n  if (isNaN(x06)) {\n    x12 = (x06 = Math.floor(x4)) + 1;\n    y12 = (y06 = Math.floor(y4)) + 1;\n  } else {\n    var z = x12 - x06 || 1, node = this._root, parent, i;\n    while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {\n      i = (y4 < y06) << 1 | x4 < x06;\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0:\n          x12 = x06 + z, y12 = y06 + z;\n          break;\n        case 1:\n          x06 = x12 - z, y12 = y06 + z;\n          break;\n        case 2:\n          x12 = x06 + z, y06 = y12 - z;\n          break;\n        case 3:\n          x06 = x12 - z, y06 = y12 - z;\n          break;\n      }\n    }\n    if (this._root && this._root.length)\n      this._root = node;\n  }\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  return this;\n}\n\n// node_modules/d3-quadtree/src/data.js\nfunction data_default2() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        data.push(node.data);\n      while (node = node.next);\n  });\n  return data;\n}\n\n// node_modules/d3-quadtree/src/extent.js\nfunction extent_default(_) {\n  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n\n// node_modules/d3-quadtree/src/quad.js\nfunction quad_default(node, x06, y06, x12, y12) {\n  this.node = node;\n  this.x0 = x06;\n  this.y0 = y06;\n  this.x1 = x12;\n  this.y1 = y12;\n}\n\n// node_modules/d3-quadtree/src/find.js\nfunction find_default(x4, y4, radius2) {\n  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;\n  if (node)\n    quads.push(new quad_default(node, x06, y06, x32, y32));\n  if (radius2 == null)\n    radius2 = Infinity;\n  else {\n    x06 = x4 - radius2, y06 = y4 - radius2;\n    x32 = x4 + radius2, y32 = y4 + radius2;\n    radius2 *= radius2;\n  }\n  while (q = quads.pop()) {\n    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)\n      continue;\n    if (node.length) {\n      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;\n      quads.push(\n        new quad_default(node[3], xm, ym, x22, y22),\n        new quad_default(node[2], x12, ym, xm, y22),\n        new quad_default(node[1], xm, y12, x22, ym),\n        new quad_default(node[0], x12, y12, xm, ym)\n      );\n      if (i = (y4 >= ym) << 1 | x4 >= xm) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    } else {\n      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;\n      if (d2 < radius2) {\n        var d = Math.sqrt(radius2 = d2);\n        x06 = x4 - d, y06 = y4 - d;\n        x32 = x4 + d, y32 = y4 + d;\n        data = node.data;\n      }\n    }\n  }\n  return data;\n}\n\n// node_modules/d3-quadtree/src/remove.js\nfunction remove_default3(d) {\n  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))\n    return this;\n  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x4, y4, xm, ym, right2, bottom2, i, j;\n  if (!node)\n    return this;\n  if (node.length)\n    while (true) {\n      if (right2 = x4 >= (xm = (x06 + x12) / 2))\n        x06 = xm;\n      else\n        x12 = xm;\n      if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n        y06 = ym;\n      else\n        y12 = ym;\n      if (!(parent = node, node = node[i = bottom2 << 1 | right2]))\n        return this;\n      if (!node.length)\n        break;\n      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])\n        retainer = parent, j = i;\n    }\n  while (node.data !== d)\n    if (!(previous = node, node = node.next))\n      return this;\n  if (next = node.next)\n    delete node.next;\n  if (previous)\n    return next ? previous.next = next : delete previous.next, this;\n  if (!parent)\n    return this._root = next, this;\n  next ? parent[i] = next : delete parent[i];\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {\n    if (retainer)\n      retainer[j] = node;\n    else\n      this._root = node;\n  }\n  return this;\n}\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i)\n    this.remove(data[i]);\n  return this;\n}\n\n// node_modules/d3-quadtree/src/root.js\nfunction root_default() {\n  return this._root;\n}\n\n// node_modules/d3-quadtree/src/size.js\nfunction size_default2() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        ++size;\n      while (node = node.next);\n  });\n  return size;\n}\n\n// node_modules/d3-quadtree/src/visit.js\nfunction visit_default(callback) {\n  var quads = [], q, node = this._root, child, x06, y06, x12, y12;\n  if (node)\n    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {\n      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/visitAfter.js\nfunction visitAfter_default(callback) {\n  var quads = [], next = [], q;\n  if (this._root)\n    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/x.js\nfunction defaultX2(d) {\n  return d[0];\n}\nfunction x_default(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n\n// node_modules/d3-quadtree/src/y.js\nfunction defaultY2(d) {\n  return d[1];\n}\nfunction y_default(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n\n// node_modules/d3-quadtree/src/quadtree.js\nfunction quadtree(nodes, x4, y4) {\n  var tree2 = new Quadtree(x4 == null ? defaultX2 : x4, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree2 : tree2.addAll(nodes);\n}\nfunction Quadtree(x4, y4, x06, y06, x12, y12) {\n  this._x = x4;\n  this._y = y4;\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  this._root = void 0;\n}\nfunction leaf_copy(leaf) {\n  var copy3 = { data: leaf.data }, next = copy3;\n  while (leaf = leaf.next)\n    next = next.next = { data: leaf.data };\n  return copy3;\n}\nvar treeProto = quadtree.prototype = Quadtree.prototype;\ntreeProto.copy = function() {\n  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;\n  if (!node)\n    return copy3;\n  if (!node.length)\n    return copy3._root = leaf_copy(node), copy3;\n  nodes = [{ source: node, target: copy3._root = new Array(4) }];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length)\n          nodes.push({ source: child, target: node.target[i] = new Array(4) });\n        else\n          node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n  return copy3;\n};\ntreeProto.add = add_default;\ntreeProto.addAll = addAll;\ntreeProto.cover = cover_default;\ntreeProto.data = data_default2;\ntreeProto.extent = extent_default;\ntreeProto.find = find_default;\ntreeProto.remove = remove_default3;\ntreeProto.removeAll = removeAll;\ntreeProto.root = root_default;\ntreeProto.size = size_default2;\ntreeProto.visit = visit_default;\ntreeProto.visitAfter = visitAfter_default;\ntreeProto.x = x_default;\ntreeProto.y = y_default;\n\n// node_modules/d3-force/src/constant.js\nfunction constant_default7(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-force/src/jiggle.js\nfunction jiggle_default(random) {\n  return (random() - 0.5) * 1e-6;\n}\n\n// node_modules/d3-force/src/collide.js\nfunction x(d) {\n  return d.x + d.vx;\n}\nfunction y(d) {\n  return d.y + d.vy;\n}\nfunction collide_default(radius2) {\n  var nodes, radii, random, strength = 1, iterations2 = 1;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(radius2 == null ? 1 : +radius2);\n  function force() {\n    var i, n = nodes.length, tree2, node, xi, yi, ri, ri2;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      tree2 = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree2.visit(apply2);\n      }\n    }\n    function apply2(quad, x06, y06, x12, y12) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x4 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l = x4 * x4 + y4 * y4;\n          if (l < r * r) {\n            if (x4 === 0)\n              x4 = jiggle_default(random), l += x4 * x4;\n            if (y4 === 0)\n              y4 = jiggle_default(random), l += y4 * y4;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x4 *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y4 *= l) * r;\n            data.vx -= x4 * (r = 1 - r);\n            data.vy -= y4 * r;\n          }\n        }\n        return;\n      }\n      return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;\n    }\n  }\n  function prepare(quad) {\n    if (quad.data)\n      return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i)\n      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/link.js\nfunction index2(d) {\n  return d.index;\n}\nfunction find2(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node)\n    throw new Error(\"node not found: \" + nodeId);\n  return node;\n}\nfunction link_default(links) {\n  var id2 = index2, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;\n  if (links == null)\n    links = [];\n  function defaultStrength(link4) {\n    return 1 / Math.min(count3[link4.source.index], count3[link4.target.index]);\n  }\n  function force(alpha) {\n    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {\n      for (var i = 0, link4, source, target, x4, y4, l, b; i < n; ++i) {\n        link4 = links[i], source = link4.source, target = link4.target;\n        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);\n        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);\n        l = Math.sqrt(x4 * x4 + y4 * y4);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x4 *= l, y4 *= l;\n        target.vx -= x4 * (b = bias[i]);\n        target.vy -= y4 * b;\n        source.vx += x4 * (b = 1 - b);\n        source.vy += y4 * b;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link4;\n    for (i = 0, count3 = new Array(n); i < m3; ++i) {\n      link4 = links[i], link4.index = i;\n      if (typeof link4.source !== \"object\")\n        link4.source = find2(nodeById, link4.source);\n      if (typeof link4.target !== \"object\")\n        link4.target = find2(nodeById, link4.target);\n      count3[link4.source.index] = (count3[link4.source.index] || 0) + 1;\n      count3[link4.target.index] = (count3[link4.target.index] || 0) + 1;\n    }\n    for (i = 0, bias = new Array(m3); i < m3; ++i) {\n      link4 = links[i], bias[i] = count3[link4.source.index] / (count3[link4.source.index] + count3[link4.target.index]);\n    }\n    strengths = new Array(m3), initializeStrength();\n    distances = new Array(m3), initializeDistance();\n  }\n  function initializeStrength() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n  function initializeDistance() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n  force.id = function(_) {\n    return arguments.length ? (id2 = _, force) : id2;\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initializeStrength(), force) : strength;\n  };\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant_default7(+_), initializeDistance(), force) : distance;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/lcg.js\nvar a = 1664525;\nvar c = 1013904223;\nvar m = 4294967296;\nfunction lcg_default() {\n  let s2 = 1;\n  return () => (s2 = (a * s2 + c) % m) / m;\n}\n\n// node_modules/d3-force/src/simulation.js\nfunction x2(d) {\n  return d.x;\n}\nfunction y2(d) {\n  return d.y;\n}\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\nfunction simulation_default(nodes) {\n  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default(\"tick\", \"end\"), random = lcg_default();\n  if (nodes == null)\n    nodes = [];\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n  function tick(iterations2) {\n    var i, n = nodes.length, node;\n    if (iterations2 === void 0)\n      iterations2 = 1;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n      forces.forEach(function(force) {\n        force(alpha);\n      });\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null)\n          node.x += node.vx *= velocityDecay;\n        else\n          node.x = node.fx, node.vx = 0;\n        if (node.fy == null)\n          node.y += node.vy *= velocityDecay;\n        else\n          node.y = node.fy, node.vy = 0;\n      }\n    }\n    return simulation;\n  }\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null)\n        node.x = node.fx;\n      if (node.fy != null)\n        node.y = node.fy;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;\n        node.x = radius2 * Math.cos(angle2);\n        node.y = radius2 * Math.sin(angle2);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n  function initializeForce(force) {\n    if (force.initialize)\n      force.initialize(nodes, random);\n    return force;\n  }\n  initializeNodes();\n  return simulation = {\n    tick,\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n    force: function(name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function(x4, y4, radius2) {\n      var i = 0, n = nodes.length, dx, dy, d2, node, closest;\n      if (radius2 == null)\n        radius2 = Infinity;\n      else\n        radius2 *= radius2;\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x4 - node.x;\n        dy = y4 - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius2)\n          closest = node, radius2 = d2;\n      }\n      return closest;\n    },\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n\n// node_modules/d3-force/src/manyBody.js\nfunction manyBody_default() {\n  var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;\n  function force(_) {\n    var i, n = nodes.length, tree2 = quadtree(nodes, x2, y2).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i)\n      node = nodes[i], tree2.visit(apply2);\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node2;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i)\n      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);\n  }\n  function accumulate(quad) {\n    var strength2 = 0, q, c6, weight = 0, x4, y4, i;\n    if (quad.length) {\n      for (x4 = y4 = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c6 = Math.abs(q.value))) {\n          strength2 += q.value, weight += c6, x4 += c6 * q.x, y4 += c6 * q.y;\n        }\n      }\n      quad.x = x4 / weight;\n      quad.y = y4 / weight;\n    } else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do\n        strength2 += strengths[q.data.index];\n      while (q = q.next);\n    }\n    quad.value = strength2;\n  }\n  function apply2(quad, x12, _, x22) {\n    if (!quad.value)\n      return true;\n    var x4 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x12, l = x4 * x4 + y4 * y4;\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x4 === 0)\n          x4 = jiggle_default(random), l += x4 * x4;\n        if (y4 === 0)\n          y4 = jiggle_default(random), l += y4 * y4;\n        if (l < distanceMin2)\n          l = Math.sqrt(distanceMin2 * l);\n        node.vx += x4 * quad.value * alpha / l;\n        node.vy += y4 * quad.value * alpha / l;\n      }\n      return true;\n    } else if (quad.length || l >= distanceMax2)\n      return;\n    if (quad.data !== node || quad.next) {\n      if (x4 === 0)\n        x4 = jiggle_default(random), l += x4 * x4;\n      if (y4 === 0)\n        y4 = jiggle_default(random), l += y4 * y4;\n      if (l < distanceMin2)\n        l = Math.sqrt(distanceMin2 * l);\n    }\n    do\n      if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x4 * w;\n        node.vy += y4 * w;\n      }\n    while (quad = quad.next);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/radial.js\nfunction radial_default(radius2, x4, y4) {\n  var nodes, strength = constant_default7(0.1), strengths, radiuses;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(+radius2);\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force(alpha) {\n    for (var i = 0, n = nodes.length; i < n; ++i) {\n      var node = nodes[i], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;\n      node.vx += dx * k2;\n      node.vy += dy * k2;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    radiuses = new Array(n);\n    for (i = 0; i < n; ++i) {\n      radiuses[i] = +radius2(nodes[i], i, nodes);\n      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _, initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/x.js\nfunction x_default2(x4) {\n  var strength = constant_default7(0.1), nodes, strengths, xz;\n  if (typeof x4 !== \"function\")\n    x4 = constant_default7(x4 == null ? 0 : +x4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : x4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/y.js\nfunction y_default2(y4) {\n  var strength = constant_default7(0.1), nodes, strengths, yz;\n  if (typeof y4 !== \"function\")\n    y4 = constant_default7(y4 == null ? 0 : +y4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-format/src/formatDecimal.js\nfunction formatDecimal_default(x4) {\n  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString(\"en\").replace(/,/g, \"\") : x4.toString(10);\n}\nfunction formatDecimalParts(x4, p) {\n  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf(\"e\")) < 0)\n    return null;\n  var i, coefficient = x4.slice(0, i);\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x4.slice(i + 1)\n  ];\n}\n\n// node_modules/d3-format/src/exponent.js\nfunction exponent_default(x4) {\n  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;\n}\n\n// node_modules/d3-format/src/formatGroup.js\nfunction formatGroup_default(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length, t = [], j = 0, g = grouping[0], length4 = 0;\n    while (i > 0 && g > 0) {\n      if (length4 + g + 1 > width)\n        g = Math.max(1, width - length4);\n      t.push(value.substring(i -= g, i + g));\n      if ((length4 += g + 1) > width)\n        break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n    return t.reverse().join(thousands);\n  };\n}\n\n// node_modules/d3-format/src/formatNumerals.js\nfunction formatNumerals_default(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n\n// node_modules/d3-format/src/formatSpecifier.js\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nfunction formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier)))\n    throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\nformatSpecifier.prototype = FormatSpecifier.prototype;\nfunction FormatSpecifier(specifier) {\n  this.fill = specifier.fill === void 0 ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === void 0 ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === void 0 ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === void 0 ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === void 0 ? void 0 : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === void 0 ? \"\" : specifier.type + \"\";\n}\nFormatSpecifier.prototype.toString = function() {\n  return this.fill + this.align + this.sign + this.symbol + (this.zero ? \"0\" : \"\") + (this.width === void 0 ? \"\" : Math.max(1, this.width | 0)) + (this.comma ? \",\" : \"\") + (this.precision === void 0 ? \"\" : \".\" + Math.max(0, this.precision | 0)) + (this.trim ? \"~\" : \"\") + this.type;\n};\n\n// node_modules/d3-format/src/formatTrim.js\nfunction formatTrim_default(s2) {\n  out:\n    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (s2[i]) {\n        case \".\":\n          i0 = i1 = i;\n          break;\n        case \"0\":\n          if (i0 === 0)\n            i0 = i;\n          i1 = i;\n          break;\n        default:\n          if (!+s2[i])\n            break out;\n          if (i0 > 0)\n            i0 = 0;\n          break;\n      }\n    }\n  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;\n}\n\n// node_modules/d3-format/src/formatPrefixAuto.js\nvar prefixExponent;\nfunction formatPrefixAuto_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;\n  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join(\"0\") : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i) : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];\n}\n\n// node_modules/d3-format/src/formatRounded.js\nfunction formatRounded_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1];\n  return exponent2 < 0 ? \"0.\" + new Array(-exponent2).join(\"0\") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + \".\" + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join(\"0\");\n}\n\n// node_modules/d3-format/src/formatTypes.js\nvar formatTypes_default = {\n  \"%\": (x4, p) => (x4 * 100).toFixed(p),\n  \"b\": (x4) => Math.round(x4).toString(2),\n  \"c\": (x4) => x4 + \"\",\n  \"d\": formatDecimal_default,\n  \"e\": (x4, p) => x4.toExponential(p),\n  \"f\": (x4, p) => x4.toFixed(p),\n  \"g\": (x4, p) => x4.toPrecision(p),\n  \"o\": (x4) => Math.round(x4).toString(8),\n  \"p\": (x4, p) => formatRounded_default(x4 * 100, p),\n  \"r\": formatRounded_default,\n  \"s\": formatPrefixAuto_default,\n  \"X\": (x4) => Math.round(x4).toString(16).toUpperCase(),\n  \"x\": (x4) => Math.round(x4).toString(16)\n};\n\n// node_modules/d3-format/src/identity.js\nfunction identity_default2(x4) {\n  return x4;\n}\n\n// node_modules/d3-format/src/locale.js\nvar map3 = Array.prototype.map;\nvar prefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\\xB5\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\nfunction locale_default(locale3) {\n  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + \"\"), currencyPrefix = locale3.currency === void 0 ? \"\" : locale3.currency[0] + \"\", currencySuffix = locale3.currency === void 0 ? \"\" : locale3.currency[1] + \"\", decimal = locale3.decimal === void 0 ? \".\" : locale3.decimal + \"\", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? \"%\" : locale3.percent + \"\", minus = locale3.minus === void 0 ? \"\\u2212\" : locale3.minus + \"\", nan = locale3.nan === void 0 ? \"NaN\" : locale3.nan + \"\";\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;\n    if (type2 === \"n\")\n      comma = true, type2 = \"g\";\n    else if (!formatTypes_default[type2])\n      precision === void 0 && (precision = 12), trim = true, type2 = \"g\";\n    if (zero3 || fill === \"0\" && align === \"=\")\n      zero3 = true, fill = \"0\", align = \"=\";\n    var prefix = symbol2 === \"$\" ? currencyPrefix : symbol2 === \"#\" && /[boxX]/.test(type2) ? \"0\" + type2.toLowerCase() : \"\", suffix = symbol2 === \"$\" ? currencySuffix : /[%p]/.test(type2) ? percent : \"\";\n    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);\n    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));\n    function format3(value) {\n      var valuePrefix = prefix, valueSuffix = suffix, i, n, c6;\n      if (type2 === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n        var valueNegative = value < 0 || 1 / value < 0;\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n        if (trim)\n          value = formatTrim_default(value);\n        if (valueNegative && +value === 0 && sign3 !== \"+\")\n          valueNegative = false;\n        valuePrefix = (valueNegative ? sign3 === \"(\" ? sign3 : minus : sign3 === \"-\" || sign3 === \"(\" ? \"\" : sign3) + valuePrefix;\n        valueSuffix = (type2 === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign3 === \"(\" ? \")\" : \"\");\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {\n              valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n      if (comma && !zero3)\n        value = group3(value, Infinity);\n      var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : \"\";\n      if (comma && zero3)\n        value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n      switch (align) {\n        case \"<\":\n          value = valuePrefix + value + valueSuffix + padding;\n          break;\n        case \"=\":\n          value = valuePrefix + padding + value + valueSuffix;\n          break;\n        case \"^\":\n          value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);\n          break;\n        default:\n          value = padding + valuePrefix + value + valueSuffix;\n          break;\n      }\n      return numerals(value);\n    }\n    format3.toString = function() {\n      return specifier + \"\";\n    };\n    return format3;\n  }\n  function formatPrefix2(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];\n    return function(value2) {\n      return f(k2 * value2) + prefix;\n    };\n  }\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix2\n  };\n}\n\n// node_modules/d3-format/src/defaultLocale.js\nvar locale;\nvar format;\nvar formatPrefix;\ndefaultLocale({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\nfunction defaultLocale(definition) {\n  locale = locale_default(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n\n// node_modules/d3-format/src/precisionFixed.js\nfunction precisionFixed_default(step) {\n  return Math.max(0, -exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionPrefix.js\nfunction precisionPrefix_default(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionRound.js\nfunction precisionRound_default(step, max5) {\n  step = Math.abs(step), max5 = Math.abs(max5) - step;\n  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;\n}\n\n// node_modules/d3-geo/src/math.js\nvar epsilon7 = 1e-6;\nvar epsilon22 = 1e-12;\nvar pi4 = Math.PI;\nvar halfPi3 = pi4 / 2;\nvar quarterPi = pi4 / 4;\nvar tau5 = pi4 * 2;\nvar degrees3 = 180 / pi4;\nvar radians2 = pi4 / 180;\nvar abs3 = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos2 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\nvar hypot = Math.hypot;\nvar log = Math.log;\nvar pow2 = Math.pow;\nvar sin2 = Math.sin;\nvar sign = Math.sign || function(x4) {\n  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;\n};\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\nfunction acos(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);\n}\nfunction asin(x4) {\n  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);\n}\nfunction haversin(x4) {\n  return (x4 = sin2(x4 / 2)) * x4;\n}\n\n// node_modules/d3-geo/src/noop.js\nfunction noop2() {\n}\n\n// node_modules/d3-geo/src/stream.js\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\nvar streamObjectType = {\n  Feature: function(object2, stream) {\n    streamGeometry(object2.geometry, stream);\n  },\n  FeatureCollection: function(object2, stream) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      streamGeometry(features[i].geometry, stream);\n  }\n};\nvar streamGeometryType = {\n  Sphere: function(object2, stream) {\n    stream.sphere();\n  },\n  Point: function(object2, stream) {\n    object2 = object2.coordinates;\n    stream.point(object2[0], object2[1], object2[2]);\n  },\n  MultiPoint: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);\n  },\n  LineString: function(object2, stream) {\n    streamLine(object2.coordinates, stream, 0);\n  },\n  MultiLineString: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamLine(coordinates2[i], stream, 0);\n  },\n  Polygon: function(object2, stream) {\n    streamPolygon(object2.coordinates, stream);\n  },\n  MultiPolygon: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamPolygon(coordinates2[i], stream);\n  },\n  GeometryCollection: function(object2, stream) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      streamGeometry(geometries[i], stream);\n  }\n};\nfunction streamLine(coordinates2, stream, closed) {\n  var i = -1, n = coordinates2.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n)\n    coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\nfunction streamPolygon(coordinates2, stream) {\n  var i = -1, n = coordinates2.length;\n  stream.polygonStart();\n  while (++i < n)\n    streamLine(coordinates2[i], stream, 1);\n  stream.polygonEnd();\n}\nfunction stream_default(object2, stream) {\n  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {\n    streamObjectType[object2.type](object2, stream);\n  } else {\n    streamGeometry(object2, stream);\n  }\n}\n\n// node_modules/d3-geo/src/area.js\nvar areaRingSum = new Adder();\nvar areaSum = new Adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\nvar areaStream = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaRingSum = new Adder();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop2;\n  },\n  sphere: function() {\n    areaSum.add(tau5);\n  }\n};\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\nfunction areaPointFirst(lambda, phi2) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);\n}\nfunction areaPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  phi2 = phi2 / 2 + quarterPi;\n  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k2 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda), v2 = k2 * sdLambda * sin2(adLambda);\n  areaRingSum.add(atan2(v2, u4));\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\nfunction area_default2(object2) {\n  areaSum = new Adder();\n  stream_default(object2, areaStream);\n  return areaSum * 2;\n}\n\n// node_modules/d3-geo/src/cartesian.js\nfunction spherical(cartesian2) {\n  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];\n}\nfunction cartesian(spherical2) {\n  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);\n  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];\n}\nfunction cartesianDot(a4, b) {\n  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];\n}\nfunction cartesianCross(a4, b) {\n  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];\n}\nfunction cartesianAddInPlace(a4, b) {\n  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];\n}\nfunction cartesianScale(vector2, k2) {\n  return [vector2[0] * k2, vector2[1] * k2, vector2[2] * k2];\n}\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\n// node_modules/d3-geo/src/bounds.js\nvar lambda02;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda002;\nvar phi002;\nvar p0;\nvar deltaSum;\nvar ranges;\nvar range3;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0)\n      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon7)\n      phi1 = 90;\n    else if (deltaSum < -epsilon7)\n      phi0 = -90;\n    range3[0] = lambda02, range3[1] = lambda1;\n  },\n  sphere: function() {\n    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\nfunction boundsPoint(lambda, phi2) {\n  ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n}\nfunction linePoint(lambda, phi2) {\n  var p = cartesian([lambda * radians2, phi2 * radians2]);\n  if (p0) {\n    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;\n    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = inflection[1] * degrees3;\n      if (phii > phi1)\n        phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = -inflection[1] * degrees3;\n      if (phii < phi0)\n        phi0 = phii;\n    } else {\n      if (phi2 < phi0)\n        phi0 = phi2;\n      if (phi2 > phi1)\n        phi1 = phi2;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n          lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n          lambda02 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda02) {\n        if (lambda < lambda02)\n          lambda02 = lambda;\n        if (lambda > lambda1)\n          lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n            lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n            lambda02 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  }\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n  p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n  range3[0] = lambda02, range3[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\nfunction boundsRingPoint(lambda, phi2) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda002 = lambda, phi002 = phi2;\n  }\n  areaStream.point(lambda, phi2);\n  linePoint(lambda, phi2);\n}\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda002, phi002);\n  areaStream.lineEnd();\n  if (abs3(deltaSum) > epsilon7)\n    lambda02 = -(lambda1 = 180);\n  range3[0] = lambda02, range3[1] = lambda1;\n  p0 = null;\n}\nfunction angle(lambda04, lambda12) {\n  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;\n}\nfunction rangeCompare(a4, b) {\n  return a4[0] - b[0];\n}\nfunction rangeContains(range5, x4) {\n  return range5[0] <= range5[1] ? range5[0] <= x4 && x4 <= range5[1] : x4 < range5[0] || range5[1] < x4;\n}\nfunction bounds_default(feature) {\n  var i, n, a4, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);\n  ranges = [];\n  stream_default(feature, boundsStream);\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a4, b[0]) || rangeContains(a4, b[1])) {\n        if (angle(a4[0], b[1]) > angle(a4[0], a4[1]))\n          a4[1] = b[1];\n        if (angle(b[0], a4[1]) > angle(a4[0], a4[1]))\n          a4[0] = b[0];\n      } else {\n        merged.push(a4 = b);\n      }\n    }\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a4[1], b[0])) > deltaMax)\n        deltaMax = delta, lambda02 = b[0], lambda1 = a4[1];\n    }\n  }\n  ranges = range3 = null;\n  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];\n}\n\n// node_modules/d3-geo/src/centroid.js\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda003;\nvar phi003;\nvar x0;\nvar y0;\nvar z0;\nvar centroidStream = {\n  sphere: noop2,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\nfunction centroidPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));\n}\nfunction centroidPointCartesian(x4, y4, z) {\n  ++W0;\n  X0 += (x4 - X0) / W0;\n  Y0 += (y4 - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\nfunction centroidLinePointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLinePoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda003, phi003);\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingPointFirst(lambda, phi2) {\n  lambda003 = lambda, phi003 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidRingPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x4 - x0 * z, cz = x0 * y4 - y0 * x4, m3 = hypot(cx, cy, cz), w = asin(m3), v2 = m3 && -w / m3;\n  X2.add(v2 * cx);\n  Y2.add(v2 * cy);\n  Z2.add(v2 * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroid_default(object2) {\n  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream_default(object2, centroidStream);\n  var x4 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x4, y4, z);\n  if (m3 < epsilon22) {\n    x4 = X1, y4 = Y1, z = Z1;\n    if (W1 < epsilon7)\n      x4 = X0, y4 = Y0, z = Z0;\n    m3 = hypot(x4, y4, z);\n    if (m3 < epsilon22)\n      return [NaN, NaN];\n  }\n  return [atan2(y4, x4) * degrees3, asin(z / m3) * degrees3];\n}\n\n// node_modules/d3-geo/src/constant.js\nfunction constant_default8(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-geo/src/compose.js\nfunction compose_default(a4, b) {\n  function compose(x4, y4) {\n    return x4 = a4(x4, y4), b(x4[0], x4[1]);\n  }\n  if (a4.invert && b.invert)\n    compose.invert = function(x4, y4) {\n      return x4 = b.invert(x4, y4), x4 && a4.invert(x4[0], x4[1]);\n    };\n  return compose;\n}\n\n// node_modules/d3-geo/src/rotation.js\nfunction rotationIdentity(lambda, phi2) {\n  if (abs3(lambda) > pi4)\n    lambda -= Math.round(lambda / tau5) * tau5;\n  return [lambda, phi2];\n}\nrotationIdentity.invert = rotationIdentity;\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n}\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi2) {\n    lambda += deltaLambda;\n    if (abs3(lambda) > pi4)\n      lambda -= Math.round(lambda / tau5) * tau5;\n    return [lambda, phi2];\n  };\n}\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);\n  function rotation(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x4 * sinDeltaPhi;\n    return [\n      atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)\n    ];\n  }\n  rotation.invert = function(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;\n    return [\n      atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k2 * sinDeltaPhi),\n      asin(k2 * cosDeltaPhi - x4 * sinDeltaPhi)\n    ];\n  };\n  return rotation;\n}\nfunction rotation_default(rotate) {\n  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);\n  function forward(coordinates2) {\n    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  }\n  forward.invert = function(coordinates2) {\n    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/circle.js\nfunction circleStream(stream, radius2, delta, direction, t03, t13) {\n  if (!delta)\n    return;\n  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;\n  if (t03 == null) {\n    t03 = radius2 + direction * tau5;\n    t13 = radius2 - step / 2;\n  } else {\n    t03 = circleRadius(cosRadius, t03);\n    t13 = circleRadius(cosRadius, t13);\n    if (direction > 0 ? t03 < t13 : t03 > t13)\n      t03 += direction * tau5;\n  }\n  for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {\n    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);\n    stream.point(point6[0], point6[1]);\n  }\n}\nfunction circleRadius(cosRadius, point6) {\n  point6 = cartesian(point6), point6[0] -= cosRadius;\n  cartesianNormalizeInPlace(point6);\n  var radius2 = acos(-point6[1]);\n  return ((-point6[2] < 0 ? -radius2 : radius2) + tau5 - epsilon7) % tau5;\n}\nfunction circle_default() {\n  var center2 = constant_default8([0, 0]), radius2 = constant_default8(90), precision = constant_default8(6), ring, rotate, stream = { point: point6 };\n  function point6(x4, y4) {\n    ring.push(x4 = rotate(x4, y4));\n    x4[0] *= degrees3, x4[1] *= degrees3;\n  }\n  function circle2() {\n    var c6 = center2.apply(this, arguments), r = radius2.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;\n    ring = [];\n    rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;\n    circleStream(stream, r, p, 1);\n    c6 = { type: \"Polygon\", coordinates: [ring] };\n    ring = rotate = null;\n    return c6;\n  }\n  circle2.center = function(_) {\n    return arguments.length ? (center2 = typeof _ === \"function\" ? _ : constant_default8([+_[0], +_[1]]), circle2) : center2;\n  };\n  circle2.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : radius2;\n  };\n  circle2.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : precision;\n  };\n  return circle2;\n}\n\n// node_modules/d3-geo/src/clip/buffer.js\nfunction buffer_default2() {\n  var lines = [], line2;\n  return {\n    point: function(x4, y4, m3) {\n      line2.push([x4, y4, m3]);\n    },\n    lineStart: function() {\n      lines.push(line2 = []);\n    },\n    lineEnd: noop2,\n    rejoin: function() {\n      if (lines.length > 1)\n        lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line2 = null;\n      return result;\n    }\n  };\n}\n\n// node_modules/d3-geo/src/pointEqual.js\nfunction pointEqual_default(a4, b) {\n  return abs3(a4[0] - b[0]) < epsilon7 && abs3(a4[1] - b[1]) < epsilon7;\n}\n\n// node_modules/d3-geo/src/clip/rejoin.js\nfunction Intersection(point6, points, other, entry) {\n  this.x = point6;\n  this.z = points;\n  this.o = other;\n  this.e = entry;\n  this.v = false;\n  this.n = this.p = null;\n}\nfunction rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {\n  var subject = [], clip = [], i, n;\n  segments.forEach(function(segment) {\n    if ((n2 = segment.length - 1) <= 0)\n      return;\n    var n2, p02 = segment[0], p1 = segment[n2], x4;\n    if (pointEqual_default(p02, p1)) {\n      if (!p02[2] && !p1[2]) {\n        stream.lineStart();\n        for (i = 0; i < n2; ++i)\n          stream.point((p02 = segment[i])[0], p02[1]);\n        stream.lineEnd();\n        return;\n      }\n      p1[0] += 2 * epsilon7;\n    }\n    subject.push(x4 = new Intersection(p02, segment, null, true));\n    clip.push(x4.o = new Intersection(p02, null, x4, false));\n    subject.push(x4 = new Intersection(p1, segment, null, false));\n    clip.push(x4.o = new Intersection(p1, null, x4, true));\n  });\n  if (!subject.length)\n    return;\n  clip.sort(compareIntersection2);\n  link(subject);\n  link(clip);\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n  var start2 = subject[0], points, point6;\n  while (1) {\n    var current = start2, isSubject = true;\n    while (current.v)\n      if ((current = current.n) === start2)\n        return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\nfunction link(array4) {\n  if (!(n = array4.length))\n    return;\n  var n, i = 0, a4 = array4[0], b;\n  while (++i < n) {\n    a4.n = b = array4[i];\n    b.p = a4;\n    a4 = b;\n  }\n  a4.n = b = array4[0];\n  b.p = a4;\n}\n\n// node_modules/d3-geo/src/polygonContains.js\nfunction longitude(point6) {\n  return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);\n}\nfunction polygonContains_default(polygon, point6) {\n  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;\n  var sum5 = new Adder();\n  if (sinPhi === 1)\n    phi2 = halfPi3 + epsilon7;\n  else if (sinPhi === -1)\n    phi2 = -halfPi3 - epsilon7;\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m3 = (ring = polygon[i]).length))\n      continue;\n    var ring, m3, point0 = ring[m3 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);\n    for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {\n      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k2 = sinPhi03 * sinPhi1;\n      sum5.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));\n      angle2 += antimeridian ? delta + sign3 * tau5 : delta;\n      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection2 = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection2);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);\n        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n  return (angle2 < -epsilon7 || angle2 < epsilon7 && sum5 < -epsilon22) ^ winding & 1;\n}\n\n// node_modules/d3-geo/src/clip/index.js\nfunction clip_default(pointVisible, clipLine, interpolate, start2) {\n  return function(sink) {\n    var line2 = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n    var clip = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point6;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains_default(polygon, start2);\n        if (segments.length) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted)\n          sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n    function point6(lambda, phi2) {\n      if (pointVisible(lambda, phi2))\n        sink.point(lambda, phi2);\n    }\n    function pointLine(lambda, phi2) {\n      line2.point(lambda, phi2);\n    }\n    function lineStart() {\n      clip.point = pointLine;\n      line2.lineStart();\n    }\n    function lineEnd() {\n      clip.point = point6;\n      line2.lineEnd();\n    }\n    function pointRing(lambda, phi2) {\n      ring.push([lambda, phi2]);\n      ringSink.point(lambda, phi2);\n    }\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point7;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n)\n        return;\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m3 = segment.length - 1) > 0) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m3; ++i)\n            sink.point((point7 = segment[i])[0], point7[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n      if (n > 1 && clean & 2)\n        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n    return clip;\n  };\n}\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\nfunction compareIntersection(a4, b) {\n  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);\n}\n\n// node_modules/d3-geo/src/clip/antimeridian.js\nvar antimeridian_default = clip_default(\n  function() {\n    return true;\n  },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi4, -halfPi3]\n);\nfunction clipAntimeridianLine(stream) {\n  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda12, phi12) {\n      var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);\n      if (abs3(delta - pi4) < epsilon7) {\n        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        stream.point(lambda12, phi02);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi4) {\n        if (abs3(lambda04 - sign0) < epsilon7)\n          lambda04 -= sign0 * epsilon7;\n        if (abs3(lambda12 - sign1) < epsilon7)\n          lambda12 -= sign1 * epsilon7;\n        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        clean = 0;\n      }\n      stream.point(lambda04 = lambda12, phi02 = phi12);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda04 = phi02 = NaN;\n    },\n    clean: function() {\n      return 2 - clean;\n    }\n  };\n}\nfunction clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {\n  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);\n  return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;\n}\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi2;\n  if (from == null) {\n    phi2 = direction * halfPi3;\n    stream.point(-pi4, phi2);\n    stream.point(0, phi2);\n    stream.point(pi4, phi2);\n    stream.point(pi4, 0);\n    stream.point(pi4, -phi2);\n    stream.point(0, -phi2);\n    stream.point(-pi4, -phi2);\n    stream.point(-pi4, 0);\n    stream.point(-pi4, phi2);\n  } else if (abs3(from[0] - to[0]) > epsilon7) {\n    var lambda = from[0] < to[0] ? pi4 : -pi4;\n    phi2 = direction * lambda / 2;\n    stream.point(-lambda, phi2);\n    stream.point(0, phi2);\n    stream.point(lambda, phi2);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\n// node_modules/d3-geo/src/clip/circle.js\nfunction circle_default2(radius2) {\n  var cr = cos2(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius2, delta, direction, from, to);\n  }\n  function visible(lambda, phi2) {\n    return cos2(lambda) * cos2(phi2) > cr;\n  }\n  function clipLine(stream) {\n    var point0, c0, v0, v00, clean;\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi2) {\n        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c6 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;\n        if (!point0 && (v00 = v0 = v2))\n          stream.lineStart();\n        if (v2 !== v0) {\n          point22 = intersect2(point0, point1);\n          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))\n            point1[2] = 1;\n        }\n        if (v2 !== v0) {\n          clean = 0;\n          if (v2) {\n            stream.lineStart();\n            point22 = intersect2(point1, point0);\n            stream.point(point22[0], point22[1]);\n          } else {\n            point22 = intersect2(point0, point1);\n            stream.point(point22[0], point22[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point22;\n        } else if (notHemisphere && point0 && smallRadius ^ v2) {\n          var t;\n          if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v2, c0 = c6;\n      },\n      lineEnd: function() {\n        if (v0)\n          stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  }\n  function intersect2(a4, b, two) {\n    var pa = cartesian(a4), pb = cartesian(b);\n    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n    if (!determinant)\n      return !two && a4;\n    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);\n    cartesianAddInPlace(A5, B3);\n    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);\n    if (t22 < 0)\n      return;\n    var t = sqrt(t22), q = cartesianScale(u4, (-w - t) / uu);\n    cartesianAddInPlace(q, A5);\n    q = spherical(q);\n    if (!two)\n      return q;\n    var lambda04 = a4[0], lambda12 = b[0], phi02 = a4[1], phi12 = b[1], z;\n    if (lambda12 < lambda04)\n      z = lambda04, lambda04 = lambda12, lambda12 = z;\n    var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;\n    if (!polar && phi12 < phi02)\n      z = phi02, phi02 = phi12, phi12 = z;\n    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {\n      var q1 = cartesianScale(u4, (-w + t) / uu);\n      cartesianAddInPlace(q1, A5);\n      return [q, spherical(q1)];\n    }\n  }\n  function code(lambda, phi2) {\n    var r = smallRadius ? radius2 : pi4 - radius2, code2 = 0;\n    if (lambda < -r)\n      code2 |= 1;\n    else if (lambda > r)\n      code2 |= 2;\n    if (phi2 < -r)\n      code2 |= 4;\n    else if (phi2 > r)\n      code2 |= 8;\n    return code2;\n  }\n  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi4, radius2 - pi4]);\n}\n\n// node_modules/d3-geo/src/clip/line.js\nfunction line_default(a4, b, x06, y06, x12, y12) {\n  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;\n  r = x06 - ax;\n  if (!dx && r > 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dx > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = x12 - ax;\n  if (!dx && r < 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dx > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  r = y06 - ay;\n  if (!dy && r > 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dy > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = y12 - ay;\n  if (!dy && r < 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dy > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  if (t03 > 0)\n    a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;\n  if (t13 < 1)\n    b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;\n  return true;\n}\n\n// node_modules/d3-geo/src/clip/rectangle.js\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\nfunction clipRectangle(x06, y06, x12, y12) {\n  function visible(x4, y4) {\n    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;\n  }\n  function interpolate(from, to, direction, stream) {\n    var a4 = 0, a1 = 0;\n    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do\n        stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);\n      while ((a4 = (a4 + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n  function corner(p, direction) {\n    return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n  }\n  function compareIntersection2(a4, b) {\n    return comparePoint(a4.x, b.x);\n  }\n  function comparePoint(a4, b) {\n    var ca3 = corner(a4, 1), cb = corner(b, 1);\n    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a4[1] : ca3 === 1 ? a4[0] - b[0] : ca3 === 2 ? a4[1] - b[1] : b[0] - a4[0];\n  }\n  return function(stream) {\n    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;\n    var clipStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart,\n      polygonEnd\n    };\n    function point6(x4, y4) {\n      if (visible(x4, y4))\n        activeStream.point(x4, y4);\n    }\n    function polygonInside() {\n      var winding = 0;\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j < m3; ++j) {\n          a0 = b02, a1 = b12, point7 = ring2[j], b02 = point7[0], b12 = point7[1];\n          if (a1 <= y12) {\n            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0))\n              ++winding;\n          } else {\n            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0))\n              --winding;\n          }\n        }\n      }\n      return winding;\n    }\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n    function polygonEnd() {\n      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;\n      if (cleanInside || visible2) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible2) {\n          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n    function lineStart() {\n      clipStream.point = linePoint2;\n      if (polygon)\n        polygon.push(ring = []);\n      first2 = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n    function lineEnd() {\n      if (segments) {\n        linePoint2(x__, y__);\n        if (v__ && v_)\n          bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point6;\n      if (v_)\n        activeStream.lineEnd();\n    }\n    function linePoint2(x4, y4) {\n      var v2 = visible(x4, y4);\n      if (polygon)\n        ring.push([x4, y4]);\n      if (first2) {\n        x__ = x4, y__ = y4, v__ = v2;\n        first2 = false;\n        if (v2) {\n          activeStream.lineStart();\n          activeStream.point(x4, y4);\n        }\n      } else {\n        if (v2 && v_)\n          activeStream.point(x4, y4);\n        else {\n          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];\n          if (line_default(a4, b, x06, y06, x12, y12)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a4[0], a4[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v2)\n              activeStream.lineEnd();\n            clean = false;\n          } else if (v2) {\n            activeStream.lineStart();\n            activeStream.point(x4, y4);\n            clean = false;\n          }\n        }\n      }\n      x_ = x4, y_ = y4, v_ = v2;\n    }\n    return clipStream;\n  };\n}\n\n// node_modules/d3-geo/src/clip/extent.js\nfunction extent_default2() {\n  var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip;\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip) : [[x06, y06], [x12, y12]];\n    }\n  };\n}\n\n// node_modules/d3-geo/src/length.js\nvar lengthSum;\nvar lambda03;\nvar sinPhi02;\nvar cosPhi02;\nvar lengthStream = {\n  sphere: noop2,\n  point: noop2,\n  lineStart: lengthLineStart,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2\n};\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop2;\n}\nfunction lengthPointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);\n  lengthStream.point = lengthPoint;\n}\nfunction lengthPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x4 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z));\n  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;\n}\nfunction length_default(object2) {\n  lengthSum = new Adder();\n  stream_default(object2, lengthStream);\n  return +lengthSum;\n}\n\n// node_modules/d3-geo/src/distance.js\nvar coordinates = [null, null];\nvar object = { type: \"LineString\", coordinates };\nfunction distance_default(a4, b) {\n  coordinates[0] = a4;\n  coordinates[1] = b;\n  return length_default(object);\n}\n\n// node_modules/d3-geo/src/contains.js\nvar containsObjectType = {\n  Feature: function(object2, point6) {\n    return containsGeometry(object2.geometry, point6);\n  },\n  FeatureCollection: function(object2, point6) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      if (containsGeometry(features[i].geometry, point6))\n        return true;\n    return false;\n  }\n};\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object2, point6) {\n    return containsPoint(object2.coordinates, point6);\n  },\n  MultiPoint: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPoint(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  LineString: function(object2, point6) {\n    return containsLine(object2.coordinates, point6);\n  },\n  MultiLineString: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsLine(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  Polygon: function(object2, point6) {\n    return containsPolygon(object2.coordinates, point6);\n  },\n  MultiPolygon: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPolygon(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  GeometryCollection: function(object2, point6) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      if (containsGeometry(geometries[i], point6))\n        return true;\n    return false;\n  }\n};\nfunction containsGeometry(geometry, point6) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;\n}\nfunction containsPoint(coordinates2, point6) {\n  return distance_default(coordinates2, point6) === 0;\n}\nfunction containsLine(coordinates2, point6) {\n  var ao, bo, ab4;\n  for (var i = 0, n = coordinates2.length; i < n; i++) {\n    bo = distance_default(coordinates2[i], point6);\n    if (bo === 0)\n      return true;\n    if (i > 0) {\n      ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);\n      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)\n        return true;\n    }\n    ao = bo;\n  }\n  return false;\n}\nfunction containsPolygon(coordinates2, point6) {\n  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));\n}\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\nfunction pointRadians(point6) {\n  return [point6[0] * radians2, point6[1] * radians2];\n}\nfunction contains_default2(object2, point6) {\n  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);\n}\n\n// node_modules/d3-geo/src/graticule.js\nfunction graticuleX(y06, y12, dy) {\n  var y4 = range(y06, y12 - epsilon7, dy).concat(y12);\n  return function(x4) {\n    return y4.map(function(y5) {\n      return [x4, y5];\n    });\n  };\n}\nfunction graticuleY(x06, x12, dx) {\n  var x4 = range(x06, x12 - epsilon7, dx).concat(x12);\n  return function(y4) {\n    return x4.map(function(x5) {\n      return [x5, y4];\n    });\n  };\n}\nfunction graticule() {\n  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;\n  function graticule3() {\n    return { type: \"MultiLineString\", coordinates: lines() };\n  }\n  function lines() {\n    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {\n      return abs3(x5 % DX) > epsilon7;\n    }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {\n      return abs3(y5 % DY) > epsilon7;\n    }).map(y4));\n  }\n  graticule3.lines = function() {\n    return lines().map(function(coordinates2) {\n      return { type: \"LineString\", coordinates: coordinates2 };\n    });\n  };\n  graticule3.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X3(X03).concat(\n          Y3(Y13).slice(1),\n          X3(X13).reverse().slice(1),\n          Y3(Y03).reverse().slice(1)\n        )\n      ]\n    };\n  };\n  graticule3.extent = function(_) {\n    if (!arguments.length)\n      return graticule3.extentMinor();\n    return graticule3.extentMajor(_).extentMinor(_);\n  };\n  graticule3.extentMajor = function(_) {\n    if (!arguments.length)\n      return [[X03, Y03], [X13, Y13]];\n    X03 = +_[0][0], X13 = +_[1][0];\n    Y03 = +_[0][1], Y13 = +_[1][1];\n    if (X03 > X13)\n      _ = X03, X03 = X13, X13 = _;\n    if (Y03 > Y13)\n      _ = Y03, Y03 = Y13, Y13 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.extentMinor = function(_) {\n    if (!arguments.length)\n      return [[x06, y06], [x12, y12]];\n    x06 = +_[0][0], x12 = +_[1][0];\n    y06 = +_[0][1], y12 = +_[1][1];\n    if (x06 > x12)\n      _ = x06, x06 = x12, x12 = _;\n    if (y06 > y12)\n      _ = y06, y06 = y12, y12 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.step = function(_) {\n    if (!arguments.length)\n      return graticule3.stepMinor();\n    return graticule3.stepMajor(_).stepMinor(_);\n  };\n  graticule3.stepMajor = function(_) {\n    if (!arguments.length)\n      return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule3;\n  };\n  graticule3.stepMinor = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule3;\n  };\n  graticule3.precision = function(_) {\n    if (!arguments.length)\n      return precision;\n    precision = +_;\n    x4 = graticuleX(y06, y12, 90);\n    y4 = graticuleY(x06, x12, precision);\n    X3 = graticuleX(Y03, Y13, 90);\n    Y3 = graticuleY(X03, X13, precision);\n    return graticule3;\n  };\n  return graticule3.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);\n}\nfunction graticule10() {\n  return graticule()();\n}\n\n// node_modules/d3-geo/src/interpolate.js\nfunction interpolate_default2(a4, b) {\n  var x06 = a4[0] * radians2, y06 = a4[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k2 = sin2(d);\n  var interpolate = d ? function(t) {\n    var B3 = sin2(t *= d) / k2, A5 = sin2(d - t) / k2, x4 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;\n    return [\n      atan2(y4, x4) * degrees3,\n      atan2(z, sqrt(x4 * x4 + y4 * y4)) * degrees3\n    ];\n  } : function() {\n    return [x06 * degrees3, y06 * degrees3];\n  };\n  interpolate.distance = d;\n  return interpolate;\n}\n\n// node_modules/d3-geo/src/identity.js\nvar identity_default3 = (x4) => x4;\n\n// node_modules/d3-geo/src/path/area.js\nvar areaSum2 = new Adder();\nvar areaRingSum2 = new Adder();\nvar x00;\nvar y00;\nvar x02;\nvar y02;\nvar areaStream2 = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaStream2.lineStart = areaRingStart2;\n    areaStream2.lineEnd = areaRingEnd2;\n  },\n  polygonEnd: function() {\n    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;\n    areaSum2.add(abs3(areaRingSum2));\n    areaRingSum2 = new Adder();\n  },\n  result: function() {\n    var area2 = areaSum2 / 2;\n    areaSum2 = new Adder();\n    return area2;\n  }\n};\nfunction areaRingStart2() {\n  areaStream2.point = areaPointFirst2;\n}\nfunction areaPointFirst2(x4, y4) {\n  areaStream2.point = areaPoint2;\n  x00 = x02 = x4, y00 = y02 = y4;\n}\nfunction areaPoint2(x4, y4) {\n  areaRingSum2.add(y02 * x4 - x02 * y4);\n  x02 = x4, y02 = y4;\n}\nfunction areaRingEnd2() {\n  areaPoint2(x00, y00);\n}\nvar area_default3 = areaStream2;\n\n// node_modules/d3-geo/src/path/bounds.js\nvar x03 = Infinity;\nvar y03 = x03;\nvar x1 = -x03;\nvar y1 = x1;\nvar boundsStream2 = {\n  point: boundsPoint2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2,\n  result: function() {\n    var bounds = [[x03, y03], [x1, y1]];\n    x1 = y1 = -(y03 = x03 = Infinity);\n    return bounds;\n  }\n};\nfunction boundsPoint2(x4, y4) {\n  if (x4 < x03)\n    x03 = x4;\n  if (x4 > x1)\n    x1 = x4;\n  if (y4 < y03)\n    y03 = y4;\n  if (y4 > y1)\n    y1 = y4;\n}\nvar bounds_default2 = boundsStream2;\n\n// node_modules/d3-geo/src/path/centroid.js\nvar X02 = 0;\nvar Y02 = 0;\nvar Z02 = 0;\nvar X12 = 0;\nvar Y12 = 0;\nvar Z12 = 0;\nvar X22 = 0;\nvar Y22 = 0;\nvar Z22 = 0;\nvar x002;\nvar y002;\nvar x04;\nvar y04;\nvar centroidStream2 = {\n  point: centroidPoint2,\n  lineStart: centroidLineStart2,\n  lineEnd: centroidLineEnd2,\n  polygonStart: function() {\n    centroidStream2.lineStart = centroidRingStart2;\n    centroidStream2.lineEnd = centroidRingEnd2;\n  },\n  polygonEnd: function() {\n    centroidStream2.point = centroidPoint2;\n    centroidStream2.lineStart = centroidLineStart2;\n    centroidStream2.lineEnd = centroidLineEnd2;\n  },\n  result: function() {\n    var centroid2 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];\n    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;\n    return centroid2;\n  }\n};\nfunction centroidPoint2(x4, y4) {\n  X02 += x4;\n  Y02 += y4;\n  ++Z02;\n}\nfunction centroidLineStart2() {\n  centroidStream2.point = centroidPointFirstLine;\n}\nfunction centroidPointFirstLine(x4, y4) {\n  centroidStream2.point = centroidPointLine;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidPointLine(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidLineEnd2() {\n  centroidStream2.point = centroidPoint2;\n}\nfunction centroidRingStart2() {\n  centroidStream2.point = centroidPointFirstRing;\n}\nfunction centroidRingEnd2() {\n  centroidPointRing(x002, y002);\n}\nfunction centroidPointFirstRing(x4, y4) {\n  centroidStream2.point = centroidPointRing;\n  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);\n}\nfunction centroidPointRing(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  z = y04 * x4 - x04 * y4;\n  X22 += z * (x04 + x4);\n  Y22 += z * (y04 + y4);\n  Z22 += z * 3;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nvar centroid_default2 = centroidStream2;\n\n// node_modules/d3-geo/src/path/context.js\nfunction PathContext(context) {\n  this._context = context;\n}\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0)\n      this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x4, y4);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x4, y4);\n        break;\n      }\n      default: {\n        this._context.moveTo(x4 + this._radius, y4);\n        this._context.arc(x4, y4, this._radius, 0, tau5);\n        break;\n      }\n    }\n  },\n  result: noop2\n};\n\n// node_modules/d3-geo/src/path/measure.js\nvar lengthSum2 = new Adder();\nvar lengthRing;\nvar x003;\nvar y003;\nvar x05;\nvar y05;\nvar lengthStream2 = {\n  point: noop2,\n  lineStart: function() {\n    lengthStream2.point = lengthPointFirst2;\n  },\n  lineEnd: function() {\n    if (lengthRing)\n      lengthPoint2(x003, y003);\n    lengthStream2.point = noop2;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length4 = +lengthSum2;\n    lengthSum2 = new Adder();\n    return length4;\n  }\n};\nfunction lengthPointFirst2(x4, y4) {\n  lengthStream2.point = lengthPoint2;\n  x003 = x05 = x4, y003 = y05 = y4;\n}\nfunction lengthPoint2(x4, y4) {\n  x05 -= x4, y05 -= y4;\n  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));\n  x05 = x4, y05 = y4;\n}\nvar measure_default = lengthStream2;\n\n// node_modules/d3-geo/src/path/string.js\nvar cacheDigits;\nvar cacheAppend;\nvar cacheRadius;\nvar cacheCircle;\nvar PathString = class {\n  constructor(digits) {\n    this._append = digits == null ? append2 : appendRound2(digits);\n    this._radius = 4.5;\n    this._ = \"\";\n  }\n  pointRadius(_) {\n    this._radius = +_;\n    return this;\n  }\n  polygonStart() {\n    this._line = 0;\n  }\n  polygonEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line === 0)\n      this._ += \"Z\";\n    this._point = NaN;\n  }\n  point(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._append`M${x4},${y4}`;\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._append`L${x4},${y4}`;\n        break;\n      }\n      default: {\n        this._append`M${x4},${y4}`;\n        if (this._radius !== cacheRadius || this._append !== cacheAppend) {\n          const r = this._radius;\n          const s2 = this._;\n          this._ = \"\";\n          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;\n          cacheRadius = r;\n          cacheAppend = this._append;\n          cacheCircle = this._;\n          this._ = s2;\n        }\n        this._ += cacheCircle;\n        break;\n      }\n    }\n  }\n  result() {\n    const result = this._;\n    this._ = \"\";\n    return result.length ? result : null;\n  }\n};\nfunction append2(strings) {\n  let i = 1;\n  this._ += strings[0];\n  for (const j = strings.length; i < j; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound2(digits) {\n  const d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new RangeError(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append2;\n  if (d !== cacheDigits) {\n    const k2 = 10 ** d;\n    cacheDigits = d;\n    cacheAppend = function append3(strings) {\n      let i = 1;\n      this._ += strings[0];\n      for (const j = strings.length; i < j; ++i) {\n        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n      }\n    };\n  }\n  return cacheAppend;\n}\n\n// node_modules/d3-geo/src/path/index.js\nfunction path_default(projection2, context) {\n  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;\n  function path2(object2) {\n    if (object2) {\n      if (typeof pointRadius === \"function\")\n        contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream_default(object2, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n  path2.area = function(object2) {\n    stream_default(object2, projectionStream(area_default3));\n    return area_default3.result();\n  };\n  path2.measure = function(object2) {\n    stream_default(object2, projectionStream(measure_default));\n    return measure_default.result();\n  };\n  path2.bounds = function(object2) {\n    stream_default(object2, projectionStream(bounds_default2));\n    return bounds_default2.result();\n  };\n  path2.centroid = function(object2) {\n    stream_default(object2, projectionStream(centroid_default2));\n    return centroid_default2.result();\n  };\n  path2.projection = function(_) {\n    if (!arguments.length)\n      return projection2;\n    projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream;\n    return path2;\n  };\n  path2.context = function(_) {\n    if (!arguments.length)\n      return context;\n    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\")\n      contextStream.pointRadius(pointRadius);\n    return path2;\n  };\n  path2.pointRadius = function(_) {\n    if (!arguments.length)\n      return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path2;\n  };\n  path2.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null)\n      digits = null;\n    else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    if (context === null)\n      contextStream = new PathString(digits);\n    return path2;\n  };\n  return path2.projection(projection2).digits(digits).context(context);\n}\n\n// node_modules/d3-geo/src/transform.js\nfunction transform_default(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\nfunction transformer(methods) {\n  return function(stream) {\n    var s2 = new TransformStream();\n    for (var key in methods)\n      s2[key] = methods[key];\n    s2.stream = stream;\n    return s2;\n  };\n}\nfunction TransformStream() {\n}\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x4, y4) {\n    this.stream.point(x4, y4);\n  },\n  sphere: function() {\n    this.stream.sphere();\n  },\n  lineStart: function() {\n    this.stream.lineStart();\n  },\n  lineEnd: function() {\n    this.stream.lineEnd();\n  },\n  polygonStart: function() {\n    this.stream.polygonStart();\n  },\n  polygonEnd: function() {\n    this.stream.polygonEnd();\n  }\n};\n\n// node_modules/d3-geo/src/projection/fit.js\nfunction fit(projection2, fitBounds, object2) {\n  var clip = projection2.clipExtent && projection2.clipExtent();\n  projection2.scale(150).translate([0, 0]);\n  if (clip != null)\n    projection2.clipExtent(null);\n  stream_default(object2, projection2.stream(bounds_default2));\n  fitBounds(bounds_default2.result());\n  if (clip != null)\n    projection2.clipExtent(clip);\n  return projection2;\n}\nfunction fitExtent(projection2, extent3, object2) {\n  return fit(projection2, function(b) {\n    var w = extent3[1][0] - extent3[0][0], h = extent3[1][1] - extent3[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x4 = +extent3[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent3[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitSize(projection2, size, object2) {\n  return fitExtent(projection2, [[0, 0], size], object2);\n}\nfunction fitWidth(projection2, width, object2) {\n  return fit(projection2, function(b) {\n    var w = +width, k2 = w / (b[1][0] - b[0][0]), x4 = (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitHeight(projection2, height, object2) {\n  return fit(projection2, function(b) {\n    var h = +height, k2 = h / (b[1][1] - b[0][1]), x4 = -k2 * b[0][0], y4 = (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\n\n// node_modules/d3-geo/src/projection/resample.js\nvar maxDepth = 16;\nvar cosMinDistance = cos2(30 * radians2);\nfunction resample_default(project2, delta2) {\n  return +delta2 ? resample(project2, delta2) : resampleNone(project2);\n}\nfunction resampleNone(project2) {\n  return transformer({\n    point: function(x4, y4) {\n      x4 = project2(x4, y4);\n      this.stream.point(x4[0], x4[1]);\n    }\n  });\n}\nfunction resample(project2, delta2) {\n  function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {\n    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a4 = a0 + a1, b = b02 + b12, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b * b + c6 * c6), phi2 = asin(c6 /= m3), lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a4), p = project2(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {\n        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m3, b /= m3, c6, depth, stream);\n        stream.point(x22, y22);\n        resampleLineTo(x22, y22, lambda22, a4, b, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;\n    var resampleStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        stream.polygonStart();\n        resampleStream.lineStart = ringStart;\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n        resampleStream.lineStart = lineStart;\n      }\n    };\n    function point6(x4, y4) {\n      x4 = project2(x4, y4);\n      stream.point(x4[0], x4[1]);\n    }\n    function lineStart() {\n      x06 = NaN;\n      resampleStream.point = linePoint2;\n      stream.lineStart();\n    }\n    function linePoint2(lambda, phi2) {\n      var c6 = cartesian([lambda, phi2]), p = project2(lambda, phi2);\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);\n      stream.point(x06, y06);\n    }\n    function lineEnd() {\n      resampleStream.point = point6;\n      stream.lineEnd();\n    }\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n    function ringPoint(lambda, phi2) {\n      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;\n      resampleStream.point = linePoint2;\n    }\n    function ringEnd() {\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n    return resampleStream;\n  };\n}\n\n// node_modules/d3-geo/src/projection/index.js\nvar transformRadians = transformer({\n  point: function(x4, y4) {\n    this.stream.point(x4 * radians2, y4 * radians2);\n  }\n});\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x4, y4) {\n      var r = rotate(x4, y4);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\nfunction scaleTranslate(k2, dx, dy, sx, sy) {\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [dx + k2 * x4, dy - k2 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [(x4 - dx) / k2 * sx, (dy - y4) / k2 * sy];\n  };\n  return transform2;\n}\nfunction scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {\n  if (!alpha)\n    return scaleTranslate(k2, dx, dy, sx, sy);\n  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [a4 * x4 - b * y4 + dx, dy - b * x4 - a4 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];\n  };\n  return transform2;\n}\nfunction projection(project2) {\n  return projectionMutator(function() {\n    return project2;\n  })();\n}\nfunction projectionMutator(projectAt) {\n  var project2, k2 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;\n  function projection2(point6) {\n    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);\n  }\n  function invert(point6) {\n    point6 = projectRotateTransform.invert(point6[0], point6[1]);\n    return point6 && [point6[0] * degrees3, point6[1] * degrees3];\n  }\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n  projection2.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, recenter()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (x4 = +_[0], y4 = +_[1], recenter()) : [x4, y4];\n  };\n  projection2.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];\n  };\n  projection2.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;\n  };\n  projection2.precision = function(_) {\n    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  function recenter() {\n    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x4 - center2[0], y4 - center2[1], sx, sy, alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose_default(project2, transform2);\n    projectRotateTransform = compose_default(rotate, projectTransform);\n    projectResample = resample_default(projectTransform, delta2);\n    return reset();\n  }\n  function reset() {\n    cache = cacheStream = null;\n    return projection2;\n  }\n  return function() {\n    project2 = projectAt.apply(this, arguments);\n    projection2.invert = project2.invert && invert;\n    return recenter();\n  };\n}\n\n// node_modules/d3-geo/src/projection/conic.js\nfunction conicProjection(projectAt) {\n  var phi02 = 0, phi12 = pi4 / 3, m3 = projectionMutator(projectAt), p = m3(phi02, phi12);\n  p.parallels = function(_) {\n    return arguments.length ? m3(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];\n  };\n  return p;\n}\n\n// node_modules/d3-geo/src/projection/cylindricalEqualArea.js\nfunction cylindricalEqualAreaRaw(phi02) {\n  var cosPhi03 = cos2(phi02);\n  function forward(lambda, phi2) {\n    return [lambda * cosPhi03, sin2(phi2) / cosPhi03];\n  }\n  forward.invert = function(x4, y4) {\n    return [x4 / cosPhi03, asin(y4 * cosPhi03)];\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/projection/conicEqualArea.js\nfunction conicEqualAreaRaw(y06, y12) {\n  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;\n  if (abs3(n) < epsilon7)\n    return cylindricalEqualAreaRaw(y06);\n  var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c6) / n;\n  function project2(x4, y4) {\n    var r = sqrt(c6 - 2 * n * sin2(y4)) / n;\n    return [r * sin2(x4 *= n), r0 - r * cos2(x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var r0y = r0 - y4, l = atan2(x4, abs3(r0y)) * sign(r0y);\n    if (r0y * n < 0)\n      l -= pi4 * sign(x4) * sign(r0y);\n    return [l / n, asin((c6 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];\n  };\n  return project2;\n}\nfunction conicEqualArea_default() {\n  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);\n}\n\n// node_modules/d3-geo/src/projection/albers.js\nfunction albers_default() {\n  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);\n}\n\n// node_modules/d3-geo/src/projection/albersUsa.js\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x4, y4) {\n      var i = -1;\n      while (++i < n)\n        streams[i].point(x4, y4);\n    },\n    sphere: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].sphere();\n    },\n    lineStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineStart();\n    },\n    lineEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineEnd();\n    },\n    polygonStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonStart();\n    },\n    polygonEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonEnd();\n    }\n  };\n}\nfunction albersUsa_default() {\n  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x4, y4) {\n    point6 = [x4, y4];\n  } };\n  function albersUsa(coordinates2) {\n    var x4 = coordinates2[0], y4 = coordinates2[1];\n    return point6 = null, (lower48Point.point(x4, y4), point6) || (alaskaPoint.point(x4, y4), point6) || (hawaiiPoint.point(x4, y4), point6);\n  }\n  albersUsa.invert = function(coordinates2) {\n    var k2 = lower48.scale(), t = lower48.translate(), x4 = (coordinates2[0] - t[0]) / k2, y4 = (coordinates2[1] - t[1]) / k2;\n    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);\n  };\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n  albersUsa.precision = function(_) {\n    if (!arguments.length)\n      return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n  albersUsa.scale = function(_) {\n    if (!arguments.length)\n      return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n  albersUsa.translate = function(_) {\n    if (!arguments.length)\n      return lower48.translate();\n    var k2 = lower48.scale(), x4 = +_[0], y4 = +_[1];\n    lower48Point = lower48.translate(_).clipExtent([[x4 - 0.455 * k2, y4 - 0.238 * k2], [x4 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);\n    alaskaPoint = alaska.translate([x4 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x4 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7], [x4 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    hawaiiPoint = hawaii.translate([x4 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x4 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7], [x4 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    return reset();\n  };\n  albersUsa.fitExtent = function(extent3, object2) {\n    return fitExtent(albersUsa, extent3, object2);\n  };\n  albersUsa.fitSize = function(size, object2) {\n    return fitSize(albersUsa, size, object2);\n  };\n  albersUsa.fitWidth = function(width, object2) {\n    return fitWidth(albersUsa, width, object2);\n  };\n  albersUsa.fitHeight = function(height, object2) {\n    return fitHeight(albersUsa, height, object2);\n  };\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n  return albersUsa.scale(1070);\n}\n\n// node_modules/d3-geo/src/projection/azimuthal.js\nfunction azimuthalRaw(scale3) {\n  return function(x4, y4) {\n    var cx = cos2(x4), cy = cos2(y4), k2 = scale3(cx * cy);\n    if (k2 === Infinity)\n      return [2, 0];\n    return [\n      k2 * cy * sin2(x4),\n      k2 * sin2(y4)\n    ];\n  };\n}\nfunction azimuthalInvert(angle2) {\n  return function(x4, y4) {\n    var z = sqrt(x4 * x4 + y4 * y4), c6 = angle2(z), sc = sin2(c6), cc2 = cos2(c6);\n    return [\n      atan2(x4 * sc, z * cc2),\n      asin(z && y4 * sc / z)\n    ];\n  };\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEqualArea.js\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\nfunction azimuthalEqualArea_default() {\n  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEquidistant.js\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c6) {\n  return (c6 = acos(c6)) && c6 / sin2(c6);\n});\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\nfunction azimuthalEquidistant_default() {\n  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/mercator.js\nfunction mercatorRaw(lambda, phi2) {\n  return [lambda, log(tan((halfPi3 + phi2) / 2))];\n}\nmercatorRaw.invert = function(x4, y4) {\n  return [x4, 2 * atan(exp(y4)) - halfPi3];\n};\nfunction mercator_default() {\n  return mercatorProjection(mercatorRaw).scale(961 / tau5);\n}\nfunction mercatorProjection(project2) {\n  var m3 = projection(project2), center2 = m3.center, scale3 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;\n  m3.scale = function(_) {\n    return arguments.length ? (scale3(_), reclip()) : scale3();\n  };\n  m3.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n  m3.center = function(_) {\n    return arguments.length ? (center2(_), reclip()) : center2();\n  };\n  m3.clipExtent = function(_) {\n    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  function reclip() {\n    var k2 = pi4 * scale3(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));\n    return clipExtent(x06 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project2 === mercatorRaw ? [[Math.max(t[0] - k2, x06), y06], [Math.min(t[0] + k2, x12), y12]] : [[x06, Math.max(t[1] - k2, y06)], [x12, Math.min(t[1] + k2, y12)]]);\n  }\n  return reclip();\n}\n\n// node_modules/d3-geo/src/projection/conicConformal.js\nfunction tany(y4) {\n  return tan((halfPi3 + y4) / 2);\n}\nfunction conicConformalRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;\n  if (!n)\n    return mercatorRaw;\n  function project2(x4, y4) {\n    if (f > 0) {\n      if (y4 < -halfPi3 + epsilon7)\n        y4 = -halfPi3 + epsilon7;\n    } else {\n      if (y4 > halfPi3 - epsilon7)\n        y4 = halfPi3 - epsilon7;\n    }\n    var r = f / pow2(tany(y4), n);\n    return [r * sin2(n * x4), f - r * cos2(n * x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var fy = f - y4, r = sign(n) * sqrt(x4 * x4 + fy * fy), l = atan2(x4, abs3(fy)) * sign(fy);\n    if (fy * n < 0)\n      l -= pi4 * sign(x4) * sign(fy);\n    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];\n  };\n  return project2;\n}\nfunction conicConformal_default() {\n  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);\n}\n\n// node_modules/d3-geo/src/projection/equirectangular.js\nfunction equirectangularRaw(lambda, phi2) {\n  return [lambda, phi2];\n}\nequirectangularRaw.invert = equirectangularRaw;\nfunction equirectangular_default() {\n  return projection(equirectangularRaw).scale(152.63);\n}\n\n// node_modules/d3-geo/src/projection/conicEquidistant.js\nfunction conicEquidistantRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;\n  if (abs3(n) < epsilon7)\n    return equirectangularRaw;\n  function project2(x4, y4) {\n    var gy = g - y4, nx = n * x4;\n    return [gy * sin2(nx), g - gy * cos2(nx)];\n  }\n  project2.invert = function(x4, y4) {\n    var gy = g - y4, l = atan2(x4, abs3(gy)) * sign(gy);\n    if (gy * n < 0)\n      l -= pi4 * sign(x4) * sign(gy);\n    return [l / n, g - sign(n) * sqrt(x4 * x4 + gy * gy)];\n  };\n  return project2;\n}\nfunction conicEquidistant_default() {\n  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);\n}\n\n// node_modules/d3-geo/src/projection/equalEarth.js\nvar A1 = 1.340264;\nvar A2 = -0.081106;\nvar A3 = 893e-6;\nvar A4 = 3796e-6;\nvar M = sqrt(3) / 2;\nvar iterations = 12;\nfunction equalEarthRaw(lambda, phi2) {\n  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\nequalEarthRaw.invert = function(x4, y4) {\n  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs3(delta) < epsilon22)\n      break;\n  }\n  return [\n    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),\n    asin(sin2(l) / M)\n  ];\n};\nfunction equalEarth_default() {\n  return projection(equalEarthRaw).scale(177.158);\n}\n\n// node_modules/d3-geo/src/projection/gnomonic.js\nfunction gnomonicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\ngnomonicRaw.invert = azimuthalInvert(atan);\nfunction gnomonic_default() {\n  return projection(gnomonicRaw).scale(144.049).clipAngle(60);\n}\n\n// node_modules/d3-geo/src/projection/identity.js\nfunction identity_default4() {\n  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({\n    point: function(x4, y4) {\n      var p = projection2([x4, y4]);\n      this.stream.point(p[0], p[1]);\n    }\n  }), postclip = identity_default3, cache, cacheStream;\n  function reset() {\n    kx2 = k2 * sx;\n    ky2 = k2 * sy;\n    cache = cacheStream = null;\n    return projection2;\n  }\n  function projection2(p) {\n    var x4 = p[0] * kx2, y4 = p[1] * ky2;\n    if (alpha) {\n      var t = y4 * ca3 - x4 * sa;\n      x4 = x4 * ca3 + y4 * sa;\n      y4 = t;\n    }\n    return [x4 + tx, y4 + ty];\n  }\n  projection2.invert = function(p) {\n    var x4 = p[0] - tx, y4 = p[1] - ty;\n    if (alpha) {\n      var t = y4 * ca3 + x4 * sa;\n      x4 = x4 * ca3 - y4 * sa;\n      y4 = t;\n    }\n    return [x4 / kx2, y4 / ky2];\n  };\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, reset()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  return projection2;\n}\n\n// node_modules/d3-geo/src/projection/naturalEarth1.js\nfunction naturalEarth1Raw(lambda, phi2) {\n  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n  return [\n    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),\n    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))\n  ];\n}\nnaturalEarth1Raw.invert = function(x4, y4) {\n  var phi2 = y4, i = 25, delta;\n  do {\n    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));\n  } while (abs3(delta) > epsilon7 && --i > 0);\n  return [\n    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),\n    phi2\n  ];\n};\nfunction naturalEarth1_default() {\n  return projection(naturalEarth1Raw).scale(175.295);\n}\n\n// node_modules/d3-geo/src/projection/orthographic.js\nfunction orthographicRaw(x4, y4) {\n  return [cos2(y4) * sin2(x4), sin2(y4)];\n}\northographicRaw.invert = azimuthalInvert(asin);\nfunction orthographic_default() {\n  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);\n}\n\n// node_modules/d3-geo/src/projection/stereographic.js\nfunction stereographicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = 1 + cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\nfunction stereographic_default() {\n  return projection(stereographicRaw).scale(250).clipAngle(142);\n}\n\n// node_modules/d3-geo/src/projection/transverseMercator.js\nfunction transverseMercatorRaw(lambda, phi2) {\n  return [log(tan((halfPi3 + phi2) / 2)), -lambda];\n}\ntransverseMercatorRaw.invert = function(x4, y4) {\n  return [-y4, 2 * atan(exp(x4)) - halfPi3];\n};\nfunction transverseMercator_default() {\n  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;\n  m3.center = function(_) {\n    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);\n  };\n  m3.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n  return rotate([0, 0, 90]).scale(159.155);\n}\n\n// node_modules/d3-hierarchy/src/cluster.js\nfunction defaultSeparation(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction meanX(children2) {\n  return children2.reduce(meanXReduce, 0) / children2.length;\n}\nfunction meanXReduce(x4, c6) {\n  return x4 + c6.x;\n}\nfunction maxY(children2) {\n  return 1 + children2.reduce(maxYReduce, 0);\n}\nfunction maxYReduce(y4, c6) {\n  return Math.max(y4, c6.y);\n}\nfunction leafLeft(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[0];\n  return node;\n}\nfunction leafRight(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[children2.length - 1];\n  return node;\n}\nfunction cluster_default() {\n  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;\n  function cluster2(root3) {\n    var previousNode, x4 = 0;\n    root3.eachAfter(function(node) {\n      var children2 = node.children;\n      if (children2) {\n        node.x = meanX(children2);\n        node.y = maxY(children2);\n      } else {\n        node.x = previousNode ? x4 += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n    var left2 = leafLeft(root3), right2 = leafRight(root3), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;\n    return root3.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root3.x) * dx;\n      node.y = (root3.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x06) / (x12 - x06) * dx;\n      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;\n    });\n  }\n  cluster2.separation = function(x4) {\n    return arguments.length ? (separation = x4, cluster2) : separation;\n  };\n  cluster2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? null : [dx, dy];\n  };\n  cluster2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? [dx, dy] : null;\n  };\n  return cluster2;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/count.js\nfunction count2(node) {\n  var sum5 = 0, children2 = node.children, i = children2 && children2.length;\n  if (!i)\n    sum5 = 1;\n  else\n    while (--i >= 0)\n      sum5 += children2[i].value;\n  node.value = sum5;\n}\nfunction count_default() {\n  return this.eachAfter(count2);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/each.js\nfunction each_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js\nfunction eachBefore_default(callback, that) {\n  var node = this, nodes = [node], children2, i, index3 = -1;\n  while (node = nodes.pop()) {\n    callback.call(that, node, ++index3, this);\n    if (children2 = node.children) {\n      for (i = children2.length - 1; i >= 0; --i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js\nfunction eachAfter_default(callback, that) {\n  var node = this, nodes = [node], next = [], children2, i, n, index3 = -1;\n  while (node = nodes.pop()) {\n    next.push(node);\n    if (children2 = node.children) {\n      for (i = 0, n = children2.length; i < n; ++i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  while (node = next.pop()) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/find.js\nfunction find_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    if (callback.call(that, node, ++index3, this)) {\n      return node;\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sum.js\nfunction sum_default(value) {\n  return this.eachAfter(function(node) {\n    var sum5 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;\n    while (--i >= 0)\n      sum5 += children2[i].value;\n    node.value = sum5;\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sort.js\nfunction sort_default2(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/path.js\nfunction path_default2(end) {\n  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];\n  while (start2 !== ancestor) {\n    start2 = start2.parent;\n    nodes.push(start2);\n  }\n  var k2 = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k2, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\nfunction leastCommonAncestor(a4, b) {\n  if (a4 === b)\n    return a4;\n  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c6 = null;\n  a4 = aNodes.pop();\n  b = bNodes.pop();\n  while (a4 === b) {\n    c6 = a4;\n    a4 = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c6;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/ancestors.js\nfunction ancestors_default() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/descendants.js\nfunction descendants_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/leaves.js\nfunction leaves_default() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/links.js\nfunction links_default() {\n  var root3 = this, links = [];\n  root3.each(function(node) {\n    if (node !== root3) {\n      links.push({ source: node.parent, target: node });\n    }\n  });\n  return links;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/iterator.js\nfunction* iterator_default2() {\n  var node = this, current, next = [node], children2, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      yield node;\n      if (children2 = node.children) {\n        for (i = 0, n = children2.length; i < n; ++i) {\n          next.push(children2[i]);\n        }\n      }\n    }\n  } while (next.length);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/index.js\nfunction hierarchy(data, children2) {\n  if (data instanceof Map) {\n    data = [void 0, data];\n    if (children2 === void 0)\n      children2 = mapChildren;\n  } else if (children2 === void 0) {\n    children2 = objectChildren;\n  }\n  var root3 = new Node2(data), node, nodes = [root3], child, childs, i, n;\n  while (node = nodes.pop()) {\n    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {\n      node.children = childs;\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = childs[i] = new Node2(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n  return root3.eachBefore(computeHeight);\n}\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\nfunction objectChildren(d) {\n  return d.children;\n}\nfunction mapChildren(d) {\n  return Array.isArray(d) ? d[1] : null;\n}\nfunction copyData(node) {\n  if (node.data.value !== void 0)\n    node.value = node.data.value;\n  node.data = node.data.data;\n}\nfunction computeHeight(node) {\n  var height = 0;\n  do\n    node.height = height;\n  while ((node = node.parent) && node.height < ++height);\n}\nfunction Node2(data) {\n  this.data = data;\n  this.depth = this.height = 0;\n  this.parent = null;\n}\nNode2.prototype = hierarchy.prototype = {\n  constructor: Node2,\n  count: count_default,\n  each: each_default2,\n  eachAfter: eachAfter_default,\n  eachBefore: eachBefore_default,\n  find: find_default2,\n  sum: sum_default,\n  sort: sort_default2,\n  path: path_default2,\n  ancestors: ancestors_default,\n  descendants: descendants_default,\n  leaves: leaves_default,\n  links: links_default,\n  copy: node_copy,\n  [Symbol.iterator]: iterator_default2\n};\n\n// node_modules/d3-hierarchy/src/accessors.js\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\nfunction required(f) {\n  if (typeof f !== \"function\")\n    throw new Error();\n  return f;\n}\n\n// node_modules/d3-hierarchy/src/constant.js\nfunction constantZero() {\n  return 0;\n}\nfunction constant_default9(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-hierarchy/src/lcg.js\nvar a2 = 1664525;\nvar c2 = 1013904223;\nvar m2 = 4294967296;\nfunction lcg_default2() {\n  let s2 = 1;\n  return () => (s2 = (a2 * s2 + c2) % m2) / m2;\n}\n\n// node_modules/d3-hierarchy/src/array.js\nfunction array_default2(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\nfunction shuffle(array4, random) {\n  let m3 = array4.length, t, i;\n  while (m3) {\n    i = random() * m3-- | 0;\n    t = array4[m3];\n    array4[m3] = array4[i];\n    array4[i] = t;\n  }\n  return array4;\n}\n\n// node_modules/d3-hierarchy/src/pack/enclose.js\nfunction enclose_default(circles) {\n  return packEncloseRandom(circles, lcg_default2());\n}\nfunction packEncloseRandom(circles, random) {\n  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B3 = [], p, e;\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p))\n      ++i;\n    else\n      e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;\n  }\n  return e;\n}\nfunction extendBasis(B3, p) {\n  var i, j;\n  if (enclosesWeakAll(p, B3))\n    return [p];\n  for (i = 0; i < B3.length; ++i) {\n    if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {\n      return [B3[i], p];\n    }\n  }\n  for (i = 0; i < B3.length - 1; ++i) {\n    for (j = i + 1; j < B3.length; ++j) {\n      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {\n        return [B3[i], B3[j], p];\n      }\n    }\n  }\n  throw new Error();\n}\nfunction enclosesNot(a4, b) {\n  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\nfunction enclosesWeak(a4, b) {\n  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction enclosesWeakAll(a4, B3) {\n  for (var i = 0; i < B3.length; ++i) {\n    if (!enclosesWeak(a4, B3[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction encloseBasis(B3) {\n  switch (B3.length) {\n    case 1:\n      return encloseBasis1(B3[0]);\n    case 2:\n      return encloseBasis2(B3[0], B3[1]);\n    case 3:\n      return encloseBasis3(B3[0], B3[1], B3[2]);\n  }\n}\nfunction encloseBasis1(a4) {\n  return {\n    x: a4.x,\n    y: a4.y,\n    r: a4.r\n  };\n}\nfunction encloseBasis2(a4, b) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x12 + x22 + x21 / l * r21) / 2,\n    y: (y12 + y22 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\nfunction encloseBasis3(a4, b, c6) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);\n  return {\n    x: x12 + xa + xb * r,\n    y: y12 + ya + yb * r,\n    r\n  };\n}\n\n// node_modules/d3-hierarchy/src/pack/siblings.js\nfunction place(b, a4, c6) {\n  var dx = b.x - a4.x, x4, a22, dy = b.y - a4.y, y4, b22, d2 = dx * dx + dy * dy;\n  if (d2) {\n    a22 = a4.r + c6.r, a22 *= a22;\n    b22 = b.r + c6.r, b22 *= b22;\n    if (a22 > b22) {\n      x4 = (d2 + b22 - a22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));\n      c6.x = b.x - x4 * dx - y4 * dy;\n      c6.y = b.y - x4 * dy + y4 * dx;\n    } else {\n      x4 = (d2 + a22 - b22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));\n      c6.x = a4.x + x4 * dx - y4 * dy;\n      c6.y = a4.y + x4 * dy + y4 * dx;\n    }\n  } else {\n    c6.x = a4.x + c6.r;\n    c6.y = a4.y;\n  }\n}\nfunction intersects(a4, b) {\n  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction score(node) {\n  var a4 = node._, b = node.next._, ab4 = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab4, dy = (a4.y * b.r + b.y * a4.r) / ab4;\n  return dx * dx + dy * dy;\n}\nfunction Node3(circle2) {\n  this._ = circle2;\n  this.next = null;\n  this.previous = null;\n}\nfunction packSiblingsRandom(circles, random) {\n  if (!(n = (circles = array_default2(circles)).length))\n    return 0;\n  var a4, b, c6, n, aa2, ca3, i, j, k2, sj, sk;\n  a4 = circles[0], a4.x = 0, a4.y = 0;\n  if (!(n > 1))\n    return a4.r;\n  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;\n  if (!(n > 2))\n    return a4.r + b.r;\n  place(b, a4, c6 = circles[2]);\n  a4 = new Node3(a4), b = new Node3(b), c6 = new Node3(c6);\n  a4.next = c6.previous = b;\n  b.next = a4.previous = c6;\n  c6.next = b.previous = a4;\n  pack:\n    for (i = 3; i < n; ++i) {\n      place(a4._, b._, c6 = circles[i]), c6 = new Node3(c6);\n      j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;\n      do {\n        if (sj <= sk) {\n          if (intersects(j._, c6._)) {\n            b = j, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sj += j._.r, j = j.next;\n        } else {\n          if (intersects(k2._, c6._)) {\n            a4 = k2, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sk += k2._.r, k2 = k2.previous;\n        }\n      } while (j !== k2.next);\n      c6.previous = a4, c6.next = b, a4.next = b.previous = b = c6;\n      aa2 = score(a4);\n      while ((c6 = c6.next) !== b) {\n        if ((ca3 = score(c6)) < aa2) {\n          a4 = c6, aa2 = ca3;\n        }\n      }\n      b = a4.next;\n    }\n  a4 = [b._], c6 = b;\n  while ((c6 = c6.next) !== b)\n    a4.push(c6._);\n  c6 = packEncloseRandom(a4, random);\n  for (i = 0; i < n; ++i)\n    a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;\n  return c6.r;\n}\nfunction siblings_default(circles) {\n  packSiblingsRandom(circles, lcg_default2());\n  return circles;\n}\n\n// node_modules/d3-hierarchy/src/pack/index.js\nfunction defaultRadius2(d) {\n  return Math.sqrt(d.value);\n}\nfunction pack_default() {\n  var radius2 = null, dx = 1, dy = 1, padding = constantZero;\n  function pack(root3) {\n    const random = lcg_default2();\n    root3.x = dx / 2, root3.y = dy / 2;\n    if (radius2) {\n      root3.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));\n    } else {\n      root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));\n    }\n    return root3;\n  }\n  pack.radius = function(x4) {\n    return arguments.length ? (radius2 = optional(x4), pack) : radius2;\n  };\n  pack.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];\n  };\n  pack.padding = function(x4) {\n    return arguments.length ? (padding = typeof x4 === \"function\" ? x4 : constant_default9(+x4), pack) : padding;\n  };\n  return pack;\n}\nfunction radiusLeaf(radius2) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius2(node) || 0);\n    }\n  };\n}\nfunction packChildrenRandom(padding, k2, random) {\n  return function(node) {\n    if (children2 = node.children) {\n      var children2, i, n = children2.length, r = padding(node) * k2 || 0, e;\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r += r;\n      e = packSiblingsRandom(children2, random);\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\nfunction translateChild(k2) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k2;\n    if (parent) {\n      node.x = parent.x + k2 * node.x;\n      node.y = parent.y + k2 * node.y;\n    }\n  };\n}\n\n// node_modules/d3-hierarchy/src/treemap/round.js\nfunction round_default2(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n\n// node_modules/d3-hierarchy/src/treemap/dice.js\nfunction dice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.y0 = y06, node.y1 = y12;\n    node.x0 = x06, node.x1 = x06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/partition.js\nfunction partition_default() {\n  var dx = 1, dy = 1, padding = 0, round2 = false;\n  function partition(root3) {\n    var n = root3.height + 1;\n    root3.x0 = root3.y0 = padding;\n    root3.x1 = dx;\n    root3.y1 = dy / n;\n    root3.eachBefore(positionNode(dy, n));\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(dy2, n) {\n    return function(node) {\n      if (node.children) {\n        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);\n      }\n      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      node.x0 = x06;\n      node.y0 = y06;\n      node.x1 = x12;\n      node.y1 = y12;\n    };\n  }\n  partition.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, partition) : round2;\n  };\n  partition.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];\n  };\n  partition.padding = function(x4) {\n    return arguments.length ? (padding = +x4, partition) : padding;\n  };\n  return partition;\n}\n\n// node_modules/d3-hierarchy/src/stratify.js\nvar preroot = { depth: -1 };\nvar ambiguous = {};\nvar imputed = {};\nfunction defaultId(d) {\n  return d.id;\n}\nfunction defaultParentId(d) {\n  return d.parentId;\n}\nfunction stratify_default() {\n  var id2 = defaultId, parentId = defaultParentId, path2;\n  function stratify(data) {\n    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();\n    if (path2 != null) {\n      const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i2 of P) {\n        if (!S.has(i2)) {\n          S.add(i2);\n          I.push(i2);\n          P.push(parentof(i2));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i2) => I[i2];\n      currentParentId = (_, i2) => P[i2];\n    }\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node2(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent)\n          throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous)\n          throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children)\n          parent.children.push(node);\n        else\n          parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root3)\n          throw new Error(\"multiple roots\");\n        root3 = node;\n      }\n    }\n    if (!root3)\n      throw new Error(\"no root\");\n    if (path2 != null) {\n      while (root3.data === imputed && root3.children.length === 1) {\n        root3 = root3.children[0], --n;\n      }\n      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {\n        node = nodes[i2];\n        if (node.data !== imputed)\n          break;\n        node.data = null;\n      }\n    }\n    root3.parent = preroot;\n    root3.eachBefore(function(node2) {\n      node2.depth = node2.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root3.parent = null;\n    if (n > 0)\n      throw new Error(\"cycle\");\n    return root3;\n  }\n  stratify.id = function(x4) {\n    return arguments.length ? (id2 = optional(x4), stratify) : id2;\n  };\n  stratify.parentId = function(x4) {\n    return arguments.length ? (parentId = optional(x4), stratify) : parentId;\n  };\n  stratify.path = function(x4) {\n    return arguments.length ? (path2 = optional(x4), stratify) : path2;\n  };\n  return stratify;\n}\nfunction normalize(path2) {\n  path2 = `${path2}`;\n  let i = path2.length;\n  if (slash(path2, i - 1) && !slash(path2, i - 2))\n    path2 = path2.slice(0, -1);\n  return path2[0] === \"/\" ? path2 : `/${path2}`;\n}\nfunction parentof(path2) {\n  let i = path2.length;\n  if (i < 2)\n    return \"\";\n  while (--i > 1)\n    if (slash(path2, i))\n      break;\n  return path2.slice(0, i);\n}\nfunction slash(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\n\n// node_modules/d3-hierarchy/src/tree.js\nfunction defaultSeparation2(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction nextLeft(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[0] : v2.t;\n}\nfunction nextRight(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[children2.length - 1] : v2.t;\n}\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\nfunction executeShifts(v2) {\n  var shift = 0, change = 0, children2 = v2.children, i = children2.length, w;\n  while (--i >= 0) {\n    w = children2[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\nfunction nextAncestor(vim, v2, ancestor) {\n  return vim.a.parent === v2.parent ? vim.a : ancestor;\n}\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null;\n  this.a = this;\n  this.z = 0;\n  this.m = 0;\n  this.c = 0;\n  this.s = 0;\n  this.t = null;\n  this.i = i;\n}\nTreeNode.prototype = Object.create(Node2.prototype);\nfunction treeRoot(root3) {\n  var tree2 = new TreeNode(root3, 0), node, nodes = [tree2], child, children2, i, n;\n  while (node = nodes.pop()) {\n    if (children2 = node._.children) {\n      node.children = new Array(n = children2.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));\n        child.parent = node;\n      }\n    }\n  }\n  (tree2.parent = new TreeNode(null, 0)).children = [tree2];\n  return tree2;\n}\nfunction tree_default() {\n  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;\n  function tree2(root3) {\n    var t = treeRoot(root3);\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n    if (nodeSize)\n      root3.eachBefore(sizeNode);\n    else {\n      var left2 = root3, right2 = root3, bottom2 = root3;\n      root3.eachBefore(function(node) {\n        if (node.x < left2.x)\n          left2 = node;\n        if (node.x > right2.x)\n          right2 = node;\n        if (node.depth > bottom2.depth)\n          bottom2 = node;\n      });\n      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);\n      root3.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx2;\n        node.y = node.depth * ky2;\n      });\n    }\n    return root3;\n  }\n  function firstWalk(v2) {\n    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;\n    if (children2) {\n      executeShifts(v2);\n      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;\n      if (w) {\n        v2.z = w.z + separation(v2._, w._);\n        v2.m = v2.z - midpoint;\n      } else {\n        v2.z = midpoint;\n      }\n    } else if (w) {\n      v2.z = w.z + separation(v2._, w._);\n    }\n    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);\n  }\n  function secondWalk(v2) {\n    v2._.x = v2.z + v2.parent.m;\n    v2.m += v2.parent.m;\n  }\n  function apportion(v2, w, ancestor) {\n    if (w) {\n      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v2;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v2;\n      }\n    }\n    return ancestor;\n  }\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n  tree2.separation = function(x4) {\n    return arguments.length ? (separation = x4, tree2) : separation;\n  };\n  tree2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? null : [dx, dy];\n  };\n  tree2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? [dx, dy] : null;\n  };\n  return tree2;\n}\n\n// node_modules/d3-hierarchy/src/treemap/slice.js\nfunction slice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.x0 = x06, node.x1 = x12;\n    node.y0 = y06, node.y1 = y06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/squarify.js\nvar phi = (1 + Math.sqrt(5)) / 2;\nfunction squarifyRatio(ratio, parent, x06, y06, x12, y12) {\n  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n  while (i0 < n) {\n    dx = x12 - x06, dy = y12 - y06;\n    do\n      sumValue = nodes[i1++].value;\n    while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue)\n        minValue = nodeValue;\n      if (nodeValue > maxValue)\n        maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) {\n        sumValue -= nodeValue;\n        break;\n      }\n      minRatio = newRatio;\n    }\n    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n    if (row.dice)\n      dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);\n    else\n      slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);\n    value -= sumValue, i0 = i1;\n  }\n  return rows;\n}\nvar squarify_default = function custom10(ratio) {\n  function squarify(parent, x06, y06, x12, y12) {\n    squarifyRatio(ratio, parent, x06, y06, x12, y12);\n  }\n  squarify.ratio = function(x4) {\n    return custom10((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return squarify;\n}(phi);\n\n// node_modules/d3-hierarchy/src/treemap/index.js\nfunction treemap_default() {\n  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;\n  function treemap(root3) {\n    root3.x0 = root3.y0 = 0;\n    root3.x1 = dx;\n    root3.y1 = dy;\n    root3.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(node) {\n    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;\n    if (x12 < x06)\n      x06 = x12 = (x06 + x12) / 2;\n    if (y12 < y06)\n      y06 = y12 = (y06 + y12) / 2;\n    node.x0 = x06;\n    node.y0 = y06;\n    node.x1 = x12;\n    node.y1 = y12;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x06 += paddingLeft(node) - p;\n      y06 += paddingTop(node) - p;\n      x12 -= paddingRight(node) - p;\n      y12 -= paddingBottom(node) - p;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      tile(node, x06, y06, x12, y12);\n    }\n  }\n  treemap.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, treemap) : round2;\n  };\n  treemap.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];\n  };\n  treemap.tile = function(x4) {\n    return arguments.length ? (tile = required(x4), treemap) : tile;\n  };\n  treemap.padding = function(x4) {\n    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();\n  };\n  treemap.paddingInner = function(x4) {\n    return arguments.length ? (paddingInner = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingInner;\n  };\n  treemap.paddingOuter = function(x4) {\n    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();\n  };\n  treemap.paddingTop = function(x4) {\n    return arguments.length ? (paddingTop = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingTop;\n  };\n  treemap.paddingRight = function(x4) {\n    return arguments.length ? (paddingRight = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingRight;\n  };\n  treemap.paddingBottom = function(x4) {\n    return arguments.length ? (paddingBottom = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingBottom;\n  };\n  treemap.paddingLeft = function(x4) {\n    return arguments.length ? (paddingLeft = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingLeft;\n  };\n  return treemap;\n}\n\n// node_modules/d3-hierarchy/src/treemap/binary.js\nfunction binary_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, i, n = nodes.length, sum5, sums = new Array(n + 1);\n  for (sums[0] = sum5 = i = 0; i < n; ++i) {\n    sums[i + 1] = sum5 += nodes[i].value;\n  }\n  partition(0, n, parent.value, x06, y06, x12, y12);\n  function partition(i2, j, value, x07, y07, x13, y13) {\n    if (i2 >= j - 1) {\n      var node = nodes[i2];\n      node.x0 = x07, node.y0 = y07;\n      node.x1 = x13, node.y1 = y13;\n      return;\n    }\n    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;\n    while (k2 < hi) {\n      var mid3 = k2 + hi >>> 1;\n      if (sums[mid3] < valueTarget)\n        k2 = mid3 + 1;\n      else\n        hi = mid3;\n    }\n    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)\n      --k2;\n    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;\n    if (x13 - x07 > y13 - y07) {\n      var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;\n      partition(i2, k2, valueLeft, x07, y07, xk, y13);\n      partition(k2, j, valueRight, xk, y07, x13, y13);\n    } else {\n      var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;\n      partition(i2, k2, valueLeft, x07, y07, x13, yk);\n      partition(k2, j, valueRight, x07, yk, x13, y13);\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/sliceDice.js\nfunction sliceDice_default(parent, x06, y06, x12, y12) {\n  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);\n}\n\n// node_modules/d3-hierarchy/src/treemap/resquarify.js\nvar resquarify_default = function custom11(ratio) {\n  function resquarify(parent, x06, y06, x12, y12) {\n    if ((rows = parent._squarify) && rows.ratio === ratio) {\n      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value = parent.value;\n      while (++j < m3) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i)\n          row.value += nodes[i].value;\n        if (row.dice)\n          dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);\n        else\n          slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);\n      rows.ratio = ratio;\n    }\n  }\n  resquarify.ratio = function(x4) {\n    return custom11((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return resquarify;\n}(phi);\n\n// node_modules/d3-polygon/src/area.js\nfunction area_default4(polygon) {\n  var i = -1, n = polygon.length, a4, b = polygon[n - 1], area2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    area2 += a4[1] * b[0] - a4[0] * b[1];\n  }\n  return area2 / 2;\n}\n\n// node_modules/d3-polygon/src/centroid.js\nfunction centroid_default3(polygon) {\n  var i = -1, n = polygon.length, x4 = 0, y4 = 0, a4, b = polygon[n - 1], c6, k2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    k2 += c6 = a4[0] * b[1] - b[0] * a4[1];\n    x4 += (a4[0] + b[0]) * c6;\n    y4 += (a4[1] + b[1]) * c6;\n  }\n  return k2 *= 3, [x4 / k2, y4 / k2];\n}\n\n// node_modules/d3-polygon/src/cross.js\nfunction cross_default(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) - (b[1] - a4[1]) * (c6[0] - a4[0]);\n}\n\n// node_modules/d3-polygon/src/hull.js\nfunction lexicographicOrder(a4, b) {\n  return a4[0] - b[0] || a4[1] - b[1];\n}\nfunction computeUpperHullIndexes(points) {\n  const n = points.length, indexes2 = [0, 1];\n  let size = 2, i;\n  for (i = 2; i < n; ++i) {\n    while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)\n      --size;\n    indexes2[size++] = i;\n  }\n  return indexes2.slice(0, size);\n}\nfunction hull_default(points) {\n  if ((n = points.length) < 3)\n    return null;\n  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);\n  for (i = 0; i < n; ++i)\n    sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i)\n    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);\n  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];\n  for (i = upperIndexes.length - 1; i >= 0; --i)\n    hull2.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)\n    hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);\n  return hull2;\n}\n\n// node_modules/d3-polygon/src/contains.js\nfunction contains_default3(polygon, point6) {\n  var n = polygon.length, p = polygon[n - 1], x4 = point6[0], y4 = point6[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x12 = p[0], y12 = p[1];\n    if (y12 > y4 !== y06 > y4 && x4 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12)\n      inside = !inside;\n    x06 = x12, y06 = y12;\n  }\n  return inside;\n}\n\n// node_modules/d3-polygon/src/length.js\nfunction length_default2(polygon) {\n  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.hypot(xa, ya);\n  }\n  return perimeter;\n}\n\n// node_modules/d3-random/src/defaultSource.js\nvar defaultSource_default = Math.random;\n\n// node_modules/d3-random/src/uniform.js\nvar uniform_default = function sourceRandomUniform(source) {\n  function randomUniform(min4, max5) {\n    min4 = min4 == null ? 0 : +min4;\n    max5 = max5 == null ? 1 : +max5;\n    if (arguments.length === 1)\n      max5 = min4, min4 = 0;\n    else\n      max5 -= min4;\n    return function() {\n      return source() * max5 + min4;\n    };\n  }\n  randomUniform.source = sourceRandomUniform;\n  return randomUniform;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/int.js\nvar int_default = function sourceRandomInt(source) {\n  function randomInt(min4, max5) {\n    if (arguments.length < 2)\n      max5 = min4, min4 = 0;\n    min4 = Math.floor(min4);\n    max5 = Math.floor(max5) - min4;\n    return function() {\n      return Math.floor(source() * max5 + min4);\n    };\n  }\n  randomInt.source = sourceRandomInt;\n  return randomInt;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/normal.js\nvar normal_default = function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x4, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y4;\n      if (x4 != null)\n        y4 = x4, x4 = null;\n      else\n        do {\n          x4 = source() * 2 - 1;\n          y4 = source() * 2 - 1;\n          r = x4 * x4 + y4 * y4;\n        } while (!r || r > 1);\n      return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n  randomNormal.source = sourceRandomNormal;\n  return randomNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logNormal.js\nvar logNormal_default = function sourceRandomLogNormal(source) {\n  var N = normal_default.source(source);\n  function randomLogNormal() {\n    var randomNormal = N.apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n  randomLogNormal.source = sourceRandomLogNormal;\n  return randomLogNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/irwinHall.js\nvar irwinHall_default = function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    if ((n = +n) <= 0)\n      return () => 0;\n    return function() {\n      for (var sum5 = 0, i = n; i > 1; --i)\n        sum5 += source();\n      return sum5 + i * source();\n    };\n  }\n  randomIrwinHall.source = sourceRandomIrwinHall;\n  return randomIrwinHall;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bates.js\nvar bates_default = function sourceRandomBates(source) {\n  var I = irwinHall_default.source(source);\n  function randomBates(n) {\n    if ((n = +n) === 0)\n      return source;\n    var randomIrwinHall = I(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n  randomBates.source = sourceRandomBates;\n  return randomBates;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/exponential.js\nvar exponential_default = function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log1p(-source()) / lambda;\n    };\n  }\n  randomExponential.source = sourceRandomExponential;\n  return randomExponential;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/pareto.js\nvar pareto_default = function sourceRandomPareto(source) {\n  function randomPareto(alpha) {\n    if ((alpha = +alpha) < 0)\n      throw new RangeError(\"invalid alpha\");\n    alpha = 1 / -alpha;\n    return function() {\n      return Math.pow(1 - source(), alpha);\n    };\n  }\n  randomPareto.source = sourceRandomPareto;\n  return randomPareto;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bernoulli.js\nvar bernoulli_default = function sourceRandomBernoulli(source) {\n  function randomBernoulli(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    return function() {\n      return Math.floor(source() + p);\n    };\n  }\n  randomBernoulli.source = sourceRandomBernoulli;\n  return randomBernoulli;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/geometric.js\nvar geometric_default = function sourceRandomGeometric(source) {\n  function randomGeometric(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    if (p === 0)\n      return () => Infinity;\n    if (p === 1)\n      return () => 1;\n    p = Math.log1p(-p);\n    return function() {\n      return 1 + Math.floor(Math.log1p(-source()) / p);\n    };\n  }\n  randomGeometric.source = sourceRandomGeometric;\n  return randomGeometric;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/gamma.js\nvar gamma_default = function sourceRandomGamma(source) {\n  var randomNormal = normal_default.source(source)();\n  function randomGamma(k2, theta) {\n    if ((k2 = +k2) < 0)\n      throw new RangeError(\"invalid k\");\n    if (k2 === 0)\n      return () => 0;\n    theta = theta == null ? 1 : +theta;\n    if (k2 === 1)\n      return () => -Math.log1p(-source()) * theta;\n    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c6 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;\n    return function() {\n      do {\n        do {\n          var x4 = randomNormal(), v2 = 1 + c6 * x4;\n        } while (v2 <= 0);\n        v2 *= v2 * v2;\n        var u4 = 1 - source();\n      } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));\n      return d * v2 * multiplier() * theta;\n    };\n  }\n  randomGamma.source = sourceRandomGamma;\n  return randomGamma;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/beta.js\nvar beta_default = function sourceRandomBeta(source) {\n  var G = gamma_default.source(source);\n  function randomBeta(alpha, beta) {\n    var X3 = G(alpha), Y3 = G(beta);\n    return function() {\n      var x4 = X3();\n      return x4 === 0 ? 0 : x4 / (x4 + Y3());\n    };\n  }\n  randomBeta.source = sourceRandomBeta;\n  return randomBeta;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/binomial.js\nvar binomial_default = function sourceRandomBinomial(source) {\n  var G = geometric_default.source(source), B3 = beta_default.source(source);\n  function randomBinomial(n, p) {\n    n = +n;\n    if ((p = +p) >= 1)\n      return () => n;\n    if (p <= 0)\n      return () => 0;\n    return function() {\n      var acc = 0, nn = n, pp = p;\n      while (nn * pp > 16 && nn * (1 - pp) > 16) {\n        var i = Math.floor((nn + 1) * pp), y4 = B3(i, nn - i + 1)();\n        if (y4 <= pp) {\n          acc += i;\n          nn -= i;\n          pp = (pp - y4) / (1 - y4);\n        } else {\n          nn = i - 1;\n          pp /= y4;\n        }\n      }\n      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);\n      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)\n        s2 += g();\n      return acc + (sign3 ? k2 : nn - k2);\n    };\n  }\n  randomBinomial.source = sourceRandomBinomial;\n  return randomBinomial;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/weibull.js\nvar weibull_default = function sourceRandomWeibull(source) {\n  function randomWeibull(k2, a4, b) {\n    var outerFunc;\n    if ((k2 = +k2) === 0) {\n      outerFunc = (x4) => -Math.log(x4);\n    } else {\n      k2 = 1 / k2;\n      outerFunc = (x4) => Math.pow(x4, k2);\n    }\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * outerFunc(-Math.log1p(-source()));\n    };\n  }\n  randomWeibull.source = sourceRandomWeibull;\n  return randomWeibull;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/cauchy.js\nvar cauchy_default = function sourceRandomCauchy(source) {\n  function randomCauchy(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * Math.tan(Math.PI * source());\n    };\n  }\n  randomCauchy.source = sourceRandomCauchy;\n  return randomCauchy;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logistic.js\nvar logistic_default = function sourceRandomLogistic(source) {\n  function randomLogistic(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      var u4 = source();\n      return a4 + b * Math.log(u4 / (1 - u4));\n    };\n  }\n  randomLogistic.source = sourceRandomLogistic;\n  return randomLogistic;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/poisson.js\nvar poisson_default = function sourceRandomPoisson(source) {\n  var G = gamma_default.source(source), B3 = binomial_default.source(source);\n  function randomPoisson(lambda) {\n    return function() {\n      var acc = 0, l = lambda;\n      while (l > 16) {\n        var n = Math.floor(0.875 * l), t = G(n)();\n        if (t > l)\n          return acc + B3(n - 1, l / t)();\n        acc += n;\n        l -= t;\n      }\n      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)\n        s2 -= Math.log1p(-source());\n      return acc + k2;\n    };\n  }\n  randomPoisson.source = sourceRandomPoisson;\n  return randomPoisson;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/lcg.js\nvar mul = 1664525;\nvar inc = 1013904223;\nvar eps = 1 / 4294967296;\nfunction lcg(seed = Math.random()) {\n  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;\n  return () => (state = mul * state + inc | 0, eps * (state >>> 0));\n}\n\n// node_modules/d3-scale/src/init.js\nfunction initRange(domain, range5) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1:\n      this.range(domain);\n      break;\n    default:\n      this.range(range5).domain(domain);\n      break;\n  }\n  return this;\n}\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1: {\n      if (typeof domain === \"function\")\n        this.interpolator(domain);\n      else\n        this.range(domain);\n      break;\n    }\n    default: {\n      this.domain(domain);\n      if (typeof interpolator === \"function\")\n        this.interpolator(interpolator);\n      else\n        this.range(interpolator);\n      break;\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-scale/src/ordinal.js\nvar implicit = Symbol(\"implicit\");\nfunction ordinal() {\n  var index3 = new InternMap(), domain = [], range5 = [], unknown = implicit;\n  function scale3(d) {\n    let i = index3.get(d);\n    if (i === void 0) {\n      if (unknown !== implicit)\n        return unknown;\n      index3.set(d, i = domain.push(d) - 1);\n    }\n    return range5[i % range5.length];\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [], index3 = new InternMap();\n    for (const value of _) {\n      if (index3.has(value))\n        continue;\n      index3.set(value, domain.push(value) - 1);\n    }\n    return scale3;\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), scale3) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return ordinal(domain, range5).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/band.js\nfunction band() {\n  var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange2 = scale3.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;\n  delete scale3.unknown;\n  function rescale() {\n    var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;\n    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round2)\n      step = Math.floor(step);\n    start2 += (stop - start2 - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round2)\n      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);\n    var values2 = range(n).map(function(i) {\n      return start2 + step * i;\n    });\n    return ordinalRange2(reverse3 ? values2.reverse() : values2);\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];\n  };\n  scale3.rangeRound = function(_) {\n    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();\n  };\n  scale3.bandwidth = function() {\n    return bandwidth;\n  };\n  scale3.step = function() {\n    return step;\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, rescale()) : round2;\n  };\n  scale3.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n  scale3.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n  scale3.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n  scale3.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n  scale3.copy = function() {\n    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n  return initRange.apply(rescale(), arguments);\n}\nfunction pointish(scale3) {\n  var copy3 = scale3.copy;\n  scale3.padding = scale3.paddingOuter;\n  delete scale3.paddingInner;\n  delete scale3.paddingOuter;\n  scale3.copy = function() {\n    return pointish(copy3());\n  };\n  return scale3;\n}\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// node_modules/d3-scale/src/constant.js\nfunction constants(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-scale/src/number.js\nfunction number3(x4) {\n  return +x4;\n}\n\n// node_modules/d3-scale/src/continuous.js\nvar unit = [0, 1];\nfunction identity3(x4) {\n  return x4;\n}\nfunction normalize2(a4, b) {\n  return (b -= a4 = +a4) ? function(x4) {\n    return (x4 - a4) / b;\n  } : constants(isNaN(b) ? NaN : 0.5);\n}\nfunction clamper(a4, b) {\n  var t;\n  if (a4 > b)\n    t = a4, a4 = b, b = t;\n  return function(x4) {\n    return Math.max(a4, Math.min(b, x4));\n  };\n}\nfunction bimap(domain, range5, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];\n  if (d1 < d0)\n    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);\n  else\n    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);\n  return function(x4) {\n    return r0(d0(x4));\n  };\n}\nfunction polymap(domain, range5, interpolate) {\n  var j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j), i = -1;\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range5 = range5.slice().reverse();\n  }\n  while (++i < j) {\n    d[i] = normalize2(domain[i], domain[i + 1]);\n    r[i] = interpolate(range5[i], range5[i + 1]);\n  }\n  return function(x4) {\n    var i2 = bisect_default(domain, x4, 1, j) - 1;\n    return r[i2](d[i2](x4));\n  };\n}\nfunction copy(source, target) {\n  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction transformer2() {\n  var domain = unit, range5 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;\n  function rescale() {\n    var n = Math.min(domain.length, range5.length);\n    if (clamp !== identity3)\n      clamp = clamper(domain[0], domain[n - 1]);\n    piecewise2 = n > 2 ? polymap : bimap;\n    output = input = null;\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range5, interpolate)))(transform2(clamp(x4)));\n  }\n  scale3.invert = function(y4) {\n    return clamp(untransform((input || (input = piecewise2(range5, domain.map(transform2), number_default)))(y4)));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return range5 = Array.from(_), interpolate = round_default, rescale();\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;\n  };\n  scale3.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t, u4) {\n    transform2 = t, untransform = u4;\n    return rescale();\n  };\n}\nfunction continuous() {\n  return transformer2()(identity3, identity3);\n}\n\n// node_modules/d3-scale/src/tickFormat.js\nfunction tickFormat(start2, stop, count3, specifier) {\n  var step = tickStep(start2, stop, count3), precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start2), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))\n        specifier.precision = precision;\n      return formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))\n        specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))\n        specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format(specifier);\n}\n\n// node_modules/d3-scale/src/linear.js\nfunction linearish(scale3) {\n  var domain = scale3.domain;\n  scale3.ticks = function(count3) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);\n  };\n  scale3.nice = function(count3) {\n    if (count3 == null)\n      count3 = 10;\n    var d = domain();\n    var i0 = 0;\n    var i1 = d.length - 1;\n    var start2 = d[i0];\n    var stop = d[i1];\n    var prestep;\n    var step;\n    var maxIter = 10;\n    if (stop < start2) {\n      step = start2, start2 = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n    while (maxIter-- > 0) {\n      step = tickIncrement(start2, stop, count3);\n      if (step === prestep) {\n        d[i0] = start2;\n        d[i1] = stop;\n        return domain(d);\n      } else if (step > 0) {\n        start2 = Math.floor(start2 / step) * step;\n        stop = Math.ceil(stop / step) * step;\n      } else if (step < 0) {\n        start2 = Math.ceil(start2 * step) / step;\n        stop = Math.floor(stop * step) / step;\n      } else {\n        break;\n      }\n      prestep = step;\n    }\n    return scale3;\n  };\n  return scale3;\n}\nfunction linear3() {\n  var scale3 = continuous();\n  scale3.copy = function() {\n    return copy(scale3, linear3());\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/identity.js\nfunction identity4(domain) {\n  var unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : x4;\n  }\n  scale3.invert = scale3;\n  scale3.domain = scale3.range = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), scale3) : domain.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return identity4(domain).unknown(unknown);\n  };\n  domain = arguments.length ? Array.from(domain, number3) : [0, 1];\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/nice.js\nfunction nice2(domain, interval2) {\n  domain = domain.slice();\n  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;\n  if (x12 < x06) {\n    t = i0, i0 = i1, i1 = t;\n    t = x06, x06 = x12, x12 = t;\n  }\n  domain[i0] = interval2.floor(x06);\n  domain[i1] = interval2.ceil(x12);\n  return domain;\n}\n\n// node_modules/d3-scale/src/log.js\nfunction transformLog(x4) {\n  return Math.log(x4);\n}\nfunction transformExp(x4) {\n  return Math.exp(x4);\n}\nfunction transformLogn(x4) {\n  return -Math.log(-x4);\n}\nfunction transformExpn(x4) {\n  return -Math.exp(-x4);\n}\nfunction pow10(x4) {\n  return isFinite(x4) ? +(\"1e\" + x4) : x4 < 0 ? 0 : x4;\n}\nfunction powp(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);\n}\nfunction logp(base) {\n  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);\n}\nfunction reflect(f) {\n  return (x4, k2) => -f(-x4, k2);\n}\nfunction loggish(transform2) {\n  const scale3 = transform2(transformLog, transformExp);\n  const domain = scale3.domain;\n  let base = 10;\n  let logs;\n  let pows;\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform2(transformLogn, transformExpn);\n    } else {\n      transform2(transformLog, transformExp);\n    }\n    return scale3;\n  }\n  scale3.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.ticks = (count3) => {\n    const d = domain();\n    let u4 = d[0];\n    let v2 = d[d.length - 1];\n    const r = v2 < u4;\n    if (r)\n      [u4, v2] = [v2, u4];\n    let i = logs(u4);\n    let j = logs(v2);\n    let k2;\n    let t;\n    const n = count3 == null ? 10 : +count3;\n    let z = [];\n    if (!(base % 1) && j - i < n) {\n      i = Math.floor(i), j = Math.ceil(j);\n      if (u4 > 0)\n        for (; i <= j; ++i) {\n          for (k2 = 1; k2 < base; ++k2) {\n            t = i < 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      else\n        for (; i <= j; ++i) {\n          for (k2 = base - 1; k2 >= 1; --k2) {\n            t = i > 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      if (z.length * 2 < n)\n        z = ticks(u4, v2, n);\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n    return r ? z.reverse() : z;\n  };\n  scale3.tickFormat = (count3, specifier) => {\n    if (count3 == null)\n      count3 = 10;\n    if (specifier == null)\n      specifier = base === 10 ? \"s\" : \",\";\n    if (typeof specifier !== \"function\") {\n      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)\n        specifier.trim = true;\n      specifier = format(specifier);\n    }\n    if (count3 === Infinity)\n      return specifier;\n    const k2 = Math.max(1, base * count3 / scale3.ticks().length);\n    return (d) => {\n      let i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5)\n        i *= base;\n      return i <= k2 ? specifier(d) : \"\";\n    };\n  };\n  scale3.nice = () => {\n    return domain(nice2(domain(), {\n      floor: (x4) => pows(Math.floor(logs(x4))),\n      ceil: (x4) => pows(Math.ceil(logs(x4)))\n    }));\n  };\n  return scale3;\n}\nfunction log2() {\n  const scale3 = loggish(transformer2()).domain([1, 10]);\n  scale3.copy = () => copy(scale3, log2()).base(scale3.base());\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/symlog.js\nfunction transformSymlog(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.log1p(Math.abs(x4 / c6));\n  };\n}\nfunction transformSymexp(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c6;\n  };\n}\nfunction symlogish(transform2) {\n  var c6 = 1, scale3 = transform2(transformSymlog(c6), transformSymexp(c6));\n  scale3.constant = function(_) {\n    return arguments.length ? transform2(transformSymlog(c6 = +_), transformSymexp(c6)) : c6;\n  };\n  return linearish(scale3);\n}\nfunction symlog() {\n  var scale3 = symlogish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, symlog()).constant(scale3.constant());\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/pow.js\nfunction transformPow(exponent2) {\n  return function(x4) {\n    return x4 < 0 ? -Math.pow(-x4, exponent2) : Math.pow(x4, exponent2);\n  };\n}\nfunction transformSqrt(x4) {\n  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);\n}\nfunction transformSquare(x4) {\n  return x4 < 0 ? -x4 * x4 : x4 * x4;\n}\nfunction powish(transform2) {\n  var scale3 = transform2(identity3, identity3), exponent2 = 1;\n  function rescale() {\n    return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));\n  }\n  scale3.exponent = function(_) {\n    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;\n  };\n  return linearish(scale3);\n}\nfunction pow3() {\n  var scale3 = powish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, pow3()).exponent(scale3.exponent());\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\nfunction sqrt2() {\n  return pow3.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/radial.js\nfunction square(x4) {\n  return Math.sign(x4) * x4 * x4;\n}\nfunction unsquare(x4) {\n  return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n}\nfunction radial() {\n  var squared = continuous(), range5 = [0, 1], round2 = false, unknown;\n  function scale3(x4) {\n    var y4 = unsquare(squared(x4));\n    return isNaN(y4) ? unknown : round2 ? Math.round(y4) : y4;\n  }\n  scale3.invert = function(y4) {\n    return squared.invert(square(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (squared.domain(_), scale3) : squared.domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (squared.range((range5 = Array.from(_, number3)).map(square)), scale3) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return scale3.range(_).round(true);\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, scale3) : round2;\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (squared.clamp(_), scale3) : squared.clamp();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return radial(squared.domain(), range5).round(round2).clamp(squared.clamp()).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/quantile.js\nfunction quantile2() {\n  var domain = [], range5 = [], thresholds = [], unknown;\n  function rescale() {\n    var i = 0, n = Math.max(1, range5.length);\n    thresholds = new Array(n - 1);\n    while (++i < n)\n      thresholds[i - 1] = quantileSorted(domain, i / n);\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : range5[bisect_default(thresholds, x4)];\n  }\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.quantiles = function() {\n    return thresholds.slice();\n  };\n  scale3.copy = function() {\n    return quantile2().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/quantize.js\nfunction quantize() {\n  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range5 = [0, 1], unknown;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n)\n      domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);\n    return scale3;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : scale3;\n  };\n  scale3.thresholds = function() {\n    return domain.slice();\n  };\n  scale3.copy = function() {\n    return quantize().domain([x06, x12]).range(range5).unknown(unknown);\n  };\n  return initRange.apply(linearish(scale3), arguments);\n}\n\n// node_modules/d3-scale/src/threshold.js\nfunction threshold() {\n  var domain = [0.5], range5 = [0, 1], unknown, n = 1;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return threshold().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-time/src/interval.js\nvar t02 = /* @__PURE__ */ new Date();\nvar t12 = /* @__PURE__ */ new Date();\nfunction timeInterval(floori, offseti, count3, field2) {\n  function interval2(date2) {\n    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;\n  }\n  interval2.floor = (date2) => {\n    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;\n  };\n  interval2.ceil = (date2) => {\n    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;\n  };\n  interval2.round = (date2) => {\n    const d0 = interval2(date2), d1 = interval2.ceil(date2);\n    return date2 - d0 < d1 - date2 ? d0 : d1;\n  };\n  interval2.offset = (date2, step) => {\n    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;\n  };\n  interval2.range = (start2, stop, step) => {\n    const range5 = [];\n    start2 = interval2.ceil(start2);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start2 < stop) || !(step > 0))\n      return range5;\n    let previous;\n    do\n      range5.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);\n    while (previous < start2 && start2 < stop);\n    return range5;\n  };\n  interval2.filter = (test) => {\n    return timeInterval((date2) => {\n      if (date2 >= date2)\n        while (floori(date2), !test(date2))\n          date2.setTime(date2 - 1);\n    }, (date2, step) => {\n      if (date2 >= date2) {\n        if (step < 0)\n          while (++step <= 0) {\n            while (offseti(date2, -1), !test(date2)) {\n            }\n          }\n        else\n          while (--step >= 0) {\n            while (offseti(date2, 1), !test(date2)) {\n            }\n          }\n      }\n    });\n  };\n  if (count3) {\n    interval2.count = (start2, end) => {\n      t02.setTime(+start2), t12.setTime(+end);\n      floori(t02), floori(t12);\n      return Math.floor(count3(t02, t12));\n    };\n    interval2.every = (step) => {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);\n    };\n  }\n  return interval2;\n}\n\n// node_modules/d3-time/src/millisecond.js\nvar millisecond = timeInterval(() => {\n}, (date2, step) => {\n  date2.setTime(+date2 + step);\n}, (start2, end) => {\n  return end - start2;\n});\nmillisecond.every = (k2) => {\n  k2 = Math.floor(k2);\n  if (!isFinite(k2) || !(k2 > 0))\n    return null;\n  if (!(k2 > 1))\n    return millisecond;\n  return timeInterval((date2) => {\n    date2.setTime(Math.floor(date2 / k2) * k2);\n  }, (date2, step) => {\n    date2.setTime(+date2 + step * k2);\n  }, (start2, end) => {\n    return (end - start2) / k2;\n  });\n};\nvar milliseconds = millisecond.range;\n\n// node_modules/d3-time/src/duration.js\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// node_modules/d3-time/src/second.js\nvar second = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds());\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationSecond);\n}, (start2, end) => {\n  return (end - start2) / durationSecond;\n}, (date2) => {\n  return date2.getUTCSeconds();\n});\nvar seconds = second.range;\n\n// node_modules/d3-time/src/minute.js\nvar timeMinute = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getMinutes();\n});\nvar timeMinutes = timeMinute.range;\nvar utcMinute = timeInterval((date2) => {\n  date2.setUTCSeconds(0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getUTCMinutes();\n});\nvar utcMinutes = utcMinute.range;\n\n// node_modules/d3-time/src/hour.js\nvar timeHour = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getHours();\n});\nvar timeHours = timeHour.range;\nvar utcHour = timeInterval((date2) => {\n  date2.setUTCMinutes(0, 0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getUTCHours();\n});\nvar utcHours = utcHour.range;\n\n// node_modules/d3-time/src/day.js\nvar timeDay = timeInterval(\n  (date2) => date2.setHours(0, 0, 0, 0),\n  (date2, step) => date2.setDate(date2.getDate() + step),\n  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,\n  (date2) => date2.getDate() - 1\n);\nvar timeDays = timeDay.range;\nvar utcDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return date2.getUTCDate() - 1;\n});\nvar utcDays = utcDay.range;\nvar unixDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return Math.floor(date2 / durationDay);\n});\nvar unixDays = unixDay.range;\n\n// node_modules/d3-time/src/week.js\nfunction timeWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setDate(date2.getDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\nvar timeSunday = timeWeekday(0);\nvar timeMonday = timeWeekday(1);\nvar timeTuesday = timeWeekday(2);\nvar timeWednesday = timeWeekday(3);\nvar timeThursday = timeWeekday(4);\nvar timeFriday = timeWeekday(5);\nvar timeSaturday = timeWeekday(6);\nvar timeSundays = timeSunday.range;\nvar timeMondays = timeMonday.range;\nvar timeTuesdays = timeTuesday.range;\nvar timeWednesdays = timeWednesday.range;\nvar timeThursdays = timeThursday.range;\nvar timeFridays = timeFriday.range;\nvar timeSaturdays = timeSaturday.range;\nfunction utcWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCDate(date2.getUTCDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2) / durationWeek;\n  });\n}\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\n// node_modules/d3-time/src/month.js\nvar timeMonth = timeInterval((date2) => {\n  date2.setDate(1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setMonth(date2.getMonth() + step);\n}, (start2, end) => {\n  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;\n}, (date2) => {\n  return date2.getMonth();\n});\nvar timeMonths = timeMonth.range;\nvar utcMonth = timeInterval((date2) => {\n  date2.setUTCDate(1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCMonth(date2.getUTCMonth() + step);\n}, (start2, end) => {\n  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;\n}, (date2) => {\n  return date2.getUTCMonth();\n});\nvar utcMonths = utcMonth.range;\n\n// node_modules/d3-time/src/year.js\nvar timeYear = timeInterval((date2) => {\n  date2.setMonth(0, 1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setFullYear(date2.getFullYear() + step);\n}, (start2, end) => {\n  return end.getFullYear() - start2.getFullYear();\n}, (date2) => {\n  return date2.getFullYear();\n});\ntimeYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);\n    date2.setMonth(0, 1);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setFullYear(date2.getFullYear() + step * k2);\n  });\n};\nvar timeYears = timeYear.range;\nvar utcYear = timeInterval((date2) => {\n  date2.setUTCMonth(0, 1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCFullYear(date2.getUTCFullYear() + step);\n}, (start2, end) => {\n  return end.getUTCFullYear() - start2.getUTCFullYear();\n}, (date2) => {\n  return date2.getUTCFullYear();\n});\nutcYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);\n    date2.setUTCMonth(0, 1);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);\n  });\n};\nvar utcYears = utcYear.range;\n\n// node_modules/d3-time/src/ticks.js\nfunction ticker(year, month, week, day, hour, minute) {\n  const tickIntervals = [\n    [second, 1, durationSecond],\n    [second, 5, 5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute, 1, durationMinute],\n    [minute, 5, 5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [hour, 1, durationHour],\n    [hour, 3, 3 * durationHour],\n    [hour, 6, 6 * durationHour],\n    [hour, 12, 12 * durationHour],\n    [day, 1, durationDay],\n    [day, 2, 2 * durationDay],\n    [week, 1, durationWeek],\n    [month, 1, durationMonth],\n    [month, 3, 3 * durationMonth],\n    [year, 1, durationYear]\n  ];\n  function ticks2(start2, stop, count3) {\n    const reverse3 = stop < start2;\n    if (reverse3)\n      [start2, stop] = [stop, start2];\n    const interval2 = count3 && typeof count3.range === \"function\" ? count3 : tickInterval(start2, stop, count3);\n    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];\n    return reverse3 ? ticks3.reverse() : ticks3;\n  }\n  function tickInterval(start2, stop, count3) {\n    const target = Math.abs(stop - start2) / count3;\n    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);\n    if (i === tickIntervals.length)\n      return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));\n    if (i === 0)\n      return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));\n    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n    return t.every(step);\n  }\n  return [ticks2, tickInterval];\n}\nvar [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);\nvar [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);\n\n// node_modules/d3-time-format/src/locale.js\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date2.setFullYear(d.y);\n    return date2;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date2.setUTCFullYear(d.y);\n    return date2;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\nfunction newDate(y4, m3, d) {\n  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };\n}\nfunction formatLocale(locale3) {\n  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;\n  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday2,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth2,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"g\": formatYearISO,\n    \"G\": formatFullYearISO,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"q\": formatQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear2,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"g\": formatUTCYearISO,\n    \"G\": formatUTCFullYearISO,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"q\": formatUTCQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"g\": parseYear,\n    \"G\": parseFullYear,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"q\": parseQuarter,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n  function newFormat(specifier, formats2) {\n    return function(date2) {\n      var string2 = [], i = -1, j = 0, n = specifier.length, c6, pad4, format3;\n      if (!(date2 instanceof Date))\n        date2 = /* @__PURE__ */ new Date(+date2);\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string2.push(specifier.slice(j, i));\n          if ((pad4 = pads[c6 = specifier.charAt(++i)]) != null)\n            c6 = specifier.charAt(++i);\n          else\n            pad4 = c6 === \"e\" ? \" \" : \"0\";\n          if (format3 = formats2[c6])\n            c6 = format3(date2, pad4);\n          string2.push(c6);\n          j = i + 1;\n        }\n      }\n      string2.push(specifier.slice(j, i));\n      return string2.join(\"\");\n    };\n  }\n  function newParse(specifier, Z) {\n    return function(string2) {\n      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += \"\", 0), week, day;\n      if (i != string2.length)\n        return null;\n      if (\"Q\" in d)\n        return new Date(d.Q);\n      if (\"s\" in d)\n        return new Date(d.s * 1e3 + (\"L\" in d ? d.L : 0));\n      if (Z && !(\"Z\" in d))\n        d.Z = 0;\n      if (\"p\" in d)\n        d.H = d.H % 12 + d.p * 12;\n      if (d.m === void 0)\n        d.m = \"q\" in d ? d.q : 0;\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53)\n          return null;\n        if (!(\"w\" in d))\n          d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();\n          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();\n          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);\n          week = timeDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d))\n          d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day = \"Z\" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n      }\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n      return localDate(d);\n    };\n  }\n  function parseSpecifier(d, specifier, string2, j) {\n    var i = 0, n = specifier.length, m3 = string2.length, c6, parse2;\n    while (i < n) {\n      if (j >= m3)\n        return -1;\n      c6 = specifier.charCodeAt(i++);\n      if (c6 === 37) {\n        c6 = specifier.charAt(i++);\n        parse2 = parses[c6 in pads ? specifier.charAt(i++) : c6];\n        if (!parse2 || (j = parse2(d, string2, j)) < 0)\n          return -1;\n      } else if (c6 != string2.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n    return j;\n  }\n  function parsePeriod(d, string2, i) {\n    var n = periodRe.exec(string2.slice(i));\n    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortWeekday(d, string2, i) {\n    var n = shortWeekdayRe.exec(string2.slice(i));\n    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseWeekday(d, string2, i) {\n    var n = weekdayRe.exec(string2.slice(i));\n    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortMonth(d, string2, i) {\n    var n = shortMonthRe.exec(string2.slice(i));\n    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseMonth(d, string2, i) {\n    var n = monthRe.exec(string2.slice(i));\n    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseLocaleDateTime(d, string2, i) {\n    return parseSpecifier(d, locale_dateTime, string2, i);\n  }\n  function parseLocaleDate(d, string2, i) {\n    return parseSpecifier(d, locale_date, string2, i);\n  }\n  function parseLocaleTime(d, string2, i) {\n    return parseSpecifier(d, locale_time, string2, i);\n  }\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n  function formatWeekday2(d) {\n    return locale_weekdays[d.getDay()];\n  }\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n  function formatMonth2(d) {\n    return locale_months[d.getMonth()];\n  }\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n  function formatQuarter(d) {\n    return 1 + ~~(d.getMonth() / 3);\n  }\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n  function formatUTCQuarter(d) {\n    return 1 + ~~(d.getUTCMonth() / 3);\n  }\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", false);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier += \"\", true);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    }\n  };\n}\nvar pads = { \"-\": \"\", \"_\": \" \", \"0\": \"0\" };\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\nfunction pad2(value, fill, width) {\n  var sign3 = value < 0 ? \"-\" : \"\", string2 = (sign3 ? -value : value) + \"\", length4 = string2.length;\n  return sign3 + (length4 < width ? new Array(width - length4 + 1).join(fill) + string2 : string2);\n}\nfunction requote(s2) {\n  return s2.replace(requoteRe, \"\\\\$&\");\n}\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\nfunction formatLookup(names) {\n  return new Map(names.map((name, i) => [name.toLowerCase(), i]));\n}\nfunction parseWeekdayNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekdayNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberISO(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\nfunction parseFullYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\nfunction parseYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;\n}\nfunction parseZone(d, string2, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string2.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\nfunction parseQuarter(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;\n}\nfunction parseMonthNumber(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\nfunction parseDayOfMonth(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseDayOfYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseHour24(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\nfunction parseMinutes(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\nfunction parseSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\nfunction parseMilliseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\nfunction parseMicroseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;\n}\nfunction parseLiteralPercent(d, string2, i) {\n  var n = percentRe.exec(string2.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\nfunction parseUnixTimestamp(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\nfunction parseUnixTimestampSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.s = +n[0], i + n[0].length) : -1;\n}\nfunction formatDayOfMonth(d, p) {\n  return pad2(d.getDate(), p, 2);\n}\nfunction formatHour24(d, p) {\n  return pad2(d.getHours(), p, 2);\n}\nfunction formatHour12(d, p) {\n  return pad2(d.getHours() % 12 || 12, p, 2);\n}\nfunction formatDayOfYear(d, p) {\n  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);\n}\nfunction formatMilliseconds(d, p) {\n  return pad2(d.getMilliseconds(), p, 3);\n}\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\nfunction formatMonthNumber(d, p) {\n  return pad2(d.getMonth() + 1, p, 2);\n}\nfunction formatMinutes(d, p) {\n  return pad2(d.getMinutes(), p, 2);\n}\nfunction formatSeconds(d, p) {\n  return pad2(d.getSeconds(), p, 2);\n}\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\nfunction formatWeekNumberSunday(d, p) {\n  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction dISO(d) {\n  var day = d.getDay();\n  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n}\nfunction formatWeekNumberISO(d, p) {\n  d = dISO(d);\n  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);\n}\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\nfunction formatWeekNumberMonday(d, p) {\n  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction formatYear2(d, p) {\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatYearISO(d, p) {\n  d = dISO(d);\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatFullYear(d, p) {\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatFullYearISO(d, p) {\n  var day = d.getDay();\n  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\")) + pad2(z / 60 | 0, \"0\", 2) + pad2(z % 60, \"0\", 2);\n}\nfunction formatUTCDayOfMonth(d, p) {\n  return pad2(d.getUTCDate(), p, 2);\n}\nfunction formatUTCHour24(d, p) {\n  return pad2(d.getUTCHours(), p, 2);\n}\nfunction formatUTCHour12(d, p) {\n  return pad2(d.getUTCHours() % 12 || 12, p, 2);\n}\nfunction formatUTCDayOfYear(d, p) {\n  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);\n}\nfunction formatUTCMilliseconds(d, p) {\n  return pad2(d.getUTCMilliseconds(), p, 3);\n}\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\nfunction formatUTCMonthNumber(d, p) {\n  return pad2(d.getUTCMonth() + 1, p, 2);\n}\nfunction formatUTCMinutes(d, p) {\n  return pad2(d.getUTCMinutes(), p, 2);\n}\nfunction formatUTCSeconds(d, p) {\n  return pad2(d.getUTCSeconds(), p, 2);\n}\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction UTCdISO(d) {\n  var day = d.getUTCDay();\n  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n}\nfunction formatUTCWeekNumberISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction formatUTCYear(d, p) {\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCYearISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCFullYear(d, p) {\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCFullYearISO(d, p) {\n  var day = d.getUTCDay();\n  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCZone() {\n  return \"+0000\";\n}\nfunction formatLiteralPercent() {\n  return \"%\";\n}\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1e3);\n}\n\n// node_modules/d3-time-format/src/defaultLocale.js\nvar locale2;\nvar timeFormat;\nvar timeParse;\nvar utcFormat;\nvar utcParse;\ndefaultLocale2({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\nfunction defaultLocale2(definition) {\n  locale2 = formatLocale(definition);\n  timeFormat = locale2.format;\n  timeParse = locale2.parse;\n  utcFormat = locale2.utcFormat;\n  utcParse = locale2.utcParse;\n  return locale2;\n}\n\n// node_modules/d3-time-format/src/isoFormat.js\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nfunction formatIsoNative(date2) {\n  return date2.toISOString();\n}\nvar formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);\nvar isoFormat_default = formatIso;\n\n// node_modules/d3-time-format/src/isoParse.js\nfunction parseIsoNative(string2) {\n  var date2 = new Date(string2);\n  return isNaN(date2) ? null : date2;\n}\nvar parseIso = +/* @__PURE__ */ new Date(\"2000-01-01T00:00:00.000Z\") ? parseIsoNative : utcParse(isoSpecifier);\nvar isoParse_default = parseIso;\n\n// node_modules/d3-scale/src/time.js\nfunction date(t) {\n  return new Date(t);\n}\nfunction number4(t) {\n  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);\n}\nfunction calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {\n  var scale3 = continuous(), invert = scale3.invert, domain = scale3.domain;\n  var formatMillisecond = format3(\".%L\"), formatSecond = format3(\":%S\"), formatMinute = format3(\"%I:%M\"), formatHour = format3(\"%I %p\"), formatDay = format3(\"%a %d\"), formatWeek = format3(\"%b %d\"), formatMonth2 = format3(\"%B\"), formatYear4 = format3(\"%Y\");\n  function tickFormat2(date2) {\n    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear4)(date2);\n  }\n  scale3.invert = function(y4) {\n    return new Date(invert(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);\n  };\n  scale3.ticks = function(interval2) {\n    var d = domain();\n    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    return specifier == null ? tickFormat2 : format3(specifier);\n  };\n  scale3.nice = function(interval2) {\n    var d = domain();\n    if (!interval2 || typeof interval2.range !== \"function\")\n      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n    return interval2 ? domain(nice2(d, interval2)) : scale3;\n  };\n  scale3.copy = function() {\n    return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));\n  };\n  return scale3;\n}\nfunction time() {\n  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/utcTime.js\nfunction utcTime() {\n  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/sequential.js\nfunction transformer3() {\n  var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : interpolator(k10 === 0 ? 0.5 : (x4 = (transform2(x4) - t03) * k10, clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale3) : [x06, x12];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1;\n      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale3) : [interpolator(0), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);\n    return scale3;\n  };\n}\nfunction copy2(source, target) {\n  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction sequential() {\n  var scale3 = linearish(transformer3()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, sequential());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialLog() {\n  var scale3 = loggish(transformer3()).domain([1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, sequentialLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSymlog() {\n  var scale3 = symlogish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialPow() {\n  var scale3 = powish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/sequentialQuantile.js\nfunction sequentialQuantile() {\n  var domain = [], interpolator = identity3;\n  function scale3(x4) {\n    if (x4 != null && !isNaN(x4 = +x4))\n      return interpolator((bisect_default(domain, x4, 1) - 1) / (domain.length - 1));\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return scale3;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  scale3.range = function() {\n    return domain.map((d, i) => interpolator(i / (domain.length - 1)));\n  };\n  scale3.quantiles = function(n) {\n    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));\n  };\n  scale3.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/diverging.js\nfunction transformer4() {\n  var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;\n  function scale3(x4) {\n    return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform2(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12, x22] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1, r2;\n      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;\n    return scale3;\n  };\n}\nfunction diverging() {\n  var scale3 = linearish(transformer4()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, diverging());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingLog() {\n  var scale3 = loggish(transformer4()).domain([0.1, 1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, divergingLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSymlog() {\n  var scale3 = symlogish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingPow() {\n  var scale3 = powish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale-chromatic/src/colors.js\nfunction colors_default(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n)\n    colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n\n// node_modules/d3-scale-chromatic/src/categorical/category10.js\nvar category10_default = colors_default(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Accent.js\nvar Accent_default = colors_default(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Dark2.js\nvar Dark2_default = colors_default(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Paired.js\nvar Paired_default = colors_default(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js\nvar Pastel1_default = colors_default(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js\nvar Pastel2_default = colors_default(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set1.js\nvar Set1_default = colors_default(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set2.js\nvar Set2_default = colors_default(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set3.js\nvar Set3_default = colors_default(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js\nvar Tableau10_default = colors_default(\"4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab\");\n\n// node_modules/d3-scale-chromatic/src/ramp.js\nvar ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);\n\n// node_modules/d3-scale-chromatic/src/diverging/BrBG.js\nvar scheme = new Array(3).concat(\n  \"d8b365f5f5f55ab4ac\",\n  \"a6611adfc27d80cdc1018571\",\n  \"a6611adfc27df5f5f580cdc1018571\",\n  \"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\n  \"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\n  \"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\n  \"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\n  \"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\n  \"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"\n).map(colors_default);\nvar BrBG_default = ramp_default(scheme);\n\n// node_modules/d3-scale-chromatic/src/diverging/PRGn.js\nvar scheme2 = new Array(3).concat(\n  \"af8dc3f7f7f77fbf7b\",\n  \"7b3294c2a5cfa6dba0008837\",\n  \"7b3294c2a5cff7f7f7a6dba0008837\",\n  \"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\n  \"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\n  \"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\n  \"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\n  \"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\n  \"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"\n).map(colors_default);\nvar PRGn_default = ramp_default(scheme2);\n\n// node_modules/d3-scale-chromatic/src/diverging/PiYG.js\nvar scheme3 = new Array(3).concat(\n  \"e9a3c9f7f7f7a1d76a\",\n  \"d01c8bf1b6dab8e1864dac26\",\n  \"d01c8bf1b6daf7f7f7b8e1864dac26\",\n  \"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\n  \"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\n  \"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\n  \"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\n  \"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\n  \"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"\n).map(colors_default);\nvar PiYG_default = ramp_default(scheme3);\n\n// node_modules/d3-scale-chromatic/src/diverging/PuOr.js\nvar scheme4 = new Array(3).concat(\n  \"998ec3f7f7f7f1a340\",\n  \"5e3c99b2abd2fdb863e66101\",\n  \"5e3c99b2abd2f7f7f7fdb863e66101\",\n  \"542788998ec3d8daebfee0b6f1a340b35806\",\n  \"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\n  \"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\n  \"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\n  \"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\n  \"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors_default);\nvar PuOr_default = ramp_default(scheme4);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdBu.js\nvar scheme5 = new Array(3).concat(\n  \"ef8a62f7f7f767a9cf\",\n  \"ca0020f4a58292c5de0571b0\",\n  \"ca0020f4a582f7f7f792c5de0571b0\",\n  \"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\n  \"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\n  \"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\n  \"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\n  \"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\n  \"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"\n).map(colors_default);\nvar RdBu_default = ramp_default(scheme5);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdGy.js\nvar scheme6 = new Array(3).concat(\n  \"ef8a62ffffff999999\",\n  \"ca0020f4a582bababa404040\",\n  \"ca0020f4a582ffffffbababa404040\",\n  \"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\n  \"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\n  \"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\n  \"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\n  \"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\n  \"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"\n).map(colors_default);\nvar RdGy_default = ramp_default(scheme6);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js\nvar scheme7 = new Array(3).concat(\n  \"fc8d59ffffbf91bfdb\",\n  \"d7191cfdae61abd9e92c7bb6\",\n  \"d7191cfdae61ffffbfabd9e92c7bb6\",\n  \"d73027fc8d59fee090e0f3f891bfdb4575b4\",\n  \"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\n  \"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\n  \"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\n  \"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\n  \"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"\n).map(colors_default);\nvar RdYlBu_default = ramp_default(scheme7);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js\nvar scheme8 = new Array(3).concat(\n  \"fc8d59ffffbf91cf60\",\n  \"d7191cfdae61a6d96a1a9641\",\n  \"d7191cfdae61ffffbfa6d96a1a9641\",\n  \"d73027fc8d59fee08bd9ef8b91cf601a9850\",\n  \"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\n  \"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\n  \"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\n  \"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\n  \"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"\n).map(colors_default);\nvar RdYlGn_default = ramp_default(scheme8);\n\n// node_modules/d3-scale-chromatic/src/diverging/Spectral.js\nvar scheme9 = new Array(3).concat(\n  \"fc8d59ffffbf99d594\",\n  \"d7191cfdae61abdda42b83ba\",\n  \"d7191cfdae61ffffbfabdda42b83ba\",\n  \"d53e4ffc8d59fee08be6f59899d5943288bd\",\n  \"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\n  \"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\n  \"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\n  \"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\n  \"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\"\n).map(colors_default);\nvar Spectral_default = ramp_default(scheme9);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js\nvar scheme10 = new Array(3).concat(\n  \"e5f5f999d8c92ca25f\",\n  \"edf8fbb2e2e266c2a4238b45\",\n  \"edf8fbb2e2e266c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"\n).map(colors_default);\nvar BuGn_default = ramp_default(scheme10);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js\nvar scheme11 = new Array(3).concat(\n  \"e0ecf49ebcda8856a7\",\n  \"edf8fbb3cde38c96c688419d\",\n  \"edf8fbb3cde38c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"\n).map(colors_default);\nvar BuPu_default = ramp_default(scheme11);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js\nvar scheme12 = new Array(3).concat(\n  \"e0f3dba8ddb543a2ca\",\n  \"f0f9e8bae4bc7bccc42b8cbe\",\n  \"f0f9e8bae4bc7bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"\n).map(colors_default);\nvar GnBu_default = ramp_default(scheme12);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js\nvar scheme13 = new Array(3).concat(\n  \"fee8c8fdbb84e34a33\",\n  \"fef0d9fdcc8afc8d59d7301f\",\n  \"fef0d9fdcc8afc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"\n).map(colors_default);\nvar OrRd_default = ramp_default(scheme13);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js\nvar scheme14 = new Array(3).concat(\n  \"ece2f0a6bddb1c9099\",\n  \"f6eff7bdc9e167a9cf02818a\",\n  \"f6eff7bdc9e167a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"\n).map(colors_default);\nvar PuBuGn_default = ramp_default(scheme14);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js\nvar scheme15 = new Array(3).concat(\n  \"ece7f2a6bddb2b8cbe\",\n  \"f1eef6bdc9e174a9cf0570b0\",\n  \"f1eef6bdc9e174a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"\n).map(colors_default);\nvar PuBu_default = ramp_default(scheme15);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js\nvar scheme16 = new Array(3).concat(\n  \"e7e1efc994c7dd1c77\",\n  \"f1eef6d7b5d8df65b0ce1256\",\n  \"f1eef6d7b5d8df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"\n).map(colors_default);\nvar PuRd_default = ramp_default(scheme16);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js\nvar scheme17 = new Array(3).concat(\n  \"fde0ddfa9fb5c51b8a\",\n  \"feebe2fbb4b9f768a1ae017e\",\n  \"feebe2fbb4b9f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"\n).map(colors_default);\nvar RdPu_default = ramp_default(scheme17);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js\nvar scheme18 = new Array(3).concat(\n  \"edf8b17fcdbb2c7fb8\",\n  \"ffffcca1dab441b6c4225ea8\",\n  \"ffffcca1dab441b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"\n).map(colors_default);\nvar YlGnBu_default = ramp_default(scheme18);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js\nvar scheme19 = new Array(3).concat(\n  \"f7fcb9addd8e31a354\",\n  \"ffffccc2e69978c679238443\",\n  \"ffffccc2e69978c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"\n).map(colors_default);\nvar YlGn_default = ramp_default(scheme19);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js\nvar scheme20 = new Array(3).concat(\n  \"fff7bcfec44fd95f0e\",\n  \"ffffd4fed98efe9929cc4c02\",\n  \"ffffd4fed98efe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"\n).map(colors_default);\nvar YlOrBr_default = ramp_default(scheme20);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js\nvar scheme21 = new Array(3).concat(\n  \"ffeda0feb24cf03b20\",\n  \"ffffb2fecc5cfd8d3ce31a1c\",\n  \"ffffb2fecc5cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"\n).map(colors_default);\nvar YlOrRd_default = ramp_default(scheme21);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js\nvar scheme22 = new Array(3).concat(\n  \"deebf79ecae13182bd\",\n  \"eff3ffbdd7e76baed62171b5\",\n  \"eff3ffbdd7e76baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"\n).map(colors_default);\nvar Blues_default = ramp_default(scheme22);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js\nvar scheme23 = new Array(3).concat(\n  \"e5f5e0a1d99b31a354\",\n  \"edf8e9bae4b374c476238b45\",\n  \"edf8e9bae4b374c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"\n).map(colors_default);\nvar Greens_default = ramp_default(scheme23);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js\nvar scheme24 = new Array(3).concat(\n  \"f0f0f0bdbdbd636363\",\n  \"f7f7f7cccccc969696525252\",\n  \"f7f7f7cccccc969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"\n).map(colors_default);\nvar Greys_default = ramp_default(scheme24);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js\nvar scheme25 = new Array(3).concat(\n  \"efedf5bcbddc756bb1\",\n  \"f2f0f7cbc9e29e9ac86a51a3\",\n  \"f2f0f7cbc9e29e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"\n).map(colors_default);\nvar Purples_default = ramp_default(scheme25);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js\nvar scheme26 = new Array(3).concat(\n  \"fee0d2fc9272de2d26\",\n  \"fee5d9fcae91fb6a4acb181d\",\n  \"fee5d9fcae91fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"\n).map(colors_default);\nvar Reds_default = ramp_default(scheme26);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js\nvar scheme27 = new Array(3).concat(\n  \"fee6cefdae6be6550d\",\n  \"feeddefdbe85fd8d3cd94701\",\n  \"feeddefdbe85fd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"\n).map(colors_default);\nvar Oranges_default = ramp_default(scheme27);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js\nfunction cividis_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + \", \" + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + \", \" + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js\nvar cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar c3 = cubehelix();\nfunction rainbow_default(t) {\n  if (t < 0 || t > 1)\n    t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c3.h = 360 * t - 100;\n  c3.s = 1.5 - 1.5 * ts;\n  c3.l = 0.8 - 0.9 * ts;\n  return c3 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js\nvar c4 = rgb();\nvar pi_1_3 = Math.PI / 3;\nvar pi_2_3 = Math.PI * 2 / 3;\nfunction sinebow_default(t) {\n  var x4;\n  t = (0.5 - t) * Math.PI;\n  c4.r = 255 * (x4 = Math.sin(t)) * x4;\n  c4.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;\n  c4.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;\n  return c4 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js\nfunction turbo_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + \", \" + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + \", \" + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js\nfunction ramp(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\nvar viridis_default = ramp(colors_default(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\nvar magma = ramp(colors_default(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\nvar inferno = ramp(colors_default(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\nvar plasma = ramp(colors_default(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\n// node_modules/d3-shape/src/constant.js\nfunction constant_default10(x4) {\n  return function constant3() {\n    return x4;\n  };\n}\n\n// node_modules/d3-shape/src/math.js\nvar abs4 = Math.abs;\nvar atan22 = Math.atan2;\nvar cos3 = Math.cos;\nvar max4 = Math.max;\nvar min3 = Math.min;\nvar sin3 = Math.sin;\nvar sqrt3 = Math.sqrt;\nvar epsilon8 = 1e-12;\nvar pi5 = Math.PI;\nvar halfPi4 = pi5 / 2;\nvar tau6 = 2 * pi5;\nfunction acos2(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi5 : Math.acos(x4);\n}\nfunction asin2(x4) {\n  return x4 >= 1 ? halfPi4 : x4 <= -1 ? -halfPi4 : Math.asin(x4);\n}\n\n// node_modules/d3-shape/src/path.js\nfunction withPath(shape) {\n  let digits = 3;\n  shape.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n  return () => new Path(digits);\n}\n\n// node_modules/d3-shape/src/arc.js\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction arcPadAngle(d) {\n  return d && d.padAngle;\n}\nfunction intersect(x06, y06, x12, y12, x22, y22, x32, y32) {\n  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;\n  if (t * t < epsilon8)\n    return;\n  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;\n  return [x06 + t * x10, y06 + t * y10];\n}\nfunction cornerTangents(x06, y06, x12, y12, r1, rc, cw) {\n  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox2 = lo * y01, oy2 = -lo * x01, x11 = x06 + ox2, y11 = y06 + oy2, x10 = x12 + ox2, y10 = y12 + oy2, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)\n    cx0 = cx1, cy0 = cy1;\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox2,\n    y01: -oy2,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\nfunction arc_default() {\n  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);\n  function arc() {\n    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;\n    if (!context)\n      context = buffer = path2();\n    if (r1 < r0)\n      r = r1, r1 = r0, r0 = r;\n    if (!(r1 > epsilon8))\n      context.moveTo(0, 0);\n    else if (da2 > tau6 - epsilon8) {\n      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon8) {\n        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    } else {\n      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;\n      if (rp > epsilon8) {\n        var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));\n        if ((da0 -= p02 * 2) > epsilon8)\n          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;\n        else\n          da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon8)\n          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;\n        else\n          da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);\n      if (rc > epsilon8) {\n        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;\n        if (da2 < pi5) {\n          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {\n            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);\n            rc0 = min3(rc, (r0 - lc) / (kc - 1));\n            rc1 = min3(rc, (r1 - lc) / (kc + 1));\n          } else {\n            rc0 = rc1 = 0;\n          }\n        }\n      }\n      if (!(da1 > epsilon8))\n        context.moveTo(x01, y01);\n      else if (rc1 > epsilon8) {\n        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);\n        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc1 < rc)\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);\n          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n      if (!(r0 > epsilon8) || !(da0 > epsilon8))\n        context.lineTo(x10, y10);\n      else if (rc0 > epsilon8) {\n        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);\n        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc0 < rc)\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);\n          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.arc(0, 0, r0, a10, a00, cw);\n    }\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;\n    return [cos3(a4) * r, sin3(a4) * r];\n  };\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : innerRadius;\n  };\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : outerRadius;\n  };\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : cornerRadius;\n  };\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padRadius;\n  };\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : startAngle;\n  };\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : endAngle;\n  };\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padAngle;\n  };\n  arc.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n  return arc;\n}\n\n// node_modules/d3-shape/src/array.js\nvar slice4 = Array.prototype.slice;\nfunction array_default3(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-shape/src/curve/linear.js\nfunction Linear(context) {\n  this._context = context;\n}\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default:\n        this._context.lineTo(x4, y4);\n        break;\n    }\n  }\n};\nfunction linear_default(context) {\n  return new Linear(context);\n}\n\n// node_modules/d3-shape/src/point.js\nfunction x3(p) {\n  return p[0];\n}\nfunction y3(p) {\n  return p[1];\n}\n\n// node_modules/d3-shape/src/line.js\nfunction line_default2(x4, y4) {\n  var defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);\n  x4 = typeof x4 === \"function\" ? x4 : x4 === void 0 ? x3 : constant_default10(x4);\n  y4 = typeof y4 === \"function\" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);\n  function line2(data) {\n    var i, n = (data = array_default3(data)).length, d, defined0 = false, buffer;\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0)\n          output.lineStart();\n        else\n          output.lineEnd();\n      }\n      if (defined0)\n        output.point(+x4(d, i, data), +y4(d, i, data));\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  line2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : x4;\n  };\n  line2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : y4;\n  };\n  line2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), line2) : defined2;\n  };\n  line2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;\n  };\n  line2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;\n  };\n  return line2;\n}\n\n// node_modules/d3-shape/src/area.js\nfunction area_default5(x06, y06, y12) {\n  var x12 = null, defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);\n  x06 = typeof x06 === \"function\" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);\n  y06 = typeof y06 === \"function\" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);\n  y12 = typeof y12 === \"function\" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);\n  function area2(data) {\n    var i, j, k2, n = (data = array_default3(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k2 = i - 1; k2 >= j; --k2) {\n            output.point(x0z[k2], y0z[k2]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);\n        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);\n      }\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  function arealine() {\n    return line_default2().defined(defined2).curve(curve).context(context);\n  }\n  area2.x = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), x12 = null, area2) : x06;\n  };\n  area2.x0 = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x06;\n  };\n  area2.x1 = function(_) {\n    return arguments.length ? (x12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x12;\n  };\n  area2.y = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), y12 = null, area2) : y06;\n  };\n  area2.y0 = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y06;\n  };\n  area2.y1 = function(_) {\n    return arguments.length ? (y12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y12;\n  };\n  area2.lineX0 = area2.lineY0 = function() {\n    return arealine().x(x06).y(y06);\n  };\n  area2.lineY1 = function() {\n    return arealine().x(x06).y(y12);\n  };\n  area2.lineX1 = function() {\n    return arealine().x(x12).y(y06);\n  };\n  area2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), area2) : defined2;\n  };\n  area2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;\n  };\n  area2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;\n  };\n  return area2;\n}\n\n// node_modules/d3-shape/src/descending.js\nfunction descending_default(a4, b) {\n  return b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-shape/src/identity.js\nfunction identity_default5(d) {\n  return d;\n}\n\n// node_modules/d3-shape/src/pie.js\nfunction pie_default() {\n  var value = identity_default5, sortValues = descending_default, sort3 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);\n  function pie(data) {\n    var i, n = (data = array_default3(data)).length, j, k2, sum5 = 0, index3 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;\n    for (i = 0; i < n; ++i) {\n      if ((v2 = arcs[index3[i] = i] = +value(data[i], i, data)) > 0) {\n        sum5 += v2;\n      }\n    }\n    if (sortValues != null)\n      index3.sort(function(i2, j2) {\n        return sortValues(arcs[i2], arcs[j2]);\n      });\n    else if (sort3 != null)\n      index3.sort(function(i2, j2) {\n        return sort3(data[i2], data[j2]);\n      });\n    for (i = 0, k2 = sum5 ? (da2 - n * pa) / sum5 : 0; i < n; ++i, a0 = a1) {\n      j = index3[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v2,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n    return arcs;\n  }\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : value;\n  };\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort3 = null, pie) : sortValues;\n  };\n  pie.sort = function(_) {\n    return arguments.length ? (sort3 = _, sortValues = null, pie) : sort3;\n  };\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : startAngle;\n  };\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : endAngle;\n  };\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : padAngle;\n  };\n  return pie;\n}\n\n// node_modules/d3-shape/src/curve/radial.js\nvar curveRadialLinear = curveRadial(linear_default);\nfunction Radial(curve) {\n  this._curve = curve;\n}\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a4, r) {\n    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));\n  }\n};\nfunction curveRadial(curve) {\n  function radial2(context) {\n    return new Radial(curve(context));\n  }\n  radial2._curve = curve;\n  return radial2;\n}\n\n// node_modules/d3-shape/src/lineRadial.js\nfunction lineRadial(l) {\n  var c6 = l.curve;\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  l.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return l;\n}\nfunction lineRadial_default() {\n  return lineRadial(line_default2().curve(curveRadialLinear));\n}\n\n// node_modules/d3-shape/src/areaRadial.js\nfunction areaRadial_default() {\n  var a4 = area_default5().curve(curveRadialLinear), c6 = a4.curve, x06 = a4.lineX0, x12 = a4.lineX1, y06 = a4.lineY0, y12 = a4.lineY1;\n  a4.angle = a4.x, delete a4.x;\n  a4.startAngle = a4.x0, delete a4.x0;\n  a4.endAngle = a4.x1, delete a4.x1;\n  a4.radius = a4.y, delete a4.y;\n  a4.innerRadius = a4.y0, delete a4.y0;\n  a4.outerRadius = a4.y1, delete a4.y1;\n  a4.lineStartAngle = function() {\n    return lineRadial(x06());\n  }, delete a4.lineX0;\n  a4.lineEndAngle = function() {\n    return lineRadial(x12());\n  }, delete a4.lineX1;\n  a4.lineInnerRadius = function() {\n    return lineRadial(y06());\n  }, delete a4.lineY0;\n  a4.lineOuterRadius = function() {\n    return lineRadial(y12());\n  }, delete a4.lineY1;\n  a4.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return a4;\n}\n\n// node_modules/d3-shape/src/pointRadial.js\nfunction pointRadial_default(x4, y4) {\n  return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];\n}\n\n// node_modules/d3-shape/src/curve/bump.js\nvar Bump = class {\n  constructor(context, x4) {\n    this._context = context;\n    this._x = x4;\n  }\n  areaStart() {\n    this._line = 0;\n  }\n  areaEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0: {\n        this._point = 1;\n        if (this._line)\n          this._context.lineTo(x4, y4);\n        else\n          this._context.moveTo(x4, y4);\n        break;\n      }\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._x)\n          this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);\n        else\n          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);\n        break;\n      }\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nvar BumpRadial = class {\n  constructor(context) {\n    this._context = context;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point === 0) {\n      this._point = 1;\n    } else {\n      const p02 = pointRadial_default(this._x0, this._y0);\n      const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y4) / 2);\n      const p2 = pointRadial_default(x4, this._y0);\n      const p3 = pointRadial_default(x4, y4);\n      this._context.moveTo(...p02);\n      this._context.bezierCurveTo(...p1, ...p2, ...p3);\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nfunction bumpX(context) {\n  return new Bump(context, true);\n}\nfunction bumpY(context) {\n  return new Bump(context, false);\n}\nfunction bumpRadial(context) {\n  return new BumpRadial(context);\n}\n\n// node_modules/d3-shape/src/link.js\nfunction linkSource(d) {\n  return d.source;\n}\nfunction linkTarget(d) {\n  return d.target;\n}\nfunction link2(curve) {\n  let source = linkSource, target = linkTarget, x4 = x3, y4 = y3, context = null, output = null, path2 = withPath(link4);\n  function link4() {\n    let buffer;\n    const argv = slice4.call(arguments);\n    const s2 = source.apply(this, argv);\n    const t = target.apply(this, argv);\n    if (context == null)\n      output = curve(buffer = path2());\n    output.lineStart();\n    argv[0] = s2, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    argv[0] = t, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    output.lineEnd();\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  link4.source = function(_) {\n    return arguments.length ? (source = _, link4) : source;\n  };\n  link4.target = function(_) {\n    return arguments.length ? (target = _, link4) : target;\n  };\n  link4.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : x4;\n  };\n  link4.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : y4;\n  };\n  link4.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link4) : context;\n  };\n  return link4;\n}\nfunction linkHorizontal() {\n  return link2(bumpX);\n}\nfunction linkVertical() {\n  return link2(bumpY);\n}\nfunction linkRadial() {\n  const l = link2(bumpRadial);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\n// node_modules/d3-shape/src/symbol/asterisk.js\nvar sqrt32 = sqrt3(3);\nvar asterisk_default = {\n  draw(context, size) {\n    const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;\n    const t = r / 2;\n    const u4 = t * sqrt32;\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n    context.moveTo(-u4, -t);\n    context.lineTo(u4, t);\n    context.moveTo(-u4, t);\n    context.lineTo(u4, -t);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/circle.js\nvar circle_default3 = {\n  draw(context, size) {\n    const r = sqrt3(size / pi5);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau6);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/cross.js\nvar cross_default2 = {\n  draw(context, size) {\n    const r = sqrt3(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond.js\nvar tan30 = sqrt3(1 / 3);\nvar tan30_2 = tan30 * 2;\nvar diamond_default = {\n  draw(context, size) {\n    const y4 = sqrt3(size / tan30_2);\n    const x4 = y4 * tan30;\n    context.moveTo(0, -y4);\n    context.lineTo(x4, 0);\n    context.lineTo(0, y4);\n    context.lineTo(-x4, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond2.js\nvar diamond2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.62625;\n    context.moveTo(0, -r);\n    context.lineTo(r, 0);\n    context.lineTo(0, r);\n    context.lineTo(-r, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/plus.js\nvar plus_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;\n    context.moveTo(-r, 0);\n    context.lineTo(r, 0);\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square.js\nvar square_default = {\n  draw(context, size) {\n    const w = sqrt3(size);\n    const x4 = -w / 2;\n    context.rect(x4, x4, w, w);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square2.js\nvar square2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.4431;\n    context.moveTo(r, r);\n    context.lineTo(r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/star.js\nvar ka = 0.8908130915292852;\nvar kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);\nvar kx = sin3(tau6 / 10) * kr;\nvar ky = -cos3(tau6 / 10) * kr;\nvar star_default = {\n  draw(context, size) {\n    const r = sqrt3(size * ka);\n    const x4 = kx * r;\n    const y4 = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x4, y4);\n    for (let i = 1; i < 5; ++i) {\n      const a4 = tau6 * i / 5;\n      const c6 = cos3(a4);\n      const s2 = sin3(a4);\n      context.lineTo(s2 * r, -c6 * r);\n      context.lineTo(c6 * x4 - s2 * y4, s2 * x4 + c6 * y4);\n    }\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle.js\nvar sqrt33 = sqrt3(3);\nvar triangle_default = {\n  draw(context, size) {\n    const y4 = -sqrt3(size / (sqrt33 * 3));\n    context.moveTo(0, y4 * 2);\n    context.lineTo(-sqrt33 * y4, -y4);\n    context.lineTo(sqrt33 * y4, -y4);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle2.js\nvar sqrt34 = sqrt3(3);\nvar triangle2_default = {\n  draw(context, size) {\n    const s2 = sqrt3(size) * 0.6824;\n    const t = s2 / 2;\n    const u4 = s2 * sqrt34 / 2;\n    context.moveTo(0, -s2);\n    context.lineTo(u4, t);\n    context.lineTo(-u4, t);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/wye.js\nvar c5 = -0.5;\nvar s = sqrt3(3) / 2;\nvar k = 1 / sqrt3(12);\nvar a3 = (k / 2 + 1) * 3;\nvar wye_default = {\n  draw(context, size) {\n    const r = sqrt3(size / a3);\n    const x06 = r / 2, y06 = r * k;\n    const x12 = x06, y12 = r * k + r;\n    const x22 = -x12, y22 = y12;\n    context.moveTo(x06, y06);\n    context.lineTo(x12, y12);\n    context.lineTo(x22, y22);\n    context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);\n    context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);\n    context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);\n    context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);\n    context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);\n    context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/times.js\nvar times_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;\n    context.moveTo(-r, -r);\n    context.lineTo(r, r);\n    context.moveTo(-r, r);\n    context.lineTo(r, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol.js\nvar symbolsFill = [\n  circle_default3,\n  cross_default2,\n  diamond_default,\n  square_default,\n  star_default,\n  triangle_default,\n  wye_default\n];\nvar symbolsStroke = [\n  circle_default3,\n  plus_default,\n  times_default,\n  triangle2_default,\n  asterisk_default,\n  square2_default,\n  diamond2_default\n];\nfunction Symbol2(type2, size) {\n  let context = null, path2 = withPath(symbol2);\n  type2 = typeof type2 === \"function\" ? type2 : constant_default10(type2 || circle_default3);\n  size = typeof size === \"function\" ? size : constant_default10(size === void 0 ? 64 : +size);\n  function symbol2() {\n    let buffer;\n    if (!context)\n      context = buffer = path2();\n    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  symbol2.type = function(_) {\n    return arguments.length ? (type2 = typeof _ === \"function\" ? _ : constant_default10(_), symbol2) : type2;\n  };\n  symbol2.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant_default10(+_), symbol2) : size;\n  };\n  symbol2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol2) : context;\n  };\n  return symbol2;\n}\n\n// node_modules/d3-shape/src/noop.js\nfunction noop_default2() {\n}\n\n// node_modules/d3-shape/src/curve/basis.js\nfunction point2(that, x4, y4) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x4) / 6,\n    (that._y0 + 4 * that._y1 + y4) / 6\n  );\n}\nfunction Basis(context) {\n  this._context = context;\n}\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3:\n        point2(this, this._x1, this._y1);\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basis_default2(context) {\n  return new Basis(context);\n}\n\n// node_modules/d3-shape/src/curve/basisClosed.js\nfunction BasisClosed(context) {\n  this._context = context;\n}\nBasisClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x2 = x4, this._y2 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 2:\n        this._point = 3;\n        this._x4 = x4, this._y4 = y4;\n        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);\n        break;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisClosed_default2(context) {\n  return new BasisClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/basisOpen.js\nfunction BasisOpen(context) {\n  this._context = context;\n}\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;\n        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisOpen_default(context) {\n  return new BasisOpen(context);\n}\n\n// node_modules/d3-shape/src/curve/bundle.js\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, j = x4.length - 1;\n    if (j > 0) {\n      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),\n          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)\n        );\n      }\n    }\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nvar bundle_default = function custom12(beta) {\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n  bundle.beta = function(beta2) {\n    return custom12(+beta2);\n  };\n  return bundle;\n}(0.85);\n\n// node_modules/d3-shape/src/curve/cardinal.js\nfunction point3(that, x4, y4) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x4),\n    that._y2 + that._k * (that._y1 - y4),\n    that._x2,\n    that._y2\n  );\n}\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        point3(this, this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        this._x1 = x4, this._y1 = y4;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinal_default = function custom13(tension) {\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom13(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalClosed.js\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalClosed_default = function custom14(tension) {\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom14(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalOpen.js\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalOpen_default = function custom15(tension) {\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom15(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/catmullRom.js\nfunction point4(that, x4, y4) {\n  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;\n  if (that._l01_a > epsilon8) {\n    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n  if (that._l23_a > epsilon8) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;\n    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;\n  }\n  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);\n}\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        this.point(this._x2, this._y2);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRom_default = function custom16(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom16(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomClosed.js\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomClosed_default = function custom17(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom17(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomOpen.js\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomOpen_default = function custom18(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom18(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/linearClosed.js\nfunction LinearClosed(context) {\n  this._context = context;\n}\nLinearClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point)\n      this._context.closePath();\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point)\n      this._context.lineTo(x4, y4);\n    else\n      this._point = 1, this._context.moveTo(x4, y4);\n  }\n};\nfunction linearClosed_default(context) {\n  return new LinearClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/monotone.js\nfunction sign2(x4) {\n  return x4 < 0 ? -1 : 1;\n}\nfunction slope3(that, x22, y22) {\n  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\nfunction point5(that, t03, t13) {\n  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;\n  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);\n}\nfunction MonotoneX(context) {\n  this._context = context;\n}\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n      case 3:\n        point5(this, this._t0, slope2(this, this._t0));\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    var t13 = NaN;\n    x4 = +x4, y4 = +y4;\n    if (x4 === this._x1 && y4 === this._y1)\n      return;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);\n        break;\n      default:\n        point5(this, this._t0, t13 = slope3(this, x4, y4));\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n    this._t0 = t13;\n  }\n};\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {\n  MonotoneX.prototype.point.call(this, y4, x4);\n};\nfunction ReflectContext(context) {\n  this._context = context;\n}\nReflectContext.prototype = {\n  moveTo: function(x4, y4) {\n    this._context.moveTo(y4, x4);\n  },\n  closePath: function() {\n    this._context.closePath();\n  },\n  lineTo: function(x4, y4) {\n    this._context.lineTo(y4, x4);\n  },\n  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {\n    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);\n  }\n};\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\n// node_modules/d3-shape/src/curve/natural.js\nfunction Natural(context) {\n  this._context = context;\n}\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, n = x4.length;\n    if (n) {\n      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);\n      if (n === 2) {\n        this._context.lineTo(x4[1], y4[1]);\n      } else {\n        var px = controlPoints(x4), py = controlPoints(y4);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);\n        }\n      }\n    }\n    if (this._line || this._line !== 0 && n === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nfunction controlPoints(x4) {\n  var i, n = x4.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);\n  a4[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];\n  for (i = 1; i < n - 1; ++i)\n    a4[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];\n  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];\n  for (i = 1; i < n; ++i)\n    m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];\n  a4[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i)\n    a4[i] = (r[i] - a4[i + 1]) / b[i];\n  b[n - 1] = (x4[n] + a4[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i)\n    b[i] = 2 * x4[i + 1] - a4[i + 1];\n  return [a4, b];\n}\nfunction natural_default(context) {\n  return new Natural(context);\n}\n\n// node_modules/d3-shape/src/curve/step.js\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2)\n      this._context.lineTo(this._x, this._y);\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    if (this._line >= 0)\n      this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y4);\n          this._context.lineTo(x4, y4);\n        } else {\n          var x12 = this._x * (1 - this._t) + x4 * this._t;\n          this._context.lineTo(x12, this._y);\n          this._context.lineTo(x12, y4);\n        }\n        break;\n      }\n    }\n    this._x = x4, this._y = y4;\n  }\n};\nfunction step_default(context) {\n  return new Step(context, 0.5);\n}\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\n// node_modules/d3-shape/src/offset/none.js\nfunction none_default(series, order) {\n  if (!((n = series.length) > 1))\n    return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m3; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n\n// node_modules/d3-shape/src/order/none.js\nfunction none_default2(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0)\n    o[n] = n;\n  return o;\n}\n\n// node_modules/d3-shape/src/stack.js\nfunction stackValue(d, key) {\n  return d[key];\n}\nfunction stackSeries(key) {\n  const series = [];\n  series.key = key;\n  return series;\n}\nfunction stack_default() {\n  var keys = constant_default10([]), order = none_default2, offset2 = none_default, value = stackValue;\n  function stack2(data) {\n    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;\n    for (const d of data) {\n      for (i = 0, ++j; i < n; ++i) {\n        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;\n      }\n    }\n    for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n    offset2(sz, oz);\n    return sz;\n  }\n  stack2.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : keys;\n  };\n  stack2.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), stack2) : value;\n  };\n  stack2.order = function(_) {\n    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : order;\n  };\n  stack2.offset = function(_) {\n    return arguments.length ? (offset2 = _ == null ? none_default : _, stack2) : offset2;\n  };\n  return stack2;\n}\n\n// node_modules/d3-shape/src/offset/expand.js\nfunction expand_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {\n    for (y4 = i = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    if (y4)\n      for (i = 0; i < n; ++i)\n        series[i][j][1] /= y4;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/diverging.js\nfunction diverging_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = 0, d[1] = dy;\n      }\n    }\n  }\n}\n\n// node_modules/d3-shape/src/offset/silhouette.js\nfunction silhouette_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var j = 0, s0 = series[order[0]], n, m3 = s0.length; j < m3; ++j) {\n    for (var i = 0, y4 = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y4 / 2;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/wiggle.js\nfunction wiggle_default(series, order) {\n  if (!((n = series.length) > 0) || !((m3 = (s0 = series[order[0]]).length) > 0))\n    return;\n  for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;\n      for (var k2 = 0; k2 < i; ++k2) {\n        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y4;\n    if (s1)\n      y4 -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y4;\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/order/appearance.js\nfunction appearance_default(series) {\n  var peaks = series.map(peak);\n  return none_default2(series).sort(function(a4, b) {\n    return peaks[a4] - peaks[b];\n  });\n}\nfunction peak(series) {\n  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n  while (++i < n)\n    if ((vi = +series[i][1]) > vj)\n      vj = vi, j = i;\n  return j;\n}\n\n// node_modules/d3-shape/src/order/ascending.js\nfunction ascending_default2(series) {\n  var sums = series.map(sum3);\n  return none_default2(series).sort(function(a4, b) {\n    return sums[a4] - sums[b];\n  });\n}\nfunction sum3(series) {\n  var s2 = 0, i = -1, n = series.length, v2;\n  while (++i < n)\n    if (v2 = +series[i][1])\n      s2 += v2;\n  return s2;\n}\n\n// node_modules/d3-shape/src/order/descending.js\nfunction descending_default2(series) {\n  return ascending_default2(series).reverse();\n}\n\n// node_modules/d3-shape/src/order/insideOut.js\nfunction insideOut_default(series) {\n  var n = series.length, i, j, sums = series.map(sum3), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top2 < bottom2) {\n      top2 += sums[j];\n      tops.push(j);\n    } else {\n      bottom2 += sums[j];\n      bottoms.push(j);\n    }\n  }\n  return bottoms.reverse().concat(tops);\n}\n\n// node_modules/d3-shape/src/order/reverse.js\nfunction reverse_default(series) {\n  return none_default2(series).reverse();\n}\n\n// node_modules/d3-zoom/src/constant.js\nvar constant_default11 = (x4) => () => x4;\n\n// node_modules/d3-zoom/src/event.js\nfunction ZoomEvent(type2, {\n  sourceEvent,\n  target,\n  transform: transform2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    transform: { value: transform2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-zoom/src/transform.js\nfunction Transform(k2, x4, y4) {\n  this.k = k2;\n  this.x = x4;\n  this.y = y4;\n}\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k2) {\n    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);\n  },\n  translate: function(x4, y4) {\n    return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);\n  },\n  apply: function(point6) {\n    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];\n  },\n  applyX: function(x4) {\n    return x4 * this.k + this.x;\n  },\n  applyY: function(y4) {\n    return y4 * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x4) {\n    return (x4 - this.x) / this.k;\n  },\n  invertY: function(y4) {\n    return (y4 - this.y) / this.k;\n  },\n  rescaleX: function(x4) {\n    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));\n  },\n  rescaleY: function(y4) {\n    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\nvar identity5 = new Transform(1, 0, 0);\ntransform.prototype = Transform.prototype;\nfunction transform(node) {\n  while (!node.__zoom)\n    if (!(node = node.parentNode))\n      return identity5;\n  return node.__zoom;\n}\n\n// node_modules/d3-zoom/src/noevent.js\nfunction nopropagation3(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default3(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-zoom/src/zoom.js\nfunction defaultFilter3(event) {\n  return (!event.ctrlKey || event.type === \"wheel\") && !event.button;\n}\nfunction defaultExtent2() {\n  var e = this;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    if (e.hasAttribute(\"viewBox\")) {\n      e = e.viewBox.baseVal;\n      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];\n    }\n    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];\n  }\n  return [[0, 0], [e.clientWidth, e.clientHeight]];\n}\nfunction defaultTransform() {\n  return this.__zoom || identity5;\n}\nfunction defaultWheelDelta(event) {\n  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);\n}\nfunction defaultTouchable3() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction defaultConstrain(transform2, extent3, translateExtent) {\n  var dx0 = transform2.invertX(extent3[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent3[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent3[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent3[1][1]) - translateExtent[1][1];\n  return transform2.translate(\n    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n  );\n}\nfunction zoom_default2() {\n  var filter4 = defaultFilter3, extent3 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default(\"start\", \"zoom\", \"end\"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;\n  function zoom(selection2) {\n    selection2.property(\"__zoom\", defaultTransform).on(\"wheel.zoom\", wheeled, { passive: false }).on(\"mousedown.zoom\", mousedowned).on(\"dblclick.zoom\", dblclicked).filter(touchable).on(\"touchstart.zoom\", touchstarted).on(\"touchmove.zoom\", touchmoved).on(\"touchend.zoom touchcancel.zoom\", touchended).style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  zoom.transform = function(collection, transform2, point6, event) {\n    var selection2 = collection.selection ? collection.selection() : collection;\n    selection2.property(\"__zoom\", defaultTransform);\n    if (collection !== selection2) {\n      schedule(collection, transform2, point6, event);\n    } else {\n      selection2.interrupt().each(function() {\n        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === \"function\" ? transform2.apply(this, arguments) : transform2).end();\n      });\n    }\n  };\n  zoom.scaleBy = function(selection2, k2, p, event) {\n    zoom.scaleTo(selection2, function() {\n      var k0 = this.__zoom.k, k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return k0 * k1;\n    }, p, event);\n  };\n  zoom.scaleTo = function(selection2, k2, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return constrain(translate(scale3(t03, k1), p02, p1), e, translateExtent);\n    }, p, event);\n  };\n  zoom.translateBy = function(selection2, x4, y4, event) {\n    zoom.transform(selection2, function() {\n      return constrain(this.__zoom.translate(\n        typeof x4 === \"function\" ? x4.apply(this, arguments) : x4,\n        typeof y4 === \"function\" ? y4.apply(this, arguments) : y4\n      ), extent3.apply(this, arguments), translateExtent);\n    }, null, event);\n  };\n  zoom.translateTo = function(selection2, x4, y4, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p;\n      return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(\n        typeof x4 === \"function\" ? -x4.apply(this, arguments) : -x4,\n        typeof y4 === \"function\" ? -y4.apply(this, arguments) : -y4\n      ), e, translateExtent);\n    }, p, event);\n  };\n  function scale3(transform2, k2) {\n    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));\n    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);\n  }\n  function translate(transform2, p02, p1) {\n    var x4 = p02[0] - p1[0] * transform2.k, y4 = p02[1] - p1[1] * transform2.k;\n    return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);\n  }\n  function centroid2(extent4) {\n    return [(+extent4[0][0] + +extent4[1][0]) / 2, (+extent4[0][1] + +extent4[1][1]) / 2];\n  }\n  function schedule(transition2, transform2, point6, event) {\n    transition2.on(\"start.zoom\", function() {\n      gesture(this, arguments).event(event).start();\n    }).on(\"interrupt.zoom end.zoom\", function() {\n      gesture(this, arguments).event(event).end();\n    }).tween(\"zoom\", function() {\n      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent3.apply(that, args), p = point6 == null ? centroid2(e) : typeof point6 === \"function\" ? point6.apply(that, args) : point6, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a4 = that.__zoom, b = typeof transform2 === \"function\" ? transform2.apply(that, args) : transform2, i = interpolate(a4.invert(p).concat(w / a4.k), b.invert(p).concat(w / b.k));\n      return function(t) {\n        if (t === 1)\n          t = b;\n        else {\n          var l = i(t), k2 = w / l[2];\n          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);\n        }\n        g.zoom(null, t);\n      };\n    });\n  }\n  function gesture(that, args, clean) {\n    return !clean && that.__zooming || new Gesture(that, args);\n  }\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.active = 0;\n    this.sourceEvent = null;\n    this.extent = extent3.apply(that, args);\n    this.taps = 0;\n  }\n  Gesture.prototype = {\n    event: function(event) {\n      if (event)\n        this.sourceEvent = event;\n      return this;\n    },\n    start: function() {\n      if (++this.active === 1) {\n        this.that.__zooming = this;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform2) {\n      if (this.mouse && key !== \"mouse\")\n        this.mouse[1] = transform2.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\")\n        this.touch0[1] = transform2.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\")\n        this.touch1[1] = transform2.invert(this.touch1[0]);\n      this.that.__zoom = transform2;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        delete this.that.__zooming;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new ZoomEvent(type2, {\n          sourceEvent: this.sourceEvent,\n          target: zoom,\n          type: type2,\n          transform: this.that.__zoom,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function wheeled(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    } else if (t.k === k2)\n      return;\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt_default(this);\n      g.start();\n    }\n    noevent_default3(event);\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale3(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n  function mousedowned(event, ...args) {\n    if (touchending || !filter4.apply(this, arguments))\n      return;\n    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true), p = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;\n    nodrag_default(event.view);\n    nopropagation3(event);\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt_default(this);\n    g.start();\n    function mousemoved(event2) {\n      noevent_default3(event2);\n      if (!g.moved) {\n        var dx = event2.clientX - x06, dy = event2.clientY - y06;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.event(event2).zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));\n    }\n    function mouseupped(event2) {\n      v2.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(event2.view, g.moved);\n      noevent_default3(event2);\n      g.event(event2).end();\n    }\n  }\n  function dblclicked(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var t03 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p02), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale3(t03, k1), p02, p1), extent3.apply(this, args), translateExtent);\n    noevent_default3(event);\n    if (duration > 0)\n      select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);\n    else\n      select_default2(this).call(zoom.transform, t13, p02, event);\n  }\n  function touchstarted(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;\n    nopropagation3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0)\n        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;\n      else if (!g.touch1 && g.touch0[2] !== p[2])\n        g.touch1 = p, g.taps = 0;\n    }\n    if (touchstarting)\n      touchstarting = clearTimeout(touchstarting);\n    if (started) {\n      if (g.taps < 2)\n        touchfirst = p[0], touchstarting = setTimeout(function() {\n          touchstarting = null;\n        }, touchDelay);\n      interrupt_default(this);\n      g.start();\n    }\n  }\n  function touchmoved(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;\n    noevent_default3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale3(t, Math.sqrt(dp / dl));\n      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    } else if (g.touch0)\n      p = g.touch0[0], l = g.touch0[1];\n    else\n      return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\n  }\n  function touchended(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;\n    nopropagation3(event);\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches[i];\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0)\n      g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0)\n      g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else {\n      g.end();\n      if (g.taps === 2) {\n        t = pointer_default(t, this);\n        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {\n          var p = select_default2(this).on(\"dblclick.zoom\");\n          if (p)\n            p.apply(this, arguments);\n        }\n      }\n    }\n  }\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant_default11(+_), zoom) : wheelDelta;\n  };\n  zoom.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : filter4;\n  };\n  zoom.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : touchable;\n  };\n  zoom.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent3;\n  };\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\n  };\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\n  };\n  zoom.constrain = function(_) {\n    return arguments.length ? (constrain = _, zoom) : constrain;\n  };\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n  zoom.tapDistance = function(_) {\n    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;\n  };\n  return zoom;\n}\n\n// node_modules/isoformat/src/format.js\nfunction format2(date2, fallback) {\n  if (!(date2 instanceof Date))\n    date2 = /* @__PURE__ */ new Date(+date2);\n  if (isNaN(date2))\n    return typeof fallback === \"function\" ? fallback(date2) : fallback;\n  const hours = date2.getUTCHours();\n  const minutes = date2.getUTCMinutes();\n  const seconds2 = date2.getUTCSeconds();\n  const milliseconds2 = date2.getUTCMilliseconds();\n  return `${formatYear3(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;\n}\nfunction formatYear3(year) {\n  return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);\n}\nfunction pad3(value, width) {\n  return `${value}`.padStart(width, \"0\");\n}\n\n// node_modules/isoformat/src/parse.js\nvar re2 = /^(?:[-+]\\d{2})?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{3})?)?(?:Z|[-+]\\d{2}:?\\d{2})?)?$/;\nfunction parse(string2, fallback) {\n  if (!re2.test(string2 += \"\"))\n    return typeof fallback === \"function\" ? fallback(string2) : fallback;\n  return new Date(string2);\n}\n\n// node_modules/@observablehq/plot/dist/time.js\nvar timeIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", timeMinute],\n  [\"hour\", timeHour],\n  [\"day\", timeDay],\n  [\"week\", timeSunday],\n  [\"month\", timeMonth],\n  [\"year\", timeYear],\n  [\"monday\", timeMonday],\n  [\"tuesday\", timeTuesday],\n  [\"wednesday\", timeWednesday],\n  [\"thursday\", timeThursday],\n  [\"friday\", timeFriday],\n  [\"saturday\", timeSaturday],\n  [\"sunday\", timeSunday]\n]);\nvar utcIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", utcMinute],\n  [\"hour\", utcHour],\n  [\"day\", utcDay],\n  [\"week\", utcSunday],\n  [\"month\", utcMonth],\n  [\"year\", utcYear],\n  [\"monday\", utcMonday],\n  [\"tuesday\", utcTuesday],\n  [\"wednesday\", utcWednesday],\n  [\"thursday\", utcThursday],\n  [\"friday\", utcFriday],\n  [\"saturday\", utcSaturday],\n  [\"sunday\", utcSunday]\n]);\nfunction maybeTimeInterval(interval2) {\n  const i = timeIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\nfunction maybeUtcInterval(interval2) {\n  const i = utcIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\n\n// node_modules/@observablehq/plot/dist/options.js\nvar TypedArray = Object.getPrototypeOf(Uint8Array);\nvar objectToString = Object.prototype.toString;\nfunction valueof(data, value, type2) {\n  const valueType = typeof value;\n  return valueType === \"string\" ? map4(data, field(value), type2) : valueType === \"function\" ? map4(data, value, type2) : valueType === \"number\" || value instanceof Date || valueType === \"boolean\" ? map4(data, constant2(value), type2) : value && typeof value.transform === \"function\" ? arrayify2(value.transform(data), type2) : arrayify2(value, type2);\n}\nvar field = (name) => (d) => d[name];\nvar indexOf = (d, i) => i;\nvar identity6 = { transform: (d) => d };\nvar one2 = () => 1;\nvar yes = () => true;\nvar string = (x4) => x4 == null ? x4 : `${x4}`;\nvar number5 = (x4) => x4 == null ? x4 : +x4;\nvar first = (x4) => x4 ? x4[0] : void 0;\nvar second2 = (x4) => x4 ? x4[1] : void 0;\nvar third = (x4) => x4 ? x4[2] : void 0;\nvar constant2 = (x4) => () => x4;\nfunction percentile(reduce2) {\n  const p = +`${reduce2}`.slice(1) / 100;\n  return (I, f) => quantile(I, p, f);\n}\nfunction maybeColorChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null ? [void 0, \"none\"] : isColor(value) ? [void 0, value] : [value, void 0];\n}\nfunction maybeNumberChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null || typeof value === \"number\" ? [void 0, value] : [value, void 0];\n}\nfunction maybeKeyword(input, name, allowed) {\n  if (input != null)\n    return keyword(input, name, allowed);\n}\nfunction keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i))\n    throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\nfunction arrayify2(data, type2) {\n  return data == null ? data : type2 === void 0 ? data instanceof Array || data instanceof TypedArray ? data : Array.from(data) : data instanceof type2 ? data : type2.from(data);\n}\nfunction map4(values2, f, type2 = Array) {\n  return values2 instanceof type2 ? values2.map(f) : type2.from(values2, f);\n}\nfunction slice5(values2, type2 = Array) {\n  return values2 instanceof type2 ? values2.slice() : type2.from(values2);\n}\nfunction isTypedArray(values2) {\n  return values2 instanceof TypedArray;\n}\nfunction isObject(option) {\n  return option?.toString === objectToString;\n}\nfunction isScaleOptions(option) {\n  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);\n}\nfunction isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\nfunction isDomainSort(sort3) {\n  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;\n}\nfunction maybeZero(x4, x12, x22, x32 = identity6) {\n  if (x12 === void 0 && x22 === void 0) {\n    x12 = 0, x22 = x4 === void 0 ? x32 : x4;\n  } else if (x12 === void 0) {\n    x12 = x4 === void 0 ? 0 : x4;\n  } else if (x22 === void 0) {\n    x22 = x4 === void 0 ? 0 : x4;\n  }\n  return [x12, x22];\n}\nfunction maybeTuple(x4, y4) {\n  return x4 === void 0 && y4 === void 0 ? [first, second2] : [x4, y4];\n}\nfunction maybeZ({ z, fill, stroke } = {}) {\n  if (z === void 0)\n    [z] = maybeColorChannel(fill);\n  if (z === void 0)\n    [z] = maybeColorChannel(stroke);\n  return z;\n}\nfunction range4(data) {\n  const n = data.length;\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i)\n    r[i] = i;\n  return r;\n}\nfunction take(values2, index3) {\n  return map4(index3, (i) => values2[i]);\n}\nfunction keyof2(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\nfunction maybeInput(key, options) {\n  if (options[key] !== void 0)\n    return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\nfunction column(source) {\n  let value;\n  return [\n    {\n      transform: () => value,\n      label: labelof(source)\n    },\n    (v2) => value = v2\n  ];\n}\nfunction maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\nfunction labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== void 0 ? value.label : defaultValue;\n}\nfunction mid(x12, x22) {\n  return {\n    transform(data) {\n      const X13 = x12.transform(data);\n      const X23 = x22.transform(data);\n      return isTemporal(X13) || isTemporal(X23) ? map4(X13, (_, i) => new Date((+X13[i] + +X23[i]) / 2)) : map4(X13, (_, i) => (+X13[i] + +X23[i]) / 2, Float64Array);\n    },\n    label: x12.label\n  };\n}\nfunction maybeInterval(interval2, type2) {\n  if (interval2 == null)\n    return;\n  if (typeof interval2 === \"number\") {\n    const n = interval2;\n    return {\n      floor: (d) => n * Math.floor(d / n),\n      offset: (d) => d + n,\n      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x4) => n * x4)\n    };\n  }\n  if (typeof interval2 === \"string\")\n    return (type2 === \"time\" ? maybeTimeInterval : maybeUtcInterval)(interval2);\n  if (typeof interval2.floor !== \"function\")\n    throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval2.offset !== \"function\")\n    throw new Error(\"invalid interval; missing offset method\");\n  return interval2;\n}\nfunction maybeValue(value) {\n  return value === void 0 || isOptions(value) ? value : { value };\n}\nfunction numberChannel(source) {\n  return source == null ? null : {\n    transform: (data) => valueof(data, source, Float64Array),\n    label: labelof(source)\n  };\n}\nfunction isTuples(data) {\n  if (!isIterable(data))\n    return false;\n  for (const d of data) {\n    if (d == null)\n      continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\nfunction isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\nfunction isTextual(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\nfunction isOrdinal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    const type2 = typeof value;\n    return type2 === \"string\" || type2 === \"boolean\";\n  }\n}\nfunction isTemporal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return value instanceof Date;\n  }\n}\nfunction isTemporalString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"string\" && isNaN(value) && parse(value);\n  }\n}\nfunction isNumericString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (typeof value !== \"string\")\n      return false;\n    if (!value.trim())\n      continue;\n    return !isNaN(value);\n  }\n}\nfunction isNumeric(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"number\";\n  }\n}\nfunction isEvery(values2, is) {\n  let every2;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (!is(value))\n      return false;\n    every2 = true;\n  }\n  return every2;\n}\nfunction isColor(value) {\n  if (typeof value !== \"string\")\n    return false;\n  value = value.toLowerCase().trim();\n  return value === \"none\" || value === \"currentcolor\" || value.startsWith(\"url(\") && value.endsWith(\")\") || // <funciri>, e.g. pattern or gradient\n  value.startsWith(\"var(\") && value.endsWith(\")\") || // CSS variable\n  color(value) !== null;\n}\nfunction isNoneish(value) {\n  return value == null || isNone(value);\n}\nfunction isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\nfunction isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\nfunction maybeFrameAnchor(value = \"middle\") {\n  return keyword(value, \"frameAnchor\", [\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\"\n  ]);\n}\nfunction orderof(values2) {\n  if (values2 == null)\n    return;\n  const first2 = values2[0];\n  const last = values2[values2.length - 1];\n  return descending(first2, last);\n}\nfunction inherit2(options = {}, ...rest) {\n  let o = options;\n  for (const defaults21 of rest) {\n    for (const key in defaults21) {\n      if (o[key] === void 0) {\n        const value = defaults21[key];\n        if (o === options)\n          o = { ...o, [key]: value };\n        else\n          o[key] = value;\n      }\n    }\n  }\n  return o;\n}\nfunction Named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = /* @__PURE__ */ new Set();\n  return Object.fromEntries(Array.from(things, (thing) => {\n    const { name } = thing;\n    if (name == null)\n      throw new Error(\"missing name\");\n    const key = `${name}`;\n    if (key === \"__proto__\")\n      throw new Error(`illegal name: ${key}`);\n    if (names.has(key))\n      throw new Error(`duplicate name: ${key}`);\n    names.add(key);\n    return [name, thing];\n  }));\n}\nfunction maybeNamed(things) {\n  return isIterable(things) ? Named(things) : things;\n}\n\n// node_modules/@observablehq/plot/dist/scales/index.js\nvar position = Symbol(\"position\");\nvar color2 = Symbol(\"color\");\nvar radius = Symbol(\"radius\");\nvar length3 = Symbol(\"length\");\nvar opacity = Symbol(\"opacity\");\nvar symbol = Symbol(\"symbol\");\nvar registry = /* @__PURE__ */ new Map([\n  [\"x\", position],\n  [\"y\", position],\n  [\"fx\", position],\n  [\"fy\", position],\n  [\"r\", radius],\n  [\"color\", color2],\n  [\"opacity\", opacity],\n  [\"symbol\", symbol],\n  [\"length\", length3]\n]);\n\n// node_modules/@observablehq/plot/dist/symbols.js\nvar sqrt35 = Math.sqrt(3);\nvar sqrt4_3 = 2 / sqrt35;\nvar symbolHexagon = {\n  draw(context, size) {\n    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;\n    context.moveTo(0, ry);\n    context.lineTo(rx, hy);\n    context.lineTo(rx, -hy);\n    context.lineTo(0, -ry);\n    context.lineTo(-rx, -hy);\n    context.lineTo(-rx, hy);\n    context.closePath();\n  }\n};\nvar symbols = /* @__PURE__ */ new Map([\n  [\"asterisk\", asterisk_default],\n  [\"circle\", circle_default3],\n  [\"cross\", cross_default2],\n  [\"diamond\", diamond_default],\n  [\"diamond2\", diamond2_default],\n  [\"hexagon\", symbolHexagon],\n  [\"plus\", plus_default],\n  [\"square\", square_default],\n  [\"square2\", square2_default],\n  [\"star\", star_default],\n  [\"times\", times_default],\n  [\"triangle\", triangle_default],\n  [\"triangle2\", triangle2_default],\n  [\"wye\", wye_default]\n]);\nfunction isSymbolObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction isSymbol(value) {\n  if (isSymbolObject(value))\n    return true;\n  if (typeof value !== \"string\")\n    return false;\n  return symbols.has(value.toLowerCase());\n}\nfunction maybeSymbol(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return symbol2;\n  const value = symbols.get(`${symbol2}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid symbol: ${symbol2}`);\n}\nfunction maybeSymbolChannel(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return [void 0, symbol2];\n  if (typeof symbol2 === \"string\") {\n    const value = symbols.get(`${symbol2}`.toLowerCase());\n    if (value)\n      return [void 0, value];\n  }\n  return [symbol2, void 0];\n}\n\n// node_modules/@observablehq/plot/dist/defined.js\nfunction defined(x4) {\n  return x4 != null && !Number.isNaN(x4);\n}\nfunction ascendingDefined2(a4, b) {\n  return +defined(b) - +defined(a4) || ascending(a4, b);\n}\nfunction descendingDefined(a4, b) {\n  return +defined(b) - +defined(a4) || descending(a4, b);\n}\nfunction nonempty(x4) {\n  return x4 != null && `${x4}` !== \"\";\n}\nfunction finite2(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction positive(x4) {\n  return x4 > 0 && isFinite(x4) ? x4 : NaN;\n}\nfunction negative(x4) {\n  return x4 < 0 && isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/basic.js\nfunction basic(options = {}, transform2) {\n  let { filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...remainingOptions } = options;\n  if (t13 === void 0) {\n    if (f1 != null)\n      t13 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      t13 = composeTransform(t13, sortTransform(s1));\n    if (r1)\n      t13 = composeTransform(t13, reverseTransform);\n  }\n  if (transform2 != null && i1 != null)\n    throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    transform: composeTransform(t13, transform2)\n  };\n}\nfunction initializer(options = {}, initializer2) {\n  let { filter: f1, sort: s1, reverse: r1, initializer: i1, ...remainingOptions } = options;\n  if (i1 === void 0) {\n    if (f1 != null)\n      i1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1)\n      i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    initializer: composeInitializer(i1, initializer2)\n  };\n}\nfunction composeTransform(t13, t22) {\n  if (t13 == null)\n    return t22 === null ? void 0 : t22;\n  if (t22 == null)\n    return t13 === null ? void 0 : t13;\n  return function(data, facets) {\n    ({ data, facets } = t13.call(this, data, facets));\n    return t22.call(this, arrayify2(data), facets);\n  };\n}\nfunction composeInitializer(i1, i2) {\n  if (i1 == null)\n    return i2 === null ? void 0 : i2;\n  if (i2 == null)\n    return i1 === null ? void 0 : i1;\n  return function(data, facets, channels, ...args) {\n    let c1, d1, f1, c22, d2, f2;\n    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));\n    ({ data: d2 = d1, facets: f2 = f1, channels: c22 } = i2.call(this, d1, f1, { ...channels, ...c1 }, ...args));\n    return { data: d2, facets: f2, channels: { ...c1, ...c22 } };\n  };\n}\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\nfunction filter3(test, options) {\n  return apply(options, filterTransform(test));\n}\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = valueof(data, value);\n    return { data, facets: facets.map((I) => I.filter((i) => V[i])) };\n  };\n}\nfunction reverse2(options) {\n  return { ...apply(options, reverseTransform), sort: null };\n}\nfunction reverseTransform(data, facets) {\n  return { data, facets: facets.map((I) => I.slice().reverse()) };\n}\nfunction shuffle2(options = {}) {\n  const { seed, ...remainingOptions } = options;\n  return { ...apply(remainingOptions, sortValue(seed == null ? Math.random : lcg(seed))), sort: null };\n}\nfunction sort2(order, options) {\n  return {\n    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),\n    sort: null\n  };\n}\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = (i, j) => compare(data[i], data[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareData)) };\n  };\n}\nfunction sortValue(value) {\n  let channel, order;\n  ({ channel, value, order = ascendingDefined2 } = { ...maybeValue(value) });\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = ascendingDefined2;\n        break;\n      case \"descending\":\n        order = descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === void 0) {\n      V = valueof(data, value);\n    } else {\n      if (channels === void 0)\n        throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V)\n        return {};\n      V = V.value;\n    }\n    const compareValue2 = (i, j) => order(V[i], V[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareValue2)) };\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/group.js\nfunction groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\nfunction groupX(outputs = { y: \"count\" }, options = {}) {\n  const { x: x4 = identity6 } = options;\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  return groupn(x4, null, outputs, options);\n}\nfunction groupY(outputs = { x: \"count\" }, options = {}) {\n  const { y: y4 = identity6 } = options;\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(null, y4, outputs, options);\n}\nfunction group2(outputs = { fill: \"count\" }, options = {}) {\n  let { x: x4, y: y4 } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(x4, y4, outputs, options);\n}\nfunction groupn(x4, y4, {\n  data: reduceData = reduceIdentity,\n  filter: filter4,\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  const [GX, setGX] = maybeColumn(x4);\n  const [GY, setGY] = maybeColumn(y4);\n  const {\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const X3 = valueof(data, x4);\n      const Y3 = valueof(data, y4);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GX2 = X3 && setGX([]);\n      const GY2 = Y3 && setGY([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y5, gg] of maybeGroup(I, Y3)) {\n            for (const [x5, g] of maybeGroup(gg, X3)) {\n              if (filter4 && !filter4.reduce(g))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(g, data));\n              if (X3)\n                GX2.push(x5);\n              if (Y3)\n                GY2.push(y5);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[g[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[g[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[g[0]]);\n              for (const o of outputs)\n                o.reduce(g);\n              if (sort3)\n                sort3.reduce(g);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (GX ? { x: GX } : { x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (GY ? { y: GY } : { y1: y12, y2: y22 }),\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction hasOutput(outputs, ...names) {\n  for (const { name } of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction maybeOutputs(outputs, inputs) {\n  const entries = Object.entries(outputs);\n  if (inputs.title != null && outputs.title === void 0)\n    entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === void 0)\n    entries.push([\"href\", reduceFirst]);\n  return entries.filter(([, reduce2]) => reduce2 !== void 0).map(([name, reduce2]) => {\n    return reduce2 === null ? { name, initialize() {\n    }, scope() {\n    }, reduce() {\n    } } : maybeOutput(name, reduce2, inputs);\n  });\n}\nfunction maybeOutput(name, reduce2, inputs) {\n  const evaluator = maybeEvaluator(name, reduce2, inputs);\n  const [output, setOutput] = column(evaluator.label);\n  let O;\n  return {\n    name,\n    output,\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent3) {\n      O.push(evaluator.reduce(I, extent3));\n    }\n  };\n}\nfunction maybeEvaluator(name, reduce2, inputs) {\n  const input = maybeInput(name, inputs);\n  const reducer2 = maybeReduce(reduce2, input);\n  let V, context;\n  return {\n    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),\n    initialize(data) {\n      V = input === void 0 ? data : valueof(data, input);\n      if (reducer2.scope === \"data\") {\n        context = reducer2.reduce(range4(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer2.scope === scope) {\n        context = reducer2.reduce(I, V);\n      }\n    },\n    reduce(I, extent3) {\n      return reducer2.scope == null ? reducer2.reduce(I, V, extent3) : reducer2.reduce(I, V, context, extent3);\n    }\n  };\n}\nfunction maybeGroup(I, X3) {\n  return X3 ? sort(group(I, (i) => X3[i]), first) : [[, I]];\n}\nfunction maybeReduce(reduce2, value) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return reduce2;\n  if (typeof reduce2 === \"function\")\n    return reduceFunction(reduce2);\n  if (/^p\\d{2}$/i.test(reduce2))\n    return reduceAccessor(percentile(reduce2));\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(deviation);\n    case \"min\":\n      return reduceAccessor(min);\n    case \"min-index\":\n      return reduceAccessor(minIndex);\n    case \"max\":\n      return reduceAccessor(max);\n    case \"max-index\":\n      return reduceAccessor(maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(median);\n    case \"variance\":\n      return reduceAccessor(variance);\n    case \"mode\":\n      return reduceAccessor(mode);\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n  }\n  throw new Error(`invalid reduce: ${reduce2}`);\n}\nfunction maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== void 0 && !outputs.some((o) => o.name === name)) {\n      return value;\n    }\n  }\n}\nfunction maybeSort(facets, sort3, reverse3) {\n  if (sort3) {\n    const S = sort3.output.transform();\n    const compare = (i, j) => ascendingDefined2(S[i], S[j]);\n    facets.forEach((f) => f.sort(compare));\n  }\n  if (reverse3) {\n    facets.forEach((f) => f.reverse());\n  }\n}\nfunction reduceFunction(f) {\n  return {\n    reduce(I, X3, extent3) {\n      return f(take(X3, I), extent3);\n    }\n  };\n}\nfunction reduceAccessor(f) {\n  return {\n    reduce(I, X3) {\n      return f(I, (i) => X3[i]);\n    }\n  };\n}\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduce(I, X3) {\n      const x4 = f(I, (i) => X3[i]);\n      return isTemporal(X3) ? new Date(x4) : x4;\n    }\n  };\n}\nvar reduceIdentity = {\n  reduce(I, X3) {\n    return take(X3, I);\n  }\n};\nvar reduceFirst = {\n  reduce(I, X3) {\n    return X3[I[0]];\n  }\n};\nvar reduceTitle = {\n  reduce(I, X3) {\n    const n = 5;\n    const groups2 = sort(rollup(I, (V) => V.length, (i) => X3[i]), second2);\n    const top2 = groups2.slice(-n).reverse();\n    if (top2.length < groups2.length) {\n      const bottom2 = groups2.slice(0, 1 - n);\n      top2[n - 1] = [`\\u2026 ${bottom2.length.toLocaleString(\"en-US\")} more`, sum(bottom2, second2)];\n    }\n    return top2.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\nvar reduceLast = {\n  reduce(I, X3) {\n    return X3[I[I.length - 1]];\n  }\n};\nvar reduceCount = {\n  label: \"Frequency\",\n  reduce(I) {\n    return I.length;\n  }\n};\nvar reduceDistinct = {\n  label: \"Distinct\",\n  reduce: (I, X3) => {\n    const s2 = new InternSet();\n    for (const i of I)\n      s2.add(X3[i]);\n    return s2.size;\n  }\n};\nvar reduceSum = reduceAccessor(sum);\nfunction reduceProportion(value, scope) {\n  return value == null ? { scope, label: \"Frequency\", reduce: (I, V, basis2 = 1) => I.length / basis2 } : { scope, reduce: (I, V, basis2 = 1) => sum(I, (i) => V[i]) / basis2 };\n}\nfunction mid2(x12, x22) {\n  const m3 = (+x12 + +x22) / 2;\n  return x12 instanceof Date ? new Date(m3) : m3;\n}\nvar reduceX = {\n  reduce(I, X3, { x1: x12, x2: x22 }) {\n    return mid2(x12, x22);\n  }\n};\nvar reduceY = {\n  reduce(I, X3, { y1: y12, y2: y22 }) {\n    return mid2(y12, y22);\n  }\n};\nvar reduceX1 = {\n  reduce(I, X3, { x1: x12 }) {\n    return x12;\n  }\n};\nvar reduceX2 = {\n  reduce(I, X3, { x2: x22 }) {\n    return x22;\n  }\n};\nvar reduceY1 = {\n  reduce(I, X3, { y1: y12 }) {\n    return y12;\n  }\n};\nvar reduceY2 = {\n  reduce(I, X3, { y2: y22 }) {\n    return y22;\n  }\n};\n\n// node_modules/@observablehq/plot/dist/channel.js\nfunction Channel(data, { scale: scale3, type: type2, value, filter: filter4, hint }, name) {\n  return inferChannelScale(name, {\n    scale: scale3,\n    type: type2,\n    value: valueof(data, value),\n    label: labelof(value),\n    filter: filter4,\n    hint\n  });\n}\nfunction Channels(channels, data) {\n  return Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, Channel(data, channel, name)]));\n}\nfunction valueObject(channels, scales) {\n  return Object.fromEntries(Object.entries(channels).map(([name, { scale: scaleName, value }]) => {\n    const scale3 = scaleName == null ? null : scales[scaleName];\n    return [name, scale3 == null ? value : map4(value, scale3)];\n  }));\n}\nfunction inferChannelScale(name, channel) {\n  const { scale: scale3, value } = channel;\n  if (scale3 === true || scale3 === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = isEvery(value, isColor) ? null : \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n        channel.scale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (isEvery(value, isSymbol)) {\n          channel.scale = null;\n          channel.value = map4(value, maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        break;\n      default:\n        channel.scale = registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale3 != null && !registry.has(scale3)) {\n    throw new Error(`unknown scale: ${scale3}`);\n  }\n  return channel;\n}\nfunction channelDomain(channels, facetChannels, data, options) {\n  const { reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;\n  for (const x4 in options) {\n    if (!registry.has(x4))\n      continue;\n    let { value: y4, reverse: reverse3 = defaultReverse, reduce: reduce2 = defaultReduce, limit = defaultLimit } = maybeValue(options[x4]);\n    if (reverse3 === void 0)\n      reverse3 = y4 === \"width\" || y4 === \"height\";\n    if (reduce2 == null || reduce2 === false)\n      continue;\n    const X3 = findScaleChannel(channels, x4) || facetChannels && findScaleChannel(facetChannels, x4);\n    if (!X3)\n      throw new Error(`missing channel for scale: ${x4}`);\n    const XV = X3.value;\n    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y4 == null) {\n      X3.domain = () => {\n        let domain = XV;\n        if (reverse3)\n          domain = domain.slice().reverse();\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV = y4 === \"data\" ? data : y4 === \"height\" ? difference2(channels, \"y1\", \"y2\") : y4 === \"width\" ? difference2(channels, \"x1\", \"x2\") : values(channels, y4, y4 === \"y\" ? \"y2\" : y4 === \"x\" ? \"x2\" : void 0);\n      const reducer2 = maybeReduce(reduce2 === true ? \"max\" : reduce2, YV);\n      X3.domain = () => {\n        let domain = rollup(range4(XV), (I) => reducer2.reduce(I, YV), (i) => XV[i]);\n        domain = sort(domain, reverse3 ? descendingGroup : ascendingGroup);\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain.map(first);\n      };\n    }\n  }\n}\nfunction findScaleChannel(channels, scale3) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale3)\n      return channel;\n  }\n}\nfunction difference2(channels, k1, k2) {\n  const X13 = values(channels, k1);\n  const X23 = values(channels, k2);\n  return map4(X23, (x22, i) => Math.abs(x22 - X13[i]), Float64Array);\n}\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== void 0)\n    channel = channels[alias];\n  if (channel)\n    return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return ascending(av, bv) || ascending(ak, bk);\n}\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return descending(av, bv) || ascending(ak, bk);\n}\n\n// node_modules/@observablehq/plot/dist/scales/schemes.js\nvar ordinalSchemes = /* @__PURE__ */ new Map([\n  // categorical\n  [\"accent\", Accent_default],\n  [\"category10\", category10_default],\n  [\"dark2\", Dark2_default],\n  [\"paired\", Paired_default],\n  [\"pastel1\", Pastel1_default],\n  [\"pastel2\", Pastel2_default],\n  [\"set1\", Set1_default],\n  [\"set2\", Set2_default],\n  [\"set3\", Set3_default],\n  [\"tableau10\", Tableau10_default],\n  // diverging\n  [\"brbg\", scheme112(scheme, BrBG_default)],\n  [\"prgn\", scheme112(scheme2, PRGn_default)],\n  [\"piyg\", scheme112(scheme3, PiYG_default)],\n  [\"puor\", scheme112(scheme4, PuOr_default)],\n  [\"rdbu\", scheme112(scheme5, RdBu_default)],\n  [\"rdgy\", scheme112(scheme6, RdGy_default)],\n  [\"rdylbu\", scheme112(scheme7, RdYlBu_default)],\n  [\"rdylgn\", scheme112(scheme8, RdYlGn_default)],\n  [\"spectral\", scheme112(scheme9, Spectral_default)],\n  // reversed diverging (for temperature data)\n  [\"burd\", scheme11r(scheme5, RdBu_default)],\n  [\"buylrd\", scheme11r(scheme7, RdYlBu_default)],\n  // sequential (single-hue)\n  [\"blues\", scheme92(scheme22, Blues_default)],\n  [\"greens\", scheme92(scheme23, Greens_default)],\n  [\"greys\", scheme92(scheme24, Greys_default)],\n  [\"oranges\", scheme92(scheme27, Oranges_default)],\n  [\"purples\", scheme92(scheme25, Purples_default)],\n  [\"reds\", scheme92(scheme26, Reds_default)],\n  // sequential (multi-hue)\n  [\"turbo\", schemei(turbo_default)],\n  [\"viridis\", schemei(viridis_default)],\n  [\"magma\", schemei(magma)],\n  [\"inferno\", schemei(inferno)],\n  [\"plasma\", schemei(plasma)],\n  [\"cividis\", schemei(cividis_default)],\n  [\"cubehelix\", schemei(cubehelix_default2)],\n  [\"warm\", schemei(warm)],\n  [\"cool\", schemei(cool)],\n  [\"bugn\", scheme92(scheme10, BuGn_default)],\n  [\"bupu\", scheme92(scheme11, BuPu_default)],\n  [\"gnbu\", scheme92(scheme12, GnBu_default)],\n  [\"orrd\", scheme92(scheme13, OrRd_default)],\n  [\"pubu\", scheme92(scheme15, PuBu_default)],\n  [\"pubugn\", scheme92(scheme14, PuBuGn_default)],\n  [\"purd\", scheme92(scheme16, PuRd_default)],\n  [\"rdpu\", scheme92(scheme17, RdPu_default)],\n  [\"ylgn\", scheme92(scheme19, YlGn_default)],\n  [\"ylgnbu\", scheme92(scheme18, YlGnBu_default)],\n  [\"ylorbr\", scheme92(scheme20, YlOrBr_default)],\n  [\"ylorrd\", scheme92(scheme21, YlOrRd_default)],\n  // cyclical\n  [\"rainbow\", schemeicyclical(rainbow_default)],\n  [\"sinebow\", schemeicyclical(sinebow_default)]\n]);\nfunction scheme92(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 1)\n      return [scheme28[3][1]];\n    if (n === 2)\n      return [scheme28[3][1], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme112(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][0], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme11r(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][2], scheme28[3][0]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();\n  };\n}\nfunction schemei(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));\n}\nfunction schemeicyclical(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\nfunction ordinalScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!ordinalSchemes.has(s2))\n    throw new Error(`unknown ordinal scheme: ${s2}`);\n  return ordinalSchemes.get(s2);\n}\nfunction ordinalRange(scheme28, length4) {\n  const s2 = ordinalScheme(scheme28);\n  const r = typeof s2 === \"function\" ? s2({ length: length4 }) : s2;\n  return r.length !== length4 ? r.slice(0, length4) : r;\n}\nfunction maybeBooleanRange(domain, scheme28 = \"greys\") {\n  const range5 = /* @__PURE__ */ new Set();\n  const [f, t] = ordinalRange(scheme28, 2);\n  for (const value of domain) {\n    if (value == null)\n      continue;\n    if (value === true)\n      range5.add(t);\n    else if (value === false)\n      range5.add(f);\n    else\n      return;\n  }\n  return [...range5];\n}\nvar quantitativeSchemes = /* @__PURE__ */ new Map([\n  // diverging\n  [\"brbg\", BrBG_default],\n  [\"prgn\", PRGn_default],\n  [\"piyg\", PiYG_default],\n  [\"puor\", PuOr_default],\n  [\"rdbu\", RdBu_default],\n  [\"rdgy\", RdGy_default],\n  [\"rdylbu\", RdYlBu_default],\n  [\"rdylgn\", RdYlGn_default],\n  [\"spectral\", Spectral_default],\n  // reversed diverging (for temperature data)\n  [\"burd\", (t) => RdBu_default(1 - t)],\n  [\"buylrd\", (t) => RdYlBu_default(1 - t)],\n  // sequential (single-hue)\n  [\"blues\", Blues_default],\n  [\"greens\", Greens_default],\n  [\"greys\", Greys_default],\n  [\"purples\", Purples_default],\n  [\"reds\", Reds_default],\n  [\"oranges\", Oranges_default],\n  // sequential (multi-hue)\n  [\"turbo\", turbo_default],\n  [\"viridis\", viridis_default],\n  [\"magma\", magma],\n  [\"inferno\", inferno],\n  [\"plasma\", plasma],\n  [\"cividis\", cividis_default],\n  [\"cubehelix\", cubehelix_default2],\n  [\"warm\", warm],\n  [\"cool\", cool],\n  [\"bugn\", BuGn_default],\n  [\"bupu\", BuPu_default],\n  [\"gnbu\", GnBu_default],\n  [\"orrd\", OrRd_default],\n  [\"pubugn\", PuBuGn_default],\n  [\"pubu\", PuBu_default],\n  [\"purd\", PuRd_default],\n  [\"rdpu\", RdPu_default],\n  [\"ylgnbu\", YlGnBu_default],\n  [\"ylgn\", YlGn_default],\n  [\"ylorbr\", YlOrBr_default],\n  [\"ylorrd\", YlOrRd_default],\n  // cyclical\n  [\"rainbow\", rainbow_default],\n  [\"sinebow\", sinebow_default]\n]);\nfunction quantitativeScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!quantitativeSchemes.has(s2))\n    throw new Error(`unknown quantitative scheme: ${s2}`);\n  return quantitativeSchemes.get(s2);\n}\nvar divergingSchemes = /* @__PURE__ */ new Set([\n  \"brbg\",\n  \"prgn\",\n  \"piyg\",\n  \"puor\",\n  \"rdbu\",\n  \"rdgy\",\n  \"rdylbu\",\n  \"rdylgn\",\n  \"spectral\",\n  \"burd\",\n  \"buylrd\"\n]);\nfunction isDivergingScheme(scheme28) {\n  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());\n}\n\n// node_modules/@observablehq/plot/dist/scales/quantitative.js\nvar flip = (i) => (t) => i(1 - t);\nvar unit2 = [0, 1];\nvar interpolators = /* @__PURE__ */ new Map([\n  // numbers\n  [\"number\", number_default],\n  // color spaces\n  [\"rgb\", rgb_default],\n  [\"hsl\", hsl_default],\n  [\"hcl\", hcl_default],\n  [\"lab\", lab2]\n]);\nfunction Interpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i))\n    throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\nfunction ScaleQ(key, scale3, channels, { type: type2, nice: nice3, clamp, zero: zero3, domain = inferAutoDomain(key, channels), unknown, round: round2, scheme: scheme28, interval: interval2, range: range5 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === \"cyclical\" ? \"rainbow\" : \"turbo\") : round2 ? round_default : number_default, reverse: reverse3 }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (type2 === \"cyclical\" || type2 === \"sequential\")\n    type2 = \"linear\";\n  reverse3 = !!reverse3;\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (interpolate.length === 1) {\n    if (reverse3) {\n      interpolate = flip(interpolate);\n      reverse3 = false;\n    }\n    if (range5 === void 0) {\n      range5 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range5.length === 2)\n        range5 = unit2;\n    }\n    scale3.interpolate((range5 === unit2 ? constant2 : interpolatePiecewise)(interpolate));\n  } else {\n    scale3.interpolate(interpolate);\n  }\n  if (zero3) {\n    const [min4, max5] = extent(domain);\n    if (min4 > 0 || max5 < 0) {\n      domain = slice5(domain);\n      if (orderof(domain) !== Math.sign(min4))\n        domain[domain.length - 1] = 0;\n      else\n        domain[0] = 0;\n    }\n  }\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain).unknown(unknown);\n  if (nice3)\n    scale3.nice(nice3 === true ? void 0 : nice3), domain = scale3.domain();\n  if (range5 !== void 0)\n    scale3.range(range5);\n  if (clamp)\n    scale3.clamp(clamp);\n  return { type: type2, domain, range: range5, scale: scale3, interpolate, interval: interval2 };\n}\nfunction ScaleLinear(key, channels, options) {\n  return ScaleQ(key, linear3(), channels, options);\n}\nfunction ScaleSqrt(key, channels, options) {\n  return ScalePow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScalePow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleQ(key, pow3().exponent(exponent2), channels, { ...options, type: \"pow\" });\n}\nfunction ScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {\n  return ScaleQ(key, log2().base(base), channels, { ...options, domain });\n}\nfunction ScaleSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleQ(key, symlog().constant(constant3), channels, options);\n}\nfunction ScaleQuantile(key, channels, {\n  range: range5,\n  quantiles = range5 === void 0 ? 5 : (range5 = [...range5]).length,\n  // deprecated; use n instead\n  n = quantiles,\n  scheme: scheme28 = \"rdylbu\",\n  domain = inferQuantileDomain(channels),\n  interpolate,\n  reverse: reverse3\n}) {\n  if (range5 === void 0) {\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  }\n  if (domain.length > 0) {\n    domain = quantile2(domain, range5 === void 0 ? { length: n } : range5).quantiles();\n  }\n  return ScaleThreshold(key, channels, { domain, range: range5, reverse: reverse3 });\n}\nfunction ScaleQuantize(key, channels, { range: range5, n = range5 === void 0 ? 5 : (range5 = [...range5]).length, scheme: scheme28 = \"rdylbu\", domain = inferAutoDomain(key, channels), unknown, interpolate, reverse: reverse3 }) {\n  const [min4, max5] = extent(domain);\n  let thresholds;\n  if (range5 === void 0) {\n    thresholds = ticks(min4, max5, n);\n    if (thresholds[0] <= min4)\n      thresholds.splice(0, 1);\n    if (thresholds[thresholds.length - 1] >= max5)\n      thresholds.pop();\n    n = thresholds.length + 1;\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  } else {\n    thresholds = quantize_default(number_default(min4, max5), n + 1).slice(1, -1);\n    if (min4 instanceof Date)\n      thresholds = thresholds.map((x4) => new Date(x4));\n  }\n  if (orderof(arrayify2(domain)) < 0)\n    thresholds.reverse();\n  return ScaleThreshold(key, channels, { domain: thresholds, range: range5, reverse: reverse3, unknown });\n}\nfunction ScaleThreshold(key, channels, {\n  domain = [0],\n  // explicit thresholds in ascending order\n  unknown,\n  scheme: scheme28 = \"rdylbu\",\n  interpolate,\n  range: range5 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,\n  reverse: reverse3\n}) {\n  domain = arrayify2(domain);\n  const sign3 = orderof(domain);\n  if (!isOrdered(domain, sign3))\n    throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse3)\n    range5 = reverse(range5);\n  return {\n    type: \"threshold\",\n    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range5 === void 0 ? [] : range5).unknown(unknown),\n    domain,\n    range: range5\n  };\n}\nfunction isOrdered(domain, sign3) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s2 = descending(d, d = domain[i]);\n    if (s2 !== 0 && s2 !== sign3)\n      return false;\n  }\n  return true;\n}\nfunction ScaleIdentity() {\n  return { type: \"identity\", scale: identity4() };\n}\nfunction inferDomain(channels, f = finite2) {\n  return channels.length ? [\n    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),\n    max(channels, ({ value }) => value === void 0 ? value : max(value, f))\n  ] : [0, 1];\n}\nfunction inferAutoDomain(key, channels) {\n  const type2 = registry.get(key);\n  return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);\n}\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite2)) : 1];\n}\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);\n  if (hint !== void 0)\n    return [0, hint.radius];\n  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));\n  const range5 = domain.map((d) => 3 * Math.sqrt(d / h25));\n  const k2 = 30 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLengthRange(channels, domain) {\n  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));\n  const range5 = domain.map((d) => 12 * d / h50);\n  const k2 = 60 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLogDomain(channels) {\n  for (const { value } of channels) {\n    if (value !== void 0) {\n      for (let v2 of value) {\n        if (v2 > 0)\n          return inferDomain(channels, positive);\n        if (v2 < 0)\n          return inferDomain(channels, negative);\n      }\n    }\n  }\n  return [1, 10];\n}\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const { value } of channels) {\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      domain.push(v2);\n  }\n  return domain;\n}\nfunction interpolatePiecewise(interpolate) {\n  return (i, j) => (t) => interpolate(i + t * (j - i));\n}\n\n// node_modules/@observablehq/plot/dist/scales/diverging.js\nfunction ScaleD(key, scale3, transform2, channels, { type: type2, nice: nice3, clamp, domain = inferDomain(channels), unknown, pivot = 0, scheme: scheme28, range: range5, symmetric = true, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : \"rdbu\") : number_default, reverse: reverse3 }) {\n  pivot = +pivot;\n  let [min4, max5] = domain;\n  if (descending(min4, max5) < 0)\n    [min4, max5] = [max5, min4], reverse3 = !reverse3;\n  min4 = Math.min(min4, pivot);\n  max5 = Math.max(max5, pivot);\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (range5 !== void 0) {\n    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range5) : piecewise(interpolate, range5);\n  }\n  if (reverse3)\n    interpolate = flip(interpolate);\n  if (symmetric) {\n    const mid3 = transform2.apply(pivot);\n    const mindelta = mid3 - transform2.apply(min4);\n    const maxdelta = transform2.apply(max5) - mid3;\n    if (mindelta < maxdelta)\n      min4 = transform2.invert(mid3 - maxdelta);\n    else if (mindelta > maxdelta)\n      max5 = transform2.invert(mid3 + mindelta);\n  }\n  scale3.domain([min4, pivot, max5]).unknown(unknown).interpolator(interpolate);\n  if (clamp)\n    scale3.clamp(clamp);\n  if (nice3)\n    scale3.nice(nice3);\n  return { type: type2, domain: [min4, max5], pivot, interpolate, scale: scale3 };\n}\nfunction ScaleDiverging(key, channels, options) {\n  return ScaleD(key, diverging(), transformIdentity, channels, options);\n}\nfunction ScaleDivergingSqrt(key, channels, options) {\n  return ScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScaleDivergingPow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow2(exponent2), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\nfunction ScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {\n  return ScaleD(key, divergingLog().base(base = +base), transformLog2, channels, { domain, pivot, ...options });\n}\nfunction ScaleDivergingSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleD(key, divergingSymlog().constant(constant3 = +constant3), transformSymlog2(constant3), channels, options);\n}\nvar transformIdentity = {\n  apply(x4) {\n    return x4;\n  },\n  invert(x4) {\n    return x4;\n  }\n};\nvar transformLog2 = {\n  apply: Math.log,\n  invert: Math.exp\n};\nvar transformSqrt2 = {\n  apply(x4) {\n    return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n  },\n  invert(x4) {\n    return Math.sign(x4) * (x4 * x4);\n  }\n};\nfunction transformPow2(exponent2) {\n  return exponent2 === 0.5 ? transformSqrt2 : {\n    apply(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), exponent2);\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), 1 / exponent2);\n    }\n  };\n}\nfunction transformSymlog2(constant3) {\n  return {\n    apply(x4) {\n      return Math.sign(x4) * Math.log1p(Math.abs(x4 / constant3));\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.expm1(Math.abs(x4)) * constant3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/scales/temporal.js\nfunction ScaleT(key, scale3, channels, options) {\n  return ScaleQ(key, scale3, channels, options);\n}\nfunction ScaleTime(key, channels, options) {\n  return ScaleT(key, time(), channels, options);\n}\nfunction ScaleUtc(key, channels, options) {\n  return ScaleT(key, utcTime(), channels, options);\n}\n\n// node_modules/@observablehq/plot/dist/scales/ordinal.js\nvar ordinalImplicit = Symbol(\"ordinal\");\nfunction ScaleO(key, scale3, channels, { type: type2, interval: interval2, domain, range: range5, reverse: reverse3, hint }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  if (type2 === \"categorical\" || type2 === ordinalImplicit)\n    type2 = \"ordinal\";\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain);\n  if (range5 !== void 0) {\n    if (typeof range5 === \"function\")\n      range5 = range5(domain);\n    scale3.range(range5);\n  }\n  return { type: type2, domain, range: range5, scale: scale3, hint, interval: interval2 };\n}\nfunction ScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range5, scheme: scheme28, unknown, ...options }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  let hint;\n  if (registry.get(key) === symbol) {\n    hint = inferSymbolHint(channels);\n    range5 = range5 === void 0 ? inferSymbolRange(hint) : map4(range5, maybeSymbol);\n  } else if (registry.get(key) === color2) {\n    if (range5 === void 0 && (type2 === \"ordinal\" || type2 === ordinalImplicit)) {\n      range5 = maybeBooleanRange(domain, scheme28);\n      if (range5 !== void 0)\n        scheme28 = void 0;\n    }\n    if (scheme28 === void 0 && range5 === void 0) {\n      scheme28 = type2 === \"ordinal\" ? \"turbo\" : \"tableau10\";\n    }\n    if (scheme28 !== void 0) {\n      if (range5 !== void 0) {\n        const interpolate = quantitativeScheme(scheme28);\n        const t03 = range5[0], d = range5[1] - range5[0];\n        range5 = ({ length: n }) => quantize_default((t) => interpolate(t03 + d * t), n);\n      } else {\n        range5 = ordinalScheme(scheme28);\n      }\n    }\n  }\n  if (unknown === implicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return ScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range5, hint });\n}\nfunction ScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {\n  return maybeRound(point().align(align).padding(padding), channels, options, key);\n}\nfunction ScaleBand(key, channels, { align = 0.5, padding = 0.1, paddingInner = padding, paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding, ...options }) {\n  return maybeRound(band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter), channels, options, key);\n}\nfunction maybeRound(scale3, channels, options, key) {\n  let { round: round2 } = options;\n  if (round2 !== void 0)\n    scale3.round(round2 = !!round2);\n  scale3 = ScaleO(key, scale3, channels, options);\n  scale3.round = round2;\n  return scale3;\n}\nfunction inferDomain2(channels, interval2, key) {\n  const values2 = new InternSet();\n  for (const { value, domain } of channels) {\n    if (domain !== void 0)\n      return domain();\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      values2.add(v2);\n  }\n  if (interval2 !== void 0) {\n    const [min4, max5] = extent(values2).map(interval2.floor, interval2);\n    return interval2.range(min4, interval2.offset(max5));\n  }\n  if (values2.size > 1e4 && registry.get(key) === position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return sort(values2, ascendingDefined2);\n}\nfunction inferHint(channels, key) {\n  let value;\n  for (const { hint } of channels) {\n    const candidate = hint?.[key];\n    if (candidate === void 0)\n      continue;\n    if (value === void 0)\n      value = candidate;\n    else if (value !== candidate)\n      return;\n  }\n  return value;\n}\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\nfunction inferSymbolRange(hint) {\n  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;\n}\n\n// node_modules/@observablehq/plot/dist/warnings.js\nvar warnings = 0;\nfunction consumeWarnings() {\n  const w = warnings;\n  warnings = 0;\n  return w;\n}\nfunction warn(message) {\n  console.warn(message);\n  ++warnings;\n}\n\n// node_modules/@observablehq/plot/dist/scales.js\nfunction Scales(channelsByScale, { label: globalLabel, inset: globalInset = 0, insetTop: globalInsetTop = globalInset, insetRight: globalInsetRight = globalInset, insetBottom: globalInsetBottom = globalInset, insetLeft: globalInsetLeft = globalInset, round: round2, nice: nice3, clamp, zero: zero3, align, padding, projection: projection2, facet: { label: facetLabel = globalLabel } = {}, ...options } = {}) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale3 = Scale(key, channels, {\n      round: registry.get(key) === position ? round2 : void 0,\n      nice: nice3,\n      clamp,\n      zero: zero3,\n      align,\n      padding,\n      projection: projection2,\n      ...scaleOptions\n    });\n    if (scale3) {\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform: transform2,\n        inset,\n        insetTop = inset !== void 0 ? inset : key === \"y\" ? globalInsetTop : 0,\n        // not fy\n        insetRight = inset !== void 0 ? inset : key === \"x\" ? globalInsetRight : 0,\n        // not fx\n        insetBottom = inset !== void 0 ? inset : key === \"y\" ? globalInsetBottom : 0,\n        // not fy\n        insetLeft = inset !== void 0 ? inset : key === \"x\" ? globalInsetLeft : 0\n        // not fx\n      } = scaleOptions || {};\n      if (transform2 == null)\n        transform2 = void 0;\n      else if (typeof transform2 !== \"function\")\n        throw new Error(\"invalid scale transform; not a function\");\n      scale3.percent = !!percent;\n      scale3.label = label === void 0 ? inferScaleLabel(channels, scale3) : label;\n      scale3.transform = transform2;\n      if (key === \"x\" || key === \"fx\") {\n        scale3.insetLeft = +insetLeft;\n        scale3.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale3.insetTop = +insetTop;\n        scale3.insetBottom = +insetBottom;\n      }\n      scales[key] = scale3;\n    }\n  }\n  return scales;\n}\nfunction ScaleFunctions(scales) {\n  return Object.fromEntries(Object.entries(scales).filter(([, { scale: scale3 }]) => scale3).map(([name, { scale: scale3, type: type2, interval: interval2, label }]) => {\n    scale3.type = type2;\n    if (interval2 != null)\n      scale3.interval = interval2;\n    if (label != null)\n      scale3.label = label;\n    return [name, scale3];\n  }));\n}\nfunction autoScaleRange(scales, dimensions) {\n  const { x: x4, y: y4, fx, fy } = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx)\n    autoScaleRangeX(fx, superdimensions);\n  if (fy)\n    autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x4)\n    autoScaleRangeX(x4, subdimensions);\n  if (y4)\n    autoScaleRangeY(y4, subdimensions);\n}\nfunction inferScaleLabel(channels = [], scale3) {\n  let label;\n  for (const { label: l } of channels) {\n    if (l === void 0)\n      continue;\n    if (label === void 0)\n      label = l;\n    else if (label !== l)\n      return;\n  }\n  if (label === void 0)\n    return;\n  if (isTemporalScale(scale3) && /^(date|time|year)$/i.test(label))\n    return;\n  if (!isOrdinalScale(scale3) && scale3.percent)\n    label = `${label} (%)`;\n  return { inferred: true, toString: () => label };\n}\nfunction outerDimensions(dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height, facet: { marginTop: facetMarginTop, marginRight: facetMarginRight, marginBottom: facetMarginBottom, marginLeft: facetMarginLeft } } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\nfunction innerDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height\n  };\n}\nfunction autoScaleRangeX(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetLeft, insetRight } = scale3;\n    const { width, marginLeft = 0, marginRight = 0 } = dimensions;\n    const left2 = marginLeft + insetLeft;\n    const right2 = width - marginRight - insetRight;\n    scale3.range = [left2, Math.max(left2, right2)];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRangeY(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetTop, insetBottom } = scale3;\n    const { height, marginTop = 0, marginBottom = 0 } = dimensions;\n    const top2 = marginTop + insetTop;\n    const bottom2 = height - marginBottom - insetBottom;\n    scale3.range = [Math.max(top2, bottom2), top2];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    else\n      scale3.range.reverse();\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRound(scale3) {\n  if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {\n    scale3.scale.round(true);\n  }\n}\nfunction roundError({ scale: scale3 }) {\n  const n = scale3.domain().length;\n  const [start2, stop] = scale3.range();\n  const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;\n  const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();\n  const m3 = n - paddingInner;\n  const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);\n  return (step - Math.floor(step)) * m3;\n}\nfunction piecewiseRange(scale3) {\n  const length4 = scale3.scale.domain().length + isThresholdScale(scale3);\n  if (!(length4 > 2))\n    return scale3.range;\n  const [start2, end] = scale3.range;\n  return Array.from({ length: length4 }, (_, i) => start2 + i / (length4 - 1) * (end - start2));\n}\nfunction normalizeScale(key, scale3, hint) {\n  return Scale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale3 });\n}\nfunction Scale(key, channels = [], options = {}) {\n  const type2 = inferScaleType(key, channels, options);\n  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== \"fx\" && key !== \"fy\" && isOrdinalScale({ type: type2 })) {\n    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n    if (values2.some(isTemporal))\n      warn(`Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isTemporalString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isNumericString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(type2)}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n  }\n  options.type = type2;\n  switch (type2) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, coerceNumbers);\n      break;\n    case \"identity\":\n      switch (registry.get(key)) {\n        case position:\n          options = coerceType(channels, options, coerceNumbers);\n          break;\n        case symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, coerceDates);\n      break;\n  }\n  switch (type2) {\n    case \"diverging\":\n      return ScaleDiverging(key, channels, options);\n    case \"diverging-sqrt\":\n      return ScaleDivergingSqrt(key, channels, options);\n    case \"diverging-pow\":\n      return ScaleDivergingPow(key, channels, options);\n    case \"diverging-log\":\n      return ScaleDivergingLog(key, channels, options);\n    case \"diverging-symlog\":\n      return ScaleDivergingSymlog(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case ordinalImplicit:\n      return ScaleOrdinal(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return ScaleLinear(key, channels, options);\n    case \"sqrt\":\n      return ScaleSqrt(key, channels, options);\n    case \"threshold\":\n      return ScaleThreshold(key, channels, options);\n    case \"quantile\":\n      return ScaleQuantile(key, channels, options);\n    case \"quantize\":\n      return ScaleQuantize(key, channels, options);\n    case \"pow\":\n      return ScalePow(key, channels, options);\n    case \"log\":\n      return ScaleLog(key, channels, options);\n    case \"symlog\":\n      return ScaleSymlog(key, channels, options);\n    case \"utc\":\n      return ScaleUtc(key, channels, options);\n    case \"time\":\n      return ScaleTime(key, channels, options);\n    case \"point\":\n      return ScalePoint(key, channels, options);\n    case \"band\":\n      return ScaleBand(key, channels, options);\n    case \"identity\":\n      return registry.get(key) === position ? ScaleIdentity() : { type: \"identity\" };\n    case void 0:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type2}`);\n  }\n}\nfunction formatScaleType(type2) {\n  return typeof type2 === \"symbol\" ? type2.description : type2;\n}\nvar typeProjection = { toString: () => \"projection\" };\nfunction inferScaleType(key, channels, { type: type2, domain, range: range5, scheme: scheme28, pivot, projection: projection2 }) {\n  if (key === \"fx\" || key === \"fy\")\n    return \"band\";\n  if ((key === \"x\" || key === \"y\") && projection2 != null)\n    type2 = typeProjection;\n  for (const { type: t } of channels) {\n    if (t === void 0)\n      continue;\n    else if (type2 === void 0)\n      type2 = t;\n    else if (type2 !== t)\n      throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);\n  }\n  if (type2 === typeProjection)\n    return;\n  if (type2 !== void 0)\n    return type2;\n  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))\n    return;\n  const kind = registry.get(key);\n  if (kind === radius)\n    return \"sqrt\";\n  if (kind === opacity || kind === length3)\n    return \"linear\";\n  if (kind === symbol)\n    return \"ordinal\";\n  if ((domain || range5 || []).length > 2)\n    return asOrdinalType(kind);\n  if (domain !== void 0) {\n    if (isOrdinal(domain))\n      return asOrdinalType(kind);\n    if (isTemporal(domain))\n      return \"utc\";\n    if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n      return \"diverging\";\n    return \"linear\";\n  }\n  const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n  if (values2.some(isOrdinal))\n    return asOrdinalType(kind);\n  if (values2.some(isTemporal))\n    return \"utc\";\n  if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n    return \"diverging\";\n  return \"linear\";\n}\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case position:\n      return \"point\";\n    case color2:\n      return ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\nfunction isTemporalScale({ type: type2 }) {\n  return type2 === \"time\" || type2 === \"utc\";\n}\nfunction isOrdinalScale({ type: type2 }) {\n  return type2 === \"ordinal\" || type2 === \"point\" || type2 === \"band\" || type2 === ordinalImplicit;\n}\nfunction isThresholdScale({ type: type2 }) {\n  return type2 === \"threshold\";\n}\nfunction isBandScale({ type: type2 }) {\n  return type2 === \"point\" || type2 === \"band\";\n}\nfunction isCollapsed(scale3) {\n  if (scale3 === void 0)\n    return true;\n  const domain = scale3.domain();\n  const value = scale3(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale3(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction coerceType(channels, { domain, ...options }, coerceValues) {\n  for (const c6 of channels) {\n    if (c6.value !== void 0) {\n      c6.value = coerceValues(c6.value);\n    }\n  }\n  return {\n    domain: domain === void 0 ? domain : coerceValues(domain),\n    ...options\n  };\n}\nfunction coerceSymbols(values2) {\n  return map4(values2, maybeSymbol);\n}\nfunction coerceDates(values2) {\n  return map4(values2, coerceDate);\n}\nfunction coerceNumbers(values2) {\n  return isTypedArray(values2) ? values2 : map4(values2, coerceNumber, Float64Array);\n}\nfunction coerceNumber(x4) {\n  return x4 == null ? NaN : Number(x4);\n}\nfunction coerceDate(x4) {\n  return x4 instanceof Date && !isNaN(x4) ? x4 : typeof x4 === \"string\" ? parse(x4) : x4 == null || isNaN(x4 = +x4) ? void 0 : new Date(x4);\n}\nfunction scale2(options = {}) {\n  let scale3;\n  for (const key in options) {\n    if (!registry.has(key))\n      continue;\n    if (!isScaleOptions(options[key]))\n      continue;\n    if (scale3 !== void 0)\n      throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale3 = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale3 === void 0)\n    throw new Error(\"invalid scale definition; no scale found\");\n  return scale3;\n}\nfunction exposeScales(scaleDescriptors) {\n  return (key) => {\n    if (!registry.has(key = `${key}`))\n      throw new Error(`unknown scale: ${key}`);\n    return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;\n  };\n}\nfunction exposeScale({ scale: scale3, type: type2, domain, range: range5, interpolate, interval: interval2, transform: transform2, percent, pivot }) {\n  if (type2 === \"identity\")\n    return { type: \"identity\", apply: (d) => d, invert: (d) => d };\n  const unknown = scale3.unknown ? scale3.unknown() : void 0;\n  return {\n    type: type2,\n    domain: slice5(domain),\n    ...range5 !== void 0 && { range: slice5(range5) },\n    ...transform2 !== void 0 && { transform: transform2 },\n    ...percent && { percent },\n    ...unknown !== void 0 && { unknown },\n    ...interval2 !== void 0 && { interval: interval2 },\n    // quantitative\n    ...interpolate !== void 0 && { interpolate },\n    ...scale3.clamp && { clamp: scale3.clamp() },\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...pivot !== void 0 && { pivot, symmetric: false },\n    // log, diverging-log\n    ...scale3.base && { base: scale3.base() },\n    // pow, diverging-pow\n    ...scale3.exponent && { exponent: scale3.exponent() },\n    // symlog, diverging-symlog\n    ...scale3.constant && { constant: scale3.constant() },\n    // band, point\n    ...scale3.align && { align: scale3.align(), round: scale3.round() },\n    ...scale3.padding && (scale3.paddingInner ? { paddingInner: scale3.paddingInner(), paddingOuter: scale3.paddingOuter() } : { padding: scale3.padding() }),\n    ...scale3.bandwidth && { bandwidth: scale3.bandwidth(), step: scale3.step() },\n    // utilities\n    apply: (t) => scale3(t),\n    ...scale3.invert && { invert: (t) => scale3.invert(t) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/projection.js\nvar pi6 = Math.PI;\nvar tau7 = 2 * pi6;\nvar defaultAspectRatio = 0.618;\nfunction Projection({ projection: projection2, inset: globalInset = 0, insetTop = globalInset, insetRight = globalInset, insetBottom = globalInset, insetLeft = globalInset } = {}, dimensions) {\n  if (projection2 == null)\n    return;\n  if (typeof projection2.stream === \"function\")\n    return projection2;\n  let options;\n  let domain;\n  let clip = \"frame\";\n  if (isObject(projection2)) {\n    let inset;\n    ({\n      type: projection2,\n      domain,\n      inset,\n      insetTop = inset !== void 0 ? inset : insetTop,\n      insetRight = inset !== void 0 ? inset : insetRight,\n      insetBottom = inset !== void 0 ? inset : insetBottom,\n      insetLeft = inset !== void 0 ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection2);\n    if (projection2 == null)\n      return;\n  }\n  if (typeof projection2 !== \"function\")\n    ({ type: projection2 } = namedProjection(projection2));\n  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection2 = projection2?.({ width: dx, height: dy, clip, ...options });\n  if (projection2 == null)\n    return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform2;\n  if (domain != null) {\n    const [[x06, y06], [x12, y12]] = path_default(projection2).bounds(domain);\n    const k2 = Math.min(dx / (x12 - x06), dy / (y12 - y06));\n    if (k2 > 0) {\n      tx -= (k2 * (x06 + x12) - dx) / 2;\n      ty -= (k2 * (y06 + y12) - dy) / 2;\n      transform2 = transform_default({\n        point(x4, y4) {\n          this.stream.point(x4 * k2 + tx, y4 * k2 + ty);\n        }\n      });\n    } else {\n      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n  transform2 ??= tx === 0 && ty === 0 ? identity7() : transform_default({\n    point(x4, y4) {\n      this.stream.point(x4 + tx, y4 + ty);\n    }\n  });\n  return { stream: (s2) => projection2.stream(transform2.stream(clip(s2))) };\n}\nfunction namedProjection(projection2) {\n  switch (`${projection2}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(albersUsa_default, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection2(albers_default, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(azimuthalEqualArea_default, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(azimuthalEquidistant_default, tau7, tau7);\n    case \"conic-conformal\":\n      return conicProjection2(conicConformal_default, tau7, tau7);\n    case \"conic-equal-area\":\n      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(equalEarth_default, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(equirectangular_default, tau7, pi6);\n    case \"gnomonic\":\n      return scaleProjection(gnomonic_default, 3.4641, 3.4641);\n    case \"identity\":\n      return { type: identity7 };\n    case \"reflect-y\":\n      return { type: reflectY };\n    case \"mercator\":\n      return scaleProjection(mercator_default, tau7, tau7);\n    case \"orthographic\":\n      return scaleProjection(orthographic_default, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(stereographic_default, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(transverseMercator_default, tau7, tau7);\n    default:\n      throw new Error(`unknown projection type: ${projection2}`);\n  }\n}\nfunction maybePostClip(clip, x12, y12, x22, y22) {\n  if (clip === false || clip == null || typeof clip === \"number\")\n    return (s2) => s2;\n  if (clip === true)\n    clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return clipRectangle(x12, y12, x22, y22);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\nfunction scaleProjection(createProjection, kx2, ky2) {\n  return {\n    type: ({ width, height, rotate, precision = 0.15, clip }) => {\n      const projection2 = createProjection();\n      if (precision != null)\n        projection2.precision?.(precision);\n      if (rotate != null)\n        projection2.rotate?.(rotate);\n      if (typeof clip === \"number\")\n        projection2.clipAngle?.(clip);\n      projection2.scale(Math.min(width / kx2, height / ky2));\n      projection2.translate([width / 2, height / 2]);\n      return projection2;\n    },\n    aspectRatio: ky2 / kx2\n  };\n}\nfunction conicProjection2(createProjection, kx2, ky2) {\n  const { type: type2, aspectRatio } = scaleProjection(createProjection, kx2, ky2);\n  return {\n    type: (options) => {\n      const { parallels, domain, width, height } = options;\n      const projection2 = type2(options);\n      if (parallels != null) {\n        projection2.parallels(parallels);\n        if (domain === void 0) {\n          projection2.fitSize([width, height], { type: \"Sphere\" });\n        }\n      }\n      return projection2;\n    },\n    aspectRatio\n  };\n}\nvar identity7 = constant2({ stream: (stream) => stream });\nvar reflectY = constant2(transform_default({\n  point(x4, y4) {\n    this.stream.point(x4, -y4);\n  }\n}));\nfunction maybeProject(cx, cy, channels, values2, context) {\n  const x4 = channels[cx] && channels[cx].scale === \"x\";\n  const y4 = channels[cy] && channels[cy].scale === \"y\";\n  if (x4 && y4) {\n    project(cx, cy, values2, context.projection);\n  } else if (x4) {\n    throw new Error(`projection requires paired x and y channels; ${cx} is missing ${cy}`);\n  } else if (y4) {\n    throw new Error(`projection requires paired x and y channels; ${cy} is missing ${cx}`);\n  }\n}\nfunction project(cx, cy, values2, projection2) {\n  const x4 = values2[cx];\n  const y4 = values2[cy];\n  const n = x4.length;\n  const X3 = values2[cx] = new Float64Array(n).fill(NaN);\n  const Y3 = values2[cy] = new Float64Array(n).fill(NaN);\n  let i;\n  const stream = projection2.stream({\n    point(x5, y5) {\n      X3[i] = x5;\n      Y3[i] = y5;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x4[i], y4[i]);\n  }\n}\nfunction projectionAspectRatio(projection2, marks2) {\n  if (typeof projection2?.stream === \"function\")\n    return defaultAspectRatio;\n  if (isObject(projection2))\n    projection2 = projection2.type;\n  if (projection2 == null)\n    return hasGeometry(marks2) ? defaultAspectRatio : void 0;\n  if (typeof projection2 !== \"function\") {\n    const { aspectRatio } = namedProjection(projection2);\n    if (aspectRatio)\n      return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\nfunction Position(channels, scales, context) {\n  const { x: x4, y: y4 } = channels;\n  let position2 = {};\n  if (x4)\n    position2.x = x4;\n  if (y4)\n    position2.y = y4;\n  position2 = valueObject(position2, scales);\n  if (context.projection)\n    maybeProject(\"x\", \"y\", channels, position2, context);\n  if (x4)\n    position2.x = coerceNumbers(position2.x);\n  if (y4)\n    position2.y = coerceNumbers(position2.y);\n  return position2;\n}\nfunction hasGeometry(marks2) {\n  for (const mark of marks2)\n    if (mark.channels.geometry)\n      return true;\n  return false;\n}\n\n// node_modules/@observablehq/plot/dist/context.js\nfunction Context(options = {}, dimensions) {\n  const { document: document2 = typeof window !== \"undefined\" ? window.document : void 0 } = options;\n  return { document: document2, projection: Projection(options, dimensions) };\n}\nfunction create2(name, { document: document2 }) {\n  return select_default2(creator_default(name).call(document2.documentElement));\n}\n\n// node_modules/@observablehq/plot/dist/memoize.js\nfunction memoize1(compute) {\n  let cacheValue, cacheKeys;\n  return (...keys) => {\n    if (cacheKeys?.length !== keys.length || cacheKeys.some((k2, i) => k2 !== keys[i])) {\n      cacheKeys = keys;\n      cacheValue = compute(...keys);\n    }\n    return cacheValue;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/format.js\nvar numberFormat = memoize1((locale3) => new Intl.NumberFormat(locale3));\nvar monthFormat = memoize1((locale3, month) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...month && { month } }));\nvar weekdayFormat = memoize1((locale3, weekday) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...weekday && { weekday } }));\nfunction formatNumber(locale3 = \"en-US\") {\n  const format3 = numberFormat(locale3);\n  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;\n}\nfunction formatMonth(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = monthFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatWeekday(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = weekdayFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatIsoDate(date2) {\n  return format2(date2, \"Invalid Date\");\n}\nfunction formatAuto(locale3 = \"en-US\") {\n  const number7 = formatNumber(locale3);\n  return (v2) => (v2 instanceof Date ? formatIsoDate : typeof v2 === \"number\" ? number7 : string)(v2);\n}\nvar formatDefault = formatAuto();\n\n// node_modules/@observablehq/plot/dist/style.js\nvar offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5;\nvar nextClipId = 0;\nfunction getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\nfunction styles(mark, { title, href, ariaLabel: variaLabel, ariaDescription, ariaHidden, target, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, opacity: opacity2, mixBlendMode, paintOrder, pointerEvents, shapeRendering }, { ariaLabel: cariaLabel, fill: defaultFill = \"currentColor\", fillOpacity: defaultFillOpacity, stroke: defaultStroke = \"none\", strokeOpacity: defaultStrokeOpacity, strokeWidth: defaultStrokeWidth, strokeLinecap: defaultStrokeLinecap, strokeLinejoin: defaultStrokeLinejoin, strokeMiterlimit: defaultStrokeMiterlimit, paintOrder: defaultPaintOrder }) {\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n  if (isNoneish(defaultFill)) {\n    if (!isNoneish(defaultStroke) && !isNoneish(fill))\n      defaultStroke = \"none\";\n  } else {\n    if (isNoneish(defaultStroke) && !isNoneish(stroke))\n      defaultFill = \"none\";\n  }\n  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = maybeNumberChannel(opacity2);\n  if (!isNone(cstroke)) {\n    if (strokeWidth === void 0)\n      strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === void 0)\n      strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === void 0)\n      strokeLinejoin = defaultStrokeLinejoin;\n    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))\n      strokeMiterlimit = defaultStrokeMiterlimit;\n    if (!isNone(cfill) && paintOrder === void 0)\n      paintOrder = defaultPaintOrder;\n  }\n  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n  mark.target = string(target);\n  mark.ariaLabel = string(cariaLabel);\n  mark.ariaDescription = string(ariaDescription);\n  mark.ariaHidden = string(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n  return {\n    title: { value: title, optional: true },\n    href: { value: href, optional: true },\n    ariaLabel: { value: variaLabel, optional: true },\n    fill: { value: vfill, scale: \"auto\", optional: true },\n    fillOpacity: { value: vfillOpacity, scale: \"opacity\", optional: true },\n    stroke: { value: vstroke, scale: \"auto\", optional: true },\n    strokeOpacity: { value: vstrokeOpacity, scale: \"opacity\", optional: true },\n    strokeWidth: { value: vstrokeWidth, optional: true },\n    opacity: { value: vopacity, scale: \"opacity\", optional: true }\n  };\n}\nfunction applyTitle(selection2, L) {\n  if (L)\n    selection2.filter((i) => nonempty(L[i])).append(\"title\").call(applyText, L);\n}\nfunction applyTitleGroup(selection2, L) {\n  if (L)\n    selection2.filter(([i]) => nonempty(L[i])).append(\"title\").call(applyTextGroup, L);\n}\nfunction applyText(selection2, T) {\n  if (T)\n    selection2.text((i) => formatDefault(T[i]));\n}\nfunction applyTextGroup(selection2, T) {\n  if (T)\n    selection2.text(([i]) => formatDefault(T[i]));\n}\nfunction applyChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", (i) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", (i) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", (i) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", (i) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", (i) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", (i) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", (i) => O[i]);\n  if (H)\n    applyHref(selection2, (i) => H[i], target);\n  applyTitle(selection2, T);\n}\nfunction applyGroupedChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", ([i]) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", ([i]) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", ([i]) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", ([i]) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", ([i]) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", ([i]) => O[i]);\n  if (H)\n    applyHref(selection2, ([i]) => H[i], target);\n  applyTitleGroup(selection2, T);\n}\nfunction groupAesthetics({ ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  return [AL, T, F, FO, S, SO, SW, O, H].filter((c6) => c6 !== void 0);\n}\nfunction groupZ2(I, Z, z) {\n  const G = group(I, (i) => Z[i]);\n  if (z === void 0 && G.size > I.length >> 1) {\n    warn(`Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`);\n  }\n  return G.values();\n}\nfunction* groupIndex(I, position2, { z }, channels) {\n  const { z: Z } = channels;\n  const A5 = groupAesthetics(channels);\n  const C3 = [...position2, ...A5];\n  for (const G of Z ? groupZ2(I, Z, z) : [I]) {\n    let Ag;\n    let Gg;\n    out:\n      for (const i of G) {\n        for (const c6 of C3) {\n          if (!defined(c6[i])) {\n            if (Gg)\n              Gg.push(-1);\n            continue out;\n          }\n        }\n        if (Ag === void 0) {\n          if (Gg)\n            yield Gg;\n          Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n          continue;\n        }\n        Gg.push(i);\n        for (let j = 0; j < A5.length; ++j) {\n          const k2 = keyof2(A5[j][i]);\n          if (k2 !== Ag[j]) {\n            yield Gg;\n            Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n            continue out;\n          }\n        }\n      }\n    if (Gg)\n      yield Gg;\n  }\n}\nfunction maybeClip(clip) {\n  if (clip === true)\n    clip = \"frame\";\n  else if (clip === false)\n    clip = null;\n  return maybeKeyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n}\nfunction applyClip(selection2, mark, dimensions, context) {\n  let clipUrl;\n  switch (mark.clip) {\n    case \"frame\": {\n      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2 = create2(\"svg:g\", context).call((g) => g.append(\"svg:clipPath\").attr(\"id\", id2).append(\"rect\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginRight - marginLeft).attr(\"height\", height - marginTop - marginBottom)).each(function() {\n        this.appendChild(selection2.node());\n        selection2.node = () => this;\n      });\n      break;\n    }\n    case \"sphere\": {\n      const { projection: projection2 } = context;\n      if (!projection2)\n        throw new Error(`the \"sphere\" clip option requires a projection`);\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2.append(\"clipPath\").attr(\"id\", id2).append(\"path\").attr(\"d\", path_default(projection2)({ type: \"Sphere\" }));\n      break;\n    }\n  }\n  applyAttr(selection2, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection2, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection2, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection2, \"clip-path\", clipUrl);\n}\nfunction applyIndirectStyles(selection2, mark, dimensions, context) {\n  applyClip(selection2, mark, dimensions, context);\n  applyAttr(selection2, \"fill\", mark.fill);\n  applyAttr(selection2, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection2, \"stroke\", mark.stroke);\n  applyAttr(selection2, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection2, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection2, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection2, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection2, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection2, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection2, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection2, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection2, \"paint-order\", mark.paintOrder);\n  applyAttr(selection2, \"pointer-events\", mark.pointerEvents);\n}\nfunction applyDirectStyles(selection2, mark) {\n  applyStyle(selection2, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection2, \"opacity\", mark.opacity);\n}\nfunction applyHref(selection2, href, target) {\n  selection2.each(function(i) {\n    const h = href(i);\n    if (h != null) {\n      const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, \"a\");\n      a4.setAttribute(\"fill\", \"inherit\");\n      a4.setAttributeNS(namespaces_default.xlink, \"href\", h);\n      if (target != null)\n        a4.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a4, this).appendChild(this);\n    }\n  });\n}\nfunction applyAttr(selection2, name, value) {\n  if (value != null)\n    selection2.attr(name, value);\n}\nfunction applyStyle(selection2, name, value) {\n  if (value != null)\n    selection2.style(name, value);\n}\nfunction applyTransform(selection2, mark, { x: x4, y: y4 }, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x4?.bandwidth)\n    tx += x4.bandwidth() / 2;\n  if (y4?.bandwidth)\n    ty += y4.bandwidth() / 2;\n  if (tx || ty)\n    selection2.attr(\"transform\", `translate(${tx},${ty})`);\n}\nfunction impliedString(value, impliedValue) {\n  if ((value = string(value)) !== impliedValue)\n    return value;\n}\nfunction impliedNumber(value, impliedValue) {\n  if ((value = number5(value)) !== impliedValue)\n    return value;\n}\nvar validClassName = /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/;\nfunction maybeClassName(name) {\n  if (name === void 0)\n    return `plot-${Math.random().toString(16).slice(2)}`;\n  name = `${name}`;\n  if (!validClassName.test(name))\n    throw new Error(`invalid class name: ${name}`);\n  return name;\n}\nfunction applyInlineStyles(selection2, style) {\n  if (typeof style === \"string\") {\n    selection2.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection2) {\n      Object.assign(element.style, style);\n    }\n  }\n}\nfunction applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {\n  return [\n    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,\n    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2\n  ];\n}\n\n// node_modules/@observablehq/plot/dist/dimensions.js\nfunction Dimensions(scales, marks2, options = {}) {\n  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;\n  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {\n    if (marginTop2 > marginTopDefault)\n      marginTopDefault = marginTop2;\n    if (marginRight2 > marginRightDefault)\n      marginRightDefault = marginRight2;\n    if (marginBottom2 > marginBottomDefault)\n      marginBottomDefault = marginBottom2;\n    if (marginLeft2 > marginLeftDefault)\n      marginLeftDefault = marginLeft2;\n  }\n  let { margin, marginTop = margin !== void 0 ? margin : marginTopDefault, marginRight = margin !== void 0 ? margin : marginRightDefault, marginBottom = margin !== void 0 ? margin : marginBottomDefault, marginLeft = margin !== void 0 ? margin : marginLeftDefault } = options;\n  marginTop = +marginTop;\n  marginRight = +marginRight;\n  marginBottom = +marginBottom;\n  marginLeft = +marginLeft;\n  let { width = 640, height = autoHeight(scales, marks2, options, {\n    width,\n    marginTopDefault,\n    marginRightDefault,\n    marginBottomDefault,\n    marginLeftDefault\n  }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault) } = options;\n  width = +width;\n  height = +height;\n  const dimensions = {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n  if (scales.fx || scales.fy) {\n    let { margin: facetMargin, marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop, marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight, marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom, marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft } = options.facet ?? {};\n    facetMarginTop = +facetMarginTop;\n    facetMarginRight = +facetMarginRight;\n    facetMarginBottom = +facetMarginBottom;\n    facetMarginLeft = +facetMarginLeft;\n    dimensions.facet = {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    };\n  }\n  return dimensions;\n}\nfunction autoHeight({ x: x4, y: y4, fy, fx }, marks2, { projection: projection2, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {\n  const nfy = fy ? fy.scale.domain().length : 1;\n  const ar = projectionAspectRatio(projection2, marks2);\n  if (ar) {\n    const nfx = fx ? fx.scale.domain().length : 1;\n    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;\n    const lar = Math.max(0.1, Math.min(10, far));\n    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);\n  }\n  const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;\n  if (aspectRatio != null) {\n    aspectRatio = +aspectRatio;\n    if (!(isFinite(aspectRatio) && aspectRatio > 0))\n      throw new Error(`invalid aspectRatio: ${aspectRatio}`);\n    const ratio = aspectRatioLength(\"y\", y4) / (aspectRatioLength(\"x\", x4) * aspectRatio);\n    const fxb = fx ? fx.scale.bandwidth() : 1;\n    const fyb = fy ? fy.scale.bandwidth() : 1;\n    const w = fxb * (width - marginLeftDefault - marginRightDefault) - x4.insetLeft - x4.insetRight;\n    return (ratio * w + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;\n  }\n  return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;\n}\nfunction aspectRatioLength(k2, scale3) {\n  if (!scale3)\n    throw new Error(`aspectRatio requires ${k2} scale`);\n  const { type: type2, domain } = scale3;\n  let transform2;\n  switch (type2) {\n    case \"linear\":\n    case \"utc\":\n    case \"time\":\n      transform2 = Number;\n      break;\n    case \"pow\": {\n      const exponent2 = scale3.scale.exponent();\n      transform2 = (x4) => Math.pow(x4, exponent2);\n      break;\n    }\n    case \"log\":\n      transform2 = Math.log;\n      break;\n    case \"point\":\n    case \"band\":\n      return domain.length;\n    default:\n      throw new Error(`unsupported ${k2} scale for aspectRatio: ${type2}`);\n  }\n  const [min4, max5] = extent(domain);\n  return Math.abs(transform2(max5) - transform2(min4));\n}\n\n// node_modules/@observablehq/plot/dist/facet.js\nfunction Facets(channelsByScale, options) {\n  const { fx, fy } = Scales(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x4, y4], i) => ({ x: x4, y: y4, i })) : fxDomain ? fxDomain.map((x4, i) => ({ x: x4, i })) : fyDomain ? fyDomain.map((y4, i) => ({ y: y4, i })) : void 0;\n}\nfunction facetOrder({ x: X3, y: Y3 }) {\n  const xi = X3 && new Map(X3.map((v2, i) => [v2, i]));\n  const yi = Y3 && new Map(Y3.map((v2, i) => [v2, i]));\n  return X3 && Y3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) || yi.get(a4.y) - yi.get(b.y) : X3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) : (a4, b) => yi.get(a4.y) - yi.get(b.y);\n}\nfunction facetGroups(data, { fx, fy }) {\n  const I = range4(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy ? rollup(I, (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G), (i) => FX[i], (i) => FY[i]) : fx ? rollup(I, (G) => (G.fx = FX[G[0]], G), (i) => FX[i]) : rollup(I, (G) => (G.fy = FY[G[0]], G), (i) => FY[i]);\n}\nfunction facetTranslate(fx, fy, { marginTop, marginLeft }) {\n  return fx && fy ? ({ x: x4, y: y4 }) => `translate(${fx(x4) - marginLeft},${fy(y4) - marginTop})` : fx ? ({ x: x4 }) => `translate(${fx(x4) - marginLeft},0)` : ({ y: y4 }) => `translate(0,${fy(y4) - marginTop})`;\n}\nfunction facetExclude(index3) {\n  const ex = [];\n  const e = new Uint32Array(sum(index3, (d) => d.length));\n  for (const i of index3) {\n    let n = 0;\n    for (const j of index3) {\n      if (i === j)\n        continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\nvar facetAnchors = /* @__PURE__ */ new Map([\n  [\"top\", facetAnchorTop],\n  [\"right\", facetAnchorRight],\n  [\"bottom\", facetAnchorBottom],\n  [\"left\", facetAnchorLeft],\n  [\"top-left\", and(facetAnchorTop, facetAnchorLeft)],\n  [\"top-right\", and(facetAnchorTop, facetAnchorRight)],\n  [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)],\n  [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)],\n  [\"top-empty\", facetAnchorTopEmpty],\n  [\"right-empty\", facetAnchorRightEmpty],\n  [\"bottom-empty\", facetAnchorBottomEmpty],\n  [\"left-empty\", facetAnchorLeftEmpty],\n  [\"empty\", facetAnchorEmpty]\n]);\nfunction maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null)\n    return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor)\n    return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\nfunction facetAnchorTop(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === 0 : true;\n}\nfunction facetAnchorBottom(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === Y3.length - 1 : true;\n}\nfunction facetAnchorLeft(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === 0 : true;\n}\nfunction facetAnchorRight(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === X3.length - 1 : true;\n}\nfunction facetAnchorTopEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i > 0) {\n    const y5 = Y3[i - 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i < Y3?.length - 1) {\n    const y5 = Y3[i + 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorLeftEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i > 0) {\n    const x5 = X3[i - 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorRightEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i < X3?.length - 1) {\n    const x5 = X3[i + 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorEmpty(facets, channels, { empty: empty4 }) {\n  return empty4;\n}\nfunction and(a4, b) {\n  return function() {\n    return a4.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\nfunction facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {\n  return fx && fy ? facets.map(({ x: x4, y: y4 }) => groups2.get(x4)?.get(y4) ?? []) : fx ? facets.map(({ x: x4 }) => groups2.get(x4) ?? []) : facets.map(({ y: y4 }) => groups2.get(y4) ?? []);\n}\n\n// node_modules/@observablehq/plot/dist/axes.js\nfunction inferFontVariant(scale3) {\n  return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction maybeAutoTickFormat(tickFormat2, domain) {\n  return tickFormat2 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat2 === \"function\" ? tickFormat2 : (typeof tickFormat2 === \"string\" ? isTemporal(domain) ? utcFormat : format : constant2)(tickFormat2);\n}\n\n// node_modules/@observablehq/plot/dist/legends/ramp.js\nfunction legendRamp(color3, options) {\n  let { label = color3.label, tickSize = 6, width = 240, height = 44 + tickSize, marginTop = 18, marginRight = 0, marginBottom = 16 + tickSize, marginLeft = 0, style, ticks: ticks2 = (width - marginLeft - marginRight) / 64, tickFormat: tickFormat2, fontVariant = inferFontVariant(color3), round: round2 = true, className } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  if (tickFormat2 === null)\n    tickFormat2 = () => null;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n          overflow: visible;\n        }\n        .${className} text {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style);\n  let tickAdjust = (g) => g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x4;\n  const applyRange = round2 ? (x5, range6) => x5.rangeRound(range6) : (x5, range6) => x5.range(range6);\n  const { type: type2, domain, range: range5, interpolate, scale: scale3, pivot } = color3;\n  if (interpolate) {\n    const interpolator = range5 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range5);\n    x4 = applyRange(scale3.copy(), quantize_default(number_default(marginLeft, width - marginRight), Math.min(domain.length + (pivot !== void 0), range5 === void 0 ? Infinity : range5.length)));\n    const n = 256;\n    const canvas = context.document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context2 = canvas.getContext(\"2d\");\n    for (let i = 0, j = n - 1; i < n; ++i) {\n      context2.fillStyle = interpolator(i / j);\n      context2.fillRect(i, 0, 1, 1);\n    }\n    svg2.append(\"image\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginLeft - marginRight).attr(\"height\", height - marginTop - marginBottom).attr(\"preserveAspectRatio\", \"none\").attr(\"xlink:href\", canvas.toDataURL());\n  } else if (type2 === \"threshold\") {\n    const thresholds = domain;\n    const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === \"string\" ? format(tickFormat2) : tickFormat2;\n    x4 = applyRange(linear3().domain([-1, range5.length - 1]), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(range5).enter().append(\"rect\").attr(\"x\", (d, i) => x4(i - 1)).attr(\"y\", marginTop).attr(\"width\", (d, i) => x4(i) - x4(i - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", (d) => d);\n    ticks2 = map4(thresholds, (_, i) => i);\n    tickFormat2 = (i) => thresholdFormat(thresholds[i], i);\n  } else {\n    x4 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(domain).enter().append(\"rect\").attr(\"x\", x4).attr(\"y\", marginTop).attr(\"width\", Math.max(0, x4.bandwidth() - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", scale3);\n    tickAdjust = () => {\n    };\n  }\n  svg2.append(\"g\").attr(\"transform\", `translate(0,${height - marginBottom})`).call(axisBottom(x4).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === \"string\" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === \"function\" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)).attr(\"font-size\", null).attr(\"font-family\", null).attr(\"font-variant\", impliedString(fontVariant, \"normal\")).call(tickAdjust).call((g) => g.select(\".domain\").remove());\n  if (label !== void 0) {\n    svg2.append(\"text\").attr(\"x\", marginLeft).attr(\"y\", marginTop - 6).attr(\"fill\", \"currentColor\").attr(\"font-weight\", \"bold\").text(label);\n  }\n  return svg2.node();\n}\n\n// node_modules/@observablehq/plot/dist/legends/swatches.js\nfunction maybeScale(scale3, key) {\n  if (key == null)\n    return key;\n  const s2 = scale3(key);\n  if (!s2)\n    throw new Error(`scale not found: ${key}`);\n  return s2;\n}\nfunction legendSwatches(color3, options) {\n  if (!isOrdinalScale(color3) && !isThresholdScale(color3))\n    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);\n  return legendItems(color3, options, (selection2, scale3) => selection2.append(\"svg\").attr(\"fill\", scale3.scale).append(\"rect\").attr(\"width\", \"100%\").attr(\"height\", \"100%\"), (className) => `.${className}-swatch svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n      }`);\n}\nfunction legendSymbols(symbol2, { fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : \"none\", fillOpacity = 1, stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? \"currentColor\" : \"none\", strokeOpacity = 1, strokeWidth = 1.5, r = 4.5, ...options } = {}, scale3) {\n  const [vf, cf] = maybeColorChannel(fill);\n  const [vs, cs] = maybeColorChannel(stroke);\n  const sf = maybeScale(scale3, vf);\n  const ss = maybeScale(scale3, vs);\n  const size = r * r * Math.PI;\n  fillOpacity = maybeNumberChannel(fillOpacity)[1];\n  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];\n  strokeWidth = maybeNumberChannel(strokeWidth)[1];\n  return legendItems(symbol2, options, (selection2) => selection2.append(\"svg\").attr(\"viewBox\", \"-8 -8 16 16\").attr(\"fill\", vf === \"color\" ? (d) => sf.scale(d) : null).attr(\"stroke\", vs === \"color\" ? (d) => ss.scale(d) : null).append(\"path\").attr(\"d\", (d) => {\n    const p = pathRound();\n    symbol2.scale(d).draw(p, size);\n    return p;\n  }), (className) => `.${className}-swatch > svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n        overflow: visible;\n        fill: ${cf};\n        fill-opacity: ${fillOpacity};\n        stroke: ${cs};\n        stroke-width: ${strokeWidth}px;\n        stroke-opacity: ${strokeOpacity};\n      }`);\n}\nfunction legendItems(scale3, options = {}, swatch, swatchStyle) {\n  let {\n    columns,\n    tickFormat: tickFormat2,\n    fontVariant = inferFontVariant(scale3),\n    // TODO label,\n    swatchSize = 15,\n    swatchWidth = swatchSize,\n    swatchHeight = swatchSize,\n    marginLeft = 0,\n    className,\n    style,\n    width\n  } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  tickFormat2 = maybeAutoTickFormat(tickFormat2, scale3.domain);\n  const swatches = create2(\"div\", context).attr(\"class\", className).attr(\"style\", `\n        --swatchWidth: ${+swatchWidth}px;\n        --swatchHeight: ${+swatchHeight}px;\n      `);\n  let extraStyle;\n  if (columns != null) {\n    extraStyle = `\n      .${className}-swatch {\n        display: flex;\n        align-items: center;\n        break-inside: avoid;\n        padding-bottom: 1px;\n      }\n      .${className}-swatch::before {\n        flex-shrink: 0;\n      }\n      .${className}-label {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n    `;\n    swatches.style(\"columns\", columns).selectAll().data(scale3.domain).enter().append(\"div\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).call((item) => item.append(\"div\").attr(\"class\", `${className}-label`).attr(\"title\", tickFormat2).text(tickFormat2));\n  } else {\n    extraStyle = `\n      .${className} {\n        display: flex;\n        align-items: center;\n        min-height: 33px;\n        flex-wrap: wrap;\n      }\n      .${className}-swatch {\n        display: inline-flex;\n        align-items: center;\n        margin-right: 1em;\n      }\n    `;\n    swatches.selectAll().data(scale3.domain).enter().append(\"span\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).append(function() {\n      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));\n    });\n  }\n  return swatches.call((div) => div.insert(\"style\", \"*\").text(`\n        .${className} {\n          font-family: system-ui, sans-serif;\n          font-size: 10px;\n          margin-bottom: 0.5em;${marginLeft === void 0 ? \"\" : `\n          margin-left: ${+marginLeft}px;`}${width === void 0 ? \"\" : `\n          width: ${width}px;`}\n        }\n        ${swatchStyle(className)}\n        ${extraStyle}\n      `)).style(\"font-variant\", impliedString(fontVariant, \"normal\")).call(applyInlineStyles, style).node();\n}\n\n// node_modules/@observablehq/plot/dist/legends.js\nvar legendRegistry = /* @__PURE__ */ new Map([\n  [\"symbol\", legendSymbols],\n  [\"color\", legendColor],\n  [\"opacity\", legendOpacity]\n]);\nfunction legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale3 = options[key];\n    if (isScaleOptions(scale3)) {\n      const context = Context(options);\n      let hint;\n      if (key === \"symbol\") {\n        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? \"color\" : void 0 } = options;\n        hint = { fill, stroke };\n      }\n      return value(normalizeScale(key, scale3, hint), legendOptions(context, scale3, options), (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null);\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\nfunction exposeLegends(scales, context, defaults21 = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key))\n      throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales))\n      return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults21[key], options), (key2) => scales[key2]);\n  };\n}\nfunction legendOptions(context, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {\n  return inherit2(options, context, { label, ticks: ticks2, tickFormat: tickFormat2 });\n}\nfunction legendColor(color3, { legend: legend2 = true, ...options }) {\n  if (legend2 === true)\n    legend2 = color3.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color3.domain === void 0)\n    return;\n  switch (`${legend2}`.toLowerCase()) {\n    case \"swatches\":\n      return legendSwatches(color3, options);\n    case \"ramp\":\n      return legendRamp(color3, options);\n    default:\n      throw new Error(`unknown legend type: ${legend2}`);\n  }\n}\nfunction legendOpacity({ type: type2, interpolate, ...scale3 }, { legend: legend2 = true, color: color3 = rgb(0, 0, 0), ...options }) {\n  if (!interpolate)\n    throw new Error(`${type2} opacity scales are not supported`);\n  if (legend2 === true)\n    legend2 = \"ramp\";\n  if (`${legend2}`.toLowerCase() !== \"ramp\")\n    throw new Error(`${legend2} opacity legends are not supported`);\n  return legendColor({ type: type2, ...scale3, interpolate: interpolateOpacity(color3) }, { legend: legend2, ...options });\n}\nfunction interpolateOpacity(color3) {\n  const { r, g, b } = rgb(color3) || rgb(0, 0, 0);\n  return (t) => `rgba(${r},${g},${b},${t})`;\n}\nfunction Legends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);\n      if (legend2 != null)\n        legends.push(legend2);\n    }\n  }\n  return legends;\n}\n\n// node_modules/@observablehq/plot/dist/mark.js\nvar Mark = class {\n  constructor(data, channels = {}, options = {}, defaults21) {\n    const { facet = \"auto\", facetAnchor, fx, fy, sort: sort3, dx = 0, dy = 0, margin = 0, marginTop = margin, marginRight = margin, marginBottom = margin, marginLeft = margin, clip, channels: extraChannels } = options;\n    this.data = data;\n    this.sort = isDomainSort(sort3) ? sort3 : null;\n    this.initializer = initializer(options).initializer;\n    this.transform = this.initializer ? options.transform : basic(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = keyword(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = fx;\n      this.fy = fy;\n    }\n    this.facetAnchor = maybeFacetAnchor(facetAnchor);\n    channels = maybeNamed(channels);\n    if (extraChannels !== void 0)\n      channels = { ...maybeNamed(extraChannels), ...channels };\n    if (defaults21 !== void 0)\n      channels = { ...styles(this, options, defaults21), ...channels };\n    this.channels = Object.fromEntries(Object.entries(channels).map(([name, channel]) => {\n      const { value } = channel;\n      if (isOptions(value)) {\n        channel = { ...channel, value: value.value };\n        if (value.scale !== void 0)\n          channel.scale = value.scale;\n      }\n      return [name, channel];\n    }).filter(([name, { value, optional: optional2 }]) => {\n      if (value != null)\n        return true;\n      if (optional2)\n        return false;\n      throw new Error(`missing channel value: ${name}`);\n    }));\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = maybeClip(clip);\n    if (this.facet === \"super\") {\n      if (fx || fy)\n        throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const { scale: scale3 } = channels[name];\n        if (scale3 !== \"x\" && scale3 !== \"y\")\n          continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n  }\n  initialize(facets, facetChannels) {\n    let data = arrayify2(this.data);\n    if (facets === void 0 && data != null)\n      facets = [range4(data)];\n    if (this.transform != null)\n      ({ facets, data } = this.transform(data, facets)), data = arrayify2(data);\n    const channels = Channels(this.channels, data);\n    if (this.sort != null)\n      channelDomain(channels, facetChannels, data, this.sort);\n    return { data, facets, channels };\n  }\n  filter(index3, channels, values2) {\n    for (const name in channels) {\n      const { filter: filter4 = defined } = channels[name];\n      if (filter4 !== null) {\n        const value = values2[name];\n        index3 = index3.filter((i) => filter4(value[i]));\n      }\n    }\n    return index3;\n  }\n  // If there is a projection, and there are both x and y channels (or x1 and\n  // y1, or x2 and y2 channels), and those channels are associated with the x\n  // and y scale respectively (and not already in screen coordinates as with an\n  // initializer), then apply the projection, replacing the x and y values. Note\n  // that the x and y scales themselves dont exist if there is a projection,\n  // but whether the channels are associated with scales still determines\n  // whether the projection should apply; think of the projection as a\n  // combination xy-scale.\n  project(channels, values2, context) {\n    maybeProject(\"x\", \"y\", channels, values2, context);\n    maybeProject(\"x1\", \"y1\", channels, values2, context);\n    maybeProject(\"x2\", \"y2\", channels, values2, context);\n  }\n  scale(channels, scales, context) {\n    const values2 = valueObject(channels, scales);\n    if (context.projection)\n      this.project(channels, values2, context);\n    return values2;\n  }\n};\nfunction marks(...marks2) {\n  marks2.plot = Mark.prototype.plot;\n  return marks2;\n}\n\n// node_modules/@observablehq/plot/dist/math.js\nvar radians3 = Math.PI / 180;\n\n// node_modules/@observablehq/plot/dist/transforms/inset.js\nfunction maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {\n  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);\n  return { inset, insetLeft, insetRight, ...options };\n}\nfunction maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {\n  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);\n  return { inset, insetTop, insetBottom, ...options };\n}\nfunction maybeInset(inset, inset1, inset2) {\n  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];\n}\n\n// node_modules/@observablehq/plot/dist/transforms/interval.js\nfunction maybeIntervalValue(value, { interval: interval2 }) {\n  value = { ...maybeValue(value) };\n  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);\n  return value;\n}\nfunction maybeIntervalK(k2, maybeInsetK, options, trivial) {\n  const { [k2]: v2, [`${k2}1`]: v1, [`${k2}2`]: v22 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null && !trivial)\n    return options;\n  const label = labelof(v2);\n  if (interval2 == null) {\n    let V;\n    const kv = { transform: (data) => V || (V = valueof(data, value)), label };\n    return {\n      ...options,\n      [k2]: void 0,\n      [`${k2}1`]: v1 === void 0 ? kv : v1,\n      [`${k2}2`]: v22 === void 0 ? kv : v22\n    };\n  }\n  let D1, V1;\n  function transform2(data) {\n    if (V1 !== void 0 && data === D1)\n      return V1;\n    return V1 = map4(valueof(D1 = data, value), (v3) => interval2.floor(v3));\n  }\n  return maybeInsetK({\n    ...options,\n    [k2]: void 0,\n    [`${k2}1`]: v1 === void 0 ? { transform: transform2, label } : v1,\n    [`${k2}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v3) => interval2.offset(v3)), label } : v22\n  });\n}\nfunction maybeIntervalMidK(k2, maybeInsetK, options) {\n  const { [k2]: v2 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null)\n    return options;\n  return maybeInsetK({\n    ...options,\n    [k2]: {\n      label: labelof(v2),\n      transform: (data) => {\n        const V1 = map4(valueof(data, value), (v3) => interval2.floor(v3));\n        const V2 = V1.map((v3) => interval2.offset(v3));\n        return V1.map(isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2);\n      }\n    }\n  });\n}\nfunction maybeTrivialIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options, true);\n}\nfunction maybeTrivialIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options, true);\n}\nfunction maybeIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options);\n}\nfunction maybeIntervalMidX(options = {}) {\n  return maybeIntervalMidK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalMidY(options = {}) {\n  return maybeIntervalMidK(\"y\", maybeInsetY, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/rule.js\nvar defaults = {\n  ariaLabel: \"rule\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar RuleX = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y1: Y13, y2: Y23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetTop, insetBottom } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions).call(applyTransform, this, { x: X3 && x4 }, offset, 0).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"x2\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"y1\", Y13 && !isCollapsed(y4) ? (i) => Y13[i] + insetTop : marginTop + insetTop).attr(\"y2\", Y23 && !isCollapsed(y4) ? y4.bandwidth ? (i) => Y23[i] + y4.bandwidth() - insetBottom : (i) => Y23[i] - insetBottom : height - marginBottom - insetBottom).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar RuleY = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12, scale: \"x\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true }\n    }, options, defaults);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { y: Y3, x1: X13, x2: X23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetLeft, insetRight } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y4 }, 0, offset).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X13 && !isCollapsed(x4) ? (i) => X13[i] + insetLeft : marginLeft + insetLeft).attr(\"x2\", X23 && !isCollapsed(x4) ? x4.bandwidth ? (i) => X23[i] + x4.bandwidth() - insetRight : (i) => X23[i] - insetRight : width - marginRight - insetRight).attr(\"y1\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).attr(\"y2\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction ruleX(data, options) {\n  let { x: x4 = identity6, y: y4, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);\n  [y12, y22] = maybeOptionalZero(y4, y12, y22);\n  return new RuleX(data, { ...rest, x: x4, y1: y12, y2: y22 });\n}\nfunction ruleY(data, options) {\n  let { y: y4 = identity6, x: x4, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);\n  [x12, x22] = maybeOptionalZero(x4, x12, x22);\n  return new RuleY(data, { ...rest, y: y4, x1: x12, x2: x22 });\n}\nfunction maybeOptionalZero(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [0, x22];\n    } else {\n      if (x22 === void 0)\n        return [0, x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [0, x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/template.js\nfunction template(strings, ...parts) {\n  let n = parts.length;\n  for (let j = 0, copy3 = true; j < n; ++j) {\n    if (typeof parts[j] !== \"function\") {\n      if (copy3) {\n        strings = strings.slice();\n        copy3 = false;\n      }\n      strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);\n      parts.splice(j, 1);\n      --j, --n;\n    }\n  }\n  return (i) => {\n    let s2 = strings[0];\n    for (let j = 0; j < n; ++j) {\n      s2 += parts[j](i) + strings[j + 1];\n    }\n    return s2;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/text.js\nvar defaults2 = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\nvar softHyphen = \"\\xAD\";\nvar Text = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf, frameAnchor, textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\", lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\", lineHeight = 1, lineWidth = Infinity, textOverflow, monospace, fontFamily = monospace ? \"ui-monospace, monospace\" : void 0, fontSize, fontStyle, fontVariant, fontWeight, rotate } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      fontSize: { value: vfontSize, optional: true },\n      rotate: { value: numberChannel(vrotate), optional: true },\n      text: { value: text2, filter: nonempty, optional: true }\n    }, options, defaults2);\n    this.rotate = crotate;\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.lineAnchor = keyword(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    if (!(this.lineWidth >= 0))\n      throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter2(this);\n    this.clipLine = clipper(this);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, rotate: R, text: T, title: TL, fontSize: FS } = channels;\n    const { rotate } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"text\").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`).call(applyAttr, \"font-size\", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction maybeTextOverflow(textOverflow) {\n  return textOverflow == null ? null : keyword(textOverflow, \"textOverflow\", [\n    \"clip\",\n    \"ellipsis\",\n    \"clip-start\",\n    \"clip-end\",\n    \"ellipsis-start\",\n    \"ellipsis-middle\",\n    \"ellipsis-end\"\n  ]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\nfunction applyMultilineText(selection2, mark, T, TL) {\n  if (!T)\n    return;\n  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;\n  selection2.each(function(i) {\n    const lines = splitLines(formatDefault(T[i])).map(clipLine);\n    const n = lines.length;\n    const y4 = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      for (let i2 = 0; i2 < n; ++i2) {\n        if (!lines[i2])\n          continue;\n        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        tspan.setAttribute(\"y\", `${(y4 + i2) * lineHeight}em`);\n        tspan.textContent = lines[i2];\n        this.appendChild(tspan);\n      }\n    } else {\n      if (y4)\n        this.setAttribute(\"y\", `${y4 * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(namespaces_default.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\nfunction text(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Text(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction textX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction textY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction applyIndirectTextStyles(selection2, mark, T) {\n  applyAttr(selection2, \"text-anchor\", mark.textAnchor);\n  applyAttr(selection2, \"font-family\", mark.fontFamily);\n  applyAttr(selection2, \"font-size\", mark.fontSize);\n  applyAttr(selection2, \"font-style\", mark.fontStyle);\n  applyAttr(selection2, \"font-variant\", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);\n  applyAttr(selection2, \"font-weight\", mark.fontWeight);\n}\nfunction inferFontVariant2(T) {\n  return isNumeric(T) || isTemporal(T) ? \"tabular-nums\" : void 0;\n}\nvar fontSizes = /* @__PURE__ */ new Set([\n  // global keywords\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n  // absolute keywords\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"xxx-large\",\n  // relative keywords\n  \"larger\",\n  \"smaller\"\n]);\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\")\n    return [void 0, fontSize];\n  if (typeof fontSize !== \"string\")\n    return [fontSize, void 0];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];\n}\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart, lineEnd = 0;\n  for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {\n    if (lineStart === void 0)\n      lineStart = wordStart;\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n    if (required2) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = void 0;\n      continue;\n    }\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\nfunction* lineBreaks(input) {\n  let i = 0, j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k2 = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\":\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \")\n          ;\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\")\n          ++k2;\n      case \"\\n\":\n        yield [i, j, true];\n        j += k2;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\nvar defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"\\u2018\": 31,\n  \"\\u2019\": 31,\n  \"\\u201C\": 47,\n  \"\\u201D\": 47,\n  \"\\u2026\": 82\n};\nfunction defaultWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += defaultWidthMap[text2[i]] ?? (isPictographic(text2, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum5;\n}\nfunction monospaceWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += isPictographic(text2, i) ? 200 : 100;\n  }\n  return sum5;\n}\nfunction splitter2({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow != null || lineWidth == Infinity)\n    return (text2) => text2.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return (text2) => lineWrap(text2, maxWidth, widthof);\n}\nfunction clipper({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow == null || lineWidth == Infinity)\n    return (text2) => text2;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-middle\":\n      return (text2) => clipMiddle(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\\u2026\");\n  }\n}\nfunction cut(text2, width, widthof, inset) {\n  const I = [];\n  let w = 0;\n  for (let i = 0, j = 0, n = text2.length; i < n; i = j) {\n    j = readCharacter(text2, i);\n    const l = widthof(text2, i, j);\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0)\n        j = i, i = I.pop(), w -= widthof(text2, i, j);\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\nfunction clipEnd(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const e = widthof(ellipsis);\n  const [i] = cut(text2, width, widthof, e);\n  return i < 0 ? text2 : text2.slice(0, i).trimEnd() + ellipsis;\n}\nfunction clipMiddle(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text2, width / 2, widthof, e);\n  const [j] = cut(text2, w - width / 2 - ei + e, widthof, -e);\n  return j < 0 ? ellipsis : text2.slice(0, i).trimEnd() + ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nfunction clipStart(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis);\n  const [j] = cut(text2, w - width + e, widthof, -e);\n  return j < 0 ? ellipsis : ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nvar reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nvar rePictographic = /\\p{Extended_Pictographic}/uy;\nfunction readCharacter(text2, i) {\n  i += isSurrogatePair(text2, i) ? 2 : 1;\n  if (isCombiner(text2, i))\n    i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text2, i))\n    return readCharacter(text2, i + 1);\n  return i;\n}\nfunction isAscii(text2, i) {\n  return text2.charCodeAt(i) < 128;\n}\nfunction isSurrogatePair(text2, i) {\n  const hi = text2.charCodeAt(i);\n  if (hi >= 55296 && hi < 56320) {\n    const lo = text2.charCodeAt(i + 1);\n    return lo >= 56320 && lo < 57344;\n  }\n  return false;\n}\nfunction isZeroWidthJoiner(text2, i) {\n  return text2.charCodeAt(i) === 8205;\n}\nfunction isCombiner(text2, i) {\n  return isAscii(text2, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text2));\n}\nfunction isPictographic(text2, i) {\n  return isAscii(text2, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text2));\n}\n\n// node_modules/@observablehq/plot/dist/marks/vector.js\nvar defaults3 = {\n  ariaLabel: \"vector\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\"\n};\nvar defaultRadius3 = 3.5;\nvar wingRatio = defaultRadius3 * 5;\nvar shapeArrow = {\n  draw(context, l, r) {\n    const wing = l * r / wingRatio;\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n    context.moveTo(-wing, wing - l);\n    context.lineTo(0, -l);\n    context.lineTo(wing, wing - l);\n  }\n};\nvar shapeSpike = {\n  draw(context, l, r) {\n    context.moveTo(-r, 0);\n    context.lineTo(0, -l);\n    context.lineTo(r, 0);\n  }\n};\nvar shapes = /* @__PURE__ */ new Map([\n  [\"arrow\", shapeArrow],\n  [\"spike\", shapeSpike]\n]);\nfunction isShapeObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction Shape(shape) {\n  if (isShapeObject(shape))\n    return shape;\n  const value = shapes.get(`${shape}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid shape: ${shape}`);\n}\nvar Vector = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r = defaultRadius3, length: length4, rotate, shape = shapeArrow, anchor = \"middle\", frameAnchor } = options;\n    const [vl, cl] = maybeNumberChannel(length4, 12);\n    const [vr, cr] = maybeNumberChannel(rotate, 0);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      length: { value: vl, scale: \"length\", optional: true },\n      rotate: { value: vr, optional: true }\n    }, options, defaults3);\n    this.r = +r;\n    this.length = cl;\n    this.rotate = cr;\n    this.shape = Shape(shape);\n    this.anchor = keyword(anchor, \"anchor\", [\"start\", \"middle\", \"end\"]);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, length: L, rotate: A5 } = channels;\n    const { length: length4, rotate, anchor, shape, r } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === \"start\" ? `` : anchor === \"end\" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length4})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length4 / 2})`}`).attr(\"d\", L ? (i) => {\n      const p = pathRound();\n      shape.draw(p, L[i], r);\n      return p;\n    } : (() => {\n      const p = pathRound();\n      shape.draw(p, length4, r);\n      return p;\n    })()).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction vector(data, options = {}) {\n  let { x: x4, y: y4, ...rest } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Vector(data, { ...rest, x: x4, y: y4 });\n}\nfunction vectorX(data, options = {}) {\n  const { x: x4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, x: x4 });\n}\nfunction vectorY(data, options = {}) {\n  const { y: y4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, y: y4 });\n}\nfunction spike(data, options = {}) {\n  const { shape = shapeSpike, stroke = defaults3.stroke, strokeWidth = 1, fill = stroke, fillOpacity = 0.3, anchor = \"start\", ...rest } = options;\n  return vector(data, { ...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor });\n}\n\n// node_modules/@observablehq/plot/dist/marks/axis.js\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !isIterable(data))\n    options = data, data = null;\n  if (options === void 0)\n    options = {};\n  return [data, options];\n}\nfunction maybeAnchor({ anchor } = {}, anchors) {\n  return anchor === void 0 ? anchors[0] : keyword(anchor, \"anchor\", anchors);\n}\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\nfunction axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\nfunction axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\nfunction axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\nfunction axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\nfunction axisKy(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"y\" ? 6 : 0, tickPadding, tickRotate, x: x4, marginTop = 20, marginRight = anchor === \"right\" ? 40 : 0, marginBottom = 20, marginLeft = anchor === \"left\" ? 40 : 0, label, labelOffset, labelAnchor, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKy(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKy(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"y\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"top\");\n      const clo = labelOffset ?? (anchor === \"right\" ? marginRight2 : marginLeft2) - 3;\n      if (cla === \"center\") {\n        this.textAnchor = void 0;\n        this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n        this.frameAnchor = anchor;\n        this.rotate = -90;\n      } else {\n        this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n        this.lineAnchor = cla;\n        this.frameAnchor = `${cla}-${anchor}`;\n        this.rotate = 0;\n      }\n      this.dy = cla === \"top\" ? 3 - marginTop2 : cla === \"bottom\" ? marginBottom2 - 3 : 0;\n      this.dx = anchor === \"right\" ? clo : -clo;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisKx(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"x\" ? 6 : 0, tickPadding, tickRotate, y: y4, marginTop = anchor === \"top\" ? 30 : 0, marginRight = 20, marginBottom = anchor === \"bottom\" ? 30 : 0, marginLeft = 20, label, labelAnchor, labelOffset, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKx(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKx(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"x\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"right\");\n      const clo = labelOffset ?? (anchor === \"top\" ? marginTop2 : marginBottom2) - 3;\n      if (cla === \"center\") {\n        this.frameAnchor = anchor;\n        this.textAnchor = void 0;\n      } else {\n        this.frameAnchor = `${anchor}-${cla}`;\n        this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n      }\n      this.lineAnchor = anchor;\n      this.dy = anchor === \"top\" ? -clo : clo;\n      this.dx = cla === \"right\" ? marginRight2 - 3 : cla === \"left\" ? 3 - marginLeft2 : 0;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisTickKy(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(vectorY, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinecap,\n    strokeLinejoin,\n    facetAnchor,\n    frameAnchor,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - offset + +insetLeft : +dx + offset - insetRight,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n  });\n}\nfunction axisTickKx(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(vectorX, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinejoin,\n    strokeLinecap,\n    facetAnchor,\n    frameAnchor,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy - offset - insetBottom : +dy + offset + +insetTop,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n  });\n}\nfunction axisTextKy(k2, anchor, data, { facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\", lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\", fontVariant, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(textY, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction axisTextKx(k2, anchor, data, { facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === \"bottom\" ? \"start\" : \"end\" : \"middle\", lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\", fontVariant, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(textX, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\nfunction gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\nfunction gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\nfunction gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\nfunction gridKy(k2, anchor, data, { y: y4 = k2 === \"y\" ? void 0 : null, x: x4 = null, x1: x12 = anchor === \"left\" ? x4 : null, x2: x22 = anchor === \"right\" ? x4 : null, ...options }) {\n  return axisMark(ruleY, k2, `${k2}-grid`, data, { y: y4, x1: x12, x2: x22, ...gridDefaults(options) });\n}\nfunction gridKx(k2, anchor, data, { x: x4 = k2 === \"x\" ? void 0 : null, y: y4 = null, y1: y12 = anchor === \"top\" ? y4 : null, y2: y22 = anchor === \"bottom\" ? y4 : null, ...options }) {\n  return axisMark(ruleX, k2, `${k2}-grid`, data, { x: x4, y1: y12, y2: y22, ...gridDefaults(options) });\n}\nfunction gridDefaults({ color: color3 = \"currentColor\", opacity: opacity2 = 0.1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, ...options }) {\n  return { stroke, strokeOpacity, strokeWidth, ...options };\n}\nfunction axisMark(mark, k2, ariaLabel, data, options, initialize) {\n  let channels;\n  const m3 = mark(data, initializer(options, function(data2, facets, _channels, scales) {\n    const { [k2]: scale3 } = scales;\n    if (!scale3)\n      throw new Error(`missing scale: ${k2}`);\n    let { ticks: ticks2, tickSpacing, interval: interval2 } = options;\n    if (isTemporalScale(scale3) && typeof ticks2 === \"string\")\n      interval2 = ticks2, ticks2 = void 0;\n    if (data2 == null) {\n      if (isIterable(ticks2)) {\n        data2 = arrayify2(ticks2);\n      } else if (scale3.ticks) {\n        if (ticks2 !== void 0) {\n          data2 = scale3.ticks(ticks2);\n        } else {\n          interval2 = maybeInterval(interval2 === void 0 ? scale3.interval : interval2, scale3.type);\n          if (interval2 !== void 0) {\n            const [min4, max5] = extent(scale3.domain());\n            data2 = interval2.range(min4, interval2.offset(interval2.floor(max5)));\n          } else {\n            const [min4, max5] = extent(scale3.range());\n            ticks2 = (max5 - min4) / (tickSpacing === void 0 ? k2 === \"x\" ? 80 : 35 : tickSpacing);\n            data2 = scale3.ticks(ticks2);\n          }\n        }\n      } else {\n        data2 = scale3.domain();\n      }\n      if (k2 === \"y\" || k2 === \"x\") {\n        facets = [range4(data2)];\n      } else {\n        channels[k2] = { scale: k2, value: identity6 };\n        facets = void 0;\n      }\n    }\n    initialize?.call(this, scale3, ticks2, channels);\n    return {\n      data: data2,\n      facets,\n      channels: Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, { ...channel, value: valueof(data2, channel.value) }]))\n    };\n  }));\n  if (data == null) {\n    channels = m3.channels;\n    m3.channels = {};\n  } else {\n    channels = {};\n  }\n  m3.ariaLabel = ariaLabel;\n  return m3;\n}\nfunction inferTextChannel(scale3, ticks2, tickFormat2) {\n  return { value: inferTickFormat(scale3, ticks2, tickFormat2) };\n}\nfunction inferTickFormat(scale3, ticks2, tickFormat2) {\n  return scale3.tickFormat ? scale3.tickFormat(isIterable(ticks2) ? null : ticks2, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === \"string\" ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : constant2(tickFormat2);\n}\nvar shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\nvar shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\nvar shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\nvar shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\nfunction inferFontVariant3(scale3) {\n  return scale3.bandwidth && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction inferScaleOrder(scale3) {\n  return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));\n}\nfunction inferAxisLabel(key, scale3, labelAnchor) {\n  const label = scale3.label;\n  if (scale3.bandwidth || !label?.inferred)\n    return label;\n  const order = inferScaleOrder(scale3);\n  return order ? key === \"x\" || labelAnchor === \"center\" ? key === \"x\" === order < 0 ? `\\u2190 ${label}` : `${label} \\u2192` : `${order < 0 ? \"\\u2191 \" : \"\\u2193 \"}${label}` : label;\n}\n\n// node_modules/@observablehq/plot/dist/marks/frame.js\nvar defaults4 = {\n  ariaLabel: \"frame\",\n  fill: \"none\",\n  stroke: \"currentColor\"\n};\nvar lineDefaults = {\n  ariaLabel: \"frame\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeLinecap: \"square\"\n};\nvar Frame = class extends Mark {\n  constructor(options = {}) {\n    const { anchor = null, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(void 0, void 0, options, anchor == null ? defaults4 : lineDefaults);\n    this.anchor = maybeKeyword(anchor, \"anchor\", [\"top\", \"right\", \"bottom\", \"left\"]);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = number5(rx);\n    this.ry = number5(ry);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    const x12 = marginLeft + insetLeft;\n    const x22 = width - marginRight - insetRight;\n    const y12 = marginTop + insetTop;\n    const y22 = height - marginBottom - insetBottom;\n    return create2(anchor ? \"svg:line\" : \"svg:rect\", context).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyTransform, this, {}).call(anchor === \"left\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x12).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"right\" ? (line2) => line2.attr(\"x1\", x22).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"top\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y12) : anchor === \"bottom\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y22).attr(\"y2\", y22) : (rect2) => rect2.attr(\"x\", x12).attr(\"y\", y12).attr(\"width\", x22 - x12).attr(\"height\", y22 - y12).attr(\"rx\", rx).attr(\"ry\", ry)).node();\n  }\n};\nfunction frame2(options) {\n  return new Frame(options);\n}\n\n// node_modules/@observablehq/plot/dist/plot.js\nfunction plot(options = {}) {\n  const { facet, style, caption, ariaLabel, ariaDescription } = options;\n  const className = maybeClassName(options.className);\n  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);\n  const topFacetState = maybeTopFacet(facet, options);\n  const facetStateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  const channelsByScale = /* @__PURE__ */ new Map();\n  if (topFacetState)\n    addScaleChannels(channelsByScale, [topFacetState]);\n  addScaleChannels(channelsByScale, facetStateByMark);\n  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));\n  for (const mark of axes) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  marks2.unshift(...axes);\n  const facets = Facets(channelsByScale, options);\n  if (facets !== void 0) {\n    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;\n    for (const mark of marks2) {\n      if (mark.facet === null || mark.facet === \"super\")\n        continue;\n      const facetState = facetStateByMark.get(mark);\n      if (facetState === void 0)\n        continue;\n      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;\n    }\n    const nonEmpty = /* @__PURE__ */ new Set();\n    for (const { facetsIndex } of facetStateByMark.values()) {\n      facetsIndex?.forEach((index3, i) => {\n        if (index3?.length > 0) {\n          nonEmpty.add(i);\n        }\n      });\n    }\n    facets.forEach(0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false);\n    for (const mark of marks2) {\n      if (mark.facet === \"exclude\") {\n        const facetState = facetStateByMark.get(mark);\n        if (facetState !== void 0)\n          facetState.facetsIndex = facetExclude(facetState.facetsIndex);\n      }\n    }\n  }\n  for (const key of registry.keys()) {\n    if (isScaleOptions(options[key]) && key !== \"fx\" && key !== \"fy\") {\n      channelsByScale.set(key, []);\n    }\n  }\n  const stateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    if (stateByMark.has(mark))\n      throw new Error(\"duplicate mark; each mark must be unique\");\n    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};\n    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels);\n    applyScaleTransforms(channels, options);\n    stateByMark.set(mark, { data, facets: facets2, channels });\n  }\n  const scaleDescriptors = Scales(addScaleChannels(channelsByScale, stateByMark), options);\n  const scales = ScaleFunctions(scaleDescriptors);\n  const dimensions = Dimensions(scaleDescriptors, marks2, options);\n  autoScaleRange(scaleDescriptors, dimensions);\n  const { fx, fy } = scales;\n  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;\n  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;\n  const context = Context(options, subdimensions, scaleDescriptors);\n  const newByScale = /* @__PURE__ */ new Set();\n  for (const [mark, state] of stateByMark) {\n    if (mark.initializer != null) {\n      const dimensions2 = mark.facet === \"super\" ? superdimensions : subdimensions;\n      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);\n      if (update.data !== void 0) {\n        state.data = update.data;\n      }\n      if (update.facets !== void 0) {\n        state.facets = update.facets;\n      }\n      if (update.channels !== void 0) {\n        inferChannelScales(update.channels);\n        Object.assign(state.channels, update.channels);\n        for (const channel of Object.values(update.channels)) {\n          const { scale: scale3 } = channel;\n          if (scale3 != null && registry.get(scale3) !== position) {\n            applyScaleTransform(channel, options);\n            newByScale.add(scale3);\n          }\n        }\n        const { fx: fx2, fy: fy2 } = update.channels;\n        if (fx2 != null || fy2 != null) {\n          const facetState = facetStateByMark.get(mark) ?? { channels: {} };\n          if (fx2 != null)\n            facetState.channels.fx = fx2;\n          if (fy2 != null)\n            facetState.channels.fy = fy2;\n          facetState.groups = facetGroups(state.data, facetState.channels);\n          facetState.facetsIndex = state.facets = facetFilter(facets, facetState);\n          facetStateByMark.set(mark, facetState);\n        }\n      }\n    }\n  }\n  if (newByScale.size) {\n    const newChannelsByScale = /* @__PURE__ */ new Map();\n    addScaleChannels(newChannelsByScale, stateByMark, (key) => newByScale.has(key));\n    addScaleChannels(channelsByScale, stateByMark, (key) => newByScale.has(key));\n    const newScaleDescriptors = inheritScaleLabels(Scales(newChannelsByScale, options), scaleDescriptors);\n    const newScales = ScaleFunctions(newScaleDescriptors);\n    Object.assign(scaleDescriptors, newScaleDescriptors);\n    Object.assign(scales, newScales);\n  }\n  for (const [mark, state] of stateByMark) {\n    state.values = mark.scale(state.channels, scales, context);\n  }\n  const { width, height } = dimensions;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"fill\", \"currentColor\").attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"text-anchor\", \"middle\").attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"aria-label\", ariaLabel).attr(\"aria-description\", ariaDescription).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n        }\n        .${className} text,\n        .${className} tspan {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style).node();\n  if (facets !== void 0) {\n    const facetDomains = { x: fx?.domain(), y: fy?.domain() };\n    facets.sort(facetOrder(facetDomains));\n    select_default2(svg2).selectAll().data(facets).enter().append(\"g\").attr(\"aria-label\", \"facet\").attr(\"transform\", facetTranslate(fx, fy, dimensions)).each(function(f) {\n      let empty4 = true;\n      for (const mark of marks2) {\n        if (mark.facet === \"super\")\n          continue;\n        const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n        if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty))\n          continue;\n        let index3 = null;\n        if (indexes2) {\n          index3 = indexes2[facetStateByMark.has(mark) ? f.i : 0];\n          index3 = mark.filter(index3, channels, values2);\n          if (index3.length === 0)\n            continue;\n          index3.fi = f.i;\n        }\n        const node = mark.render(index3, scales, values2, subdimensions, context);\n        if (node == null)\n          continue;\n        empty4 = false;\n        this.appendChild(node);\n      }\n      if (empty4)\n        this.remove();\n    });\n  }\n  for (const mark of marks2) {\n    if (facets !== void 0 && mark.facet !== \"super\")\n      continue;\n    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n    let index3 = null;\n    if (indexes2) {\n      index3 = indexes2[0];\n      index3 = mark.filter(index3, channels, values2);\n      if (index3.length === 0)\n        continue;\n    }\n    const node = mark.render(index3, scales, values2, superdimensions, context);\n    if (node != null)\n      svg2.appendChild(node);\n  }\n  let figure = svg2;\n  const legends = Legends(scaleDescriptors, context, options);\n  if (caption != null || legends.length > 0) {\n    const { document: document2 } = context;\n    figure = document2.createElement(\"figure\");\n    figure.style.maxWidth = \"initial\";\n    for (const legend2 of legends)\n      figure.appendChild(legend2);\n    figure.appendChild(svg2);\n    if (caption != null) {\n      const figcaption = document2.createElement(\"figcaption\");\n      figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));\n      figure.appendChild(figcaption);\n    }\n  }\n  figure.scale = exposeScales(scaleDescriptors);\n  figure.legend = exposeLegends(scaleDescriptors, context, options);\n  const w = consumeWarnings();\n  if (w > 0) {\n    select_default2(svg2).append(\"text\").attr(\"x\", width).attr(\"y\", 20).attr(\"dy\", \"-1em\").attr(\"text-anchor\", \"end\").attr(\"font-family\", \"initial\").text(\"\\u26A0\\uFE0F\").append(\"title\").text(`${w.toLocaleString(\"en-US\")} warning${w === 1 ? \"\" : \"s\"}. Please check the console.`);\n  }\n  return figure;\n}\nfunction plotThis({ marks: marks2 = [], ...options } = {}) {\n  return plot({ ...options, marks: [...marks2, this] });\n}\nMark.prototype.plot = plotThis;\nfunction flatMarks(marks2) {\n  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);\n}\nfunction markify(mark) {\n  return typeof mark.render === \"function\" ? mark : new Render(mark);\n}\nvar Render = class extends Mark {\n  constructor(render2) {\n    if (typeof render2 !== \"function\")\n      throw new TypeError(\"invalid mark; missing render function\");\n    super();\n    this.render = render2;\n  }\n  render() {\n  }\n};\nfunction applyScaleTransforms(channels, options) {\n  for (const name in channels)\n    applyScaleTransform(channels[name], options);\n  return channels;\n}\nfunction applyScaleTransform(channel, options) {\n  const { scale: scale3 } = channel;\n  if (scale3 == null)\n    return;\n  const { type: type2, percent, interval: interval2, transform: transform2 = percent ? (x4) => x4 * 100 : maybeInterval(interval2, type2)?.floor } = options[scale3] ?? {};\n  if (transform2 != null)\n    channel.value = map4(channel.value, transform2);\n}\nfunction inferChannelScales(channels) {\n  for (const name in channels) {\n    inferChannelScale(name, channels[name]);\n  }\n}\nfunction addScaleChannels(channelsByScale, stateByMark, filter4 = yes) {\n  for (const { channels } of stateByMark.values()) {\n    for (const name in channels) {\n      const channel = channels[name];\n      const { scale: scale3 } = channel;\n      if (scale3 != null && filter4(scale3)) {\n        const scaleChannels = channelsByScale.get(scale3);\n        if (scaleChannels !== void 0)\n          scaleChannels.push(channel);\n        else\n          channelsByScale.set(scale3, [channel]);\n      }\n    }\n  }\n  return channelsByScale;\n}\nfunction maybeTopFacet(facet, options) {\n  if (facet == null)\n    return;\n  const { x: x4, y: y4 } = facet;\n  if (x4 == null && y4 == null)\n    return;\n  const data = arrayify2(facet.data ?? x4 ?? y4);\n  if (data === void 0)\n    throw new Error(`missing facet data`);\n  const channels = {};\n  if (x4 != null)\n    channels.fx = Channel(data, { value: x4, scale: \"fx\" });\n  if (y4 != null)\n    channels.fy = Channel(data, { value: y4, scale: \"fy\" });\n  applyScaleTransforms(channels, options);\n  const groups2 = facetGroups(data, channels);\n  return { channels, groups: groups2, data: facet.data };\n}\nfunction maybeMarkFacet(mark, topFacetState, options) {\n  if (mark.facet === null || mark.facet === \"super\")\n    return;\n  const { fx, fy } = mark;\n  if (fx != null || fy != null) {\n    const data2 = arrayify2(mark.data ?? fx ?? fy);\n    if (data2 === void 0)\n      throw new Error(`missing facet data in ${mark.ariaLabel}`);\n    if (data2 === null)\n      return;\n    const channels2 = {};\n    if (fx != null)\n      channels2.fx = Channel(data2, { value: fx, scale: \"fx\" });\n    if (fy != null)\n      channels2.fy = Channel(data2, { value: fy, scale: \"fy\" });\n    applyScaleTransforms(channels2, options);\n    return { channels: channels2, groups: facetGroups(data2, channels2) };\n  }\n  if (topFacetState === void 0)\n    return;\n  const { channels, groups: groups2, data } = topFacetState;\n  if (mark.facet !== \"auto\" || mark.data === data)\n    return { channels, groups: groups2 };\n  if ((groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {\n    warn(`Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is \"auto\", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`);\n  }\n}\nfunction inferAxes(marks2, channelsByScale, options) {\n  let { projection: projection2, x: x4 = {}, y: y4 = {}, fx = {}, fy = {}, axis: axis2, grid, facet = {}, facet: { axis: facetAxis = axis2, grid: facetGrid } = facet, x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x4, y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y4, fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx, fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy } = options;\n  if (projection2 || !isScaleOptions(x4) && !hasScaleChannel(\"x\", marks2))\n    xAxis = xGrid = null;\n  if (projection2 || !isScaleOptions(y4) && !hasScaleChannel(\"y\", marks2))\n    yAxis = yGrid = null;\n  if (!channelsByScale.has(\"fx\"))\n    fxAxis = fxGrid = null;\n  if (!channelsByScale.has(\"fy\"))\n    fyAxis = fyGrid = null;\n  if (xAxis === void 0)\n    xAxis = !hasAxis(marks2, \"x\");\n  if (yAxis === void 0)\n    yAxis = !hasAxis(marks2, \"y\");\n  if (fxAxis === void 0)\n    fxAxis = !hasAxis(marks2, \"fx\");\n  if (fyAxis === void 0)\n    fyAxis = !hasAxis(marks2, \"fy\");\n  if (xAxis === true)\n    xAxis = \"bottom\";\n  if (yAxis === true)\n    yAxis = \"left\";\n  if (fxAxis === true)\n    fxAxis = xAxis === \"top\" || xAxis === null ? \"bottom\" : \"top\";\n  if (fyAxis === true)\n    fyAxis = yAxis === \"right\" || yAxis === null ? \"left\" : \"right\";\n  const axes = [];\n  maybeGrid(axes, fyGrid, gridFy, fy);\n  maybeAxis(axes, fyAxis, axisFy, \"right\", \"left\", facet, fy);\n  maybeGrid(axes, fxGrid, gridFx, fx);\n  maybeAxis(axes, fxAxis, axisFx, \"top\", \"bottom\", facet, fx);\n  maybeGrid(axes, yGrid, gridY, y4);\n  maybeAxis(axes, yAxis, axisY, \"left\", \"right\", options, y4);\n  maybeGrid(axes, xGrid, gridX, x4);\n  maybeAxis(axes, xAxis, axisX, \"bottom\", \"top\", options, x4);\n  return axes;\n}\nfunction maybeAxis(axes, axis2, axisType, primary, secondary, defaults21, options) {\n  if (!axis2)\n    return;\n  const both = isBoth(axis2);\n  options = axisOptions(both ? primary : axis2, defaults21, options);\n  const { line: line2 } = options;\n  if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2))\n    axes.push(frame2(lineOptions(options)));\n  axes.push(axisType(options));\n  if (both)\n    axes.push(axisType({ ...options, anchor: secondary, label: null }));\n}\nfunction maybeGrid(axes, grid, gridType, options) {\n  if (!grid || isNone(grid))\n    return;\n  axes.push(gridType(gridOptions(grid, options)));\n}\nfunction isBoth(value) {\n  return /^\\s*both\\s*$/i.test(value);\n}\nfunction axisOptions(anchor, defaults21, { line: line2 = defaults21.line, ticks: ticks2, tickSize, tickSpacing, tickPadding, tickFormat: tickFormat2, tickRotate, fontVariant, ariaLabel, ariaDescription, label = defaults21.label, labelAnchor, labelOffset }) {\n  return {\n    anchor,\n    line: line2,\n    ticks: ticks2,\n    tickSize,\n    tickSpacing,\n    tickPadding,\n    tickFormat: tickFormat2,\n    tickRotate,\n    fontVariant,\n    ariaLabel,\n    ariaDescription,\n    label,\n    labelAnchor,\n    labelOffset\n  };\n}\nfunction lineOptions(options) {\n  const { anchor, line: line2 } = options;\n  return { anchor, facetAnchor: anchor + \"-empty\", stroke: line2 === true ? void 0 : line2 };\n}\nfunction gridOptions(grid, { stroke = isColor(grid) ? grid : void 0, ticks: ticks2 = isGridTicks(grid) ? grid : void 0, tickSpacing, ariaLabel, ariaDescription }) {\n  return {\n    stroke,\n    ticks: ticks2,\n    tickSpacing,\n    ariaLabel,\n    ariaDescription\n  };\n}\nfunction isGridTicks(grid) {\n  switch (typeof grid) {\n    case \"number\":\n      return true;\n    case \"string\":\n      return !isColor(grid);\n  }\n  return isIterable(grid) || typeof grid?.range === \"function\";\n}\nfunction hasAxis(marks2, k2) {\n  const prefix = `${k2}-axis `;\n  return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));\n}\nfunction hasScaleChannel(k2, marks2) {\n  for (const mark of marks2) {\n    for (const key in mark.channels) {\n      if (mark.channels[key].scale === k2) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction inheritScaleLabels(newScales, scales) {\n  for (const key in newScales) {\n    const newScale = newScales[key];\n    const scale3 = scales[key];\n    if (newScale.label === void 0 && scale3) {\n      newScale.label = scale3.label;\n    }\n  }\n  return newScales;\n}\nfunction actualDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  const fxr = fx && outerRange(fx);\n  const fyr = fy && outerRange(fy);\n  return {\n    marginTop: fy ? fyr[0] : marginTop,\n    marginRight: fx ? width - fxr[1] : marginRight,\n    marginBottom: fy ? height - fyr[1] : marginBottom,\n    marginLeft: fx ? fxr[0] : marginLeft,\n    // Some marks, namely the x- and y-axis labels, want to know what the\n    // desired (rather than actual) margins are for positioning.\n    inset: {\n      marginTop: dimensions.marginTop,\n      marginRight: dimensions.marginRight,\n      marginBottom: dimensions.marginBottom,\n      marginLeft: dimensions.marginLeft\n    },\n    width,\n    height\n  };\n}\nfunction outerRange(scale3) {\n  const domain = scale3.domain();\n  let x12 = scale3(domain[0]);\n  let x22 = scale3(domain[domain.length - 1]);\n  if (x22 < x12)\n    [x12, x22] = [x22, x12];\n  return [x12, x22 + scale3.bandwidth()];\n}\n\n// node_modules/@observablehq/plot/dist/curve.js\nvar curves = /* @__PURE__ */ new Map([\n  [\"basis\", basis_default2],\n  [\"basis-closed\", basisClosed_default2],\n  [\"basis-open\", basisOpen_default],\n  [\"bundle\", bundle_default],\n  [\"bump-x\", bumpX],\n  [\"bump-y\", bumpY],\n  [\"cardinal\", cardinal_default],\n  [\"cardinal-closed\", cardinalClosed_default],\n  [\"cardinal-open\", cardinalOpen_default],\n  [\"catmull-rom\", catmullRom_default],\n  [\"catmull-rom-closed\", catmullRomClosed_default],\n  [\"catmull-rom-open\", catmullRomOpen_default],\n  [\"linear\", linear_default],\n  [\"linear-closed\", linearClosed_default],\n  [\"monotone-x\", monotoneX],\n  [\"monotone-y\", monotoneY],\n  [\"natural\", natural_default],\n  [\"step\", step_default],\n  [\"step-after\", stepAfter],\n  [\"step-before\", stepBefore]\n]);\nfunction Curve(curve = linear_default, tension) {\n  if (typeof curve === \"function\")\n    return curve;\n  const c6 = curves.get(`${curve}`.toLowerCase());\n  if (!c6)\n    throw new Error(`unknown curve: ${curve}`);\n  if (tension !== void 0) {\n    if (\"beta\" in c6) {\n      return c6.beta(tension);\n    } else if (\"tension\" in c6) {\n      return c6.tension(tension);\n    } else if (\"alpha\" in c6) {\n      return c6.alpha(tension);\n    }\n  }\n  return c6;\n}\nfunction PathCurve(curve = curveAuto, tension) {\n  return typeof curve !== \"function\" && `${curve}`.toLowerCase() === \"auto\" ? curveAuto : Curve(curve, tension);\n}\nfunction curveAuto(context) {\n  return linear_default(context);\n}\n\n// node_modules/@observablehq/plot/dist/transforms/bin.js\nfunction binX(outputs = { y: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(maybeBinValue(x4, options, identity6), null, null, y4, outputs, maybeInsetX(options));\n}\nfunction binY(outputs = { x: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(null, maybeBinValue(y4, options, identity6), x4, null, outputs, maybeInsetY(options));\n}\nfunction bin2(outputs = { fill: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = maybeBinValueTuple(options);\n  return binn(x4, y4, null, null, outputs, maybeInsetX(maybeInsetY(options)));\n}\nfunction maybeDenseInterval(bin3, k2, options = {}) {\n  return options?.interval == null ? options : bin3({ [k2]: options?.reduce === void 0 ? reduceFirst : options.reduce, filter: null }, options);\n}\nfunction maybeDenseIntervalX(options) {\n  return maybeDenseInterval(binX, \"y\", options);\n}\nfunction maybeDenseIntervalY(options) {\n  return maybeDenseInterval(binY, \"x\", options);\n}\nfunction binn(bx, by, gx, gy, {\n  data: reduceData = reduceIdentity,\n  // TODO avoid materializing when unused?\n  filter: filter4 = reduceCount,\n  // return only non-empty bins by default\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  if (gx != null && hasOutput(outputs, \"x\", \"x1\", \"x2\"))\n    gx = null;\n  if (gy != null && hasOutput(outputs, \"y\", \"y1\", \"y2\"))\n    gy = null;\n  const [BX1, setBX1] = maybeColumn(bx);\n  const [BX2, setBX2] = maybeColumn(bx);\n  const [BY1, setBY1] = maybeColumn(by);\n  const [BY2, setBY2] = maybeColumn(by);\n  const [k2, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = maybeColumn(k2);\n  const {\n    x: x4,\n    y: y4,\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval: interval2,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const K2 = valueof(data, k2);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GK2 = K2 && setGK([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      const BX12 = bx && setBX1([]);\n      const BX22 = bx && setBX2([]);\n      const BY12 = by && setBY1([]);\n      const BY22 = by && setBY2([]);\n      const bin3 = Bin(bx?.(data), by?.(data));\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [k3, g] of maybeGroup(I, K2)) {\n            for (const [b, extent3] of bin3(g)) {\n              if (filter4 && !filter4.reduce(b, extent3))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(b, data, extent3));\n              if (K2)\n                GK2.push(k3);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[b[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[b[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[b[0]]);\n              if (BX12)\n                BX12.push(extent3.x1), BX22.push(extent3.x2);\n              if (BY12)\n                BY12.push(extent3.y1), BY22.push(extent3.y2);\n              for (const o of outputs)\n                o.reduce(b, extent3);\n              if (sort3)\n                sort3.reduce(b);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x4, x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y4, y1: y12, y2: y22 }),\n    ...GK && { [gk]: GK },\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {\n  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];\n}\nfunction maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {\n  value = { ...maybeValue(value) };\n  if (value.domain === void 0)\n    value.domain = domain;\n  if (value.cumulative === void 0)\n    value.cumulative = cumulative;\n  if (value.thresholds === void 0)\n    value.thresholds = thresholds;\n  if (value.interval === void 0)\n    value.interval = interval2;\n  if (value.value === void 0)\n    value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\nfunction maybeBinValueTuple(options) {\n  let { x: x4, y: y4 } = options;\n  x4 = maybeBinValue(x4, options);\n  y4 = maybeBinValue(y4, options);\n  [x4.value, y4.value] = maybeTuple(x4.value, y4.value);\n  return { x: x4, y: y4 };\n}\nfunction maybeBin(options) {\n  if (options == null)\n    return;\n  const { value, cumulative, domain = extent, thresholds } = options;\n  const bin3 = (data) => {\n    let V = valueof(data, value);\n    let T;\n    if (isTemporal(V) || isTimeThresholds(thresholds)) {\n      V = map4(V, coerceDate, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\")\n        t = utcTickInterval(min4, max5, t);\n      if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    } else {\n      V = map4(V, coerceNumber, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\") {\n        if (domain === extent) {\n          let step = tickIncrement(min4, max5, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min4 / step);\n              let r1 = Math.round(max5 / step);\n              if (!(r0 * step <= min4))\n                --r0;\n              if (!(r1 * step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min4 * step);\n              let r1 = Math.round(max5 * step);\n              if (!(r0 / step <= min4))\n                --r0;\n              if (!(r1 / step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) / step;\n            } else {\n              t = [min4];\n            }\n          } else {\n            t = [min4];\n          }\n        } else {\n          t = ticks(min4, max5, t);\n        }\n      } else if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    }\n    const E2 = [];\n    if (T.length === 1)\n      E2.push([T[0], T[0]]);\n    else\n      for (let i = 1; i < T.length; ++i)\n        E2.push([T[i - 1], T[i]]);\n    E2.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E2, T, V);\n    return E2;\n  };\n  bin3.label = labelof(value);\n  return bin3;\n}\nfunction maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {\n  if (thresholds === void 0) {\n    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return thresholdFreedmanDiaconis;\n      case \"scott\":\n        return thresholdScott;\n      case \"sturges\":\n        return thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    const interval3 = maybeInterval(thresholds);\n    if (interval3 !== void 0)\n      return interval3;\n    throw new Error(`invalid thresholds: ${thresholds}`);\n  }\n  return thresholds;\n}\nfunction maybeRangeInterval(interval2) {\n  interval2 = maybeInterval(interval2);\n  if (!isInterval(interval2))\n    throw new Error(`invalid interval: ${interval2}`);\n  return interval2;\n}\nfunction thresholdAuto(values2, min4, max5) {\n  return Math.min(200, thresholdScott(values2, min4, max5));\n}\nfunction isTimeThresholds(t) {\n  return isTimeInterval(t) || isIterable(t) && isTemporal(t);\n}\nfunction isTimeInterval(t) {\n  return isInterval(t) && typeof t === \"function\" && t() instanceof Date;\n}\nfunction isInterval(t) {\n  return t ? typeof t.range === \"function\" : false;\n}\nfunction Bin(EX, EY) {\n  return EX && EY ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [ix, [x12, x22]] of EX.entries()) {\n      const Y3 = EY.bin(X3[ix]);\n      for (const [iy, [y12, y22]] of EY.entries()) {\n        yield [Y3[iy], { x1: x12, y1: y12, x2: x22, y2: y22 }];\n      }\n    }\n  } : EX ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [i, [x12, x22]] of EX.entries()) {\n      yield [X3[i], { x1: x12, x2: x22 }];\n    }\n  } : function* (I) {\n    const Y3 = EY.bin(I);\n    for (const [i, [y12, y22]] of EY.entries()) {\n      yield [Y3[i], { y1: y12, y2: y22 }];\n    }\n  };\n}\nfunction bin1(E2, T, V) {\n  T = T.map(coerceNumber);\n  return (I) => {\n    const B3 = E2.map(() => []);\n    for (const i of I)\n      B3[bisect_default(T, V[i]) - 1]?.push(i);\n    return B3;\n  };\n}\nfunction bin1cp(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = 1, n = B3.length; i < n; ++i) {\n      const C3 = B3[i - 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\nfunction bin1cn(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = B3.length - 2; i >= 0; --i) {\n      const C3 = B3[i + 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/identity.js\nfunction maybeIdentityX(options = {}) {\n  const { x: x4, x1: x12, x2: x22 } = options;\n  return x12 === void 0 && x22 === void 0 && x4 === void 0 ? { ...options, x: identity6 } : options;\n}\nfunction maybeIdentityY(options = {}) {\n  const { y: y4, y1: y12, y2: y22 } = options;\n  return y12 === void 0 && y22 === void 0 && y4 === void 0 ? { ...options, y: identity6 } : options;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/stack.js\nfunction stackX(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4, ...rest } = options;\n  const [transform2, Y3, x12, x22] = stackAlias(y4, x4, \"x\", stack2, rest);\n  return { ...transform2, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };\n}\nfunction stackX1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackX2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, , X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackY(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4, ...rest } = options;\n  const [transform2, X3, y12, y22] = stackAlias(x4, y4, \"y\", stack2, rest);\n  return { ...transform2, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };\n}\nfunction stackY1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction stackY2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, , Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction maybeStackX({ x: x4, x1: x12, x2: x22, ...options } = {}) {\n  if (x12 === void 0 && x22 === void 0)\n    return stackX({ x: x4, ...options });\n  [x12, x22] = maybeZero(x4, x12, x22);\n  return { ...options, x1: x12, x2: x22 };\n}\nfunction maybeStackY({ y: y4, y1: y12, y2: y22, ...options } = {}) {\n  if (y12 === void 0 && y22 === void 0)\n    return stackY({ y: y4, ...options });\n  [y12, y22] = maybeZero(y4, y12, y22);\n  return { ...options, y1: y12, y2: y22 };\n}\nfunction mergeOptions2(options) {\n  const { offset: offset2, order, reverse: reverse3, ...rest } = options;\n  return [{ offset: offset2, order, reverse: reverse3 }, rest];\n}\nfunction stack(x4, y4 = one2, ky2, { offset: offset2, order, reverse: reverse3 }, options) {\n  const z = maybeZ(options);\n  const [X3, setX] = maybeColumn(x4);\n  const [Y13, setY1] = column(y4);\n  const [Y23, setY2] = column(y4);\n  offset2 = maybeOffset(offset2);\n  order = maybeOrder(order, offset2, ky2);\n  return [\n    basic(options, (data, facets) => {\n      const X4 = x4 == null ? void 0 : setX(valueof(data, x4));\n      const Y3 = valueof(data, y4, Float64Array);\n      const Z = valueof(data, z);\n      const O = order && order(data, X4, Y3, Z);\n      const n = data.length;\n      const Y14 = setY1(new Float64Array(n));\n      const Y24 = setY2(new Float64Array(n));\n      const facetstacks = [];\n      for (const facet of facets) {\n        const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];\n        if (O)\n          applyOrder(stacks, O);\n        for (const stack2 of stacks) {\n          let yn = 0, yp = 0;\n          if (reverse3)\n            stack2.reverse();\n          for (const i of stack2) {\n            const y5 = Y3[i];\n            if (y5 < 0)\n              yn = Y24[i] = (Y14[i] = yn) + y5;\n            else if (y5 > 0)\n              yp = Y24[i] = (Y14[i] = yp) + y5;\n            else\n              Y24[i] = Y14[i] = yp;\n          }\n        }\n        facetstacks.push(stacks);\n      }\n      if (offset2)\n        offset2(facetstacks, Y14, Y24, Z);\n      return { data, facets };\n    }),\n    X3,\n    Y13,\n    Y23\n  ];\n}\nvar stackAlias = stack;\nfunction maybeOffset(offset2) {\n  if (offset2 == null)\n    return;\n  if (typeof offset2 === \"function\")\n    return offset2;\n  switch (`${offset2}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset2}`);\n}\nfunction extent2(stack2, Y23) {\n  let min4 = 0, max5 = 0;\n  for (const i of stack2) {\n    const y4 = Y23[i];\n    if (y4 < min4)\n      min4 = y4;\n    if (y4 > max5)\n      max5 = y4;\n  }\n  return [min4, max5];\n}\nfunction offsetExpand(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = 1 / (yp - yn || 1);\n        Y13[i] = m3 * (Y13[i] - yn);\n        Y23[i] = m3 * (Y23[i] - yn);\n      }\n    }\n  }\n}\nfunction offsetCenter(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = (yp + yn) / 2;\n        Y13[i] -= m3;\n        Y23[i] -= m3;\n      }\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetWiggle(facetstacks, Y13, Y23, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new InternMap();\n    let y4 = 0;\n    for (const stack2 of stacks) {\n      let j = -1;\n      const Fi = stack2.map((i) => Math.abs(Y23[i] - Y13[i]));\n      const Df = stack2.map((i) => {\n        j = Z ? Z[i] : ++j;\n        const value = Y23[i] - Y13[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...cumsum(Df)];\n      for (const i of stack2) {\n        Y13[i] += y4;\n        Y23[i] += y4;\n      }\n      const s1 = sum(Fi);\n      if (s1)\n        y4 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetZero(stacks, Y13, Y23) {\n  const m3 = min(stacks, (stack2) => min(stack2, (i) => Y13[i]));\n  for (const stack2 of stacks) {\n    for (const i of stack2) {\n      Y13[i] -= m3;\n      Y23[i] -= m3;\n    }\n  }\n}\nfunction offsetCenterFacets(facetstacks, Y13, Y23) {\n  const n = facetstacks.length;\n  if (n === 1)\n    return;\n  const facets = facetstacks.map((stacks) => stacks.flat());\n  const m3 = facets.map((I) => (min(I, (i) => Y13[i]) + max(I, (i) => Y23[i])) / 2);\n  const m0 = min(m3);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m3[j];\n    for (const i of facets[j]) {\n      Y13[i] += p;\n      Y23[i] += p;\n    }\n  }\n}\nfunction maybeOrder(order, offset2, ky2) {\n  if (order === void 0 && offset2 === offsetWiggle)\n    return orderInsideOut;\n  if (order == null)\n    return;\n  if (typeof order === \"string\") {\n    switch (order.toLowerCase()) {\n      case \"value\":\n      case ky2:\n        return orderY;\n      case \"z\":\n        return orderZ;\n      case \"sum\":\n        return orderSum;\n      case \"appearance\":\n        return orderAppearance;\n      case \"inside-out\":\n        return orderInsideOut;\n    }\n    return orderFunction(field(order));\n  }\n  if (typeof order === \"function\")\n    return orderFunction(order);\n  if (Array.isArray(order))\n    return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\nfunction orderY(data, X3, Y3) {\n  return Y3;\n}\nfunction orderZ(order, X3, Y3, Z) {\n  return Z;\n}\nfunction orderSum(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => sum(I, (i) => Y3[i]), (i) => Z[i]));\n}\nfunction orderAppearance(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => X3[greatest(I, (i) => Y3[i])], (i) => Z[i]));\n}\nfunction orderInsideOut(data, X3, Y3, Z) {\n  const I = range4(data);\n  const K2 = groupSort(I, (I2) => X3[greatest(I2, (i) => Y3[i])], (i) => Z[i]);\n  const sums = rollup(I, (I2) => sum(I2, (i) => Y3[i]), (i) => Z[i]);\n  const Kp = [], Kn = [];\n  let s2 = 0;\n  for (const k2 of K2) {\n    if (s2 < 0) {\n      s2 += sums.get(k2);\n      Kp.push(k2);\n    } else {\n      s2 -= sums.get(k2);\n      Kn.push(k2);\n    }\n  }\n  return orderZDomain(Z, Kn.reverse().concat(Kp));\n}\nfunction orderFunction(f) {\n  return (data) => valueof(data, f);\n}\nfunction orderGiven(domain) {\n  return (data, X3, Y3, Z) => orderZDomain(Z, domain);\n}\nfunction orderZDomain(Z, domain) {\n  if (!Z)\n    throw new Error(\"missing channel: z\");\n  domain = new InternMap(domain.map((d, i) => [d, i]));\n  return Z.map((z) => domain.get(z));\n}\nfunction applyOrder(stacks, O) {\n  for (const stack2 of stacks) {\n    stack2.sort((i, j) => ascendingDefined2(O[i], O[j]));\n  }\n}\n\n// node_modules/@observablehq/plot/dist/marks/area.js\nvar defaults5 = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Area = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, z, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults5);\n    this.z = z;\n    this.curve = Curve(curve, tension);\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call((g) => g.selectAll().data(groupIndex(index3, [X13, Y13, X23, Y23], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(\"d\", area_default5().curve(this.curve).defined((i) => i >= 0).x0((i) => X13[i]).y0((i) => Y13[i]).x1((i) => X23[i]).y1((i) => Y23[i]))).node();\n  }\n};\nfunction area(data, options) {\n  if (options === void 0)\n    return areaY(data, { x: first, y: second2 });\n  return new Area(data, options);\n}\nfunction areaX(data, options) {\n  const { y: y4 = indexOf, ...rest } = maybeDenseIntervalY(options);\n  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y4, y2: void 0 })));\n}\nfunction areaY(data, options) {\n  const { x: x4 = indexOf, ...rest } = maybeDenseIntervalX(options);\n  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x4, x2: void 0 })));\n}\n\n// node_modules/@observablehq/plot/dist/marks/marker.js\nfunction markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {\n  mark.markerStart = maybeMarker(markerStart);\n  mark.markerMid = maybeMarker(markerMid);\n  mark.markerEnd = maybeMarker(markerEnd);\n}\nfunction maybeMarker(marker) {\n  if (marker == null || marker === false)\n    return null;\n  if (marker === true)\n    return markerCircleFill;\n  if (typeof marker === \"function\")\n    return marker;\n  switch (`${marker}`.toLowerCase()) {\n    case \"none\":\n      return null;\n    case \"arrow\":\n      return markerArrow;\n    case \"dot\":\n      return markerDot;\n    case \"circle\":\n    case \"circle-fill\":\n      return markerCircleFill;\n    case \"circle-stroke\":\n      return markerCircleStroke;\n  }\n  throw new Error(`invalid marker: ${marker}`);\n}\nfunction markerArrow(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"orient\", \"auto\").attr(\"fill\", \"none\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).attr(\"stroke-linecap\", \"round\").attr(\"stroke-linejoin\", \"round\").call((marker) => marker.append(\"path\").attr(\"d\", \"M-1.5,-3l3,3l-3,3\")).node();\n}\nfunction markerDot(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"none\").call((marker) => marker.append(\"circle\").attr(\"r\", 2.5)).node();\n}\nfunction markerCircleFill(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"white\").attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nfunction markerCircleStroke(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", \"white\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nvar nextMarkerId = 0;\nfunction applyMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && ((i) => S[i]));\n}\nfunction applyGroupedMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && (([i]) => S[i]));\n}\nfunction applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke) {\n  const iriByMarkerColor = /* @__PURE__ */ new Map();\n  function applyMarker(marker) {\n    return function(i) {\n      const color3 = strokeof(i);\n      let iriByColor = iriByMarkerColor.get(marker);\n      if (!iriByColor)\n        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());\n      let iri = iriByColor.get(color3);\n      if (!iri) {\n        const context = { document: this.ownerDocument };\n        const node = this.parentNode.insertBefore(marker(color3, context), this);\n        const id2 = `plot-marker-${++nextMarkerId}`;\n        node.setAttribute(\"id\", id2);\n        iriByColor.set(color3, iri = `url(#${id2})`);\n      }\n      return iri;\n    };\n  }\n  if (markerStart)\n    path2.attr(\"marker-start\", applyMarker(markerStart));\n  if (markerMid)\n    path2.attr(\"marker-mid\", applyMarker(markerMid));\n  if (markerEnd)\n    path2.attr(\"marker-end\", applyMarker(markerEnd));\n}\n\n// node_modules/@observablehq/plot/dist/marks/link.js\nvar defaults6 = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Link = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults6);\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", curve === curveAuto && context.projection ? sphereLink(context.projection, X13, Y13, X23, Y23) : (i) => {\n      const p = pathRound();\n      const c6 = curve(p);\n      c6.lineStart();\n      c6.point(X13[i], Y13[i]);\n      c6.point(X23[i], Y23[i]);\n      c6.lineEnd();\n      return p;\n    }).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels)).node();\n  }\n};\nfunction sphereLink(projection2, X13, Y13, X23, Y23) {\n  const path2 = path_default(projection2);\n  X13 = coerceNumbers(X13);\n  Y13 = coerceNumbers(Y13);\n  X23 = coerceNumbers(X23);\n  Y23 = coerceNumbers(Y23);\n  return (i) => path2({\n    type: \"LineString\",\n    coordinates: [\n      [X13[i], Y13[i]],\n      [X23[i], Y23[i]]\n    ]\n  });\n}\nfunction link3(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Link(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\nfunction maybeSameValue(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [x22];\n    } else {\n      if (x22 === void 0)\n        return [x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/marks/arrow.js\nvar defaults7 = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\nvar Arrow = class extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1: x12,\n      y1: y12,\n      x2: x22,\n      y2: y22,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8,\n      // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset\n    } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults7);\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13, SW } = channels;\n    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;\n    const sw = SW ? (i) => SW[i] : constant2(strokeWidth === void 0 ? 1 : strokeWidth);\n    const bendAngle = bend * radians3;\n    const wingAngle = headAngle * radians3 / 2;\n    const wingScale = headLength / 1.5;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => {\n      let x12 = X13[i], y12 = Y13[i], x22 = X23[i], y22 = Y23[i];\n      const lineLength = Math.hypot(x22 - x12, y22 - y12);\n      if (lineLength <= insetStart + insetEnd)\n        return null;\n      let lineAngle = Math.atan2(y22 - y12, x22 - x12);\n      const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);\n      const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n      if (insetStart || insetEnd) {\n        if (r < 1e5) {\n          const sign3 = Math.sign(bendAngle);\n          const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r, sign3);\n          if (insetStart) {\n            [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));\n          }\n          if (insetEnd) {\n            const [x5, y5] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign3 * Math.sign(insetEnd));\n            lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);\n            x22 = x5, y22 = y5;\n          }\n        } else {\n          const dx = x22 - x12, dy = y22 - y12, d = Math.hypot(dx, dy);\n          if (insetStart)\n            x12 += dx / d * insetStart, y12 += dy / d * insetStart;\n          if (insetEnd)\n            x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;\n        }\n      }\n      const endAngle = lineAngle + bendAngle;\n      const leftAngle = endAngle + wingAngle;\n      const rightAngle = endAngle - wingAngle;\n      const x32 = x22 - headLength2 * Math.cos(leftAngle);\n      const y32 = y22 - headLength2 * Math.sin(leftAngle);\n      const x4 = x22 - headLength2 * Math.cos(rightAngle);\n      const y4 = y22 - headLength2 * Math.sin(rightAngle);\n      return `M${x12},${y12}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x4},${y4}`;\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction pointPointCenter([ax, ay], [bx, by], r, sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const k2 = sign3 * Math.sqrt(r * r - d * d / 4) / d;\n  return [(ax + bx) / 2 - dy * k2, (ay + by) / 2 + dx * k2];\n}\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const x4 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y4 = sign3 * Math.sqrt(ar * ar - x4 * x4);\n  return [ax + (dx * x4 + dy * y4) / d, ay + (dy * x4 - dx * y4) / d];\n}\nfunction arrow(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Arrow(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/dot.js\nvar defaults8 = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\nfunction withDefaultSort(options) {\n  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: \"r\", order: \"descending\" }, options) : options;\n}\nvar Dot = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r, rotate, symbol: symbol2 = circle_default3, frameAnchor } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);\n    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true },\n      rotate: { value: vrotate, optional: true },\n      symbol: { value: vsymbol, scale: \"auto\", optional: true }\n    }, withDefaultSort(options), defaults8);\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    const { channels } = this;\n    const { symbol: symbolChannel } = channels;\n    if (symbolChannel) {\n      const { fill: fillChannel, stroke: strokeChannel } = channels;\n      symbolChannel.hint = {\n        fill: fillChannel ? fillChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.fill,\n        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.stroke\n      };\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, r: R, rotate: A5, symbol: S } = channels;\n    const { r, rotate, symbol: symbol2 } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const circle2 = this.symbol === circle_default3;\n    const size = R ? void 0 : r * r * Math.PI;\n    if (negative(r))\n      index3 = [];\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(circle2 ? \"circle\" : \"path\").call(applyDirectStyles, this).call(circle2 ? (selection2) => {\n      selection2.attr(\"cx\", X3 ? (i) => X3[i] : cx).attr(\"cy\", Y3 ? (i) => Y3[i] : cy).attr(\"r\", R ? (i) => R[i] : r);\n    } : (selection2) => {\n      selection2.attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}`).attr(\"d\", R && S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : R ? (i) => {\n        const p = pathRound();\n        symbol2.draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, size);\n        return p;\n      } : (() => {\n        const p = pathRound();\n        symbol2.draw(p, size);\n        return p;\n      })());\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction dot(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Dot(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction dotX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction dotY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction circle(data, options) {\n  return dot(data, { ...options, symbol: \"circle\" });\n}\nfunction hexagon(data, options) {\n  return dot(data, { ...options, symbol: \"hexagon\" });\n}\n\n// node_modules/@observablehq/plot/dist/marks/line.js\nvar defaults9 = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Line = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults9);\n    this.z = z;\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  filter(index3) {\n    return index3;\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(groupIndex(index3, [X3, Y3], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels).attr(\"d\", curve === curveAuto && context.projection ? sphereLine(context.projection, X3, Y3) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i]))).node();\n  }\n};\nfunction sphereLine(projection2, X3, Y3) {\n  const path2 = path_default(projection2);\n  X3 = coerceNumbers(X3);\n  Y3 = coerceNumbers(Y3);\n  return (I) => {\n    let line2 = [];\n    const lines = [line2];\n    for (const i of I) {\n      if (i === -1) {\n        line2 = [];\n        lines.push(line2);\n      } else {\n        line2.push([X3[i], Y3[i]]);\n      }\n    }\n    return path2({ type: \"MultiLineString\", coordinates: lines });\n  };\n}\nfunction line(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Line(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction lineX(data, options = {}) {\n  const { x: x4 = identity6, y: y4 = indexOf, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4 }));\n}\nfunction lineY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4 }));\n}\n\n// node_modules/@observablehq/plot/dist/marks/bar.js\nvar AbstractBar = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    super(data, channels, options, defaults21);\n    const { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", this._x(scales, channels, dimensions)).attr(\"width\", this._width(scales, channels, dimensions)).attr(\"y\", this._y(scales, channels, dimensions)).attr(\"height\", this._height(scales, channels, dimensions)).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n  _x(scales, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _y(scales, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _width({ x: x4 }, { x: X3 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    const bandwidth = X3 && x4 ? x4.bandwidth() : width - marginRight - marginLeft;\n    return Math.max(0, bandwidth - insetLeft - insetRight);\n  }\n  _height({ y: y4 }, { y: Y3 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    const bandwidth = Y3 && y4 ? y4.bandwidth() : height - marginTop - marginBottom;\n    return Math.max(0, bandwidth - insetTop - insetBottom);\n  }\n};\nvar defaults10 = {\n  ariaLabel: \"bar\"\n};\nvar BarX = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4 } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      x2: { value: x22, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, 0, 0);\n  }\n  _x({ x: x4 }, { x1: X13, x2: X23 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return isCollapsed(x4) ? marginLeft + insetLeft : (i) => Math.min(X13[i], X23[i]) + insetLeft;\n  }\n  _width({ x: x4 }, { x1: X13, x2: X23 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    return isCollapsed(x4) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight);\n  }\n};\nvar BarY = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22 } = options;\n    super(data, {\n      y1: { value: y12, scale: \"y\" },\n      y2: { value: y22, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, 0);\n  }\n  _y({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop }) {\n    const { insetTop } = this;\n    return isCollapsed(y4) ? marginTop + insetTop : (i) => Math.min(Y13[i], Y23[i]) + insetTop;\n  }\n  _height({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    return isCollapsed(y4) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y23[i] - Y13[i]) - insetTop - insetBottom);\n  }\n};\nfunction barX(data, options = { y: indexOf, x2: identity6 }) {\n  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));\n}\nfunction barY(data, options = { x: indexOf, y2: identity6 }) {\n  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/rect.js\nvar defaults11 = {\n  ariaLabel: \"rect\"\n};\nvar Rect = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults11);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x1: X13, y1: Y13, x2: X23, y2: Y23 } = channels;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { projection: projection2 } = context;\n    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X13 && X23 && x4, y: Y13 && Y23 && y4 }, 0, 0).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.min(X13[i], X23[i]) + insetLeft : marginLeft + insetLeft).attr(\"y\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.min(Y13[i], Y23[i]) + insetTop : marginTop + insetTop).attr(\"width\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft).attr(\"height\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.max(0, Math.abs(Y13[i] - Y23[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction rect(data, options) {\n  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));\n}\nfunction rectX(data, options = { y: indexOf, interval: 1, x2: identity6 }) {\n  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));\n}\nfunction rectY(data, options = { x: indexOf, interval: 1, y2: identity6 }) {\n  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/cell.js\nvar defaults12 = {\n  ariaLabel: \"cell\"\n};\nvar Cell = class extends AbstractBar {\n  constructor(data, { x: x4, y: y4, ...options } = {}) {\n    super(data, {\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults12);\n  }\n  _transform(selection2, mark) {\n    selection2.call(applyTransform, mark, {}, 0, 0);\n  }\n};\nfunction cell(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Cell(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction cellX(data, options = {}) {\n  let { x: x4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, x: x4, fill, stroke });\n}\nfunction cellY(data, options = {}) {\n  let { y: y4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, y: y4, fill, stroke });\n}\n\n// node_modules/@observablehq/plot/dist/marks/auto.js\nfunction autoSpec(data, options) {\n  options = normalizeOptions(options);\n  let {\n    fx,\n    fy,\n    x: { value: xValue, reduce: xReduce, zero: xZero, ...xOptions },\n    y: { value: yValue, reduce: yReduce, zero: yZero, ...yOptions },\n    color: { value: colorValue, color: colorColor, reduce: colorReduce },\n    size: { value: sizeValue, reduce: sizeReduce },\n    // TODO constant radius?\n    mark\n  } = options;\n  const { x: x4, y: y4 } = options;\n  let X3, Y3;\n  if (xReduce === void 0)\n    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === void 0)\n    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n  if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3 ??= materializeValue(data, x4))) && (yValue == null || isOrdinal(Y3 ??= materializeValue(data, y4)))) {\n    sizeReduce = \"count\";\n  }\n  if (xZero === void 0)\n    xZero = isZeroReducer(xReduce) ? true : void 0;\n  if (yZero === void 0)\n    yZero = isZeroReducer(yReduce) ? true : void 0;\n  if (xValue == null && yValue == null)\n    throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null)\n    throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null)\n    throw new Error(\"reducing y requires x\");\n  if (mark === void 0) {\n    mark = sizeValue != null || sizeReduce != null ? \"dot\" : xZero || yZero || colorReduce != null ? \"bar\" : xValue != null && yValue != null ? isOrdinal(X3 ??= materializeValue(data, x4)) || isOrdinal(Y3 ??= materializeValue(data, y4)) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? \"dot\" : \"line\" : xValue != null || yValue != null ? \"rule\" : null;\n  }\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      ...xZero !== void 0 && { zero: xZero },\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      ...yZero !== void 0 && { zero: yZero },\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...colorColor !== void 0 && { color: colorColor }\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark\n  };\n}\nfunction auto(data, options) {\n  options = normalizeOptions(options);\n  const { x: x4, y: y4, color: color3, size } = options;\n  const X3 = materializeValue(data, x4);\n  const Y3 = materializeValue(data, y4);\n  const C3 = materializeValue(data, color3);\n  const S = materializeValue(data, size);\n  let { fx, fy, x: { reduce: xReduce, zero: xZero, ...xOptions }, y: { reduce: yReduce, zero: yZero, ...yOptions }, color: { color: colorColor, reduce: colorReduce }, size: { reduce: sizeReduce }, mark } = autoSpec(data, {\n    ...options,\n    x: { ...x4, value: X3 },\n    y: { ...y4, value: Y3 },\n    color: { ...color3, value: C3 },\n    size: { ...size, value: S }\n  });\n  let Z;\n  let colorMode;\n  if (mark != null) {\n    switch (`${mark}`.toLowerCase()) {\n      case \"dot\":\n        mark = dot;\n        colorMode = \"stroke\";\n        break;\n      case \"line\":\n        mark = X3 && Y3 ? line : X3 ? lineX : lineY;\n        colorMode = \"stroke\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"area\":\n        mark = yZero ? areaY : xZero || Y3 && isMonotonic(Y3) ? areaX : areaY;\n        colorMode = \"fill\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"rule\":\n        mark = X3 ? ruleX : ruleY;\n        colorMode = \"stroke\";\n        break;\n      case \"bar\":\n        mark = yZero ? isOrdinalReduced(xReduce, X3) ? barY : rectY : xZero ? isOrdinalReduced(yReduce, Y3) ? barX : rectX : isOrdinalReduced(xReduce, X3) && isOrdinalReduced(yReduce, Y3) ? cell : isOrdinalReduced(xReduce, X3) ? barY : isOrdinalReduced(yReduce, Y3) ? barX : rect;\n        colorMode = \"fill\";\n        break;\n      default:\n        throw new Error(`invalid mark: ${mark}`);\n    }\n  }\n  let markOptions = {\n    fx,\n    fy,\n    x: X3 ?? void 0,\n    y: Y3 ?? void 0,\n    [colorMode]: C3 ?? colorColor,\n    z: Z,\n    r: S ?? void 0\n    // treat null size as undefined for default constant radius\n  };\n  let transform2;\n  let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`);\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transform2 = isOrdinal(X3) ? groupX : binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transform2 = isOrdinal(Y3) ? groupY : binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X3 && Y3) {\n      transform2 = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin2;\n    } else if (X3) {\n      transform2 = isOrdinal(X3) ? groupX : binX;\n    } else if (Y3) {\n      transform2 = isOrdinal(Y3) ? groupY : binY;\n    }\n  }\n  if (transform2) {\n    if (transform2 === bin2 || transform2 === binX)\n      markOptions.x = { value: X3, ...xOptions };\n    if (transform2 === bin2 || transform2 === binY)\n      markOptions.y = { value: Y3, ...yOptions };\n    markOptions = transform2(transformOptions, markOptions);\n  }\n  if (xZero === void 0)\n    xZero = transform2 !== binX && (mark === barX || mark === areaX || mark === rectX);\n  if (yZero === void 0)\n    yZero = transform2 !== binY && (mark === barY || mark === areaY || mark === rectY);\n  const frames = fx != null || fy != null ? frame2({ strokeOpacity: 0.1 }) : null;\n  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];\n  mark = mark(data, markOptions);\n  return colorMode === \"stroke\" ? marks(frames, rules, mark) : marks(frames, mark, rules);\n}\nfunction isMonotonic(values2) {\n  let previous;\n  let previousOrder;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (previous === void 0) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign(ascending(previous, value));\n    if (!order)\n      continue;\n    if (previousOrder !== void 0 && order !== previousOrder)\n      return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\nfunction normalizeOptions({ x: x4, y: y4, color: color3, size, fx, fy, mark } = {}) {\n  if (!isOptions(x4))\n    x4 = makeOptions(x4);\n  if (!isOptions(y4))\n    y4 = makeOptions(y4);\n  if (!isOptions(color3))\n    color3 = isColor(color3) ? { color: color3 } : makeOptions(color3);\n  if (!isOptions(size))\n    size = makeOptions(size);\n  if (isOptions(fx))\n    ({ value: fx } = makeOptions(fx));\n  if (isOptions(fy))\n    ({ value: fy } = makeOptions(fy));\n  return { x: x4, y: y4, color: color3, size, fx, fy, mark };\n}\nfunction materializeValue(data, options) {\n  const V = valueof(data, options.value);\n  if (V)\n    V.label = labelof(options.value);\n  return V;\n}\nfunction makeOptions(value) {\n  return isReducer(value) ? { reduce: value } : { value };\n}\nfunction isZeroReducer(reduce2) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce2);\n}\nfunction isSelectReducer(reduce2) {\n  return /^(?:first|last|mode)$/i.test(reduce2);\n}\nfunction isOrdinalReduced(reduce2, value) {\n  return reduce2 != null && !isSelectReducer(reduce2) || !value ? false : isOrdinal(value);\n}\nfunction isReducer(reduce2) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return true;\n  if (/^p\\d{2}$/i.test(reduce2))\n    return true;\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\":\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\":\n    case \"max\":\n    case \"max-index\":\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      return true;\n  }\n  return false;\n}\nfunction isHighCardinality(value) {\n  return value ? new InternSet(value).size > value.length >> 1 : false;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/map.js\nfunction mapX(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"x\", \"x1\", \"x2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction mapY(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"y\", \"y1\", \"y2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction map5(outputs = {}, options = {}) {\n  const z = maybeZ(options);\n  const channels = Object.entries(outputs).map(([key, map6]) => {\n    const input = maybeInput(key, options);\n    if (input == null)\n      throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = column(input);\n    return { key, input, output, setOutput, map: maybeMap(map6) };\n  });\n  return {\n    ...basic(options, (data, facets) => {\n      const Z = valueof(data, z);\n      const X3 = channels.map(({ input }) => valueof(data, input));\n      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n          channels.forEach(({ map: map6 }, i) => map6.map(I, X3[i], MX[i]));\n        }\n      }\n      return { data, facets };\n    }),\n    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))\n  };\n}\nvar mapAlias = map5;\nfunction maybeMap(map6) {\n  if (map6 && typeof map6.map === \"function\")\n    return map6;\n  if (typeof map6 === \"function\")\n    return mapFunction(map6);\n  switch (`${map6}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction(rank);\n    case \"quantile\":\n      return mapFunction(rankQuantile);\n  }\n  throw new Error(`invalid map: ${map6}`);\n}\nfunction rankQuantile(V) {\n  const n = count(V) - 1;\n  return rank(V).map((r) => r / n);\n}\nfunction mapFunction(f) {\n  return {\n    map(I, S, T) {\n      const M2 = f(take(S, I));\n      if (M2.length !== I.length)\n        throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i)\n        T[I[i]] = M2[i];\n    }\n  };\n}\nvar mapCumsum = {\n  map(I, S, T) {\n    let sum5 = 0;\n    for (const i of I)\n      T[i] = sum5 += S[i];\n  }\n};\n\n// node_modules/@observablehq/plot/dist/marks/tick.js\nvar defaults13 = {\n  ariaLabel: \"tick\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar AbstractTick = class extends Mark {\n  constructor(data, channels, options) {\n    super(data, channels, options, defaults13);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", this._x1(scales, channels, dimensions)).attr(\"x2\", this._x2(scales, channels, dimensions)).attr(\"y1\", this._y1(scales, channels, dimensions)).attr(\"y2\", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar TickX = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, offset, 0);\n  }\n  _x1(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _x2(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _y1({ y: y4 }, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 && y4 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _y2({ y: y4 }, { y: Y3 }, { height, marginBottom }) {\n    const { insetBottom } = this;\n    return Y3 && y4 ? (i) => Y3[i] + y4.bandwidth() - insetBottom : height - marginBottom - insetBottom;\n  }\n};\nvar TickY = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, offset);\n  }\n  _x1({ x: x4 }, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 && x4 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _x2({ x: x4 }, { x: X3 }, { width, marginRight }) {\n    const { insetRight } = this;\n    return X3 && x4 ? (i) => X3[i] + x4.bandwidth() - insetRight : width - marginRight - insetRight;\n  }\n  _y1(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n  _y2(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n};\nfunction tickX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new TickX(data, { ...remainingOptions, x: x4 });\n}\nfunction tickY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new TickY(data, { ...remainingOptions, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/box.js\nfunction boxX(data, options = {}) {\n  const { x: x4 = { transform: (x5) => x5 }, y: y4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = y4 != null ? groupY : groupZ;\n  return marks(ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barX(data, group3({ x1: \"p25\", x2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickX(data, group3({ x: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ x: oqr }, { x: x4, y: y4, z: y4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction boxY(data, options = {}) {\n  const { y: y4 = { transform: (y5) => y5 }, x: x4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = x4 != null ? groupX : groupZ;\n  return marks(ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barY(data, group3({ y1: \"p25\", y2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickY(data, group3({ y: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ y: oqr }, { x: x4, y: y4, z: x4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction oqr(values2) {\n  const r1 = loqr1(values2);\n  const r2 = hiqr2(values2);\n  return values2.map((v2) => v2 < r1 || v2 > r2 ? v2 : NaN);\n}\nfunction loqr1(values2, value) {\n  const lo = quartile1(values2, value) * 2.5 - quartile3(values2, value) * 1.5;\n  return min(values2, (d) => d >= lo ? d : NaN);\n}\nfunction hiqr2(values2, value) {\n  const hi = quartile3(values2, value) * 2.5 - quartile1(values2, value) * 1.5;\n  return max(values2, (d) => d <= hi ? d : NaN);\n}\nfunction quartile1(values2, value) {\n  return quantile(values2, 0.25, value);\n}\nfunction quartile3(values2, value) {\n  return quantile(values2, 0.75, value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/raster.js\nvar defaults14 = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\nfunction number6(input, name) {\n  const x4 = +input;\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nfunction integer(input, name) {\n  const x4 = Math.floor(input);\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nvar AbstractRaster = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    let { width, height, x: x4, y: y4, x1: x12 = x4 == null ? 0 : void 0, y1: y12 = y4 == null ? 0 : void 0, x2: x22 = x4 == null ? width : void 0, y2: y22 = y4 == null ? height : void 0, pixelSize = defaults21.pixelSize, blur: blur3 = 0, interpolate } = options;\n    if (width != null)\n      width = integer(width, \"width\");\n    if (height != null)\n      height = integer(height, \"height\");\n    if (x12 != null)\n      x12 = number6(x12, \"x1\");\n    if (y12 != null)\n      y12 = number6(y12, \"y1\");\n    if (x22 != null)\n      x22 = number6(x22, \"x2\");\n    if (y22 != null)\n      y22 = number6(y22, \"y2\");\n    if (x4 == null && (x12 == null || x22 == null))\n      throw new Error(\"missing x\");\n    if (y4 == null && (y12 == null || y22 == null))\n      throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      if (x4 === void 0 && x12 != null && x22 != null)\n        x4 = denseX(x12, x22, width, height);\n      if (y4 === void 0 && y12 != null && y22 != null)\n        y4 = denseY(y12, y22, width, height);\n    }\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12 == null ? null : [x12], scale: \"x\", optional: true, filter: null },\n      y1: { value: y12 == null ? null : [y12], scale: \"y\", optional: true, filter: null },\n      x2: { value: x22 == null ? null : [x22], scale: \"x\", optional: true, filter: null },\n      y2: { value: y22 == null ? null : [y22], scale: \"y\", optional: true, filter: null },\n      ...channels\n    }, options, defaults21);\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number6(pixelSize, \"pixelSize\");\n    this.blur = number6(blur3, \"blur\");\n    this.interpolate = x4 == null || y4 == null ? null : maybeInterpolate(interpolate);\n  }\n};\nvar Raster = class extends AbstractRaster {\n  constructor(data, options = {}) {\n    const { imageRendering } = options;\n    if (data == null) {\n      const { fill, fillOpacity } = options;\n      if (maybeNumberChannel(fillOpacity)[0] !== void 0)\n        options = sampler(\"fillOpacity\", options);\n      if (maybeColorChannel(fill)[0] !== void 0)\n        options = sampler(\"fill\", options);\n    }\n    super(data, void 0, options, defaults14);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, { color: color3, ...scales }, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const color3 = scales.color ?? ((x4) => x4);\n    const { x: X3, y: Y3 } = channels;\n    const { document: document2 } = context;\n    const [x12, y12, x22, y22] = renderBounds(channels, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const n = w * h;\n    let { fill: F, fillOpacity: FO } = channels;\n    let offset2 = 0;\n    if (this.interpolate) {\n      const kx2 = w / dx;\n      const ky2 = h / dy;\n      const IX = map4(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map4(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      if (F)\n        F = this.interpolate(index3, w, h, IX, IY, F);\n      if (FO)\n        FO = this.interpolate(index3, w, h, IX, IY, FO);\n    } else if (this.data == null && index3)\n      offset2 = index3.fi * n;\n    const canvas = document2.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image2 = context2d.createImageData(w, h);\n    const imageData = image2.data;\n    let { r, g, b } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };\n    let a4 = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color3(F[i + offset2]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({ r, g, b } = rgb(fi));\n      }\n      if (FO)\n        a4 = FO[i + offset2] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a4;\n    }\n    if (this.blur > 0)\n      blurImage(image2, this.blur);\n    context2d.putImageData(image2, 0, 0);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g2) => g2.append(\"image\").attr(\"transform\", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr(\"width\", Math.abs(dx)).attr(\"height\", Math.abs(dy)).attr(\"preserveAspectRatio\", \"none\").call(applyAttr, \"image-rendering\", this.imageRendering).call(applyDirectStyles, this).attr(\"xlink:href\", canvas.toDataURL())).node();\n  }\n};\nfunction maybeTuples(k2, data, options) {\n  if (arguments.length < 3)\n    options = data, data = null;\n  let { x: x4, y: y4, [k2]: z, ...rest } = options;\n  if (x4 === void 0 && y4 === void 0 && isTuples(data)) {\n    x4 = first, y4 = second2;\n    if (z === void 0)\n      z = third;\n  }\n  return [data, { ...rest, x: x4, y: y4, [k2]: z }];\n}\nfunction raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(data, data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity6 });\n}\nfunction renderBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, dimensions, { projection: projection2 }) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return [\n    x12 && projection2 == null ? x12[0] : marginLeft,\n    y12 && projection2 == null ? y12[0] : marginTop,\n    x22 && projection2 == null ? x22[0] : width - marginRight,\n    y22 && projection2 == null ? y22[0] : height - marginBottom\n  ];\n}\nfunction rasterBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, scales, dimensions, context) {\n  const channels = {};\n  if (x12)\n    channels.x1 = x12;\n  if (y12)\n    channels.y1 = y12;\n  if (x22)\n    channels.x2 = x22;\n  if (y22)\n    channels.y2 = y22;\n  return renderBounds(valueObject(channels, scales), dimensions, context);\n}\nfunction sampler(name, options = {}) {\n  const { [name]: value } = options;\n  if (typeof value !== \"function\")\n    throw new Error(`invalid ${name}: not a function`);\n  return initializer({ ...options, [name]: void 0 }, function(data, facets, channels, scales, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    if (!x4)\n      throw new Error(\"missing scale: x\");\n    if (!y4)\n      throw new Error(\"missing scale: y\");\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2 } = this;\n    const { width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = options;\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx2 = dx / w;\n    const ky2 = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [void 0]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x4.invert(x12 + xi * kx2), y4.invert(y12 + yi * ky2), facet);\n        }\n      }\n    }\n    return { data: V, facets, channels: { [name]: { value: V, scale: true } } };\n  });\n}\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\")\n    return interpolate;\n  if (interpolate == null)\n    return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\nfunction interpolateNone(index3, width, height, X3, Y3, V) {\n  const W = new Array(width * height);\n  for (const i of index3) {\n    if (X3[i] < 0 || X3[i] >= width || Y3[i] < 0 || Y3[i] >= height)\n      continue;\n    W[Math.floor(Y3[i]) * width + Math.floor(X3[i])] = V[i];\n  }\n  return W;\n}\nfunction interpolatorBarycentric({ random = lcg(42) } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const n = index3.length;\n    const nw = width >> 2;\n    const nh = (height >> 2) - 1;\n    const m3 = n + nw * 2 + nh * 2;\n    const XY2 = new Float64Array(m3 * 2);\n    for (let i2 = 0; i2 < n; ++i2)\n      XY2[i2 * 2] = X3[index3[i2]], XY2[i2 * 2 + 1] = Y3[index3[i2]];\n    let i = n;\n    const addPoint = (x4, y4) => (XY2[i * 2] = x4, XY2[i * 2 + 1] = y4, i++);\n    for (let j = 0; j <= nw; ++j)\n      addPoint(j / nw * width, 0), addPoint(j / nw * width, height);\n    for (let j = 0; j < nh; ++j)\n      addPoint(width, j / nh * height), addPoint(0, j / nh * height);\n    V = take(V, index3);\n    const delaunay = new Delaunay(XY2.subarray(0, n * 2));\n    for (let j = n, ij; j < m3; ++j)\n      V[j] = V[ij = delaunay.find(XY2[j * 2], XY2[j * 2 + 1], ij)];\n    const { points, triangles } = new Delaunay(XY2);\n    const W = new V.constructor(width * height);\n    const mix = mixer(V, random);\n    for (let i2 = 0; i2 < triangles.length; i2 += 3) {\n      const ta = triangles[i2];\n      const tb = triangles[i2 + 1];\n      const tc = triangles[i2 + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x12 = Math.min(Ax, Bx, Cx);\n      const x22 = Math.max(Ax, Bx, Cx);\n      const y12 = Math.min(Ay, By, Cy);\n      const y22 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z)\n        continue;\n      const va = V[ta];\n      const vb = V[tb];\n      const vc = V[tc];\n      for (let x4 = Math.floor(x12); x4 < x22; ++x4) {\n        for (let y4 = Math.floor(y12); y4 < y22; ++y4) {\n          if (x4 < 0 || x4 >= width || y4 < 0 || y4 >= height)\n            continue;\n          const xp = x4 + 0.5;\n          const yp = y4 + 0.5;\n          const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z;\n          if (ga < 0)\n            continue;\n          const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z;\n          if (gb < 0)\n            continue;\n          const gc = 1 - ga - gb;\n          if (gc < 0)\n            continue;\n          W[x4 + width * y4] = mix(va, ga, vb, gb, vc, gc, x4, y4);\n        }\n      }\n    }\n    return W;\n  };\n}\nfunction interpolateNearest(index3, width, height, X3, Y3, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n  let iy, ix;\n  for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n    ix = iy;\n    for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n      ix = delaunay.find(x4, y4, ix);\n      if (x4 === 0.5)\n        iy = ix;\n      W[k2] = V[index3[ix]];\n    }\n  }\n  return W;\n}\nfunction interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n    let iy, ix, iw;\n    for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n      ix = iy;\n      for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n        let cx = x4;\n        let cy = y4;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x4 === 0.5)\n          iy = ix;\n        let distance;\n        let step = 0;\n        while ((distance = Math.hypot(X3[index3[iw]] - cx, Y3[index3[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle2 = random(x4, y4, step) * 2 * Math.PI;\n          cx += Math.cos(angle2) * distance;\n          cy += Math.sin(angle2) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k2] = V[index3[iw]];\n      }\n    }\n    return W;\n  };\n}\nfunction blend(a4, ca3, b, cb, c6, cc2) {\n  return ca3 * a4 + cb * b + cc2 * c6;\n}\nfunction pick(random) {\n  return (a4, ca3, b, cb, c6, cc2, x4, y4) => {\n    const u4 = random(x4, y4);\n    return u4 < ca3 ? a4 : u4 < ca3 + cb ? b : c6;\n  };\n}\nfunction mixer(F, random) {\n  return isNumeric(F) || isTemporal(F) ? blend : pick(random);\n}\nfunction denseX(x12, x22, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X3 = new Float64Array(n);\n      const kx2 = (x22 - x12) / width;\n      const x06 = x12 + kx2 / 2;\n      for (let i = 0; i < n; ++i)\n        X3[i] = i % width * kx2 + x06;\n      return X3;\n    }\n  };\n}\nfunction denseY(y12, y22, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y3 = new Float64Array(n);\n      const ky2 = (y22 - y12) / height;\n      const y06 = y12 + ky2 / 2;\n      for (let i = 0; i < n; ++i)\n        Y3[i] = Math.floor(i / width) % height * ky2 + y06;\n      return Y3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/contour.js\nvar defaults15 = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\nvar Contour = class extends AbstractRaster {\n  constructor(data, { smooth = true, value, ...options } = {}) {\n    const channels = styles({}, options, defaults15);\n    if (value === void 0) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== void 0)\n            throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n    if (value != null) {\n      const v2 = { transform: (D3) => D3.map((d) => d.value), label: labelof(value) };\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v2;\n        }\n      }\n    }\n    if (data == null) {\n      if (value == null)\n        throw new Error(\"missing contour value\");\n      options = sampler(\"value\", { value, ...options });\n      value = null;\n    } else {\n      let { interpolate } = options;\n      if (value === void 0)\n        value = identity6;\n      if (interpolate === void 0)\n        options.interpolate = \"nearest\";\n    }\n    super(data, { value: { value, optional: true } }, contourGeometry(options), defaults15);\n    const contourChannels = { geometry: { value: identity6 } };\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const { scale: scale3 } = channel;\n      if (scale3 === \"x\" || scale3 === \"y\" || key === \"value\")\n        continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index3, { x: x4, y: y4, value, ...channels }, values2) {\n    return super.filter(index3, channels, values2);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G } = channels;\n    const path2 = path_default();\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction contourGeometry({ thresholds, interval: interval2, ...options }) {\n  thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const kx2 = w / dx;\n    const ky2 = h / dy;\n    const V = channels.value.value;\n    const VV = [];\n    if (this.interpolate) {\n      const { x: X3, y: Y3 } = Position(channels, scales, context);\n      const IX = map2(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map2(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index3 = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index3, w, h, IX, IY, V));\n      }\n    } else if (facets) {\n      const n = w * h;\n      const m3 = facets.length;\n      for (let i = 0; i < m3; ++i)\n        VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n    if (this.blur > 0)\n      for (const V2 of VV)\n        blur2({ data: V2, width: w, height: h }, this.blur);\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null)\n      throw new Error(`unsupported thresholds: ${thresholds}`);\n    const { contour: contour2 } = contours_default().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V2 of VV)\n      contourFacets.push(range(contourData.length, contourData.push(...T.map((t) => contour2(V2, t)))));\n    for (const { coordinates: coordinates2 } of contourData) {\n      for (const rings of coordinates2) {\n        for (const ring of rings) {\n          for (const point6 of ring) {\n            point6[0] = point6[0] / kx2 + x12;\n            point6[1] = point6[1] / ky2 + y12;\n          }\n        }\n      }\n    }\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: Channels(this.contourChannels, contourData)\n    };\n  });\n}\nfunction maybeTicks(thresholds, V, min4, max5) {\n  if (typeof thresholds?.range === \"function\")\n    return thresholds.range(thresholds.floor(min4), max5);\n  if (typeof thresholds === \"function\")\n    thresholds = thresholds(V, min4, max5);\n  if (typeof thresholds !== \"number\")\n    return arrayify2(thresholds, Array);\n  const tz = ticks(...nice(min4, max5, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max5)\n    tz.pop();\n  while (tz[1] < min4)\n    tz.shift();\n  return tz;\n}\nfunction contour() {\n  return new Contour(...maybeTuples(\"value\", ...arguments));\n}\nfunction finiteExtent(VV) {\n  return [min(VV, (V) => min(V, finite3)), max(VV, (V) => max(V, finite3))];\n}\nfunction finite3(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/marks/delaunay.js\nvar delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\nvar voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar DelaunayLink = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, delaunayLinkDefaults);\n    this.curve = Curve(curve, tension);\n    markers(this, options);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { curve } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function links(index4) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k2 in channels)\n        newChannels[k2] = [];\n      const X13 = [];\n      const X23 = [];\n      const Y13 = [];\n      const Y23 = [];\n      function link4(ti, tj) {\n        ti = index4[ti];\n        tj = index4[tj];\n        newIndex.push(++i);\n        X13[i] = xi(ti);\n        Y13[i] = yi(ti);\n        X23[i] = xi(tj);\n        Y23[i] = yi(tj);\n        for (const k2 in channels)\n          newChannels[k2].push(channels[k2][tj]);\n      }\n      const { halfedges, hull: hull2, triangles } = Delaunay.from(index4, xi, yi);\n      for (let i2 = 0; i2 < halfedges.length; ++i2) {\n        const j = halfedges[i2];\n        if (j > i2)\n          link4(triangles[i2], triangles[j]);\n      }\n      for (let i2 = 0; i2 < hull2.length; ++i2) {\n        link4(hull2[i2], hull2[(i2 + 1) % hull2.length]);\n      }\n      select_default2(this).selectAll().data(newIndex).join(\"path\").call(applyDirectStyles, mark).attr(\"d\", (i2) => {\n        const p = pathRound();\n        const c6 = curve(p);\n        c6.lineStart();\n        c6.point(X13[i2], Y13[i2]);\n        c6.point(X23[i2], Y23[i2]);\n        c6.lineEnd();\n        return p;\n      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(links) : (g) => g.datum(index3).each(links)).node();\n  }\n};\nvar AbstractDelaunayMark = class extends Mark {\n  constructor(data, options = {}, defaults21, zof = ({ z }) => z) {\n    const { x: x4, y: y4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: zof(options), optional: true }\n    }, options, defaults21);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function mesh(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      select_default2(this).append(\"path\").datum(index4[0]).call(applyDirectStyles, mark).attr(\"d\", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(mesh) : (g) => g.datum(index3).each(mesh)).node();\n  }\n};\nvar DelaunayMesh = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n};\nvar Hull = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n};\nvar Voronoi2 = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, voronoiDefaults);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function cells(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      const voronoi2 = voronoiof(delaunay, dimensions);\n      select_default2(this).selectAll().data(index4).enter().append(\"path\").call(applyDirectStyles, mark).attr(\"d\", (_, i) => voronoi2.renderCell(i)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(cells) : (g) => g.datum(index3).each(cells)).node();\n  }\n};\nvar VoronoiMesh = class extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n};\nfunction voronoiof(delaunay, dimensions) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\nfunction delaunayMark(DelaunayMark, data, { x: x4, y: y4, ...options } = {}) {\n  [x4, y4] = maybeTuple(x4, y4);\n  return new DelaunayMark(data, { ...options, x: x4, y: y4 });\n}\nfunction delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\nfunction delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\nfunction hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\nfunction voronoi(data, options) {\n  return delaunayMark(Voronoi2, data, options);\n}\nfunction voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/density.js\nvar defaults16 = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Density = class extends Mark {\n  constructor(data, { x: x4, y: y4, z, weight, fill, stroke, ...options } = {}) {\n    const fillDensity = isDensity(fill) && (fill = \"currentColor\", true);\n    const strokeDensity = isDensity(stroke) && (stroke = \"currentColor\", true);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: maybeZ({ z, fill, stroke }), optional: true },\n      weight: { value: weight, optional: true }\n    }, densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity), defaults16);\n    if (fillDensity)\n      this.fill = void 0;\n    if (strokeDensity)\n      this.stroke = void 0;\n    this.z = z;\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { contours } = channels;\n    const path2 = path_default();\n    return create_default(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", (i) => path2(contours[i]))).node();\n  }\n};\nfunction density(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Density(data, { ...remainingOptions, x: x4, y: y4 });\n}\nvar dropChannels = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\", \"weight\"]);\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k2 = 100;\n  let { bandwidth, thresholds } = options;\n  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;\n  thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === \"function\" ? coerceNumbers(thresholds) : +thresholds;\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const { z } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const { width, height } = dimensions;\n    const { x: X3, y: Y3 } = Position(channels, scales, context);\n    const newChannels = Object.fromEntries(Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }]));\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n    const density2 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index3 of Z ? groupZ2(facet, Z, z) : [facet]) {\n        const contour2 = density2.contours(index3);\n        facetContours.push([index3, contour2]);\n      }\n    }\n    let T = thresholds;\n    if (!isTypedArray(T)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour2] of facetContours) {\n          const max5 = contour2.max;\n          if (max5 > maxValue)\n            maxValue = max5;\n        }\n      }\n      T = Float64Array.from({ length: thresholds - 1 }, (_, i) => maxValue * k2 * (i + 1) / thresholds);\n    }\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index3, contour2] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour2(t / k2));\n          if (FD)\n            FD.push(t);\n          if (SD)\n            SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index3[0]]);\n          }\n        }\n      }\n    }\n    if (FD)\n      FD.push(0);\n    if (SD)\n      SD.push(0);\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...FD && { fill: { value: FD, scale: \"color\" } },\n        ...SD && { stroke: { value: SD, scale: \"color\" } },\n        contours: { value: contours }\n      }\n    };\n  });\n}\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/geo.js\nvar defaults17 = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Geo = class extends Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = maybeNumberChannel(options.r, 3);\n    super(data, {\n      geometry: { value: options.geometry },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true }\n    }, withDefaultSort(options), defaults17);\n    this.r = cr;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G, r: R } = channels;\n    const path2 = path_default(context.projection ?? scaleProjection2(scales));\n    const { r } = this;\n    if (negative(r))\n      index3 = [];\n    else if (r !== void 0)\n      path2.pointRadius(r);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", R ? (i) => path2.pointRadius(R[i])(G[i]) : (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction scaleProjection2({ x: X3, y: Y3 }) {\n  if (X3 || Y3) {\n    X3 ??= (x4) => x4;\n    Y3 ??= (y4) => y4;\n    return transform_default({\n      point(x4, y4) {\n        this.stream.point(X3(x4), Y3(y4));\n      }\n    });\n  }\n}\nfunction geo(data, { geometry = identity6, ...options } = {}) {\n  switch (data?.type) {\n    case \"FeatureCollection\":\n      data = data.features;\n      break;\n    case \"GeometryCollection\":\n      data = data.geometries;\n      break;\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      data = [data];\n      break;\n  }\n  return new Geo(data, { geometry, ...options });\n}\nfunction sphere({ strokeWidth = 1.5, ...options } = {}) {\n  return geo({ type: \"Sphere\" }, { strokeWidth, ...options });\n}\nfunction graticule2({ strokeOpacity = 0.1, ...options } = {}) {\n  return geo(graticule10(), { strokeOpacity, ...options });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/hexbin.js\nvar ox = 0.5;\nvar oy = 0;\nfunction hexbin(outputs = { fill: \"count\" }, { binWidth, ...options } = {}) {\n  binWidth = binWidth === void 0 ? 20 : number5(binWidth);\n  outputs = maybeOutputs(outputs, options);\n  const { z, fill, stroke } = options;\n  if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, \"fill\"))\n    options.stroke = \"none\";\n  if (options.symbol === void 0)\n    options.symbol = \"hexagon\";\n  if (options.r === void 0 && !hasOutput(outputs, \"r\"))\n    options.r = binWidth / 2;\n  return initializer(options, (data, facets, channels, scales, _, context) => {\n    let { x: X3, y: Y3, z: Z, fill: F, stroke: S, symbol: Q } = channels;\n    if (X3 === void 0)\n      throw new Error(\"missing channel: x\");\n    if (Y3 === void 0)\n      throw new Error(\"missing channel: y\");\n    ({ x: X3, y: Y3 } = Position(channels, scales, context));\n    Z = Z ? Z.value : valueof(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n    const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S, symbol: Q });\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs)\n      o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs)\n        o.scope(\"facet\", facet);\n      for (const [f, I] of maybeGroup(facet, G)) {\n        for (const bin3 of hbin(I, X3, Y3, binWidth)) {\n          binFacet.push(++i);\n          BX.push(bin3.x);\n          BY.push(bin3.y);\n          if (Z)\n            GZ.push(G === Z ? f : Z[bin3[0]]);\n          if (F)\n            GF.push(G === F ? f : F[bin3[0]]);\n          if (S)\n            GS.push(G === S ? f : S[bin3[0]]);\n          if (Q)\n            GQ.push(G === Q ? f : Q[bin3[0]]);\n          for (const o of outputs)\n            o.reduce(bin3);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n    const binChannels = {\n      x: { value: BX },\n      y: { value: BY },\n      ...Z && { z: { value: GZ } },\n      ...F && { fill: { value: GF, scale: true } },\n      ...S && { stroke: { value: GS, scale: true } },\n      ...Q && { symbol: { value: GQ, scale: true } },\n      ...Object.fromEntries(outputs.map(({ name, output }) => [\n        name,\n        { scale: true, radius: name === \"r\" ? binWidth / 2 : void 0, value: output.transform() }\n      ]))\n    };\n    return { data, facets: binFacets, channels: binChannels };\n  });\n}\nfunction hbin(I, X3, Y3, dx) {\n  const dy = dx * (1.5 / sqrt35);\n  const bins = /* @__PURE__ */ new Map();\n  for (const i of I) {\n    let px = X3[i], py = Y3[i];\n    if (isNaN(px) || isNaN(py))\n      continue;\n    let pj = Math.round(py = (py - oy) / dy), pi7 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi7, pi22 = pi7 + (px < pi7 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)\n        pi7 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n    }\n    const key = `${pi7},${pj}`;\n    let bin3 = bins.get(key);\n    if (bin3 === void 0) {\n      bins.set(key, bin3 = []);\n      bin3.x = (pi7 + (pj & 1) / 2) * dx + ox;\n      bin3.y = pj * dy + oy;\n    }\n    bin3.push(i);\n  }\n  return bins.values();\n}\n\n// node_modules/@observablehq/plot/dist/marks/hexgrid.js\nvar defaults18 = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\nfunction hexgrid(options) {\n  return new Hexgrid(options);\n}\nvar Hexgrid = class extends Mark {\n  constructor({ binWidth = 20, clip = true, ...options } = {}) {\n    super(void 0, void 0, { clip, ...options }, defaults18);\n    this.binWidth = number5(binWidth);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { binWidth } = this;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const x06 = marginLeft - ox, x12 = width - marginRight - ox, y06 = marginTop - oy, y12 = height - marginBottom - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x06 / wx), i1 = Math.ceil(x12 / wx), j0 = Math.floor((y06 + hy) / wy), j1 = Math.ceil((y12 - hy) / wy) + 1, path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path2;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path2}`;\n      }\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append(\"path\").call(applyDirectStyles, this).attr(\"d\", d)).node();\n  }\n};\nfunction round(x4) {\n  return Math.round(x4 * 1e3) / 1e3;\n}\n\n// node_modules/@observablehq/plot/dist/marks/image.js\nvar defaults19 = {\n  ariaLabel: \"image\",\n  fill: null,\n  stroke: null\n};\nfunction isPath(string2) {\n  return /^\\.*\\//.test(string2);\n}\nfunction isUrl(string2) {\n  return /^(blob|data|file|http|https):/i.test(string2);\n}\nfunction maybePathChannel(value) {\n  return typeof value === \"string\" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];\n}\nvar Image2 = class extends Mark {\n  constructor(data, options = {}) {\n    let { x: x4, y: y4, width, height, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;\n    if (width === void 0 && height !== void 0)\n      width = height;\n    else if (height === void 0 && width !== void 0)\n      height = width;\n    const [vs, cs] = maybePathChannel(src);\n    const [vw, cw] = maybeNumberChannel(width, 16);\n    const [vh, ch] = maybeNumberChannel(height, 16);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      width: { value: vw, filter: positive, optional: true },\n      height: { value: vh, filter: positive, optional: true },\n      src: { value: vs, optional: true }\n    }, options, defaults19);\n    this.src = cs;\n    this.width = cw;\n    this.height = ch;\n    this.preserveAspectRatio = impliedString(preserveAspectRatio, \"xMidYMid\");\n    this.crossOrigin = string(crossOrigin);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, width: W, height: H, src: S } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"image\").call(applyDirectStyles, this).attr(\"x\", W && X3 ? (i) => X3[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X3 ? (i) => X3[i] - this.width / 2 : cx - this.width / 2).attr(\"y\", H && Y3 ? (i) => Y3[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y3 ? (i) => Y3[i] - this.height / 2 : cy - this.height / 2).attr(\"width\", W ? (i) => W[i] : this.width).attr(\"height\", H ? (i) => H[i] : this.height).call(applyAttr, \"href\", S ? (i) => S[i] : this.src).call(applyAttr, \"preserveAspectRatio\", this.preserveAspectRatio).call(applyAttr, \"crossorigin\", this.crossOrigin).call(applyAttr, \"image-rendering\", this.imageRendering).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction image(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Image2(data, { ...remainingOptions, x: x4, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/stats.js\nfunction ibetainv(p, a4, b) {\n  var EPS = 1e-8;\n  var a1 = a4 - 1;\n  var b12 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u4, err, x4, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a4 >= 1 && b >= 1) {\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x4 = -x4;\n    al = (x4 * x4 - 3) / 6;\n    h = 2 / (1 / (2 * a4 - 1) + 1 / (2 * b - 1));\n    w = x4 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a4 - 1)) * (al + 5 / 6 - 2 / (3 * h));\n    x4 = a4 / (a4 + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a4 / (a4 + b));\n    lnb = Math.log(b / (a4 + b));\n    t = Math.exp(a4 * lna) / a4;\n    u4 = Math.exp(b * lnb) / b;\n    w = t + u4;\n    if (p < t / w)\n      x4 = Math.pow(a4 * w * p, 1 / a4);\n    else\n      x4 = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -gammaln(a4) - gammaln(b) + gammaln(a4 + b);\n  for (; j < 10; j++) {\n    if (x4 === 0 || x4 === 1)\n      return x4;\n    err = ibeta(x4, a4, b) - p;\n    t = Math.exp(a1 * Math.log(x4) + b12 * Math.log(1 - x4) + afac);\n    u4 = err / t;\n    x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b12 / (1 - x4))));\n    if (x4 <= 0)\n      x4 = 0.5 * (x4 + t);\n    if (x4 >= 1)\n      x4 = 0.5 * (x4 + t + 1);\n    if (Math.abs(t) < EPS * x4 && j > 0)\n      break;\n  }\n  return x4;\n}\nfunction ibeta(x4, a4, b) {\n  var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln(a4 + b) - gammaln(a4) - gammaln(b) + a4 * Math.log(x4) + b * Math.log(1 - x4));\n  if (x4 < 0 || x4 > 1)\n    return false;\n  if (x4 < (a4 + 1) / (a4 + b + 2))\n    return bt * betacf(x4, a4, b) / a4;\n  return 1 - bt * betacf(1 - x4, b, a4) / b;\n}\nfunction betacf(x4, a4, b) {\n  var fpmin = 1e-30;\n  var m3 = 1;\n  var qab = a4 + b;\n  var qap = a4 + 1;\n  var qam = a4 - 1;\n  var c6 = 1;\n  var d = 1 - qab * x4 / qap;\n  var m22, aa2, del, h;\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n  for (; m3 <= 100; m3++) {\n    m22 = 2 * m3;\n    aa2 = m3 * (b - m3) * x4 / ((qam + m22) * (a4 + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    h *= d * c6;\n    aa2 = -(a4 + m3) * (qab + m3) * x4 / ((a4 + m22) * (qap + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    del = d * c6;\n    h *= del;\n    if (Math.abs(del - 1) < 3e-7)\n      break;\n  }\n  return h;\n}\nfunction gammaln(x4) {\n  var j = 0;\n  var cof = [\n    76.18009172947146,\n    -86.5053203294167,\n    24.01409824083091,\n    -1.231739572450155,\n    0.001208650973866179,\n    -5395239384953e-18\n  ];\n  var ser = 1.000000000190015;\n  var xx, y4, tmp2;\n  tmp2 = (y4 = xx = x4) + 5.5;\n  tmp2 -= (xx + 0.5) * Math.log(tmp2);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y4;\n  return Math.log(2.506628274631 * ser / xx) - tmp2;\n}\nfunction qt(p, dof) {\n  var x4 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n  x4 = Math.sqrt(dof * (1 - x4) / x4);\n  return p > 0.5 ? x4 : -x4;\n}\n\n// node_modules/@observablehq/plot/dist/marks/linearRegression.js\nvar defaults20 = {\n  ariaLabel: \"linear-regression\",\n  fill: \"currentColor\",\n  fillOpacity: 0.1,\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar LinearRegression = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, ci = 0.95, precision = 4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults20);\n    this.z = z;\n    this.ci = +ci;\n    this.precision = +precision;\n    if (!(0 <= this.ci && this.ci < 1))\n      throw new Error(`invalid ci; not in [0, 1): ${ci}`);\n    if (!(this.precision > 0))\n      throw new Error(`invalid precision: ${precision}`);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { ci } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(Z ? groupZ2(index3, Z, this.z) : [index3]).enter().call((enter) => enter.append(\"path\").attr(\"fill\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr(\"d\", (I) => this._renderLine(I, X3, Y3)).call(ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr(\"stroke\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {\n      ...channels,\n      stroke: null,\n      strokeOpacity: null,\n      strokeWidth: null\n    }).attr(\"d\", (I) => this._renderBand(I, X3, Y3)) : () => {\n    }))).node();\n  }\n};\nfunction pathBefore() {\n  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, \"path\"), this);\n}\nvar LinearRegressionX = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    const g = confidenceIntervalF(I, Y3, X3, (1 - ci) / 2, f);\n    return area_default5().y((y4) => y4).x0((y4) => g(y4, -1)).x1((y4) => g(y4, 1))(range(y12, y22 - precision / 2, precision).concat(y22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    return `M${f(y12)},${y12}L${f(y22)},${y22}`;\n  }\n};\nvar LinearRegressionY = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    const g = confidenceIntervalF(I, X3, Y3, (1 - ci) / 2, f);\n    return area_default5().x((x4) => x4).y0((x4) => g(x4, -1)).y1((x4) => g(x4, 1))(range(x12, x22 - precision / 2, precision).concat(x22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    return `M${x12},${f(x12)}L${x22},${f(x22)}`;\n  }\n};\nfunction linearRegressionX(data, options = {}) {\n  const { y: y4 = indexOf, x: x4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionX(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionY(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionF(I, X3, Y3) {\n  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n  for (const i of I) {\n    const xi = X3[i];\n    const yi = Y3[i];\n    sumX += xi;\n    sumY += yi;\n    sumXY += xi * yi;\n    sumX2 += xi * xi;\n  }\n  const n = I.length;\n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  return (x4) => slope * x4 + intercept;\n}\nfunction confidenceIntervalF(I, X3, Y3, p, f) {\n  const mean2 = sum(I, (i) => X3[i]) / I.length;\n  let a4 = 0, b = 0;\n  for (const i of I) {\n    a4 += (X3[i] - mean2) ** 2;\n    b += (Y3[i] - f(X3[i])) ** 2;\n  }\n  const sy = Math.sqrt(b / (I.length - 2));\n  const t = qt(p, I.length - 2);\n  return (x4, k2) => {\n    const Y4 = f(x4);\n    const se = sy * Math.sqrt(1 / I.length + (x4 - mean2) ** 2 / a4);\n    return Y4 + k2 * t * se;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/tree.js\nfunction treeNode(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    frameAnchor,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (frameAnchor === void 0)\n    frameAnchor = treeAnchor.frameAnchor;\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeNodeValue);\n  const [X3, setX] = column();\n  const [Y3, setY] = column();\n  return {\n    x: X3,\n    y: Y3,\n    frameAnchor,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X4 = setX([]);\n      const Y4 = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const node of root3.descendants()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X4, Y4);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction treeLink(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    curve = \"bump-x\",\n    stroke = \"#555\",\n    strokeWidth = 1.5,\n    strokeOpacity = 0.5,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  remainingOptions = { curve, stroke, strokeWidth, strokeOpacity, ...remainingOptions };\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeLinkValue);\n  const [X13, setX1] = column();\n  const [X23, setX2] = column();\n  const [Y13, setY1] = column();\n  const [Y23, setY2] = column();\n  return {\n    x1: X13,\n    x2: X23,\n    y1: Y13,\n    y2: Y23,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X14 = setX1([]);\n      const X24 = setX2([]);\n      const Y14 = setY1([]);\n      const Y24 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const { source, target } of root3.links()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X14, Y14);\n          treeAnchor.position(target, treeIndex, X24, Y24);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\nvar treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = y4;\n    Y3[i] = -x4;\n  }\n};\nvar treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = -y4;\n    Y3[i] = -x4;\n  }\n};\nfunction maybeTreeSort(sort3) {\n  return sort3 == null || typeof sort3 === \"function\" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith(\"node:\") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));\n}\nfunction nodeSort(value) {\n  return (a4, b) => ascendingDefined2(value(a4), value(b));\n}\nfunction nodeData(field2) {\n  return (node) => node.data?.[field2];\n}\nfunction normalizer(delimiter = \"/\") {\n  return `${delimiter}` === \"/\" ? (P) => P : (P) => P.map(replaceAll(delimiter, \"/\"));\n}\nfunction replaceAll(search, replace) {\n  search = new RegExp(regexEscape(search), \"g\");\n  return (value) => value == null ? null : `${value}`.replace(search, replace);\n}\nfunction regexEscape(string2) {\n  return `${string2}`.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isNodeValue(option) {\n  return isObject(option) && typeof option.node === \"function\";\n}\nfunction isLinkValue(option) {\n  return isObject(option) && typeof option.link === \"function\";\n}\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\"))\n    return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  if (isLinkValue(value))\n    return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\"))\n    return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\nfunction nodePath(node) {\n  return node.id;\n}\nfunction nodeName(node) {\n  return nameof(node.id);\n}\nfunction nodeDepth(node) {\n  return node.depth;\n}\nfunction nodeHeight(node) {\n  return node.height;\n}\nfunction nodeInternal(node) {\n  return !!node.children;\n}\nfunction parentValue(evaluate) {\n  return (child, parent) => parent == null ? void 0 : evaluate(parent);\n}\nfunction nameof(path2) {\n  let i = path2.length;\n  while (--i > 0)\n    if (slash2(path2, i))\n      break;\n  return path2.slice(i + 1);\n}\nfunction slash2(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\nvar output_setValues = 2;\nvar output_evaluate = 3;\nvar output_values = 4;\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== void 0) {\n      outputs.push([name, ...column(value), treeValue]);\n    }\n  }\n  return outputs;\n}\n\n// node_modules/@observablehq/plot/dist/marks/tree.js\nfunction tree(data, options = {}) {\n  let { fill, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, marker, markerStart = marker, markerEnd = marker, dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd), text: textText = \"node:name\", textStroke = \"white\", title = \"node:path\", dx, dy, ...remainingOptions } = options;\n  if (dx === void 0)\n    dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;\n  return marks(link3(data, treeLink({\n    markerStart,\n    markerEnd,\n    stroke: stroke !== void 0 ? stroke : fill === void 0 ? \"node:internal\" : fill,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    ...remainingOptions\n  })), dotDot ? dot(data, treeNode({ fill: fill === void 0 ? \"node:internal\" : fill, title, ...remainingOptions })) : null, textText != null ? text(data, treeNode({\n    text: textText,\n    fill: fill === void 0 ? \"currentColor\" : fill,\n    stroke: textStroke,\n    dx,\n    dy,\n    title,\n    ...remainingOptions\n  })) : null);\n}\nfunction cluster(data, options) {\n  return tree(data, { ...options, treeLayout: cluster_default });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/centroid.js\nfunction centroid({ geometry = identity6, ...options } = {}) {\n  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, { projection: projection2 }) => {\n    const G = valueof(data, geometry);\n    const n = G.length;\n    const X3 = new Float64Array(n);\n    const Y3 = new Float64Array(n);\n    const path2 = path_default(projection2);\n    for (let i = 0; i < n; ++i)\n      [X3[i], Y3[i]] = path2.centroid(G[i]);\n    return { data, facets, channels: { x: { value: X3 }, y: { value: Y3 } } };\n  });\n}\nfunction geoCentroid({ geometry = identity6, ...options } = {}) {\n  let C3;\n  return {\n    ...options,\n    x: { transform: (data) => Float64Array.from(C3 = valueof(valueof(data, geometry), centroid_default), ([x4]) => x4) },\n    y: { transform: () => Float64Array.from(C3, ([, y4]) => y4) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/dodge.js\nvar import_interval_tree_1d = __toESM(require_interval_tree(), 1);\nvar anchorXLeft = ({ marginLeft }) => [1, marginLeft];\nvar anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];\nvar anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];\nvar anchorYTop = ({ marginTop }) => [1, marginTop];\nvar anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];\nvar anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];\nfunction maybeAnchor2(anchor) {\n  return typeof anchor === \"string\" ? { anchor } : anchor;\n}\nfunction dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"left\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, number5(padding), options);\n}\nfunction dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"bottom\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, number5(padding), options);\n}\nfunction mergeOptions3(options) {\n  const { anchor, padding, ...rest } = options;\n  return [{ anchor, padding }, rest];\n}\nfunction dodge(y4, x4, anchor, padding, options) {\n  const { r } = options;\n  if (r != null && typeof r !== \"number\") {\n    const { channels, sort: sort3, reverse: reverse3 } = options;\n    options = { ...options, channels: { r: { value: r, scale: \"r\" }, ...maybeNamed(channels) } };\n    if (sort3 === void 0 && reverse3 === void 0)\n      options.sort = { channel: \"r\", order: \"descending\" };\n  }\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    let { [x4]: X3, r: R } = channels;\n    if (!channels[x4])\n      throw new Error(`missing channel: ${x4}`);\n    ({ [x4]: X3 } = Position(channels, scales, context));\n    const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number5(options.r) : 3;\n    if (R)\n      R = coerceNumbers(valueof(R.value, scales[R.scale] || identity6));\n    let [ky2, ty] = anchor(dimensions);\n    const compare = ky2 ? compareAscending : compareSymmetric;\n    const Y3 = new Float64Array(X3.length);\n    const radius2 = R ? (i) => R[i] : () => r2;\n    for (let I of facets) {\n      const tree2 = (0, import_interval_tree_1d.default)();\n      I = I.filter(R ? (i) => finite2(X3[i]) && positive(R[i]) : (i) => finite2(X3[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius2(i);\n        const y06 = ky2 ? ri + padding : 0;\n        const l = X3[i] - ri;\n        const h = X3[i] + ri;\n        let k2 = 2;\n        tree2.queryInterval(l - padding, h + padding, ([, , j]) => {\n          const yj = Y3[j] - y06;\n          const dx = X3[i] - X3[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * r2);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k2++] = yj - dy;\n          intervals[k2++] = yj + dy;\n        });\n        let candidates = intervals.slice(0, k2);\n        if (ky2)\n          candidates = candidates.filter((y5) => y5 >= 0);\n        out:\n          for (const y5 of candidates.sort(compare)) {\n            for (let j = 0; j < k2; j += 2) {\n              if (intervals[j] + 1e-6 < y5 && y5 < intervals[j + 1] - 1e-6) {\n                continue out;\n              }\n            }\n            Y3[i] = y5 + y06;\n            break;\n          }\n        tree2.insert([l, h, i]);\n      }\n    }\n    if (!ky2)\n      ky2 = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y3[i] = Y3[i] * ky2 + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [x4]: { value: X3 },\n        [y4]: { value: Y3 },\n        ...R && { r: { value: R } }\n      }\n    };\n  });\n}\nfunction compareSymmetric(a4, b) {\n  return Math.abs(a4) - Math.abs(b);\n}\nfunction compareAscending(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/normalize.js\nfunction normalizeX(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapX(normalize3(basis2), options);\n}\nfunction normalizeY(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapY(normalize3(basis2), options);\n}\nfunction normalize3(basis2) {\n  if (basis2 === void 0)\n    return normalizeFirst;\n  if (typeof basis2 === \"function\")\n    return normalizeBasis((I, S) => basis2(take(S, I)));\n  if (/^p\\d{2}$/i.test(basis2))\n    return normalizeAccessor(percentile(basis2));\n  switch (`${basis2}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis2}`);\n}\nfunction normalizeBasis(basis2) {\n  return {\n    map(I, S, T) {\n      const b = +basis2(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, (i) => S[i]));\n}\nvar normalizeExtent = {\n  map(I, S, T) {\n    const [s1, s2] = extent(I, (i) => S[i]), d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\nvar normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeDeviation = {\n  map(I, S, T) {\n    const m3 = mean(I, (i) => S[i]);\n    const d = deviation(I, (i) => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m3) / d : 0;\n    }\n  }\n};\nvar normalizeMax = normalizeAccessor(max);\nvar normalizeMean = normalizeAccessor(mean);\nvar normalizeMedian = normalizeAccessor(median);\nvar normalizeMin = normalizeAccessor(min);\nvar normalizeSum = normalizeAccessor(sum);\n\n// node_modules/@observablehq/plot/dist/transforms/window.js\nfunction windowX(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapX(window2(windowOptions), options);\n}\nfunction windowY(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapY(window2(windowOptions), options);\n}\nfunction window2(options = {}) {\n  if (typeof options === \"number\")\n    options = { k: options };\n  let { k: k2, reduce: reduce2, shift, anchor, strict } = options;\n  if (anchor === void 0 && shift !== void 0) {\n    anchor = maybeShift(shift);\n    warn(`Warning: the shift option is deprecated; please use anchor \"${anchor}\" instead.`);\n  }\n  if (!((k2 = Math.floor(k2)) > 0))\n    throw new Error(`invalid k: ${k2}`);\n  return maybeReduce2(reduce2)(k2, maybeAnchor3(anchor, k2), strict);\n}\nfunction maybeAnchor3(anchor = \"middle\", k2) {\n  switch (`${anchor}`.toLowerCase()) {\n    case \"middle\":\n      return k2 - 1 >> 1;\n    case \"start\":\n      return 0;\n    case \"end\":\n      return k2 - 1;\n  }\n  throw new Error(`invalid anchor: ${anchor}`);\n}\nfunction maybeShift(shift) {\n  switch (`${shift}`.toLowerCase()) {\n    case \"centered\":\n      return \"middle\";\n    case \"leading\":\n      return \"start\";\n    case \"trailing\":\n      return \"end\";\n  }\n  throw new Error(`invalid shift: ${shift}`);\n}\nfunction maybeReduce2(reduce2 = \"mean\") {\n  if (typeof reduce2 === \"string\") {\n    if (/^p\\d{2}$/i.test(reduce2))\n      return reduceNumbers(percentile(reduce2));\n    switch (reduce2.toLowerCase()) {\n      case \"deviation\":\n        return reduceNumbers(deviation);\n      case \"max\":\n        return reduceArray(max);\n      case \"mean\":\n        return reduceMean;\n      case \"median\":\n        return reduceNumbers(median);\n      case \"min\":\n        return reduceArray(min);\n      case \"mode\":\n        return reduceArray(mode);\n      case \"sum\":\n        return reduceSum2;\n      case \"variance\":\n        return reduceNumbers(variance);\n      case \"difference\":\n        return reduceDifference;\n      case \"ratio\":\n        return reduceRatio;\n      case \"first\":\n        return reduceFirst2;\n      case \"last\":\n        return reduceLast2;\n    }\n  }\n  if (typeof reduce2 !== \"function\")\n    throw new Error(`invalid reduce: ${reduce2}`);\n  return reduceArray(reduce2);\n}\nfunction slice6(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\nfunction reduceNumbers(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      let nans = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        if (isNaN(C3[i]))\n          ++nans;\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        if (isNaN(C3[i + k2 - 1]))\n          ++nans;\n        T[I[i + s2]] = nans === 0 ? f(C3.subarray(i, i + k2)) : NaN;\n        if (isNaN(C3[i]))\n          --nans;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(C3.subarray(0, i + k2));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(C3.subarray(i, i + k2));\n      }\n    }\n  };\n}\nfunction reduceArray(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      let count3 = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        count3 += defined(S[I[i]]);\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        count3 += defined(S[I[i + k2 - 1]]);\n        if (count3 === k2)\n          T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n        count3 -= defined(S[I[i]]);\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, 0, i + k2)));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n      }\n    }\n  };\n}\nfunction reduceSum2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      let nans = 0;\n      let sum5 = 0;\n      for (let i = 0; i < k2 - 1; ++i) {\n        const v2 = S[I[i]];\n        if (v2 === null || isNaN(v2))\n          ++nans;\n        else\n          sum5 += +v2;\n      }\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        if (b === null || isNaN(b))\n          ++nans;\n        else\n          sum5 += +b;\n        T[I[i + s2]] = nans === 0 ? sum5 : NaN;\n        if (a4 === null || isNaN(a4))\n          --nans;\n        else\n          sum5 -= +a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      let sum5 = 0;\n      const n = I.length;\n      for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n        sum5 += +S[I[i]] || 0;\n      }\n      for (let i = -s2, j = n - s2; i < j; ++i) {\n        sum5 += +S[I[i + k2 - 1]] || 0;\n        T[I[i + s2]] = sum5;\n        sum5 -= +S[I[i]] || 0;\n      }\n    }\n  };\n}\nfunction reduceMean(k2, s2, strict) {\n  if (strict) {\n    const sum5 = reduceSum2(k2, s2, strict);\n    return {\n      map(I, S, T) {\n        sum5.map(I, S, T);\n        for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n          T[I[i + s2]] /= k2;\n        }\n      }\n    };\n  } else {\n    return {\n      map(I, S, T) {\n        let sum5 = 0;\n        let count3 = 0;\n        const n = I.length;\n        for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n          let v2 = S[I[i]];\n          if (v2 !== null && !isNaN(v2 = +v2))\n            sum5 += v2, ++count3;\n        }\n        for (let i = -s2, j = n - s2; i < j; ++i) {\n          let a4 = S[I[i + k2 - 1]];\n          let b = S[I[i]];\n          if (a4 !== null && !isNaN(a4 = +a4))\n            sum5 += a4, ++count3;\n          T[I[i + s2]] = sum5 / count3;\n          if (b !== null && !isNaN(b = +b))\n            sum5 -= b, --count3;\n        }\n      }\n    };\n  }\n}\nfunction firstDefined(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    const v2 = S[I[i]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction lastDefined(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    const v2 = S[I[j]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction firstNumber(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    let v2 = S[I[i]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction lastNumber(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    let v2 = S[I[j]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction reduceDifference(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b - a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) - firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceRatio(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b / a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) / firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceFirst2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = firstDefined(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceLast2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i + k2 - 1]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastDefined(S, I, i, k2);\n      }\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/select.js\nfunction select(selector, options = {}) {\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  let key, value;\n  for (key in selector) {\n    if (value !== void 0)\n      throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === void 0)\n    throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\")\n    return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\nfunction selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\nfunction selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\nfunction selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\nfunction selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\nfunction selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\nfunction selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\nfunction* selectorFirst(I) {\n  yield I[0];\n}\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\nfunction* selectorMin(I, X3) {\n  yield least(I, (i) => X3[i]);\n}\nfunction* selectorMax(I, X3) {\n  yield greatest(I, (i) => X3[i]);\n}\nfunction selectChannel(v2, selector, options) {\n  if (v2 != null) {\n    if (options[v2] == null)\n      throw new Error(`missing channel: ${v2}`);\n    v2 = options[v2];\n  }\n  const z = maybeZ(options);\n  return basic(options, (data, facets) => {\n    const Z = valueof(data, z);\n    const V = valueof(data, v2);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return { data, facets: selectFacets };\n  });\n}\n\n// node_modules/tslib/tslib.es6.js\nfunction __rest(s2, e) {\n  var t = {};\n  for (var p in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)\n      t[p] = s2[p];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))\n        t[p[i]] = s2[p[i]];\n    }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s2 = typeof Symbol === \"function\" && Symbol.iterator, m3 = s2 && o[s2], i = 0;\n  if (m3)\n    return m3.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s2 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v2) {\n  return this instanceof __await ? (this.v = v2, this) : new __await(v2);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v2) {\n        return new Promise(function(a4, b) {\n          q.push([n, v2, a4, b]) > 1 || resume(n, v2);\n        });\n      };\n  }\n  function resume(n, v2) {\n    try {\n      step(g[n](v2));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v2) {\n    if (f(v2), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v2) {\n      return (p = !p) ? { value: __await(o[n](v2)), done: false } : f ? f(v2) : v2;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m3 = o[Symbol.asyncIterator], i;\n  return m3 ? m3.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v2) {\n      return new Promise(function(resolve, reject) {\n        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v2) {\n    Promise.resolve(v2).then(function(v3) {\n      resolve({ value: v3, done: d });\n    }, reject);\n  }\n}\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar buffer_exports = {};\n__export(buffer_exports, {\n  compareArrayLike: () => compareArrayLike,\n  joinUint8Arrays: () => joinUint8Arrays,\n  memcpy: () => memcpy,\n  rebaseValueOffsets: () => rebaseValueOffsets,\n  toArrayBufferView: () => toArrayBufferView,\n  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,\n  toArrayBufferViewIterator: () => toArrayBufferViewIterator,\n  toBigInt64Array: () => toBigInt64Array,\n  toBigUint64Array: () => toBigUint64Array,\n  toFloat32Array: () => toFloat32Array,\n  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,\n  toFloat32ArrayIterator: () => toFloat32ArrayIterator,\n  toFloat64Array: () => toFloat64Array,\n  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,\n  toFloat64ArrayIterator: () => toFloat64ArrayIterator,\n  toInt16Array: () => toInt16Array,\n  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,\n  toInt16ArrayIterator: () => toInt16ArrayIterator,\n  toInt32Array: () => toInt32Array,\n  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,\n  toInt32ArrayIterator: () => toInt32ArrayIterator,\n  toInt8Array: () => toInt8Array,\n  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,\n  toInt8ArrayIterator: () => toInt8ArrayIterator,\n  toUint16Array: () => toUint16Array,\n  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,\n  toUint16ArrayIterator: () => toUint16ArrayIterator,\n  toUint32Array: () => toUint32Array,\n  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,\n  toUint32ArrayIterator: () => toUint32ArrayIterator,\n  toUint8Array: () => toUint8Array,\n  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,\n  toUint8ArrayIterator: () => toUint8ArrayIterator,\n  toUint8ClampedArray: () => toUint8ClampedArray,\n  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,\n  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator\n});\n\n// node_modules/apache-arrow/util/utf8.mjs\nvar decoder = new TextDecoder(\"utf-8\");\nvar decodeUtf8 = (buffer) => decoder.decode(buffer);\nvar encoder = new TextEncoder();\nvar encodeUtf8 = (value) => encoder.encode(value);\n\n// node_modules/apache-arrow/util/compat.mjs\nvar [BigIntCtor, BigIntAvailable] = (() => {\n  const BigIntUnavailableError = () => {\n    throw new Error(\"BigInt is not available in this environment\");\n  };\n  function BigIntUnavailable() {\n    throw BigIntUnavailableError();\n  }\n  BigIntUnavailable.asIntN = () => {\n    throw BigIntUnavailableError();\n  };\n  BigIntUnavailable.asUintN = () => {\n    throw BigIntUnavailableError();\n  };\n  return typeof BigInt !== \"undefined\" ? [BigInt, true] : [BigIntUnavailable, false];\n})();\nvar [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {\n  const BigInt64ArrayUnavailableError = () => {\n    throw new Error(\"BigInt64Array is not available in this environment\");\n  };\n  class BigInt64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigInt64ArrayUnavailableError();\n    }\n  }\n  return typeof BigInt64Array !== \"undefined\" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];\n})();\nvar [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {\n  const BigUint64ArrayUnavailableError = () => {\n    throw new Error(\"BigUint64Array is not available in this environment\");\n  };\n  class BigUint64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigUint64ArrayUnavailableError();\n    }\n  }\n  return typeof BigUint64Array !== \"undefined\" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];\n})();\nvar isNumber = (x4) => typeof x4 === \"number\";\nvar isBoolean = (x4) => typeof x4 === \"boolean\";\nvar isFunction = (x4) => typeof x4 === \"function\";\nvar isObject2 = (x4) => x4 != null && Object(x4) === x4;\nvar isPromise = (x4) => {\n  return isObject2(x4) && isFunction(x4.then);\n};\nvar isIterable2 = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.iterator]);\n};\nvar isAsyncIterable = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.asyncIterator]);\n};\nvar isArrowJSON = (x4) => {\n  return isObject2(x4) && isObject2(x4[\"schema\"]);\n};\nvar isIteratorResult = (x4) => {\n  return isObject2(x4) && \"done\" in x4 && \"value\" in x4;\n};\nvar isFileHandle = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"stat\"]) && isNumber(x4[\"fd\"]);\n};\nvar isFetchResponse = (x4) => {\n  return isObject2(x4) && isReadableDOMStream(x4[\"body\"]);\n};\nvar isReadableInterop = (x4) => \"_getDOMStream\" in x4 && \"_getNodeStream\" in x4;\nvar isWritableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"abort\"]) && isFunction(x4[\"getWriter\"]) && !isReadableInterop(x4);\n};\nvar isReadableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"cancel\"]) && isFunction(x4[\"getReader\"]) && !isReadableInterop(x4);\n};\nvar isWritableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"end\"]) && isFunction(x4[\"write\"]) && isBoolean(x4[\"writable\"]) && !isReadableInterop(x4);\n};\nvar isReadableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"read\"]) && isFunction(x4[\"pipe\"]) && isBoolean(x4[\"readable\"]) && !isReadableInterop(x4);\n};\nvar isFlatbuffersByteBuffer = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"clear\"]) && isFunction(x4[\"bytes\"]) && isFunction(x4[\"position\"]) && isFunction(x4[\"setPosition\"]) && isFunction(x4[\"capacity\"]) && isFunction(x4[\"getBufferIdentifier\"]) && isFunction(x4[\"createLong\"]);\n};\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar SharedArrayBuf = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : ArrayBuffer;\nfunction collapseContiguousByteRanges(chunks) {\n  const result = chunks[0] ? [chunks[0]] : [];\n  let xOffset, yOffset, xLen, yLen;\n  for (let x4, y4, i = 0, j = 0, n = chunks.length; ++i < n; ) {\n    x4 = result[j];\n    y4 = chunks[i];\n    if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    ({ byteOffset: xOffset, byteLength: xLen } = x4);\n    ({ byteOffset: yOffset, byteLength: yLen } = y4);\n    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    result[j] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);\n  }\n  return result;\n}\nfunction memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));\n  dst.set(src, targetByteOffset);\n  return target;\n}\nfunction joinUint8Arrays(chunks, size) {\n  const result = collapseContiguousByteRanges(chunks);\n  const byteLength = result.reduce((x4, b) => x4 + b.byteLength, 0);\n  let source, sliced, buffer;\n  let offset2 = 0, index3 = -1;\n  const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);\n  for (const n = result.length; ++index3 < n; ) {\n    source = result[index3];\n    sliced = source.subarray(0, Math.min(source.length, length4 - offset2));\n    if (length4 <= offset2 + sliced.length) {\n      if (sliced.length < source.length) {\n        result[index3] = source.subarray(sliced.length);\n      } else if (sliced.length === source.length) {\n        index3++;\n      }\n      buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;\n      break;\n    }\n    memcpy(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);\n    offset2 += sliced.length;\n  }\n  return [buffer || new Uint8Array(0), result.slice(index3), byteLength - (buffer ? buffer.byteLength : 0)];\n}\nfunction toArrayBufferView(ArrayBufferViewCtor, input) {\n  let value = isIteratorResult(input) ? input.value : input;\n  if (value instanceof ArrayBufferViewCtor) {\n    if (ArrayBufferViewCtor === Uint8Array) {\n      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);\n    }\n    return value;\n  }\n  if (!value) {\n    return new ArrayBufferViewCtor(0);\n  }\n  if (typeof value === \"string\") {\n    value = encodeUtf8(value);\n  }\n  if (value instanceof ArrayBuffer) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (value instanceof SharedArrayBuf) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (isFlatbuffersByteBuffer(value)) {\n    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());\n  }\n  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);\n}\nvar toInt8Array = (input) => toArrayBufferView(Int8Array, input);\nvar toInt16Array = (input) => toArrayBufferView(Int16Array, input);\nvar toInt32Array = (input) => toArrayBufferView(Int32Array, input);\nvar toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);\nvar toUint8Array = (input) => toArrayBufferView(Uint8Array, input);\nvar toUint16Array = (input) => toArrayBufferView(Uint16Array, input);\nvar toUint32Array = (input) => toArrayBufferView(Uint32Array, input);\nvar toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);\nvar toFloat32Array = (input) => toArrayBufferView(Float32Array, input);\nvar toFloat64Array = (input) => toArrayBufferView(Float64Array, input);\nvar toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);\nvar pump = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* toArrayBufferViewIterator(ArrayCtor, source) {\n  const wrap = function* (x4) {\n    yield x4;\n  };\n  const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;\n  yield* pump(function* (it) {\n    let r = null;\n    do {\n      r = it.next(yield toArrayBufferView(ArrayCtor, r));\n    } while (!r.done);\n  }(buffers[Symbol.iterator]()));\n  return new ArrayCtor();\n}\nvar toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);\nvar toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);\nvar toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);\nvar toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);\nvar toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);\nvar toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);\nvar toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);\nvar toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);\nvar toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);\nfunction toArrayBufferViewAsyncIterator(ArrayCtor, source) {\n  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {\n    if (isPromise(source)) {\n      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));\n    }\n    const wrap = function(x4) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield yield __await(yield __await(x4));\n      });\n    };\n    const emit = function(source2) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {\n          let r = null;\n          do {\n            r = it.next(yield r === null || r === void 0 ? void 0 : r.value);\n          } while (!r.done);\n        }(source2[Symbol.iterator]())))));\n      });\n    };\n    const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;\n    yield __await(\n      // otherwise if AsyncIterable, use it\n      yield* __asyncDelegator(__asyncValues(pump(function(it) {\n        return __asyncGenerator(this, arguments, function* () {\n          let r = null;\n          do {\n            r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));\n          } while (!r.done);\n        });\n      }(buffers[Symbol.asyncIterator]()))))\n    );\n    return yield __await(new ArrayCtor());\n  });\n}\nvar toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);\nvar toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);\nvar toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);\nvar toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);\nvar toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);\nvar toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);\nvar toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);\nvar toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);\nvar toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);\nfunction rebaseValueOffsets(offset2, length4, valueOffsets) {\n  if (offset2 !== 0) {\n    valueOffsets = valueOffsets.slice(0, length4 + 1);\n    for (let i = -1; ++i <= length4; ) {\n      valueOffsets[i] += offset2;\n    }\n  }\n  return valueOffsets;\n}\nfunction compareArrayLike(a4, b) {\n  let i = 0;\n  const n = a4.length;\n  if (n !== b.length) {\n    return false;\n  }\n  if (n > 0) {\n    do {\n      if (a4[i] !== b[i]) {\n        return false;\n      }\n    } while (++i < n);\n  }\n  return true;\n}\n\n// node_modules/apache-arrow/io/adapters.mjs\nvar adapters_default = {\n  fromIterable(source) {\n    return pump2(fromIterable(source));\n  },\n  fromAsyncIterable(source) {\n    return pump2(fromAsyncIterable(source));\n  },\n  fromDOMStream(source) {\n    return pump2(fromDOMStream(source));\n  },\n  fromNodeStream(stream) {\n    return pump2(fromNodeStream(stream));\n  },\n  // @ts-ignore\n  toDOMStream(source, options) {\n    throw new Error(`\"toDOMStream\" not available in this environment`);\n  },\n  // @ts-ignore\n  toNodeStream(source, options) {\n    throw new Error(`\"toNodeStream\" not available in this environment`);\n  }\n};\nvar pump2 = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* fromIterable(source) {\n  let done, threw = false;\n  let buffers = [], buffer;\n  let cmd, size, bufferLength = 0;\n  function byteRange() {\n    if (cmd === \"peek\") {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  }\n  ({ cmd, size } = yield null);\n  const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n  try {\n    do {\n      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      }\n      if (done || size <= bufferLength) {\n        do {\n          ({ cmd, size } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === \"function\" && it.throw(e);\n  } finally {\n    threw === false && typeof it.return === \"function\" && it.return(null);\n  }\n  return null;\n}\nfunction fromAsyncIterable(source) {\n  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n    let done, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && typeof it.throw === \"function\" && (yield __await(it.throw(e)));\n    } finally {\n      threw === false && typeof it.return === \"function\" && (yield __await(it.return(new Uint8Array(0))));\n    }\n    return yield __await(null);\n  });\n}\nfunction fromDOMStream(source) {\n  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n    let done = false, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = new AdaptiveByteReader(source);\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it[\"read\"]()) : yield __await(it[\"read\"](size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(toUint8Array(buffer));\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && (yield __await(it[\"cancel\"](e)));\n    } finally {\n      threw === false ? yield __await(it[\"cancel\"]()) : source[\"locked\"] && it.releaseLock();\n    }\n    return yield __await(null);\n  });\n}\nvar AdaptiveByteReader = class {\n  constructor(source) {\n    this.source = source;\n    this.reader = null;\n    this.reader = this.source[\"getReader\"]();\n    this.reader[\"closed\"].catch(() => {\n    });\n  }\n  get closed() {\n    return this.reader ? this.reader[\"closed\"].catch(() => {\n    }) : Promise.resolve();\n  }\n  releaseLock() {\n    if (this.reader) {\n      this.reader.releaseLock();\n    }\n    this.reader = null;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { reader, source } = this;\n      reader && (yield reader[\"cancel\"](reason).catch(() => {\n      }));\n      source && (source[\"locked\"] && this.releaseLock());\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (size === 0) {\n        return { done: this.reader == null, value: new Uint8Array(0) };\n      }\n      const result = yield this.reader.read();\n      !result.done && (result.value = toUint8Array(result));\n      return result;\n    });\n  }\n};\nvar onEvent = (stream, event) => {\n  const handler = (_) => resolve([event, _]);\n  let resolve;\n  return [event, handler, new Promise((r) => (resolve = r) && stream[\"once\"](event, handler))];\n};\nfunction fromNodeStream(stream) {\n  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n    const events = [];\n    let event = \"error\";\n    let done = false, err = null;\n    let cmd, size, bufferLength = 0;\n    let buffers = [], buffer;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    if (stream[\"isTTY\"]) {\n      yield yield __await(new Uint8Array(0));\n      return yield __await(null);\n    }\n    try {\n      events[0] = onEvent(stream, \"end\");\n      events[1] = onEvent(stream, \"error\");\n      do {\n        events[2] = onEvent(stream, \"readable\");\n        [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));\n        if (event === \"error\") {\n          break;\n        }\n        if (!(done = event === \"end\")) {\n          if (!Number.isFinite(size - bufferLength)) {\n            buffer = toUint8Array(stream[\"read\"]());\n          } else {\n            buffer = toUint8Array(stream[\"read\"](size - bufferLength));\n            if (buffer.byteLength < size - bufferLength) {\n              buffer = toUint8Array(stream[\"read\"]());\n            }\n          }\n          if (buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } finally {\n      yield __await(cleanup(events, event === \"error\" ? err : null));\n    }\n    return yield __await(null);\n    function cleanup(events2, err2) {\n      buffer = buffers = null;\n      return new Promise((resolve, reject) => {\n        for (const [evt, fn] of events2) {\n          stream[\"off\"](evt, fn);\n        }\n        try {\n          const destroy = stream[\"destroy\"];\n          destroy && destroy.call(stream, err2);\n          err2 = void 0;\n        } catch (e) {\n          err2 = e || err2;\n        } finally {\n          err2 != null ? reject(err2) : resolve();\n        }\n      });\n    }\n  });\n}\n\n// node_modules/apache-arrow/enum.mjs\nvar MetadataVersion;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion || (MetadataVersion = {}));\nvar UnionMode;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode || (UnionMode = {}));\nvar Precision;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision || (Precision = {}));\nvar DateUnit;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit || (DateUnit = {}));\nvar TimeUnit;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit || (TimeUnit = {}));\nvar IntervalUnit;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit || (IntervalUnit = {}));\nvar MessageHeader;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nvar Type;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"Float\"] = 3] = \"Float\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct\"] = 13] = \"Struct\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type3[Type3[\"Int8\"] = -2] = \"Int8\";\n  Type3[Type3[\"Int16\"] = -3] = \"Int16\";\n  Type3[Type3[\"Int32\"] = -4] = \"Int32\";\n  Type3[Type3[\"Int64\"] = -5] = \"Int64\";\n  Type3[Type3[\"Uint8\"] = -6] = \"Uint8\";\n  Type3[Type3[\"Uint16\"] = -7] = \"Uint16\";\n  Type3[Type3[\"Uint32\"] = -8] = \"Uint32\";\n  Type3[Type3[\"Uint64\"] = -9] = \"Uint64\";\n  Type3[Type3[\"Float16\"] = -10] = \"Float16\";\n  Type3[Type3[\"Float32\"] = -11] = \"Float32\";\n  Type3[Type3[\"Float64\"] = -12] = \"Float64\";\n  Type3[Type3[\"DateDay\"] = -13] = \"DateDay\";\n  Type3[Type3[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type3[Type3[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type3[Type3[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type3[Type3[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type3[Type3[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type3[Type3[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type3[Type3[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type3[Type3[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type3[Type3[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type3[Type3[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type3[Type3[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type3[Type3[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type3[Type3[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\nvar BufferType;\n(function(BufferType2) {\n  BufferType2[BufferType2[\"OFFSET\"] = 0] = \"OFFSET\";\n  BufferType2[BufferType2[\"DATA\"] = 1] = \"DATA\";\n  BufferType2[BufferType2[\"VALIDITY\"] = 2] = \"VALIDITY\";\n  BufferType2[BufferType2[\"TYPE\"] = 3] = \"TYPE\";\n})(BufferType || (BufferType = {}));\n\n// node_modules/apache-arrow/util/vector.mjs\nvar vector_exports = {};\n__export(vector_exports, {\n  clampIndex: () => clampIndex,\n  clampRange: () => clampRange,\n  createElementComparator: () => createElementComparator\n});\n\n// node_modules/apache-arrow/util/pretty.mjs\nvar undf = void 0;\nfunction valueToString(x4) {\n  if (x4 === null) {\n    return \"null\";\n  }\n  if (x4 === undf) {\n    return \"undefined\";\n  }\n  switch (typeof x4) {\n    case \"number\":\n      return `${x4}`;\n    case \"bigint\":\n      return `${x4}`;\n    case \"string\":\n      return `\"${x4}\"`;\n  }\n  if (typeof x4[Symbol.toPrimitive] === \"function\") {\n    return x4[Symbol.toPrimitive](\"string\");\n  }\n  if (ArrayBuffer.isView(x4)) {\n    if (x4 instanceof BigInt64ArrayCtor || x4 instanceof BigUint64ArrayCtor) {\n      return `[${[...x4].map((x5) => valueToString(x5))}]`;\n    }\n    return `[${x4}]`;\n  }\n  return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_, y4) => typeof y4 === \"bigint\" ? `${y4}` : y4);\n}\n\n// node_modules/apache-arrow/util/bn.mjs\nvar bn_exports = {};\n__export(bn_exports, {\n  BN: () => BN,\n  bignumToBigInt: () => bignumToBigInt,\n  bignumToString: () => bignumToString,\n  isArrowBigNumSymbol: () => isArrowBigNumSymbol\n});\nvar isArrowBigNumSymbol = Symbol.for(\"isArrowBigNum\");\nfunction BigNum(x4, ...xs) {\n  if (xs.length === 0) {\n    return Object.setPrototypeOf(toArrayBufferView(this[\"TypedArray\"], x4), this.constructor.prototype);\n  }\n  return Object.setPrototypeOf(new this[\"TypedArray\"](x4, ...xs), this.constructor.prototype);\n}\nBigNum.prototype[isArrowBigNumSymbol] = true;\nBigNum.prototype.toJSON = function() {\n  return `\"${bignumToString(this)}\"`;\n};\nBigNum.prototype.valueOf = function() {\n  return bignumToNumber(this);\n};\nBigNum.prototype.toString = function() {\n  return bignumToString(this);\n};\nBigNum.prototype[Symbol.toPrimitive] = function(hint = \"default\") {\n  switch (hint) {\n    case \"number\":\n      return bignumToNumber(this);\n    case \"string\":\n      return bignumToString(this);\n    case \"default\":\n      return bignumToBigInt(this);\n  }\n  return bignumToString(this);\n};\nfunction SignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction UnsignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction DecimalBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nObject.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype, BigNum.prototype, { \"constructor\": SignedBigNum, \"signed\": true, \"TypedArray\": Int32Array, \"BigIntArray\": BigInt64ArrayCtor });\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, { \"constructor\": UnsignedBigNum, \"signed\": false, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nObject.assign(DecimalBigNum.prototype, BigNum.prototype, { \"constructor\": DecimalBigNum, \"signed\": true, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nfunction bignumToNumber(bn) {\n  const { buffer, byteOffset, length: length4, \"signed\": signed } = bn;\n  const words = new BigUint64ArrayCtor(buffer, byteOffset, length4);\n  const negative2 = signed && words[words.length - 1] & BigInt(1) << BigInt(63);\n  let number7 = negative2 ? BigInt(1) : BigInt(0);\n  let i = BigInt(0);\n  if (!negative2) {\n    for (const word of words) {\n      number7 += word * (BigInt(1) << BigInt(32) * i++);\n    }\n  } else {\n    for (const word of words) {\n      number7 += ~word * (BigInt(1) << BigInt(32) * i++);\n    }\n    number7 *= BigInt(-1);\n  }\n  return number7;\n}\nvar bignumToString;\nvar bignumToBigInt;\nif (!BigIntAvailable) {\n  bignumToString = decimalToString;\n  bignumToBigInt = bignumToString;\n} else {\n  bignumToBigInt = (a4) => a4.byteLength === 8 ? new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0] : decimalToString(a4);\n  bignumToString = (a4) => a4.byteLength === 8 ? `${new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0]}` : decimalToString(a4);\n}\nfunction decimalToString(a4) {\n  let digits = \"\";\n  const base64 = new Uint32Array(2);\n  let base32 = new Uint16Array(a4.buffer, a4.byteOffset, a4.byteLength / 2);\n  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n  let i = -1;\n  const n = base32.length - 1;\n  do {\n    for (base64[0] = base32[i = 0]; i < n; ) {\n      base32[i++] = base64[1] = base64[0] / 10;\n      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];\n    }\n    base32[i] = base64[1] = base64[0] / 10;\n    base64[0] = base64[0] - base64[1] * 10;\n    digits = `${base64[0]}${digits}`;\n  } while (checks[0] || checks[1] || checks[2] || checks[3]);\n  return digits !== null && digits !== void 0 ? digits : `0`;\n}\nvar BN = class {\n  /** @nocollapse */\n  static new(num, isSigned) {\n    switch (isSigned) {\n      case true:\n        return new SignedBigNum(num);\n      case false:\n        return new UnsignedBigNum(num);\n    }\n    switch (num.constructor) {\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case BigInt64ArrayCtor:\n        return new SignedBigNum(num);\n    }\n    if (num.byteLength === 16) {\n      return new DecimalBigNum(num);\n    }\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static signed(num) {\n    return new SignedBigNum(num);\n  }\n  /** @nocollapse */\n  static unsigned(num) {\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static decimal(num) {\n    return new DecimalBigNum(num);\n  }\n  constructor(num, isSigned) {\n    return BN.new(num, isSigned);\n  }\n};\n\n// node_modules/apache-arrow/type.mjs\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\nvar _f;\nvar _g;\nvar _h;\nvar _j;\nvar _k;\nvar _l;\nvar _m;\nvar _o;\nvar _p;\nvar _q;\nvar _r;\nvar _s;\nvar _t;\nvar _u;\nvar DataType = class {\n  /** @nocollapse */\n  static isNull(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Null;\n  }\n  /** @nocollapse */\n  static isInt(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Int;\n  }\n  /** @nocollapse */\n  static isFloat(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Float;\n  }\n  /** @nocollapse */\n  static isBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Binary;\n  }\n  /** @nocollapse */\n  static isUtf8(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Utf8;\n  }\n  /** @nocollapse */\n  static isBool(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Bool;\n  }\n  /** @nocollapse */\n  static isDecimal(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Decimal;\n  }\n  /** @nocollapse */\n  static isDate(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Date;\n  }\n  /** @nocollapse */\n  static isTime(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Time;\n  }\n  /** @nocollapse */\n  static isTimestamp(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Timestamp;\n  }\n  /** @nocollapse */\n  static isInterval(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Interval;\n  }\n  /** @nocollapse */\n  static isList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.List;\n  }\n  /** @nocollapse */\n  static isStruct(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Struct;\n  }\n  /** @nocollapse */\n  static isUnion(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Union;\n  }\n  /** @nocollapse */\n  static isFixedSizeBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeBinary;\n  }\n  /** @nocollapse */\n  static isFixedSizeList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeList;\n  }\n  /** @nocollapse */\n  static isMap(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Map;\n  }\n  /** @nocollapse */\n  static isDictionary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Dictionary;\n  }\n  /** @nocollapse */\n  static isDenseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Dense;\n  }\n  /** @nocollapse */\n  static isSparseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Sparse;\n  }\n  get typeId() {\n    return Type.NONE;\n  }\n};\n_a = Symbol.toStringTag;\nDataType[_a] = ((proto) => {\n  proto.children = null;\n  proto.ArrayType = Array;\n  return proto[Symbol.toStringTag] = \"DataType\";\n})(DataType.prototype);\nvar Null = class extends DataType {\n  toString() {\n    return `Null`;\n  }\n  get typeId() {\n    return Type.Null;\n  }\n};\n_b = Symbol.toStringTag;\nNull[_b] = ((proto) => proto[Symbol.toStringTag] = \"Null\")(Null.prototype);\nvar Int_ = class extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Int;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 8:\n        return this.isSigned ? Int8Array : Uint8Array;\n      case 16:\n        return this.isSigned ? Int16Array : Uint16Array;\n      case 32:\n        return this.isSigned ? Int32Array : Uint32Array;\n      case 64:\n        return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;\n  }\n};\n_c = Symbol.toStringTag;\nInt_[_c] = ((proto) => {\n  proto.isSigned = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Int\";\n})(Int_.prototype);\nvar Int8 = class extends Int_ {\n  constructor() {\n    super(true, 8);\n  }\n  get ArrayType() {\n    return Int8Array;\n  }\n};\nvar Int16 = class extends Int_ {\n  constructor() {\n    super(true, 16);\n  }\n  get ArrayType() {\n    return Int16Array;\n  }\n};\nvar Int32 = class extends Int_ {\n  constructor() {\n    super(true, 32);\n  }\n  get ArrayType() {\n    return Int32Array;\n  }\n};\nvar Int64 = class extends Int_ {\n  constructor() {\n    super(true, 64);\n  }\n  get ArrayType() {\n    return BigInt64ArrayCtor;\n  }\n};\nvar Uint8 = class extends Int_ {\n  constructor() {\n    super(false, 8);\n  }\n  get ArrayType() {\n    return Uint8Array;\n  }\n};\nvar Uint16 = class extends Int_ {\n  constructor() {\n    super(false, 16);\n  }\n  get ArrayType() {\n    return Uint16Array;\n  }\n};\nvar Uint32 = class extends Int_ {\n  constructor() {\n    super(false, 32);\n  }\n  get ArrayType() {\n    return Uint32Array;\n  }\n};\nvar Uint64 = class extends Int_ {\n  constructor() {\n    super(false, 64);\n  }\n  get ArrayType() {\n    return BigUint64ArrayCtor;\n  }\n};\nObject.defineProperty(Int8.prototype, \"ArrayType\", { value: Int8Array });\nObject.defineProperty(Int16.prototype, \"ArrayType\", { value: Int16Array });\nObject.defineProperty(Int32.prototype, \"ArrayType\", { value: Int32Array });\nObject.defineProperty(Int64.prototype, \"ArrayType\", { value: BigInt64ArrayCtor });\nObject.defineProperty(Uint8.prototype, \"ArrayType\", { value: Uint8Array });\nObject.defineProperty(Uint16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Uint32.prototype, \"ArrayType\", { value: Uint32Array });\nObject.defineProperty(Uint64.prototype, \"ArrayType\", { value: BigUint64ArrayCtor });\nvar Float = class extends DataType {\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId() {\n    return Type.Float;\n  }\n  get ArrayType() {\n    switch (this.precision) {\n      case Precision.HALF:\n        return Uint16Array;\n      case Precision.SINGLE:\n        return Float32Array;\n      case Precision.DOUBLE:\n        return Float64Array;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `Float${this.precision << 5 || 16}`;\n  }\n};\n_d = Symbol.toStringTag;\nFloat[_d] = ((proto) => {\n  proto.precision = null;\n  return proto[Symbol.toStringTag] = \"Float\";\n})(Float.prototype);\nvar Float16 = class extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n};\nvar Float32 = class extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n};\nvar Float64 = class extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n};\nObject.defineProperty(Float16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Float32.prototype, \"ArrayType\", { value: Float32Array });\nObject.defineProperty(Float64.prototype, \"ArrayType\", { value: Float64Array });\nvar Binary = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return `Binary`;\n  }\n};\n_e = Symbol.toStringTag;\nBinary[_e] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Binary\";\n})(Binary.prototype);\nvar Utf8 = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Utf8;\n  }\n  toString() {\n    return `Utf8`;\n  }\n};\n_f = Symbol.toStringTag;\nUtf8[_f] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Utf8\";\n})(Utf8.prototype);\nvar Bool = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Bool;\n  }\n  toString() {\n    return `Bool`;\n  }\n};\n_g = Symbol.toStringTag;\nBool[_g] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Bool\";\n})(Bool.prototype);\nvar Decimal = class extends DataType {\n  constructor(scale3, precision, bitWidth = 128) {\n    super();\n    this.scale = scale3;\n    this.precision = precision;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Decimal;\n  }\n  toString() {\n    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;\n  }\n};\n_h = Symbol.toStringTag;\nDecimal[_h] = ((proto) => {\n  proto.scale = null;\n  proto.precision = null;\n  proto.ArrayType = Uint32Array;\n  return proto[Symbol.toStringTag] = \"Decimal\";\n})(Decimal.prototype);\nvar Date_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Date;\n  }\n  toString() {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n};\n_j = Symbol.toStringTag;\nDate_[_j] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Date\";\n})(Date_.prototype);\nvar Time_ = class extends DataType {\n  constructor(unit3, bitWidth) {\n    super();\n    this.unit = unit3;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Time;\n  }\n  toString() {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 32:\n        return Int32Array;\n      case 64:\n        return BigInt64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n};\n_k = Symbol.toStringTag;\nTime_[_k] = ((proto) => {\n  proto.unit = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Time\";\n})(Time_.prototype);\nvar Timestamp_ = class extends DataType {\n  constructor(unit3, timezone) {\n    super();\n    this.unit = unit3;\n    this.timezone = timezone;\n  }\n  get typeId() {\n    return Type.Timestamp;\n  }\n  toString() {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;\n  }\n};\n_l = Symbol.toStringTag;\nTimestamp_[_l] = ((proto) => {\n  proto.unit = null;\n  proto.timezone = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Timestamp\";\n})(Timestamp_.prototype);\nvar Interval_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Interval;\n  }\n  toString() {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n};\n_m = Symbol.toStringTag;\nInterval_[_m] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Interval\";\n})(Interval_.prototype);\nvar List = class extends DataType {\n  constructor(child) {\n    super();\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.List;\n  }\n  toString() {\n    return `List<${this.valueType}>`;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n};\n_o = Symbol.toStringTag;\nList[_o] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"List\";\n})(List.prototype);\nvar Struct = class extends DataType {\n  constructor(children2) {\n    super();\n    this.children = children2;\n  }\n  get typeId() {\n    return Type.Struct;\n  }\n  toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_p = Symbol.toStringTag;\nStruct[_p] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"Struct\";\n})(Struct.prototype);\nvar Union_ = class extends DataType {\n  constructor(mode2, typeIds, children2) {\n    super();\n    this.mode = mode2;\n    this.children = children2;\n    this.typeIds = typeIds = Int32Array.from(typeIds);\n    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));\n  }\n  get typeId() {\n    return Type.Union;\n  }\n  toString() {\n    return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;\n  }\n};\n_q = Symbol.toStringTag;\nUnion_[_q] = ((proto) => {\n  proto.mode = null;\n  proto.typeIds = null;\n  proto.children = null;\n  proto.typeIdToChildIndex = null;\n  proto.ArrayType = Int8Array;\n  return proto[Symbol.toStringTag] = \"Union\";\n})(Union_.prototype);\nvar FixedSizeBinary = class extends DataType {\n  constructor(byteWidth) {\n    super();\n    this.byteWidth = byteWidth;\n  }\n  get typeId() {\n    return Type.FixedSizeBinary;\n  }\n  toString() {\n    return `FixedSizeBinary[${this.byteWidth}]`;\n  }\n};\n_r = Symbol.toStringTag;\nFixedSizeBinary[_r] = ((proto) => {\n  proto.byteWidth = null;\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"FixedSizeBinary\";\n})(FixedSizeBinary.prototype);\nvar FixedSizeList = class extends DataType {\n  constructor(listSize, child) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n  toString() {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n};\n_s = Symbol.toStringTag;\nFixedSizeList[_s] = ((proto) => {\n  proto.children = null;\n  proto.listSize = null;\n  return proto[Symbol.toStringTag] = \"FixedSizeList\";\n})(FixedSizeList.prototype);\nvar Map_ = class extends DataType {\n  constructor(child, keysSorted = false) {\n    super();\n    this.children = [child];\n    this.keysSorted = keysSorted;\n  }\n  get typeId() {\n    return Type.Map;\n  }\n  get keyType() {\n    return this.children[0].type.children[0].type;\n  }\n  get valueType() {\n    return this.children[0].type.children[1].type;\n  }\n  get childType() {\n    return this.children[0].type;\n  }\n  toString() {\n    return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_t = Symbol.toStringTag;\nMap_[_t] = ((proto) => {\n  proto.children = null;\n  proto.keysSorted = null;\n  return proto[Symbol.toStringTag] = \"Map_\";\n})(Map_.prototype);\nvar getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);\nvar Dictionary = class extends DataType {\n  constructor(dictionary, indices, id2, isOrdered2) {\n    super();\n    this.indices = indices;\n    this.dictionary = dictionary;\n    this.isOrdered = isOrdered2 || false;\n    this.id = id2 == null ? getId() : typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get typeId() {\n    return Type.Dictionary;\n  }\n  get children() {\n    return this.dictionary.children;\n  }\n  get valueType() {\n    return this.dictionary;\n  }\n  get ArrayType() {\n    return this.dictionary.ArrayType;\n  }\n  toString() {\n    return `Dictionary<${this.indices}, ${this.dictionary}>`;\n  }\n};\n_u = Symbol.toStringTag;\nDictionary[_u] = ((proto) => {\n  proto.id = null;\n  proto.indices = null;\n  proto.isOrdered = null;\n  proto.dictionary = null;\n  return proto[Symbol.toStringTag] = \"Dictionary\";\n})(Dictionary.prototype);\nfunction strideForType(type2) {\n  const t = type2;\n  switch (type2.typeId) {\n    case Type.Decimal:\n      return type2.bitWidth / 32;\n    case Type.Timestamp:\n      return 2;\n    case Type.Date:\n      return 1 + t.unit;\n    case Type.Interval:\n      return 1 + t.unit;\n    case Type.FixedSizeList:\n      return t.listSize;\n    case Type.FixedSizeBinary:\n      return t.byteWidth;\n    default:\n      return 1;\n  }\n}\n\n// node_modules/apache-arrow/visitor.mjs\nvar Visitor = class {\n  visitMany(nodes, ...args) {\n    return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));\n  }\n  visit(...args) {\n    return this.getVisitFn(args[0], false).apply(this, args);\n  }\n  getVisitFn(node, throwIfNotFound = true) {\n    return getVisitFn(this, node, throwIfNotFound);\n  }\n  getVisitFnByTypeId(typeId, throwIfNotFound = true) {\n    return getVisitFnByTypeId(this, typeId, throwIfNotFound);\n  }\n  visitNull(_node, ..._args) {\n    return null;\n  }\n  visitBool(_node, ..._args) {\n    return null;\n  }\n  visitInt(_node, ..._args) {\n    return null;\n  }\n  visitFloat(_node, ..._args) {\n    return null;\n  }\n  visitUtf8(_node, ..._args) {\n    return null;\n  }\n  visitBinary(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeBinary(_node, ..._args) {\n    return null;\n  }\n  visitDate(_node, ..._args) {\n    return null;\n  }\n  visitTimestamp(_node, ..._args) {\n    return null;\n  }\n  visitTime(_node, ..._args) {\n    return null;\n  }\n  visitDecimal(_node, ..._args) {\n    return null;\n  }\n  visitList(_node, ..._args) {\n    return null;\n  }\n  visitStruct(_node, ..._args) {\n    return null;\n  }\n  visitUnion(_node, ..._args) {\n    return null;\n  }\n  visitDictionary(_node, ..._args) {\n    return null;\n  }\n  visitInterval(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeList(_node, ..._args) {\n    return null;\n  }\n  visitMap(_node, ..._args) {\n    return null;\n  }\n};\nfunction getVisitFn(visitor, node, throwIfNotFound = true) {\n  if (typeof node === \"number\") {\n    return getVisitFnByTypeId(visitor, node, throwIfNotFound);\n  }\n  if (typeof node === \"string\" && node in Type) {\n    return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);\n  }\n  if (node && node instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);\n  }\n  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);\n  }\n  return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);\n}\nfunction getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {\n  let fn = null;\n  switch (dtype) {\n    case Type.Null:\n      fn = visitor.visitNull;\n      break;\n    case Type.Bool:\n      fn = visitor.visitBool;\n      break;\n    case Type.Int:\n      fn = visitor.visitInt;\n      break;\n    case Type.Int8:\n      fn = visitor.visitInt8 || visitor.visitInt;\n      break;\n    case Type.Int16:\n      fn = visitor.visitInt16 || visitor.visitInt;\n      break;\n    case Type.Int32:\n      fn = visitor.visitInt32 || visitor.visitInt;\n      break;\n    case Type.Int64:\n      fn = visitor.visitInt64 || visitor.visitInt;\n      break;\n    case Type.Uint8:\n      fn = visitor.visitUint8 || visitor.visitInt;\n      break;\n    case Type.Uint16:\n      fn = visitor.visitUint16 || visitor.visitInt;\n      break;\n    case Type.Uint32:\n      fn = visitor.visitUint32 || visitor.visitInt;\n      break;\n    case Type.Uint64:\n      fn = visitor.visitUint64 || visitor.visitInt;\n      break;\n    case Type.Float:\n      fn = visitor.visitFloat;\n      break;\n    case Type.Float16:\n      fn = visitor.visitFloat16 || visitor.visitFloat;\n      break;\n    case Type.Float32:\n      fn = visitor.visitFloat32 || visitor.visitFloat;\n      break;\n    case Type.Float64:\n      fn = visitor.visitFloat64 || visitor.visitFloat;\n      break;\n    case Type.Utf8:\n      fn = visitor.visitUtf8;\n      break;\n    case Type.Binary:\n      fn = visitor.visitBinary;\n      break;\n    case Type.FixedSizeBinary:\n      fn = visitor.visitFixedSizeBinary;\n      break;\n    case Type.Date:\n      fn = visitor.visitDate;\n      break;\n    case Type.DateDay:\n      fn = visitor.visitDateDay || visitor.visitDate;\n      break;\n    case Type.DateMillisecond:\n      fn = visitor.visitDateMillisecond || visitor.visitDate;\n      break;\n    case Type.Timestamp:\n      fn = visitor.visitTimestamp;\n      break;\n    case Type.TimestampSecond:\n      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMillisecond:\n      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMicrosecond:\n      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampNanosecond:\n      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;\n      break;\n    case Type.Time:\n      fn = visitor.visitTime;\n      break;\n    case Type.TimeSecond:\n      fn = visitor.visitTimeSecond || visitor.visitTime;\n      break;\n    case Type.TimeMillisecond:\n      fn = visitor.visitTimeMillisecond || visitor.visitTime;\n      break;\n    case Type.TimeMicrosecond:\n      fn = visitor.visitTimeMicrosecond || visitor.visitTime;\n      break;\n    case Type.TimeNanosecond:\n      fn = visitor.visitTimeNanosecond || visitor.visitTime;\n      break;\n    case Type.Decimal:\n      fn = visitor.visitDecimal;\n      break;\n    case Type.List:\n      fn = visitor.visitList;\n      break;\n    case Type.Struct:\n      fn = visitor.visitStruct;\n      break;\n    case Type.Union:\n      fn = visitor.visitUnion;\n      break;\n    case Type.DenseUnion:\n      fn = visitor.visitDenseUnion || visitor.visitUnion;\n      break;\n    case Type.SparseUnion:\n      fn = visitor.visitSparseUnion || visitor.visitUnion;\n      break;\n    case Type.Dictionary:\n      fn = visitor.visitDictionary;\n      break;\n    case Type.Interval:\n      fn = visitor.visitInterval;\n      break;\n    case Type.IntervalDayTime:\n      fn = visitor.visitIntervalDayTime || visitor.visitInterval;\n      break;\n    case Type.IntervalYearMonth:\n      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;\n      break;\n    case Type.FixedSizeList:\n      fn = visitor.visitFixedSizeList;\n      break;\n    case Type.Map:\n      fn = visitor.visitMap;\n      break;\n  }\n  if (typeof fn === \"function\")\n    return fn;\n  if (!throwIfNotFound)\n    return () => null;\n  throw new Error(`Unrecognized type '${Type[dtype]}'`);\n}\nfunction inferDType(type2) {\n  switch (type2.typeId) {\n    case Type.Null:\n      return Type.Null;\n    case Type.Int: {\n      const { bitWidth, isSigned } = type2;\n      switch (bitWidth) {\n        case 8:\n          return isSigned ? Type.Int8 : Type.Uint8;\n        case 16:\n          return isSigned ? Type.Int16 : Type.Uint16;\n        case 32:\n          return isSigned ? Type.Int32 : Type.Uint32;\n        case 64:\n          return isSigned ? Type.Int64 : Type.Uint64;\n      }\n      return Type.Int;\n    }\n    case Type.Float:\n      switch (type2.precision) {\n        case Precision.HALF:\n          return Type.Float16;\n        case Precision.SINGLE:\n          return Type.Float32;\n        case Precision.DOUBLE:\n          return Type.Float64;\n      }\n      return Type.Float;\n    case Type.Binary:\n      return Type.Binary;\n    case Type.Utf8:\n      return Type.Utf8;\n    case Type.Bool:\n      return Type.Bool;\n    case Type.Decimal:\n      return Type.Decimal;\n    case Type.Time:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimeSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimeMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimeMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimeNanosecond;\n      }\n      return Type.Time;\n    case Type.Timestamp:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimestampSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimestampMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimestampMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimestampNanosecond;\n      }\n      return Type.Timestamp;\n    case Type.Date:\n      switch (type2.unit) {\n        case DateUnit.DAY:\n          return Type.DateDay;\n        case DateUnit.MILLISECOND:\n          return Type.DateMillisecond;\n      }\n      return Type.Date;\n    case Type.Interval:\n      switch (type2.unit) {\n        case IntervalUnit.DAY_TIME:\n          return Type.IntervalDayTime;\n        case IntervalUnit.YEAR_MONTH:\n          return Type.IntervalYearMonth;\n      }\n      return Type.Interval;\n    case Type.Map:\n      return Type.Map;\n    case Type.List:\n      return Type.List;\n    case Type.Struct:\n      return Type.Struct;\n    case Type.Union:\n      switch (type2.mode) {\n        case UnionMode.Dense:\n          return Type.DenseUnion;\n        case UnionMode.Sparse:\n          return Type.SparseUnion;\n      }\n      return Type.Union;\n    case Type.FixedSizeBinary:\n      return Type.FixedSizeBinary;\n    case Type.FixedSizeList:\n      return Type.FixedSizeList;\n    case Type.Dictionary:\n      return Type.Dictionary;\n  }\n  throw new Error(`Unrecognized type '${Type[type2.typeId]}'`);\n}\nVisitor.prototype.visitInt8 = null;\nVisitor.prototype.visitInt16 = null;\nVisitor.prototype.visitInt32 = null;\nVisitor.prototype.visitInt64 = null;\nVisitor.prototype.visitUint8 = null;\nVisitor.prototype.visitUint16 = null;\nVisitor.prototype.visitUint32 = null;\nVisitor.prototype.visitUint64 = null;\nVisitor.prototype.visitFloat16 = null;\nVisitor.prototype.visitFloat32 = null;\nVisitor.prototype.visitFloat64 = null;\nVisitor.prototype.visitDateDay = null;\nVisitor.prototype.visitDateMillisecond = null;\nVisitor.prototype.visitTimestampSecond = null;\nVisitor.prototype.visitTimestampMillisecond = null;\nVisitor.prototype.visitTimestampMicrosecond = null;\nVisitor.prototype.visitTimestampNanosecond = null;\nVisitor.prototype.visitTimeSecond = null;\nVisitor.prototype.visitTimeMillisecond = null;\nVisitor.prototype.visitTimeMicrosecond = null;\nVisitor.prototype.visitTimeNanosecond = null;\nVisitor.prototype.visitDenseUnion = null;\nVisitor.prototype.visitSparseUnion = null;\nVisitor.prototype.visitIntervalDayTime = null;\nVisitor.prototype.visitIntervalYearMonth = null;\n\n// node_modules/apache-arrow/util/math.mjs\nvar math_exports = {};\n__export(math_exports, {\n  float64ToUint16: () => float64ToUint16,\n  uint16ToFloat64: () => uint16ToFloat64\n});\nvar f64 = new Float64Array(1);\nvar u32 = new Uint32Array(f64.buffer);\nfunction uint16ToFloat64(h) {\n  const expo = (h & 31744) >> 10;\n  const sigf = (h & 1023) / 1024;\n  const sign3 = Math.pow(-1, (h & 32768) >> 15);\n  switch (expo) {\n    case 31:\n      return sign3 * (sigf ? Number.NaN : 1 / 0);\n    case 0:\n      return sign3 * (sigf ? 6103515625e-14 * sigf : 0);\n  }\n  return sign3 * Math.pow(2, expo - 15) * (1 + sigf);\n}\nfunction float64ToUint16(d) {\n  if (d !== d) {\n    return 32256;\n  }\n  f64[0] = d;\n  const sign3 = (u32[1] & 2147483648) >> 16 & 65535;\n  let expo = u32[1] & 2146435072, sigf = 0;\n  if (expo >= 1089470464) {\n    if (u32[0] > 0) {\n      expo = 31744;\n    } else {\n      expo = (expo & 2080374784) >> 16;\n      sigf = (u32[1] & 1048575) >> 10;\n    }\n  } else if (expo <= 1056964608) {\n    sigf = 1048576 + (u32[1] & 1048575);\n    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;\n    expo = 0;\n  } else {\n    expo = expo - 1056964608 >> 10;\n    sigf = (u32[1] & 1048575) + 512 >> 10;\n  }\n  return sign3 | expo | sigf & 65535;\n}\n\n// node_modules/apache-arrow/visitor/set.mjs\nvar SetVisitor = class extends Visitor {\n};\nfunction wrapSet(fn) {\n  return (data, _1, _2) => {\n    if (data.setValid(_1, _2 != null)) {\n      return fn(data, _1, _2);\n    }\n  };\n}\nvar setEpochMsToDays = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs / 864e5);\n};\nvar setEpochMsToMillisecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs / 4294967296);\n};\nvar setEpochMsToMicrosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e3 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);\n};\nvar setEpochMsToNanosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e6 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);\n};\nvar setVariableWidthBytes = (values2, valueOffsets, index3, value) => {\n  if (index3 + 1 < valueOffsets.length) {\n    const { [index3]: x4, [index3 + 1]: y4 } = valueOffsets;\n    values2.set(value.subarray(0, y4 - x4), x4);\n  }\n};\nvar setBool = ({ offset: offset2, values: values2 }, index3, val) => {\n  const idx = offset2 + index3;\n  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);\n};\nvar setInt = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat16 = ({ values: values2 }, index3, value) => {\n  values2[index3] = float64ToUint16(value);\n};\nvar setAnyFloat = (data, index3, value) => {\n  switch (data.type.precision) {\n    case Precision.HALF:\n      return setFloat16(data, index3, value);\n    case Precision.SINGLE:\n    case Precision.DOUBLE:\n      return setFloat(data, index3, value);\n  }\n};\nvar setDateDay = ({ values: values2 }, index3, value) => {\n  setEpochMsToDays(values2, index3, value.valueOf());\n};\nvar setDateMillisecond = ({ values: values2 }, index3, value) => {\n  setEpochMsToMillisecondsLong(values2, index3 * 2, value.valueOf());\n};\nvar setFixedSizeBinary = ({ stride, values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setBinary = ({ values: values2, valueOffsets }, index3, value) => setVariableWidthBytes(values2, valueOffsets, index3, value);\nvar setUtf8 = ({ values: values2, valueOffsets }, index3, value) => {\n  setVariableWidthBytes(values2, valueOffsets, index3, encodeUtf8(value));\n};\nvar setDate = (data, index3, value) => {\n  data.type.unit === DateUnit.DAY ? setDateDay(data, index3, value) : setDateMillisecond(data, index3, value);\n};\nvar setTimestampSecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value / 1e3);\nvar setTimestampMillisecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value);\nvar setTimestampMicrosecond = ({ values: values2 }, index3, value) => setEpochMsToMicrosecondsLong(values2, index3 * 2, value);\nvar setTimestampNanosecond = ({ values: values2 }, index3, value) => setEpochMsToNanosecondsLong(values2, index3 * 2, value);\nvar setTimestamp = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimestampSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimestampMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimestampMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimestampNanosecond(data, index3, value);\n  }\n};\nvar setTimeSecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMillisecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMicrosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeNanosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTime = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimeSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimeMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimeMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimeNanosecond(data, index3, value);\n  }\n};\nvar setDecimal = ({ values: values2, stride }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setList = (data, index3, value) => {\n  const values2 = data.children[0];\n  const valueOffsets = data.valueOffsets;\n  const set4 = instance.getVisitFn(values2);\n  if (Array.isArray(value)) {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value[++idx]);\n    }\n  } else {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value.get(++idx));\n    }\n  }\n};\nvar setMap = (data, index3, value) => {\n  const values2 = data.children[0];\n  const { valueOffsets } = data;\n  const set4 = instance.getVisitFn(values2);\n  let { [index3]: idx, [index3 + 1]: end } = valueOffsets;\n  const entries = value instanceof Map ? value.entries() : Object.entries(value);\n  for (const val of entries) {\n    set4(values2, idx, val);\n    if (++idx >= end)\n      break;\n  }\n};\nvar _setStructArrayValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2[i]);\nvar _setStructVectorValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2.get(i));\nvar _setStructMapValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2.get(f.name));\nvar _setStructObjectValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2[f.name]);\nvar setStruct = (data, index3, value) => {\n  const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));\n  const set4 = value instanceof Map ? _setStructMapValue(index3, value) : value instanceof Vector2 ? _setStructVectorValue(index3, value) : Array.isArray(value) ? _setStructArrayValue(index3, value) : _setStructObjectValue(index3, value);\n  data.type.children.forEach((f, i) => set4(childSetters[i], data.children[i], f, i));\n};\nvar setUnion = (data, index3, value) => {\n  data.type.mode === UnionMode.Dense ? setDenseUnion(data, index3, value) : setSparseUnion(data, index3, value);\n};\nvar setDenseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, data.valueOffsets[index3], value);\n};\nvar setSparseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, index3, value);\n};\nvar setDictionary = (data, index3, value) => {\n  var _a5;\n  (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index3], value);\n};\nvar setIntervalValue = (data, index3, value) => {\n  data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index3, value) : setIntervalYearMonth(data, index3, value);\n};\nvar setIntervalDayTime = ({ values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, 2), 2 * index3);\n};\nvar setIntervalYearMonth = ({ values: values2 }, index3, value) => {\n  values2[index3] = value[0] * 12 + value[1] % 12;\n};\nvar setFixedSizeList = (data, index3, value) => {\n  const { stride } = data;\n  const child = data.children[0];\n  const set4 = instance.getVisitFn(child);\n  if (Array.isArray(value)) {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value[idx]);\n    }\n  } else {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value.get(idx));\n    }\n  }\n};\nSetVisitor.prototype.visitBool = wrapSet(setBool);\nSetVisitor.prototype.visitInt = wrapSet(setInt);\nSetVisitor.prototype.visitInt8 = wrapSet(setInt);\nSetVisitor.prototype.visitInt16 = wrapSet(setInt);\nSetVisitor.prototype.visitInt32 = wrapSet(setInt);\nSetVisitor.prototype.visitInt64 = wrapSet(setInt);\nSetVisitor.prototype.visitUint8 = wrapSet(setInt);\nSetVisitor.prototype.visitUint16 = wrapSet(setInt);\nSetVisitor.prototype.visitUint32 = wrapSet(setInt);\nSetVisitor.prototype.visitUint64 = wrapSet(setInt);\nSetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);\nSetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);\nSetVisitor.prototype.visitFloat32 = wrapSet(setFloat);\nSetVisitor.prototype.visitFloat64 = wrapSet(setFloat);\nSetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);\nSetVisitor.prototype.visitBinary = wrapSet(setBinary);\nSetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);\nSetVisitor.prototype.visitDate = wrapSet(setDate);\nSetVisitor.prototype.visitDateDay = wrapSet(setDateDay);\nSetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);\nSetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);\nSetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);\nSetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);\nSetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);\nSetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);\nSetVisitor.prototype.visitTime = wrapSet(setTime);\nSetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);\nSetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);\nSetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);\nSetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);\nSetVisitor.prototype.visitDecimal = wrapSet(setDecimal);\nSetVisitor.prototype.visitList = wrapSet(setList);\nSetVisitor.prototype.visitStruct = wrapSet(setStruct);\nSetVisitor.prototype.visitUnion = wrapSet(setUnion);\nSetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);\nSetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);\nSetVisitor.prototype.visitDictionary = wrapSet(setDictionary);\nSetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);\nSetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);\nSetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);\nSetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);\nSetVisitor.prototype.visitMap = wrapSet(setMap);\nvar instance = new SetVisitor();\n\n// node_modules/apache-arrow/row/struct.mjs\nvar kParent = Symbol.for(\"parent\");\nvar kRowIndex = Symbol.for(\"rowIndex\");\nvar StructRow = class {\n  constructor(parent, rowIndex) {\n    this[kParent] = parent;\n    this[kRowIndex] = rowIndex;\n    return new Proxy(this, new StructRowProxyHandler());\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const i = this[kRowIndex];\n    const parent = this[kParent];\n    const keys = parent.type.children;\n    const json = {};\n    for (let j = -1, n = keys.length; ++j < n; ) {\n      json[keys[j].name] = instance2.visit(parent.children[j], i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n  [Symbol.iterator]() {\n    return new StructRowIterator(this[kParent], this[kRowIndex]);\n  }\n};\nvar StructRowIterator = class {\n  constructor(data, rowIndex) {\n    this.childIndex = 0;\n    this.children = data.children;\n    this.rowIndex = rowIndex;\n    this.childFields = data.type.children;\n    this.numChildren = this.childFields.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.childIndex;\n    if (i < this.numChildren) {\n      this.childIndex = i + 1;\n      return {\n        done: false,\n        value: [\n          this.childFields[i].name,\n          instance2.visit(this.children[i], this.rowIndex)\n        ]\n      };\n    }\n    return { done: true, value: null };\n  }\n};\nObject.defineProperties(StructRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }\n});\nvar StructRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kParent].type.children.map((f) => f.name);\n  }\n  has(row, key) {\n    return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;\n  }\n  getOwnPropertyDescriptor(row, key) {\n    if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      instance.visit(row[kParent].children[idx], row[kRowIndex], val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key) || typeof key === \"symbol\") {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\n\n// node_modules/apache-arrow/visitor/get.mjs\nvar GetVisitor = class extends Visitor {\n};\nfunction wrapGet(fn) {\n  return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;\n}\nvar epochDaysToMs = (data, index3) => 864e5 * data[index3];\nvar epochMillisecondsLongToMs = (data, index3) => 4294967296 * data[index3 + 1] + (data[index3] >>> 0);\nvar epochMicrosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e3) + (data[index3] >>> 0) / 1e3;\nvar epochNanosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e6) + (data[index3] >>> 0) / 1e6;\nvar epochMillisecondsToDate = (epochMs) => new Date(epochMs);\nvar epochDaysToDate = (data, index3) => epochMillisecondsToDate(epochDaysToMs(data, index3));\nvar epochMillisecondsLongToDate = (data, index3) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index3));\nvar getNull = (_data, _index) => null;\nvar getVariableWidthBytes = (values2, valueOffsets, index3) => {\n  if (index3 + 1 >= valueOffsets.length) {\n    return null;\n  }\n  const x4 = valueOffsets[index3];\n  const y4 = valueOffsets[index3 + 1];\n  return values2.subarray(x4, y4);\n};\nvar getBool = ({ offset: offset2, values: values2 }, index3) => {\n  const idx = offset2 + index3;\n  const byte = values2[idx >> 3];\n  return (byte & 1 << idx % 8) !== 0;\n};\nvar getDateDay = ({ values: values2 }, index3) => epochDaysToDate(values2, index3);\nvar getDateMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToDate(values2, index3 * 2);\nvar getNumeric = ({ stride, values: values2 }, index3) => values2[stride * index3];\nvar getFloat16 = ({ stride, values: values2 }, index3) => uint16ToFloat64(values2[stride * index3]);\nvar getBigInts = ({ values: values2 }, index3) => values2[index3];\nvar getFixedSizeBinary = ({ stride, values: values2 }, index3) => values2.subarray(stride * index3, stride * (index3 + 1));\nvar getBinary = ({ values: values2, valueOffsets }, index3) => getVariableWidthBytes(values2, valueOffsets, index3);\nvar getUtf8 = ({ values: values2, valueOffsets }, index3) => {\n  const bytes = getVariableWidthBytes(values2, valueOffsets, index3);\n  return bytes !== null ? decodeUtf8(bytes) : null;\n};\nvar getInt = ({ values: values2 }, index3) => values2[index3];\nvar getFloat = ({ type: type2, values: values2 }, index3) => type2.precision !== Precision.HALF ? values2[index3] : uint16ToFloat64(values2[index3]);\nvar getDate = (data, index3) => data.type.unit === DateUnit.DAY ? getDateDay(data, index3) : getDateMillisecond(data, index3);\nvar getTimestampSecond = ({ values: values2 }, index3) => 1e3 * epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMicrosecond = ({ values: values2 }, index3) => epochMicrosecondsLongToMs(values2, index3 * 2);\nvar getTimestampNanosecond = ({ values: values2 }, index3) => epochNanosecondsLongToMs(values2, index3 * 2);\nvar getTimestamp = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimestampSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimestampMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimestampMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimestampNanosecond(data, index3);\n  }\n};\nvar getTimeSecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMillisecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMicrosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeNanosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTime = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimeSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimeMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimeMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimeNanosecond(data, index3);\n  }\n};\nvar getDecimal = ({ values: values2, stride }, index3) => BN.decimal(values2.subarray(stride * index3, stride * (index3 + 1)));\nvar getList = (data, index3) => {\n  const { valueOffsets, stride, children: children2 } = data;\n  const { [index3 * stride]: begin, [index3 * stride + 1]: end } = valueOffsets;\n  const child = children2[0];\n  const slice7 = child.slice(begin, end - begin);\n  return new Vector2([slice7]);\n};\nvar getMap = (data, index3) => {\n  const { valueOffsets, children: children2 } = data;\n  const { [index3]: begin, [index3 + 1]: end } = valueOffsets;\n  const child = children2[0];\n  return new MapRow(child.slice(begin, end - begin));\n};\nvar getStruct = (data, index3) => {\n  return new StructRow(data, index3);\n};\nvar getUnion = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index3) : getSparseUnion(data, index3);\n};\nvar getDenseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, data.valueOffsets[index3]);\n};\nvar getSparseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, index3);\n};\nvar getDictionary = (data, index3) => {\n  var _a5;\n  return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index3]);\n};\nvar getInterval = (data, index3) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index3) : getIntervalYearMonth(data, index3);\nvar getIntervalDayTime = ({ values: values2 }, index3) => values2.subarray(2 * index3, 2 * (index3 + 1));\nvar getIntervalYearMonth = ({ values: values2 }, index3) => {\n  const interval2 = values2[index3];\n  const int32s = new Int32Array(2);\n  int32s[0] = Math.trunc(interval2 / 12);\n  int32s[1] = Math.trunc(interval2 % 12);\n  return int32s;\n};\nvar getFixedSizeList = (data, index3) => {\n  const { stride, children: children2 } = data;\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  return new Vector2([slice7]);\n};\nGetVisitor.prototype.visitNull = wrapGet(getNull);\nGetVisitor.prototype.visitBool = wrapGet(getBool);\nGetVisitor.prototype.visitInt = wrapGet(getInt);\nGetVisitor.prototype.visitInt8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitUint8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitFloat = wrapGet(getFloat);\nGetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);\nGetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);\nGetVisitor.prototype.visitBinary = wrapGet(getBinary);\nGetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);\nGetVisitor.prototype.visitDate = wrapGet(getDate);\nGetVisitor.prototype.visitDateDay = wrapGet(getDateDay);\nGetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);\nGetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);\nGetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);\nGetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);\nGetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);\nGetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);\nGetVisitor.prototype.visitTime = wrapGet(getTime);\nGetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);\nGetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);\nGetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);\nGetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);\nGetVisitor.prototype.visitDecimal = wrapGet(getDecimal);\nGetVisitor.prototype.visitList = wrapGet(getList);\nGetVisitor.prototype.visitStruct = wrapGet(getStruct);\nGetVisitor.prototype.visitUnion = wrapGet(getUnion);\nGetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);\nGetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);\nGetVisitor.prototype.visitDictionary = wrapGet(getDictionary);\nGetVisitor.prototype.visitInterval = wrapGet(getInterval);\nGetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);\nGetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);\nGetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);\nGetVisitor.prototype.visitMap = wrapGet(getMap);\nvar instance2 = new GetVisitor();\n\n// node_modules/apache-arrow/row/map.mjs\nvar kKeys = Symbol.for(\"keys\");\nvar kVals = Symbol.for(\"vals\");\nvar MapRow = class {\n  constructor(slice7) {\n    this[kKeys] = new Vector2([slice7.children[0]]).memoize();\n    this[kVals] = slice7.children[1];\n    return new Proxy(this, new MapRowProxyHandler());\n  }\n  [Symbol.iterator]() {\n    return new MapRowIterator(this[kKeys], this[kVals]);\n  }\n  get size() {\n    return this[kKeys].length;\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const keys = this[kKeys];\n    const vals = this[kVals];\n    const json = {};\n    for (let i = -1, n = keys.length; ++i < n; ) {\n      json[keys.get(i)] = instance2.visit(vals, i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n};\nvar MapRowIterator = class {\n  constructor(keys, vals) {\n    this.keys = keys;\n    this.vals = vals;\n    this.keyIndex = 0;\n    this.numKeys = keys.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.keyIndex;\n    if (i === this.numKeys) {\n      return { done: true, value: null };\n    }\n    this.keyIndex++;\n    return {\n      done: false,\n      value: [\n        this.keys.get(i),\n        instance2.visit(this.vals, i)\n      ]\n    };\n  }\n};\nvar MapRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kKeys].toArray().map(String);\n  }\n  has(row, key) {\n    return row[kKeys].includes(key);\n  }\n  getOwnPropertyDescriptor(row, key) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      const val = instance2.visit(Reflect.get(row, kVals), idx);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      instance.visit(Reflect.get(row, kVals), idx, val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key)) {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\nObject.defineProperties(MapRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kVals]: { writable: true, enumerable: false, configurable: false, value: null }\n});\n\n// node_modules/apache-arrow/util/vector.mjs\nfunction clampIndex(source, index3, then) {\n  const length4 = source.length;\n  const adjust = index3 > -1 ? index3 : length4 + index3 % length4;\n  return then ? then(source, adjust) : adjust;\n}\nvar tmp;\nfunction clampRange(source, begin, end, then) {\n  const { length: len = 0 } = source;\n  let lhs = typeof begin !== \"number\" ? 0 : begin;\n  let rhs = typeof end !== \"number\" ? len : end;\n  lhs < 0 && (lhs = (lhs % len + len) % len);\n  rhs < 0 && (rhs = (rhs % len + len) % len);\n  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);\n  rhs > len && (rhs = len);\n  return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\nvar isNaNFast = (value) => value !== value;\nfunction createElementComparator(search) {\n  const typeofSearch = typeof search;\n  if (typeofSearch !== \"object\" || search === null) {\n    if (isNaNFast(search)) {\n      return isNaNFast;\n    }\n    return (value) => value === search;\n  }\n  if (search instanceof Date) {\n    const valueOfSearch = search.valueOf();\n    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;\n  }\n  if (ArrayBuffer.isView(search)) {\n    return (value) => value ? compareArrayLike(search, value) : false;\n  }\n  if (search instanceof Map) {\n    return createMapComparator(search);\n  }\n  if (Array.isArray(search)) {\n    return createArrayLikeComparator(search);\n  }\n  if (search instanceof Vector2) {\n    return createVectorComparator(search);\n  }\n  return createObjectComparator(search, true);\n}\nfunction createArrayLikeComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[i]);\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createMapComparator(lhs) {\n  let i = -1;\n  const comparators = [];\n  for (const v2 of lhs.values())\n    comparators[++i] = createElementComparator(v2);\n  return createSubElementsComparator(comparators);\n}\nfunction createVectorComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs.get(i));\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createObjectComparator(lhs, allowEmpty = false) {\n  const keys = Object.keys(lhs);\n  if (!allowEmpty && keys.length === 0) {\n    return () => false;\n  }\n  const comparators = [];\n  for (let i = -1, n = keys.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[keys[i]]);\n  }\n  return createSubElementsComparator(comparators, keys);\n}\nfunction createSubElementsComparator(comparators, keys) {\n  return (rhs) => {\n    if (!rhs || typeof rhs !== \"object\") {\n      return false;\n    }\n    switch (rhs.constructor) {\n      case Array:\n        return compareArray(comparators, rhs);\n      case Map:\n        return compareObject(comparators, rhs, rhs.keys());\n      case MapRow:\n      case StructRow:\n      case Object:\n      case void 0:\n        return compareObject(comparators, rhs, keys || Object.keys(rhs));\n    }\n    return rhs instanceof Vector2 ? compareVector(comparators, rhs) : false;\n  };\n}\nfunction compareArray(comparators, arr) {\n  const n = comparators.length;\n  if (arr.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](arr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareVector(comparators, vec2) {\n  const n = comparators.length;\n  if (vec2.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](vec2.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareObject(comparators, obj, keys) {\n  const lKeyItr = keys[Symbol.iterator]();\n  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n  let i = 0;\n  const n = comparators.length;\n  let rVal = rValItr.next();\n  let lKey = lKeyItr.next();\n  let rKey = rKeyItr.next();\n  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n      break;\n    }\n  }\n  if (i === n && lKey.done && rKey.done && rVal.done) {\n    return true;\n  }\n  lKeyItr.return && lKeyItr.return();\n  rKeyItr.return && rKeyItr.return();\n  rValItr.return && rValItr.return();\n  return false;\n}\n\n// node_modules/apache-arrow/util/bit.mjs\nvar bit_exports = {};\n__export(bit_exports, {\n  BitIterator: () => BitIterator,\n  getBit: () => getBit,\n  getBool: () => getBool2,\n  packBools: () => packBools,\n  popcnt_array: () => popcnt_array,\n  popcnt_bit_range: () => popcnt_bit_range,\n  popcnt_uint32: () => popcnt_uint32,\n  setBool: () => setBool2,\n  truncateBitmap: () => truncateBitmap\n});\nfunction getBool2(_data, _index, byte, bit) {\n  return (byte & 1 << bit) !== 0;\n}\nfunction getBit(_data, _index, byte, bit) {\n  return (byte & 1 << bit) >> bit;\n}\nfunction setBool2(bytes, index3, value) {\n  return value ? !!(bytes[index3 >> 3] |= 1 << index3 % 8) || true : !(bytes[index3 >> 3] &= ~(1 << index3 % 8)) && false;\n}\nfunction truncateBitmap(offset2, length4, bitmap) {\n  const alignedSize = bitmap.byteLength + 7 & ~7;\n  if (offset2 > 0 || bitmap.byteLength < alignedSize) {\n    const bytes = new Uint8Array(alignedSize);\n    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (\n      // Otherwise iterate each bit from the offset and return a new one\n      packBools(new BitIterator(bitmap, offset2, length4, null, getBool2)).subarray(0, alignedSize)\n    ));\n    return bytes;\n  }\n  return bitmap;\n}\nfunction packBools(values2) {\n  const xs = [];\n  let i = 0, bit = 0, byte = 0;\n  for (const value of values2) {\n    value && (byte |= 1 << bit);\n    if (++bit === 8) {\n      xs[i++] = byte;\n      byte = bit = 0;\n    }\n  }\n  if (i === 0 || bit > 0) {\n    xs[i++] = byte;\n  }\n  const b = new Uint8Array(xs.length + 7 & ~7);\n  b.set(xs);\n  return b;\n}\nvar BitIterator = class {\n  constructor(bytes, begin, length4, context, get3) {\n    this.bytes = bytes;\n    this.length = length4;\n    this.context = context;\n    this.get = get3;\n    this.bit = begin % 8;\n    this.byteIndex = begin >> 3;\n    this.byte = bytes[this.byteIndex++];\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.length) {\n      if (this.bit === 8) {\n        this.bit = 0;\n        this.byte = this.bytes[this.byteIndex++];\n      }\n      return {\n        value: this.get(this.context, this.index++, this.byte, this.bit++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction popcnt_bit_range(data, lhs, rhs) {\n  if (rhs - lhs <= 0) {\n    return 0;\n  }\n  if (rhs - lhs < 8) {\n    let sum5 = 0;\n    for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {\n      sum5 += bit;\n    }\n    return sum5;\n  }\n  const rhsInside = rhs >> 3 << 3;\n  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);\n  return (\n    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8\n    popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8\n    popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8\n    popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)\n  );\n}\nfunction popcnt_array(arr, byteOffset, byteLength) {\n  let cnt = 0, pos = Math.trunc(byteOffset);\n  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;\n  while (len - pos >= 4) {\n    cnt += popcnt_uint32(view.getUint32(pos));\n    pos += 4;\n  }\n  while (len - pos >= 2) {\n    cnt += popcnt_uint32(view.getUint16(pos));\n    pos += 2;\n  }\n  while (len - pos >= 1) {\n    cnt += popcnt_uint32(view.getUint8(pos));\n    pos += 1;\n  }\n  return cnt;\n}\nfunction popcnt_uint32(uint32) {\n  let i = Math.trunc(uint32);\n  i = i - (i >>> 1 & 1431655765);\n  i = (i & 858993459) + (i >>> 2 & 858993459);\n  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;\n}\n\n// node_modules/apache-arrow/data.mjs\nvar kUnknownNullCount = -1;\nvar Data = class {\n  constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {\n    this.type = type2;\n    this.children = children2;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset2 || 0, 0));\n    this.length = Math.floor(Math.max(length4 || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    let buffer;\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type2);\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n    this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get buffers() {\n    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n  }\n  get byteLength() {\n    let byteLength = 0;\n    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;\n    valueOffsets && (byteLength += valueOffsets.byteLength);\n    values2 && (byteLength += values2.byteLength);\n    nullBitmap && (byteLength += nullBitmap.byteLength);\n    typeIds && (byteLength += typeIds.byteLength);\n    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);\n  }\n  get nullCount() {\n    let nullCount = this._nullCount;\n    let nullBitmap;\n    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n    }\n    return nullCount;\n  }\n  getValid(index3) {\n    if (this.nullable && this.nullCount > 0) {\n      const pos = this.offset + index3;\n      const val = this.nullBitmap[pos >> 3];\n      return (val & 1 << pos % 8) !== 0;\n    }\n    return true;\n  }\n  setValid(index3, value) {\n    if (!this.nullable) {\n      return value;\n    }\n    if (!this.nullBitmap || this.nullBitmap.byteLength <= index3 >> 3) {\n      const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);\n      Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });\n    }\n    const { nullBitmap, offset: offset2 } = this;\n    const pos = offset2 + index3 >> 3;\n    const bit = (offset2 + index3) % 8;\n    const val = nullBitmap[pos] >> bit & 1;\n    value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);\n    return value;\n  }\n  clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {\n    return new Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);\n  }\n  slice(offset2, length4) {\n    const { stride, typeId, children: children2 } = this;\n    const nullCount = +(this._nullCount === 0) - 1;\n    const childStride = typeId === 16 ? stride : 1;\n    const buffers = this._sliceBuffers(offset2, length4, stride, typeId);\n    return this.clone(\n      this.type,\n      this.offset + offset2,\n      length4,\n      nullCount,\n      buffers,\n      // Don't slice children if we have value offsets (the variable-width types)\n      children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)\n    );\n  }\n  _changeLengthAndBackfillNullBitmap(newLength) {\n    if (this.typeId === Type.Null) {\n      return this.clone(this.type, 0, newLength, 0);\n    }\n    const { length: length4, nullCount } = this;\n    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);\n    bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;\n    if (nullCount > 0) {\n      bitmap.set(truncateBitmap(this.offset, length4, this.nullBitmap), 0);\n    }\n    const buffers = this.buffers;\n    buffers[BufferType.VALIDITY] = bitmap;\n    return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);\n  }\n  _sliceBuffers(offset2, length4, stride, typeId) {\n    let arr;\n    const { buffers } = this;\n    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length4));\n    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));\n    return buffers;\n  }\n  _sliceChildren(children2, offset2, length4) {\n    return children2.map((child) => child.slice(offset2, length4));\n  }\n};\nData.prototype.children = Object.freeze([]);\nvar MakeDataVisitor = class extends Visitor {\n  visit(props) {\n    return this.getVisitFn(props[\"type\"]).call(this, props);\n  }\n  visitNull(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"length\"]: length4 = 0 } = props;\n    return new Data(type2, offset2, length4, 0);\n  }\n  visitBool(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length >> 3, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitInt(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFloat(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitUtf8(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitFixedSizeBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDate(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTimestamp(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTime(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDecimal(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n  visitStruct(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { length: length4 = children2.reduce((len, { length: length5 }) => Math.max(len, length5), 0), nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);\n  }\n  visitUnion(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const typeIds = toArrayBufferView(type2.ArrayType, props[\"typeIds\"]);\n    const { [\"length\"]: length4 = typeIds.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    if (DataType.isSparseUnion(type2)) {\n      return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap, typeIds], children2);\n    }\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children2);\n  }\n  visitDictionary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.indices.ArrayType, props[\"data\"]);\n    const { [\"dictionary\"]: dictionary = new Vector2([new MakeDataVisitor().visit({ type: type2.dictionary })]) } = props;\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);\n  }\n  visitInterval(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFixedSizeList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.valueType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { [\"length\"]: length4 = child.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);\n  }\n  visitMap(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.childType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n};\nfunction makeData(props) {\n  return new MakeDataVisitor().visit(props);\n}\n\n// node_modules/apache-arrow/util/chunk.mjs\nvar ChunkedIterator = class {\n  constructor(numChunks = 0, getChunkIterator) {\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  next() {\n    while (this.chunkIndex < this.numChunks) {\n      const next = this.chunkIterator.next();\n      if (!next.done) {\n        return next;\n      }\n      if (++this.chunkIndex < this.numChunks) {\n        this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n      }\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction computeChunkNullCounts(chunks) {\n  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\nfunction computeChunkOffsets(chunks) {\n  return chunks.reduce((offsets, chunk, index3) => {\n    offsets[index3 + 1] = offsets[index3] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\nfunction sliceChunks(chunks, offsets, begin, end) {\n  const slices = [];\n  for (let i = -1, n = chunks.length; ++i < n; ) {\n    const chunk = chunks[i];\n    const offset2 = offsets[i];\n    const { length: length4 } = chunk;\n    if (offset2 >= end) {\n      break;\n    }\n    if (begin >= offset2 + length4) {\n      continue;\n    }\n    if (offset2 >= begin && offset2 + length4 <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    const from = Math.max(0, begin - offset2);\n    const to = Math.min(end - offset2, length4);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\nfunction binarySearch(chunks, offsets, idx, fn) {\n  let lhs = 0, mid3 = 0, rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid3 = lhs + Math.trunc((rhs - lhs) * 0.5);\n    idx < offsets[mid3] ? rhs = mid3 : lhs = mid3;\n  } while (lhs < rhs);\n}\nfunction isChunkedValid(data, index3) {\n  return data.getValid(index3);\n}\nfunction wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function(index3) {\n    const data = this.data;\n    return binarySearch(data, this._offsets, index3, chunkedFn);\n  };\n}\nfunction wrapChunkedCall2(fn) {\n  let _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function(index3, value) {\n    const data = this.data;\n    _2 = value;\n    const result = binarySearch(data, this._offsets, index3, chunkedFn);\n    _2 = void 0;\n    return result;\n  };\n}\nfunction wrapChunkedIndexOf(indexOf2) {\n  let _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    let begin = fromIndex, index3 = 0, total = 0;\n    for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {\n      const chunk = data[i];\n      if (~(index3 = indexOf2(chunk, _1, begin))) {\n        return total + index3;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function(element, offset2) {\n    _1 = element;\n    const data = this.data;\n    const result = typeof offset2 !== \"number\" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset2, chunkedIndexOf);\n    _1 = void 0;\n    return result;\n  };\n}\n\n// node_modules/apache-arrow/visitor/indexof.mjs\nvar IndexOfVisitor = class extends Visitor {\n};\nfunction nullIndexOf(data, searchElement) {\n  return searchElement === null && data.length > 0 ? 0 : -1;\n}\nfunction indexOfNull(data, fromIndex) {\n  const { nullBitmap } = data;\n  if (!nullBitmap || data.nullCount <= 0) {\n    return -1;\n  }\n  let i = 0;\n  for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {\n    if (!isValid) {\n      return i;\n    }\n    ++i;\n  }\n  return -1;\n}\nfunction indexOfValue(data, searchElement, fromIndex) {\n  if (searchElement === void 0) {\n    return -1;\n  }\n  if (searchElement === null) {\n    return indexOfNull(data, fromIndex);\n  }\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction indexOfUnion(data, searchElement, fromIndex) {\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nIndexOfVisitor.prototype.visitNull = nullIndexOf;\nIndexOfVisitor.prototype.visitBool = indexOfValue;\nIndexOfVisitor.prototype.visitInt = indexOfValue;\nIndexOfVisitor.prototype.visitInt8 = indexOfValue;\nIndexOfVisitor.prototype.visitInt16 = indexOfValue;\nIndexOfVisitor.prototype.visitInt32 = indexOfValue;\nIndexOfVisitor.prototype.visitInt64 = indexOfValue;\nIndexOfVisitor.prototype.visitUint8 = indexOfValue;\nIndexOfVisitor.prototype.visitUint16 = indexOfValue;\nIndexOfVisitor.prototype.visitUint32 = indexOfValue;\nIndexOfVisitor.prototype.visitUint64 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat = indexOfValue;\nIndexOfVisitor.prototype.visitFloat16 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat32 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat64 = indexOfValue;\nIndexOfVisitor.prototype.visitUtf8 = indexOfValue;\nIndexOfVisitor.prototype.visitBinary = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;\nIndexOfVisitor.prototype.visitDate = indexOfValue;\nIndexOfVisitor.prototype.visitDateDay = indexOfValue;\nIndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestamp = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTime = indexOfValue;\nIndexOfVisitor.prototype.visitTimeSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitDecimal = indexOfValue;\nIndexOfVisitor.prototype.visitList = indexOfValue;\nIndexOfVisitor.prototype.visitStruct = indexOfValue;\nIndexOfVisitor.prototype.visitUnion = indexOfValue;\nIndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitDictionary = indexOfValue;\nIndexOfVisitor.prototype.visitInterval = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;\nIndexOfVisitor.prototype.visitMap = indexOfValue;\nvar instance3 = new IndexOfVisitor();\n\n// node_modules/apache-arrow/visitor/iterator.mjs\nvar IteratorVisitor = class extends Visitor {\n};\nfunction vectorIterator(vector2) {\n  const { type: type2 } = vector2;\n  if (vector2.nullCount === 0 && vector2.stride === 1 && (type2.typeId === Type.Timestamp || type2 instanceof Int_ && type2.bitWidth !== 64 || type2 instanceof Time_ && type2.bitWidth !== 64 || type2 instanceof Float && type2.precision !== Precision.HALF)) {\n    return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n      const data = vector2.data[chunkIndex];\n      return data.values.subarray(0, data.length)[Symbol.iterator]();\n    });\n  }\n  let offset2 = 0;\n  return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n    const data = vector2.data[chunkIndex];\n    const length4 = data.length;\n    const inner = vector2.slice(offset2, offset2 + length4);\n    offset2 += length4;\n    return new VectorIterator(inner);\n  });\n}\nvar VectorIterator = class {\n  constructor(vector2) {\n    this.vector = vector2;\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.vector.length) {\n      return {\n        value: this.vector.get(this.index++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nIteratorVisitor.prototype.visitNull = vectorIterator;\nIteratorVisitor.prototype.visitBool = vectorIterator;\nIteratorVisitor.prototype.visitInt = vectorIterator;\nIteratorVisitor.prototype.visitInt8 = vectorIterator;\nIteratorVisitor.prototype.visitInt16 = vectorIterator;\nIteratorVisitor.prototype.visitInt32 = vectorIterator;\nIteratorVisitor.prototype.visitInt64 = vectorIterator;\nIteratorVisitor.prototype.visitUint8 = vectorIterator;\nIteratorVisitor.prototype.visitUint16 = vectorIterator;\nIteratorVisitor.prototype.visitUint32 = vectorIterator;\nIteratorVisitor.prototype.visitUint64 = vectorIterator;\nIteratorVisitor.prototype.visitFloat = vectorIterator;\nIteratorVisitor.prototype.visitFloat16 = vectorIterator;\nIteratorVisitor.prototype.visitFloat32 = vectorIterator;\nIteratorVisitor.prototype.visitFloat64 = vectorIterator;\nIteratorVisitor.prototype.visitUtf8 = vectorIterator;\nIteratorVisitor.prototype.visitBinary = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;\nIteratorVisitor.prototype.visitDate = vectorIterator;\nIteratorVisitor.prototype.visitDateDay = vectorIterator;\nIteratorVisitor.prototype.visitDateMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestamp = vectorIterator;\nIteratorVisitor.prototype.visitTimestampSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitTime = vectorIterator;\nIteratorVisitor.prototype.visitTimeSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitDecimal = vectorIterator;\nIteratorVisitor.prototype.visitList = vectorIterator;\nIteratorVisitor.prototype.visitStruct = vectorIterator;\nIteratorVisitor.prototype.visitUnion = vectorIterator;\nIteratorVisitor.prototype.visitDenseUnion = vectorIterator;\nIteratorVisitor.prototype.visitSparseUnion = vectorIterator;\nIteratorVisitor.prototype.visitDictionary = vectorIterator;\nIteratorVisitor.prototype.visitInterval = vectorIterator;\nIteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;\nIteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeList = vectorIterator;\nIteratorVisitor.prototype.visitMap = vectorIterator;\nvar instance4 = new IteratorVisitor();\n\n// node_modules/apache-arrow/visitor/bytelength.mjs\nvar sum4 = (x4, y4) => x4 + y4;\nvar GetByteLengthVisitor = class extends Visitor {\n  visitNull(____, _) {\n    return 0;\n  }\n  visitInt(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitFloat(data, _) {\n    return data.type.ArrayType.BYTES_PER_ELEMENT;\n  }\n  visitBool(____, _) {\n    return 1 / 8;\n  }\n  visitDecimal(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitDate(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitTime(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitTimestamp(data, _) {\n    return data.type.unit === TimeUnit.SECOND ? 4 : 8;\n  }\n  visitInterval(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitStruct(data, i) {\n    return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitFixedSizeBinary(data, _) {\n    return data.type.byteWidth;\n  }\n  visitMap(data, i) {\n    return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitDictionary(data, i) {\n    var _a5;\n    return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);\n  }\n};\nvar getUtf8ByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getBinaryByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getListByteLength = ({ valueOffsets, stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const { [index3 * stride]: start2 } = valueOffsets;\n  const { [index3 * stride + 1]: end } = valueOffsets;\n  const visit = instance5.getVisitFn(child.type);\n  const slice7 = child.slice(start2, end - start2);\n  let size = 8;\n  for (let idx = -1, len = end - start2; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getFixedSizeListByteLength = ({ stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  const visit = instance5.getVisitFn(child.type);\n  let size = 0;\n  for (let idx = -1, len = slice7.length; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getUnionByteLength = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index3) : getSparseUnionByteLength(data, index3);\n};\nvar getDenseUnionByteLength = ({ type: type2, children: children2, typeIds, valueOffsets }, index3) => {\n  const childIndex = type2.typeIdToChildIndex[typeIds[index3]];\n  return 8 + instance5.visit(children2[childIndex], valueOffsets[index3]);\n};\nvar getSparseUnionByteLength = ({ children: children2 }, index3) => {\n  return 4 + instance5.visitMany(children2, children2.map(() => index3)).reduce(sum4, 0);\n};\nGetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;\nGetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;\nGetByteLengthVisitor.prototype.visitList = getListByteLength;\nGetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;\nGetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;\nGetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;\nGetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;\nvar instance5 = new GetByteLengthVisitor();\n\n// node_modules/apache-arrow/vector.mjs\nvar _a2;\nvar visitorsByTypeId = {};\nvar vectorPrototypesByTypeId = {};\nvar Vector2 = class {\n  constructor(input) {\n    var _b2, _c2, _d2;\n    const data = input[0] instanceof Vector2 ? input.flatMap((x4) => x4.data) : input;\n    if (data.length === 0 || data.some((x4) => !(x4 instanceof Data))) {\n      throw new TypeError(\"Vector constructor expects an Array of Data instances.\");\n    }\n    const type2 = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;\n    switch (data.length) {\n      case 0:\n        this._offsets = [0];\n        break;\n      case 1: {\n        const { get: get3, set: set4, indexOf: indexOf2, byteLength } = visitorsByTypeId[type2.typeId];\n        const unchunkedData = data[0];\n        this.isValid = (index3) => isChunkedValid(unchunkedData, index3);\n        this.get = (index3) => get3(unchunkedData, index3);\n        this.set = (index3, value) => set4(unchunkedData, index3, value);\n        this.indexOf = (index3) => indexOf2(unchunkedData, index3);\n        this.getByteLength = (index3) => byteLength(unchunkedData, index3);\n        this._offsets = [0, unchunkedData.length];\n        break;\n      }\n      default:\n        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type2.typeId]);\n        this._offsets = computeChunkOffsets(data);\n        break;\n    }\n    this.data = data;\n    this.type = type2;\n    this.stride = strideForType(type2);\n    this.numChildren = (_d2 = (_c2 = type2.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;\n    this.length = this._offsets[this._offsets.length - 1];\n  }\n  /**\n   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.\n   */\n  get byteLength() {\n    if (this._byteLength === -1) {\n      this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);\n    }\n    return this._byteLength;\n  }\n  /**\n   * The number of null elements in this Vector.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * The Array or TypedAray constructor used for the JS representation\n   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.\n   */\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  /**\n   * The name that should be printed when the Vector is logged in a message.\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;\n  }\n  /**\n   * The name of this Vector.\n   */\n  get VectorName() {\n    return `${Type[this.type.typeId]}Vector`;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  includes(element, offset2) {\n    return this.indexOf(element, offset2) > 0;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for the Vector's elements.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(this);\n  }\n  /**\n   * Combines two or more Vectors of the same type.\n   * @param others Additional Vectors to add to the end of this Vector.\n   */\n  concat(...others) {\n    return new Vector2(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Vector.\n   * @param start The beginning of the specified portion of the Vector.\n   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    return new Vector2(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));\n  }\n  toJSON() {\n    return [...this];\n  }\n  /**\n   * Return a JavaScript Array or TypedArray of the Vector's elements.\n   *\n   * @note If this Vector contains a single Data chunk and the Vector's type is a\n   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this\n   *  method returns a zero-copy slice of the underlying TypedArray values. If there's\n   *  more than one chunk, the resulting TypedArray will be a copy of the data from each\n   *  chunk's underlying TypedArray values.\n   *\n   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.\n   */\n  toArray() {\n    const { type: type2, data, length: length4, stride, ArrayType } = this;\n    switch (type2.typeId) {\n      case Type.Int:\n      case Type.Float:\n      case Type.Decimal:\n      case Type.Time:\n      case Type.Timestamp:\n        switch (data.length) {\n          case 0:\n            return new ArrayType();\n          case 1:\n            return data[0].values.subarray(0, length4 * stride);\n          default:\n            return data.reduce((memo, { values: values2, length: chunk_length }) => {\n              memo.array.set(values2.subarray(0, chunk_length * stride), memo.offset);\n              memo.offset += chunk_length * stride;\n              return memo;\n            }, { array: new ArrayType(length4 * stride), offset: 0 }).array;\n        }\n    }\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Vector.\n   *\n   * @returns A string representation of the Vector.\n   */\n  toString() {\n    return `[${[...this].join(\",\")}]`;\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.numChildren) {\n      return new Vector2(this.data.map(({ children: children2 }) => children2[index3]));\n    }\n    return null;\n  }\n  get isMemoized() {\n    if (DataType.isDictionary(this.type)) {\n      return this.data[0].dictionary.isMemoized;\n    }\n    return false;\n  }\n  /**\n   * Adds memoization to the Vector's {@link get} method. For dictionary\n   * vectors, this method return a vector that memoizes only the dictionary\n   * values.\n   *\n   * Memoization is very useful when decoding a value is expensive such as\n   * Uft8. The memoization creates a cache of the size of the Vector and\n   * therfore increases memory usage.\n   *\n   * @returns A new vector that memoizes calls to {@link get}.\n   */\n  memoize() {\n    if (DataType.isDictionary(this.type)) {\n      const dictionary = new MemoizedVector(this.data[0].dictionary);\n      const newData = this.data.map((data) => {\n        const cloned = data.clone();\n        cloned.dictionary = dictionary;\n        return cloned;\n      });\n      return new Vector2(newData);\n    }\n    return new MemoizedVector(this);\n  }\n  /**\n   * Returns a vector without memoization of the {@link get} method. If this\n   * vector is not memoized, this method returns this vector.\n   *\n   * @returns A a vector without memoization.\n   */\n  unmemoize() {\n    if (DataType.isDictionary(this.type) && this.isMemoized) {\n      const dictionary = this.data[0].dictionary.unmemoize();\n      const newData = this.data.map((data) => {\n        const newData2 = data.clone();\n        newData2.dictionary = dictionary;\n        return newData2;\n      });\n      return new Vector2(newData);\n    }\n    return this;\n  }\n};\n_a2 = Symbol.toStringTag;\nVector2[_a2] = ((proto) => {\n  proto.type = DataType.prototype;\n  proto.data = [];\n  proto.length = 0;\n  proto.stride = 1;\n  proto.numChildren = 0;\n  proto._nullCount = -1;\n  proto._byteLength = -1;\n  proto._offsets = new Uint32Array([0]);\n  proto[Symbol.isConcatSpreadable] = true;\n  const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === \"number\" && T !== Type.NONE);\n  for (const typeId of typeIds) {\n    const get3 = instance2.getVisitFnByTypeId(typeId);\n    const set4 = instance.getVisitFnByTypeId(typeId);\n    const indexOf2 = instance3.getVisitFnByTypeId(typeId);\n    const byteLength = instance5.getVisitFnByTypeId(typeId);\n    visitorsByTypeId[typeId] = { get: get3, set: set4, indexOf: indexOf2, byteLength };\n    vectorPrototypesByTypeId[typeId] = Object.create(proto, {\n      [\"isValid\"]: { value: wrapChunkedCall1(isChunkedValid) },\n      [\"get\"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },\n      [\"set\"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },\n      [\"indexOf\"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },\n      [\"getByteLength\"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }\n    });\n  }\n  return \"Vector\";\n})(Vector2.prototype);\nvar MemoizedVector = class extends Vector2 {\n  constructor(vector2) {\n    super(vector2.data);\n    const get3 = this.get;\n    const set4 = this.set;\n    const slice7 = this.slice;\n    const cache = new Array(this.length);\n    Object.defineProperty(this, \"get\", {\n      value(index3) {\n        const cachedValue = cache[index3];\n        if (cachedValue !== void 0) {\n          return cachedValue;\n        }\n        const value = get3.call(this, index3);\n        cache[index3] = value;\n        return value;\n      }\n    });\n    Object.defineProperty(this, \"set\", {\n      value(index3, value) {\n        set4.call(this, index3, value);\n        cache[index3] = value;\n      }\n    });\n    Object.defineProperty(this, \"slice\", {\n      value: (begin, end) => new MemoizedVector(slice7.call(this, begin, end))\n    });\n    Object.defineProperty(this, \"isMemoized\", { value: true });\n    Object.defineProperty(this, \"unmemoize\", {\n      value: () => new Vector2(this.data)\n    });\n    Object.defineProperty(this, \"memoize\", {\n      value: () => this\n    });\n  }\n};\n\n// node_modules/apache-arrow/builder/valid.mjs\nfunction createIsValidFunction(nullValues) {\n  if (!nullValues || nullValues.length <= 0) {\n    return function isValid(value) {\n      return true;\n    };\n  }\n  let fnBody = \"\";\n  const noNaNs = nullValues.filter((x4) => x4 === x4);\n  if (noNaNs.length > 0) {\n    fnBody = `\n    switch (x) {${noNaNs.map((x4) => `\n        case ${valueToCase(x4)}:`).join(\"\")}\n            return false;\n    }`;\n  }\n  if (nullValues.length !== noNaNs.length) {\n    fnBody = `if (x !== x) return false;\n${fnBody}`;\n  }\n  return new Function(`x`, `${fnBody}\nreturn true;`);\n}\nfunction valueToCase(x4) {\n  if (typeof x4 !== \"bigint\") {\n    return valueToString(x4);\n  } else if (BigIntAvailable) {\n    return `${valueToString(x4)}n`;\n  }\n  return `\"${valueToString(x4)}\"`;\n}\n\n// node_modules/apache-arrow/builder/buffer.mjs\nvar roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;\nvar sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);\nvar BufferBuilder = class {\n  constructor(buffer, stride = 1) {\n    this.buffer = buffer;\n    this.stride = stride;\n    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;\n    this.ArrayType = buffer.constructor;\n    this._resize(this.length = Math.ceil(buffer.length / stride));\n  }\n  get byteLength() {\n    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;\n  }\n  get reservedLength() {\n    return this.buffer.length / this.stride;\n  }\n  get reservedByteLength() {\n    return this.buffer.byteLength;\n  }\n  // @ts-ignore\n  set(index3, value) {\n    return this;\n  }\n  append(value) {\n    return this.set(this.length, value);\n  }\n  reserve(extra) {\n    if (extra > 0) {\n      this.length += extra;\n      const stride = this.stride;\n      const length4 = this.length * stride;\n      const reserved = this.buffer.length;\n      if (length4 >= reserved) {\n        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length4 * 2, this.BYTES_PER_ELEMENT));\n      }\n    }\n    return this;\n  }\n  flush(length4 = this.length) {\n    length4 = roundLengthUpToNearest64Bytes(length4 * this.stride, this.BYTES_PER_ELEMENT);\n    const array4 = sliceOrExtendArray(this.buffer, length4);\n    this.clear();\n    return array4;\n  }\n  clear() {\n    this.length = 0;\n    this._resize(0);\n    return this;\n  }\n  _resize(newLength) {\n    return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);\n  }\n};\nBufferBuilder.prototype.offset = 0;\nvar DataBufferBuilder = class extends BufferBuilder {\n  last() {\n    return this.get(this.length - 1);\n  }\n  get(index3) {\n    return this.buffer[index3];\n  }\n  set(index3, value) {\n    this.reserve(index3 - this.length + 1);\n    this.buffer[index3 * this.stride] = value;\n    return this;\n  }\n};\nvar BitmapBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Uint8Array(0)) {\n    super(data, 1 / 8);\n    this.numValid = 0;\n  }\n  get numInvalid() {\n    return this.length - this.numValid;\n  }\n  get(idx) {\n    return this.buffer[idx >> 3] >> idx % 8 & 1;\n  }\n  set(idx, val) {\n    const { buffer } = this.reserve(idx - this.length + 1);\n    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;\n    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);\n    return this;\n  }\n  clear() {\n    this.numValid = 0;\n    return super.clear();\n  }\n};\nvar OffsetsBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Int32Array(1)) {\n    super(data, 1);\n  }\n  append(value) {\n    return this.set(this.length - 1, value);\n  }\n  set(index3, value) {\n    const offset2 = this.length - 1;\n    const buffer = this.reserve(index3 - offset2 + 1).buffer;\n    if (offset2 < index3++) {\n      buffer.fill(buffer[offset2], offset2, index3);\n    }\n    buffer[index3] = buffer[index3 - 1] + value;\n    return this;\n  }\n  flush(length4 = this.length - 1) {\n    if (length4 > this.length) {\n      this.set(length4 - 1, 0);\n    }\n    return super.flush(length4 + 1);\n  }\n};\n\n// node_modules/apache-arrow/builder.mjs\nvar Builder = class {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  constructor({ \"type\": type2, \"nullValues\": nulls }) {\n    this.length = 0;\n    this.finished = false;\n    this.type = type2;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type2);\n    this._nulls = new BitmapBufferBuilder();\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughDOM(options) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /**\n   * Flush the `Builder` and return a `Vector<T>`.\n   * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n   */\n  toVector() {\n    return new Vector2([this.flush()]);\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get nullCount() {\n    return this._nulls.numInvalid;\n  }\n  get numChildren() {\n    return this.children.length;\n  }\n  /**\n   * @returns The aggregate length (in bytes) of the values that have been written.\n   */\n  get byteLength() {\n    let size = 0;\n    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;\n    _offsets && (size += _offsets.byteLength);\n    _values && (size += _values.byteLength);\n    _nulls && (size += _nulls.byteLength);\n    _typeIds && (size += _typeIds.byteLength);\n    return children2.reduce((size2, child) => size2 + child.byteLength, size);\n  }\n  /**\n   * @returns The aggregate number of rows that have been reserved to write new values.\n   */\n  get reservedLength() {\n    return this._nulls.reservedLength;\n  }\n  /**\n   * @returns The aggregate length (in bytes) that has been reserved to write new values.\n   */\n  get reservedByteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.reservedByteLength);\n    this._values && (size += this._values.reservedByteLength);\n    this._nulls && (size += this._nulls.reservedByteLength);\n    this._typeIds && (size += this._typeIds.reservedByteLength);\n    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);\n  }\n  get valueOffsets() {\n    return this._offsets ? this._offsets.buffer : null;\n  }\n  get values() {\n    return this._values ? this._values.buffer : null;\n  }\n  get nullBitmap() {\n    return this._nulls ? this._nulls.buffer : null;\n  }\n  get typeIds() {\n    return this._typeIds ? this._typeIds.buffer : null;\n  }\n  /**\n   * Appends a value (or null) to this `Builder`.\n   * This is equivalent to `builder.set(builder.length, value)`.\n   * @param {T['TValue'] | TNull } value The value to append.\n   */\n  append(value) {\n    return this.set(this.length, value);\n  }\n  /**\n   * Validates whether a value is valid (true), or null (false)\n   * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n   */\n  isValid(value) {\n    return this._isValid(value);\n  }\n  /**\n   * Write a value (or null-value sentinel) at the supplied index.\n   * If the value matches one of the null-value representations, a 1-bit is\n   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n   * the null `BitmapBufferBuilder`, and the value is passed to\n   * `Builder.prototype.setValue()`.\n   * @param {number} index The index of the value to write.\n   * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n   * @returns {this} The updated `Builder` instance.\n   */\n  set(index3, value) {\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value);\n    }\n    return this;\n  }\n  /**\n   * Write a value to the underlying buffers at the supplied index, bypassing\n   * the null-value check. This is a low-level method that\n   * @param {number} index\n   * @param {T['TValue'] | TNull } value\n   */\n  setValue(index3, value) {\n    this._setValue(this, index3, value);\n  }\n  setValid(index3, valid2) {\n    this.length = this._nulls.set(index3, +valid2).length;\n    return valid2;\n  }\n  // @ts-ignore\n  addChild(child, name = `${this.numChildren}`) {\n    throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n  }\n  /**\n   * Retrieve the child `Builder` at the supplied `index`, or null if no child\n   * exists at that index.\n   * @param {number} index The index of the child `Builder` to retrieve.\n   * @returns {Builder | null} The child Builder at the supplied index or null.\n   */\n  getChildAt(index3) {\n    return this.children[index3] || null;\n  }\n  /**\n   * Commit all the values that have been written to their underlying\n   * ArrayBuffers, including any child Builders if applicable, and reset\n   * the internal `Builder` state.\n   * @returns A `Data<T>` of the buffers and children representing the values written.\n   */\n  flush() {\n    let data;\n    let typeIds;\n    let nullBitmap;\n    let valueOffsets;\n    const { type: type2, length: length4, nullCount, _typeIds, _offsets, _values, _nulls } = this;\n    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {\n      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);\n    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());\n    } else {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);\n    }\n    if (nullCount > 0) {\n      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);\n    }\n    const children2 = this.children.map((child) => child.flush());\n    this.clear();\n    return makeData({\n      type: type2,\n      length: length4,\n      nullCount,\n      children: children2,\n      \"child\": children2[0],\n      data,\n      typeIds,\n      nullBitmap,\n      valueOffsets\n    });\n  }\n  /**\n   * Finalize this `Builder`, and child builders if applicable.\n   * @returns {this} The finalized `Builder` instance.\n   */\n  finish() {\n    this.finished = true;\n    for (const child of this.children)\n      child.finish();\n    return this;\n  }\n  /**\n   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n   * @returns {this} The cleared `Builder` instance.\n   */\n  clear() {\n    var _a5, _b2, _c2, _d2;\n    this.length = 0;\n    (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();\n    (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();\n    (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();\n    (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();\n    for (const child of this.children)\n      child.clear();\n    return this;\n  }\n};\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\nBuilder.prototype._isValid = () => true;\nvar FixedWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n  }\n  setValue(index3, value) {\n    const values2 = this._values;\n    values2.reserve(index3 - values2.length + 1);\n    return super.setValue(index3, value);\n  }\n};\nvar VariableWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._pendingLength = 0;\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  setValue(index3, value) {\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.length);\n    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;\n    pending.set(index3, value);\n  }\n  setValid(index3, isValid) {\n    if (!super.setValid(index3, isValid)) {\n      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index3, void 0);\n      return false;\n    }\n    return true;\n  }\n  clear() {\n    this._pendingLength = 0;\n    this._pending = void 0;\n    return super.clear();\n  }\n  flush() {\n    this._flush();\n    return super.flush();\n  }\n  finish() {\n    this._flush();\n    return super.finish();\n  }\n  _flush() {\n    const pending = this._pending;\n    const pendingLength = this._pendingLength;\n    this._pendingLength = 0;\n    this._pending = void 0;\n    if (pending && pending.size > 0) {\n      this._flushPending(pending, pendingLength);\n    }\n    return this;\n  }\n};\n\n// node_modules/apache-arrow/fb/block.mjs\nvar Block = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * Index to the start of the RecordBlock (note this is past the Message header)\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * Length of the metadata\n   */\n  metaDataLength() {\n    return this.bb.readInt32(this.bb_pos + 8);\n  }\n  /**\n   * Length of the data (this is aligned so there can be a gap between this and\n   * the metadata).\n   */\n  bodyLength() {\n    return this.bb.readInt64(this.bb_pos + 16);\n  }\n  static sizeOf() {\n    return 24;\n  }\n  static createBlock(builder, offset2, metaDataLength, bodyLength) {\n    builder.prep(8, 24);\n    builder.writeInt64(bodyLength);\n    builder.pad(4);\n    builder.writeInt32(metaDataLength);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/flatbuffers/mjs/constants.js\nvar SIZEOF_SHORT = 2;\nvar SIZEOF_INT = 4;\nvar FILE_IDENTIFIER_LENGTH = 4;\nvar SIZE_PREFIX_LENGTH = 4;\n\n// node_modules/flatbuffers/mjs/utils.js\nvar int32 = new Int32Array(2);\nvar float32 = new Float32Array(int32.buffer);\nvar float64 = new Float64Array(int32.buffer);\nvar isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n// node_modules/flatbuffers/mjs/long.js\nvar Long = class {\n  constructor(low, high) {\n    this.low = low | 0;\n    this.high = high | 0;\n  }\n  static create(low, high) {\n    return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);\n  }\n  toFloat64() {\n    return (this.low >>> 0) + this.high * 4294967296;\n  }\n  equals(other) {\n    return this.low == other.low && this.high == other.high;\n  }\n};\nLong.ZERO = new Long(0, 0);\n\n// node_modules/flatbuffers/mjs/encoding.js\nvar Encoding;\n(function(Encoding2) {\n  Encoding2[Encoding2[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n  Encoding2[Encoding2[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n\n// node_modules/flatbuffers/mjs/byte-buffer.js\nvar ByteBuffer = class {\n  /**\n   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n   */\n  constructor(bytes_) {\n    this.bytes_ = bytes_;\n    this.position_ = 0;\n  }\n  /**\n   * Create and allocate a new ByteBuffer with a given size.\n   */\n  static allocate(byte_size) {\n    return new ByteBuffer(new Uint8Array(byte_size));\n  }\n  clear() {\n    this.position_ = 0;\n  }\n  /**\n   * Get the underlying `Uint8Array`.\n   */\n  bytes() {\n    return this.bytes_;\n  }\n  /**\n   * Get the buffer's position.\n   */\n  position() {\n    return this.position_;\n  }\n  /**\n   * Set the buffer's position.\n   */\n  setPosition(position2) {\n    this.position_ = position2;\n  }\n  /**\n   * Get the buffer's capacity.\n   */\n  capacity() {\n    return this.bytes_.length;\n  }\n  readInt8(offset2) {\n    return this.readUint8(offset2) << 24 >> 24;\n  }\n  readUint8(offset2) {\n    return this.bytes_[offset2];\n  }\n  readInt16(offset2) {\n    return this.readUint16(offset2) << 16 >> 16;\n  }\n  readUint16(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;\n  }\n  readInt32(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;\n  }\n  readUint32(offset2) {\n    return this.readInt32(offset2) >>> 0;\n  }\n  readInt64(offset2) {\n    return new Long(this.readInt32(offset2), this.readInt32(offset2 + 4));\n  }\n  readUint64(offset2) {\n    return new Long(this.readUint32(offset2), this.readUint32(offset2 + 4));\n  }\n  readFloat32(offset2) {\n    int32[0] = this.readInt32(offset2);\n    return float32[0];\n  }\n  readFloat64(offset2) {\n    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);\n    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);\n    return float64[0];\n  }\n  writeInt8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeUint8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeInt16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeUint16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeInt32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeUint32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeInt64(offset2, value) {\n    this.writeInt32(offset2, value.low);\n    this.writeInt32(offset2 + 4, value.high);\n  }\n  writeUint64(offset2, value) {\n    this.writeUint32(offset2, value.low);\n    this.writeUint32(offset2 + 4, value.high);\n  }\n  writeFloat32(offset2, value) {\n    float32[0] = value;\n    this.writeInt32(offset2, int32[0]);\n  }\n  writeFloat64(offset2, value) {\n    float64[0] = value;\n    this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);\n    this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);\n  }\n  /**\n   * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n   * schema does not include a file_identifier (likely points at padding or the\n   * start of a the root vtable).\n   */\n  getBufferIdentifier() {\n    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n    }\n    let result = \"\";\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n    }\n    return result;\n  }\n  /**\n   * Look up a field in the vtable, return an offset into the object, or 0 if the\n   * field is not present.\n   */\n  __offset(bb_pos, vtable_offset) {\n    const vtable = bb_pos - this.readInt32(bb_pos);\n    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n  }\n  /**\n   * Initialize any Table-derived type to point to the union at the given offset.\n   */\n  __union(t, offset2) {\n    t.bb_pos = offset2 + this.readInt32(offset2);\n    t.bb = this;\n    return t;\n  }\n  /**\n   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n   * This allocates a new string and converts to wide chars upon each access.\n   *\n   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\n   * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n   * and from UTF-16 when the data will just be packaged back up in another\n   * FlatBuffer later on.\n   *\n   * @param offset\n   * @param opt_encoding Defaults to UTF16_STRING\n   */\n  __string(offset2, opt_encoding) {\n    offset2 += this.readInt32(offset2);\n    const length4 = this.readInt32(offset2);\n    let result = \"\";\n    let i = 0;\n    offset2 += SIZEOF_INT;\n    if (opt_encoding === Encoding.UTF8_BYTES) {\n      return this.bytes_.subarray(offset2, offset2 + length4);\n    }\n    while (i < length4) {\n      let codePoint;\n      const a4 = this.readUint8(offset2 + i++);\n      if (a4 < 192) {\n        codePoint = a4;\n      } else {\n        const b = this.readUint8(offset2 + i++);\n        if (a4 < 224) {\n          codePoint = (a4 & 31) << 6 | b & 63;\n        } else {\n          const c6 = this.readUint8(offset2 + i++);\n          if (a4 < 240) {\n            codePoint = (a4 & 15) << 12 | (b & 63) << 6 | c6 & 63;\n          } else {\n            const d = this.readUint8(offset2 + i++);\n            codePoint = (a4 & 7) << 18 | (b & 63) << 12 | (c6 & 63) << 6 | d & 63;\n          }\n        }\n      }\n      if (codePoint < 65536) {\n        result += String.fromCharCode(codePoint);\n      } else {\n        codePoint -= 65536;\n        result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);\n      }\n    }\n    return result;\n  }\n  /**\n   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n   * if a string then return a new one\n   *\n   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n   * makes the behaviour of __union_with_string different compared to __union\n   */\n  __union_with_string(o, offset2) {\n    if (typeof o === \"string\") {\n      return this.__string(offset2);\n    }\n    return this.__union(o, offset2);\n  }\n  /**\n   * Retrieve the relative offset stored at \"offset\"\n   */\n  __indirect(offset2) {\n    return offset2 + this.readInt32(offset2);\n  }\n  /**\n   * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector(offset2) {\n    return offset2 + this.readInt32(offset2) + SIZEOF_INT;\n  }\n  /**\n   * Get the length of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector_len(offset2) {\n    return this.readInt32(offset2 + this.readInt32(offset2));\n  }\n  __has_identifier(ident) {\n    if (ident.length != FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n    }\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function for generating list for obj api\n   */\n  createScalarList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      if (listAccessor(i) !== null) {\n        ret.push(listAccessor(i));\n      }\n    }\n    return ret;\n  }\n  /**\n   * A helper function for generating list for obj api\n   * @param listAccessor function that accepts an index and return data at that index\n   * @param listLength listLength\n   * @param res result list\n   */\n  createObjList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val.unpack());\n      }\n    }\n    return ret;\n  }\n};\n\n// node_modules/flatbuffers/mjs/builder.js\nvar Builder2 = class {\n  /**\n   * Create a FlatBufferBuilder.\n   */\n  constructor(opt_initial_size) {\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n    let initial_size;\n    if (!opt_initial_size) {\n      initial_size = 1024;\n    } else {\n      initial_size = opt_initial_size;\n    }\n    this.bb = ByteBuffer.allocate(initial_size);\n    this.space = initial_size;\n  }\n  clear() {\n    this.bb.clear();\n    this.space = this.bb.capacity();\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n  }\n  /**\n   * In order to save space, fields that are set to their default value\n   * don't get serialized into the buffer. Forcing defaults provides a\n   * way to manually disable this optimization.\n   *\n   * @param forceDefaults true always serializes default values\n   */\n  forceDefaults(forceDefaults) {\n    this.force_defaults = forceDefaults;\n  }\n  /**\n   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n   * called finish(). The actual data starts at the ByteBuffer's current position,\n   * not necessarily at 0.\n   */\n  dataBuffer() {\n    return this.bb;\n  }\n  /**\n   * Get the bytes representing the FlatBuffer. Only call this after you've\n   * called finish().\n   */\n  asUint8Array() {\n    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n  }\n  /**\n   * Prepare to write an element of `size` after `additional_bytes` have been\n   * written, e.g. if you write a string, you need to align such the int length\n   * field is aligned to 4 bytes, and the string data follows it directly. If all\n   * you need to do is alignment, `additional_bytes` will be 0.\n   *\n   * @param size This is the of the new element to write\n   * @param additional_bytes The padding size\n   */\n  prep(size, additional_bytes) {\n    if (size > this.minalign) {\n      this.minalign = size;\n    }\n    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n    while (this.space < align_size + size + additional_bytes) {\n      const old_buf_size = this.bb.capacity();\n      this.bb = Builder2.growByteBuffer(this.bb);\n      this.space += this.bb.capacity() - old_buf_size;\n    }\n    this.pad(align_size);\n  }\n  pad(byte_size) {\n    for (let i = 0; i < byte_size; i++) {\n      this.bb.writeInt8(--this.space, 0);\n    }\n  }\n  writeInt8(value) {\n    this.bb.writeInt8(this.space -= 1, value);\n  }\n  writeInt16(value) {\n    this.bb.writeInt16(this.space -= 2, value);\n  }\n  writeInt32(value) {\n    this.bb.writeInt32(this.space -= 4, value);\n  }\n  writeInt64(value) {\n    this.bb.writeInt64(this.space -= 8, value);\n  }\n  writeFloat32(value) {\n    this.bb.writeFloat32(this.space -= 4, value);\n  }\n  writeFloat64(value) {\n    this.bb.writeFloat64(this.space -= 8, value);\n  }\n  /**\n   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int8` to add the the buffer.\n   */\n  addInt8(value) {\n    this.prep(1, 0);\n    this.writeInt8(value);\n  }\n  /**\n   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int16` to add the the buffer.\n   */\n  addInt16(value) {\n    this.prep(2, 0);\n    this.writeInt16(value);\n  }\n  /**\n   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int32` to add the the buffer.\n   */\n  addInt32(value) {\n    this.prep(4, 0);\n    this.writeInt32(value);\n  }\n  /**\n   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int64` to add the the buffer.\n   */\n  addInt64(value) {\n    this.prep(8, 0);\n    this.writeInt64(value);\n  }\n  /**\n   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float32` to add the the buffer.\n   */\n  addFloat32(value) {\n    this.prep(4, 0);\n    this.writeFloat32(value);\n  }\n  /**\n   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float64` to add the the buffer.\n   */\n  addFloat64(value) {\n    this.prep(8, 0);\n    this.writeFloat64(value);\n  }\n  addFieldInt8(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt8(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt16(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt16(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt64(voffset, value, defaultValue) {\n    if (this.force_defaults || !value.equals(defaultValue)) {\n      this.addInt64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat64(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldOffset(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addOffset(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n   */\n  addFieldStruct(voffset, value, defaultValue) {\n    if (value != defaultValue) {\n      this.nested(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structures are always stored inline, they need to be created right\n   * where they're used.  You'll get this assertion failure if you\n   * created it elsewhere.\n   */\n  nested(obj) {\n    if (obj != this.offset()) {\n      throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n    }\n  }\n  /**\n   * Should not be creating any other object, string or vector\n   * while an object is being constructed\n   */\n  notNested() {\n    if (this.isNested) {\n      throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n    }\n  }\n  /**\n   * Set the current vtable at `voffset` to the current location in the buffer.\n   */\n  slot(voffset) {\n    if (this.vtable !== null)\n      this.vtable[voffset] = this.offset();\n  }\n  /**\n   * @returns Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.bb.capacity() - this.space;\n  }\n  /**\n   * Doubles the size of the backing ByteBuffer and copies the old data towards\n   * the end of the new buffer (since we build the buffer backwards).\n   *\n   * @param bb The current buffer with the existing data\n   * @returns A new byte buffer with the old data copied\n   * to it. The data is located at the end of the buffer.\n   *\n   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n   * it a uint8Array we need to suppress the type check:\n   * @suppress {checkTypes}\n   */\n  static growByteBuffer(bb2) {\n    const old_buf_size = bb2.capacity();\n    if (old_buf_size & 3221225472) {\n      throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n    }\n    const new_buf_size = old_buf_size << 1;\n    const nbb = ByteBuffer.allocate(new_buf_size);\n    nbb.setPosition(new_buf_size - old_buf_size);\n    nbb.bytes().set(bb2.bytes(), new_buf_size - old_buf_size);\n    return nbb;\n  }\n  /**\n   * Adds on offset, relative to where it will be written.\n   *\n   * @param offset The offset to add.\n   */\n  addOffset(offset2) {\n    this.prep(SIZEOF_INT, 0);\n    this.writeInt32(this.offset() - offset2 + SIZEOF_INT);\n  }\n  /**\n   * Start encoding a new object in the buffer.  Users will not usually need to\n   * call this directly. The FlatBuffers compiler will generate helper methods\n   * that call this method internally.\n   */\n  startObject(numfields) {\n    this.notNested();\n    if (this.vtable == null) {\n      this.vtable = [];\n    }\n    this.vtable_in_use = numfields;\n    for (let i = 0; i < numfields; i++) {\n      this.vtable[i] = 0;\n    }\n    this.isNested = true;\n    this.object_start = this.offset();\n  }\n  /**\n   * Finish off writing the object that is under construction.\n   *\n   * @returns The offset to the object inside `dataBuffer`\n   */\n  endObject() {\n    if (this.vtable == null || !this.isNested) {\n      throw new Error(\"FlatBuffers: endObject called without startObject\");\n    }\n    this.addInt32(0);\n    const vtableloc = this.offset();\n    let i = this.vtable_in_use - 1;\n    for (; i >= 0 && this.vtable[i] == 0; i--) {\n    }\n    const trimmed_size = i + 1;\n    for (; i >= 0; i--) {\n      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n    }\n    const standard_fields = 2;\n    this.addInt16(vtableloc - this.object_start);\n    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n    this.addInt16(len);\n    let existing_vtable = 0;\n    const vt1 = this.space;\n    outer_loop:\n      for (i = 0; i < this.vtables.length; i++) {\n        const vt2 = this.bb.capacity() - this.vtables[i];\n        if (len == this.bb.readInt16(vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existing_vtable = this.vtables[i];\n          break;\n        }\n      }\n    if (existing_vtable) {\n      this.space = this.bb.capacity() - vtableloc;\n      this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n    } else {\n      this.vtables.push(this.offset());\n      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n    }\n    this.isNested = false;\n    return vtableloc;\n  }\n  /**\n   * Finalize a buffer, poiting to the given `root_table`.\n   */\n  finish(root_table, opt_file_identifier, opt_size_prefix) {\n    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n    if (opt_file_identifier) {\n      const file_identifier = opt_file_identifier;\n      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n        throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n      }\n      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n        this.writeInt8(file_identifier.charCodeAt(i));\n      }\n    }\n    this.prep(this.minalign, SIZEOF_INT + size_prefix);\n    this.addOffset(root_table);\n    if (size_prefix) {\n      this.addInt32(this.bb.capacity() - this.space);\n    }\n    this.bb.setPosition(this.space);\n  }\n  /**\n   * Finalize a size prefixed buffer, pointing to the given `root_table`.\n   */\n  finishSizePrefixed(root_table, opt_file_identifier) {\n    this.finish(root_table, opt_file_identifier, true);\n  }\n  /**\n   * This checks a required field has been set in a given table that has\n   * just been constructed.\n   */\n  requiredField(table, field2) {\n    const table_start = this.bb.capacity() - table;\n    const vtable_start = table_start - this.bb.readInt32(table_start);\n    const ok = this.bb.readInt16(vtable_start + field2) != 0;\n    if (!ok) {\n      throw new Error(\"FlatBuffers: field \" + field2 + \" must be set\");\n    }\n  }\n  /**\n   * Start a new array/vector of objects.  Users usually will not call\n   * this directly. The FlatBuffers compiler will create a start/end\n   * method for vector types in generated code.\n   *\n   * @param elem_size The size of each element in the array\n   * @param num_elems The number of elements in the array\n   * @param alignment The alignment of the array\n   */\n  startVector(elem_size, num_elems, alignment) {\n    this.notNested();\n    this.vector_num_elems = num_elems;\n    this.prep(SIZEOF_INT, elem_size * num_elems);\n    this.prep(alignment, elem_size * num_elems);\n  }\n  /**\n   * Finish off the creation of an array and all its elements. The array must be\n   * created with `startVector`.\n   *\n   * @returns The offset at which the newly created array\n   * starts.\n   */\n  endVector() {\n    this.writeInt32(this.vector_num_elems);\n    return this.offset();\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If the string passed has\n   * already been seen, we return the offset of the already written string\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createSharedString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    if (!this.string_maps) {\n      this.string_maps = /* @__PURE__ */ new Map();\n    }\n    if (this.string_maps.has(s2)) {\n      return this.string_maps.get(s2);\n    }\n    const offset2 = this.createString(s2);\n    this.string_maps.set(s2, offset2);\n    return offset2;\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n   * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    let utf8;\n    if (s2 instanceof Uint8Array) {\n      utf8 = s2;\n    } else {\n      utf8 = [];\n      let i = 0;\n      while (i < s2.length) {\n        let codePoint;\n        const a4 = s2.charCodeAt(i++);\n        if (a4 < 55296 || a4 >= 56320) {\n          codePoint = a4;\n        } else {\n          const b = s2.charCodeAt(i++);\n          codePoint = (a4 << 10) + b + (65536 - (55296 << 10) - 56320);\n        }\n        if (codePoint < 128) {\n          utf8.push(codePoint);\n        } else {\n          if (codePoint < 2048) {\n            utf8.push(codePoint >> 6 & 31 | 192);\n          } else {\n            if (codePoint < 65536) {\n              utf8.push(codePoint >> 12 & 15 | 224);\n            } else {\n              utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);\n            }\n            utf8.push(codePoint >> 6 & 63 | 128);\n          }\n          utf8.push(codePoint & 63 | 128);\n        }\n      }\n    }\n    this.addInt8(0);\n    this.startVector(1, utf8.length, 1);\n    this.bb.setPosition(this.space -= utf8.length);\n    for (let i = 0, offset2 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n      bytes[offset2++] = utf8[i];\n    }\n    return this.endVector();\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function to pack an object\n   *\n   * @returns offset of obj\n   */\n  createObjectOffset(obj) {\n    if (obj === null) {\n      return 0;\n    }\n    if (typeof obj === \"string\") {\n      return this.createString(obj);\n    } else {\n      return obj.pack(this);\n    }\n  }\n  /**\n   * A helper function to pack a list of object\n   *\n   * @returns list of offsets of each non null object\n   */\n  createObjectOffsetList(list) {\n    const ret = [];\n    for (let i = 0; i < list.length; ++i) {\n      const val = list[i];\n      if (val !== null) {\n        ret.push(this.createObjectOffset(val));\n      } else {\n        throw new Error(\"FlatBuffers: Argument for createObjectOffsetList cannot contain null.\");\n      }\n    }\n    return ret;\n  }\n  createStructOffsetList(list, startFunc) {\n    startFunc(this, list.length);\n    this.createObjectOffsetList(list);\n    return this.endVector();\n  }\n};\n\n// node_modules/apache-arrow/fb/key-value.mjs\nvar KeyValue = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsKeyValue(bb2, obj) {\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsKeyValue(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  key(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  value(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startKeyValue(builder) {\n    builder.startObject(2);\n  }\n  static addKey(builder, keyOffset) {\n    builder.addFieldOffset(0, keyOffset, 0);\n  }\n  static addValue(builder, valueOffset) {\n    builder.addFieldOffset(1, valueOffset, 0);\n  }\n  static endKeyValue(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createKeyValue(builder, keyOffset, valueOffset) {\n    KeyValue.startKeyValue(builder);\n    KeyValue.addKey(builder, keyOffset);\n    KeyValue.addValue(builder, valueOffset);\n    return KeyValue.endKeyValue(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/metadata-version.mjs\nvar MetadataVersion2;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion2 || (MetadataVersion2 = {}));\n\n// node_modules/apache-arrow/fb/endianness.mjs\nvar Endianness;\n(function(Endianness2) {\n  Endianness2[Endianness2[\"Little\"] = 0] = \"Little\";\n  Endianness2[Endianness2[\"Big\"] = 1] = \"Big\";\n})(Endianness || (Endianness = {}));\n\n// node_modules/apache-arrow/fb/dictionary-kind.mjs\nvar DictionaryKind;\n(function(DictionaryKind2) {\n  DictionaryKind2[DictionaryKind2[\"DenseArray\"] = 0] = \"DenseArray\";\n})(DictionaryKind || (DictionaryKind = {}));\n\n// node_modules/apache-arrow/fb/int.mjs\nvar Int = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInt(bb2, obj) {\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInt(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  isSigned() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startInt(builder) {\n    builder.startObject(2);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(0, bitWidth, 0);\n  }\n  static addIsSigned(builder, isSigned) {\n    builder.addFieldInt8(1, +isSigned, 0);\n  }\n  static endInt(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInt(builder, bitWidth, isSigned) {\n    Int.startInt(builder);\n    Int.addBitWidth(builder, bitWidth);\n    Int.addIsSigned(builder, isSigned);\n    return Int.endInt(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-encoding.mjs\nvar DictionaryEncoding = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryEncoding(bb2, obj) {\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * The known dictionary id in the application where this data is used. In\n   * the file or streaming formats, the dictionary ids are found in the\n   * DictionaryBatch messages\n   */\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * The dictionary indices are constrained to be non-negative integers. If\n   * this field is null, the indices must be signed int32. To maximize\n   * cross-language compatibility and performance, implementations are\n   * recommended to prefer signed integer types over unsigned integer types\n   * and to avoid uint64 indices unless they are required by an application.\n   */\n  indexType(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * By default, dictionaries are not ordered, or the order does not have\n   * semantic meaning. In some statistical, applications, dictionary-encoding\n   * is used to represent ordered categorical data, and we provide a way to\n   * preserve that metadata here\n   */\n  isOrdered() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  dictionaryKind() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;\n  }\n  static startDictionaryEncoding(builder) {\n    builder.startObject(4);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addIndexType(builder, indexTypeOffset) {\n    builder.addFieldOffset(1, indexTypeOffset, 0);\n  }\n  static addIsOrdered(builder, isOrdered2) {\n    builder.addFieldInt8(2, +isOrdered2, 0);\n  }\n  static addDictionaryKind(builder, dictionaryKind) {\n    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n  }\n  static endDictionaryEncoding(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/binary.mjs\nvar Binary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBinary(bb2, obj) {\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBinary(builder) {\n    builder.startObject(0);\n  }\n  static endBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBinary(builder) {\n    Binary2.startBinary(builder);\n    return Binary2.endBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/bool.mjs\nvar Bool2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBool(bb2, obj) {\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBool(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBool(builder) {\n    builder.startObject(0);\n  }\n  static endBool(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBool(builder) {\n    Bool2.startBool(builder);\n    return Bool2.endBool(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/date-unit.mjs\nvar DateUnit2;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit2 || (DateUnit2 = {}));\n\n// node_modules/apache-arrow/fb/date.mjs\nvar Date2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDate(bb2, obj) {\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDate(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit2.MILLISECOND;\n  }\n  static startDate(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, DateUnit2.MILLISECOND);\n  }\n  static endDate(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDate(builder, unit3) {\n    Date2.startDate(builder);\n    Date2.addUnit(builder, unit3);\n    return Date2.endDate(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/decimal.mjs\nvar Decimal2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDecimal(bb2, obj) {\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDecimal(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Total number of decimal digits\n   */\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of digits after the decimal point \".\"\n   */\n  scale() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of bits per value. The only accepted widths are 128 and 256.\n   * We use bitWidth for consistency with Int::bitWidth.\n   */\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;\n  }\n  static startDecimal(builder) {\n    builder.startObject(3);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt32(0, precision, 0);\n  }\n  static addScale(builder, scale3) {\n    builder.addFieldInt32(1, scale3, 0);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(2, bitWidth, 128);\n  }\n  static endDecimal(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDecimal(builder, precision, scale3, bitWidth) {\n    Decimal2.startDecimal(builder);\n    Decimal2.addPrecision(builder, precision);\n    Decimal2.addScale(builder, scale3);\n    Decimal2.addBitWidth(builder, bitWidth);\n    return Decimal2.endDecimal(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time-unit.mjs\nvar TimeUnit2;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit2 || (TimeUnit2 = {}));\n\n// node_modules/apache-arrow/fb/fixed-size-binary.mjs\nvar FixedSizeBinary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeBinary(bb2, obj) {\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of bytes per value\n   */\n  byteWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeBinary(builder) {\n    builder.startObject(1);\n  }\n  static addByteWidth(builder, byteWidth) {\n    builder.addFieldInt32(0, byteWidth, 0);\n  }\n  static endFixedSizeBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeBinary(builder, byteWidth) {\n    FixedSizeBinary2.startFixedSizeBinary(builder);\n    FixedSizeBinary2.addByteWidth(builder, byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/fixed-size-list.mjs\nvar FixedSizeList2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeList(bb2, obj) {\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of list items per value\n   */\n  listSize() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeList(builder) {\n    builder.startObject(1);\n  }\n  static addListSize(builder, listSize) {\n    builder.addFieldInt32(0, listSize, 0);\n  }\n  static endFixedSizeList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeList(builder, listSize) {\n    FixedSizeList2.startFixedSizeList(builder);\n    FixedSizeList2.addListSize(builder, listSize);\n    return FixedSizeList2.endFixedSizeList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/precision.mjs\nvar Precision2;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision2 || (Precision2 = {}));\n\n// node_modules/apache-arrow/fb/floating-point.mjs\nvar FloatingPoint = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFloatingPoint(bb2, obj) {\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFloatingPoint(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision2.HALF;\n  }\n  static startFloatingPoint(builder) {\n    builder.startObject(1);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt16(0, precision, Precision2.HALF);\n  }\n  static endFloatingPoint(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFloatingPoint(builder, precision) {\n    FloatingPoint.startFloatingPoint(builder);\n    FloatingPoint.addPrecision(builder, precision);\n    return FloatingPoint.endFloatingPoint(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/interval-unit.mjs\nvar IntervalUnit2;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit2 || (IntervalUnit2 = {}));\n\n// node_modules/apache-arrow/fb/interval.mjs\nvar Interval = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInterval(bb2, obj) {\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInterval(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit2.YEAR_MONTH;\n  }\n  static startInterval(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, IntervalUnit2.YEAR_MONTH);\n  }\n  static endInterval(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInterval(builder, unit3) {\n    Interval.startInterval(builder);\n    Interval.addUnit(builder, unit3);\n    return Interval.endInterval(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/list.mjs\nvar List2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsList(bb2, obj) {\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startList(builder) {\n    builder.startObject(0);\n  }\n  static endList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createList(builder) {\n    List2.startList(builder);\n    return List2.endList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/map.mjs\nvar Map2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMap(bb2, obj) {\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMap(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Set to true if the keys within each value are sorted\n   */\n  keysSorted() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startMap(builder) {\n    builder.startObject(1);\n  }\n  static addKeysSorted(builder, keysSorted) {\n    builder.addFieldInt8(0, +keysSorted, 0);\n  }\n  static endMap(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createMap(builder, keysSorted) {\n    Map2.startMap(builder);\n    Map2.addKeysSorted(builder, keysSorted);\n    return Map2.endMap(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/null.mjs\nvar Null2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsNull(bb2, obj) {\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsNull(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startNull(builder) {\n    builder.startObject(0);\n  }\n  static endNull(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createNull(builder) {\n    Null2.startNull(builder);\n    return Null2.endNull(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/struct_.mjs\nvar Struct_ = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsStruct_(bb2, obj) {\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsStruct_(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startStruct_(builder) {\n    builder.startObject(0);\n  }\n  static endStruct_(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createStruct_(builder) {\n    Struct_.startStruct_(builder);\n    return Struct_.endStruct_(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time.mjs\nvar Time = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTime(bb2, obj) {\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTime(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;\n  }\n  static startTime(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.MILLISECOND);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(1, bitWidth, 32);\n  }\n  static endTime(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTime(builder, unit3, bitWidth) {\n    Time.startTime(builder);\n    Time.addUnit(builder, unit3);\n    Time.addBitWidth(builder, bitWidth);\n    return Time.endTime(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/timestamp.mjs\nvar Timestamp = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTimestamp(bb2, obj) {\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTimestamp(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.SECOND;\n  }\n  timezone(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startTimestamp(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.SECOND);\n  }\n  static addTimezone(builder, timezoneOffset) {\n    builder.addFieldOffset(1, timezoneOffset, 0);\n  }\n  static endTimestamp(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTimestamp(builder, unit3, timezoneOffset) {\n    Timestamp.startTimestamp(builder);\n    Timestamp.addUnit(builder, unit3);\n    Timestamp.addTimezone(builder, timezoneOffset);\n    return Timestamp.endTimestamp(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/union-mode.mjs\nvar UnionMode2;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode2 || (UnionMode2 = {}));\n\n// node_modules/apache-arrow/fb/union.mjs\nvar Union = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUnion(bb2, obj) {\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUnion(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  mode() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode2.Sparse;\n  }\n  typeIds(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index3 * 4) : 0;\n  }\n  typeIdsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  typeIdsArray() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;\n  }\n  static startUnion(builder) {\n    builder.startObject(2);\n  }\n  static addMode(builder, mode2) {\n    builder.addFieldInt16(0, mode2, UnionMode2.Sparse);\n  }\n  static addTypeIds(builder, typeIdsOffset) {\n    builder.addFieldOffset(1, typeIdsOffset, 0);\n  }\n  static createTypeIdsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt32(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startTypeIdsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endUnion(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUnion(builder, mode2, typeIdsOffset) {\n    Union.startUnion(builder);\n    Union.addMode(builder, mode2);\n    Union.addTypeIds(builder, typeIdsOffset);\n    return Union.endUnion(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/utf8.mjs\nvar Utf82 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUtf8(bb2, obj) {\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUtf8(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startUtf8(builder) {\n    builder.startObject(0);\n  }\n  static endUtf8(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUtf8(builder) {\n    Utf82.startUtf8(builder);\n    return Utf82.endUtf8(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/type.mjs\nvar Type2;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"FloatingPoint\"] = 3] = \"FloatingPoint\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct_\"] = 13] = \"Struct_\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Duration\"] = 18] = \"Duration\";\n  Type3[Type3[\"LargeBinary\"] = 19] = \"LargeBinary\";\n  Type3[Type3[\"LargeUtf8\"] = 20] = \"LargeUtf8\";\n  Type3[Type3[\"LargeList\"] = 21] = \"LargeList\";\n})(Type2 || (Type2 = {}));\n\n// node_modules/apache-arrow/fb/field.mjs\nvar Field = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsField(bb2, obj) {\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsField(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  name(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  /**\n   * Whether or not this field can contain nulls. Should be true in general.\n   */\n  nullable() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  typeType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type2.NONE;\n  }\n  /**\n   * This is the type of the decoded value if the field is dictionary encoded.\n   */\n  // @ts-ignore\n  type(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  /**\n   * Present only if the field is dictionary encoded.\n   */\n  dictionary(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * children apply only to nested data types like Struct, List and Union. For\n   * primitive types children will have length 0.\n   */\n  children(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  childrenLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startField(builder) {\n    builder.startObject(7);\n  }\n  static addName(builder, nameOffset) {\n    builder.addFieldOffset(0, nameOffset, 0);\n  }\n  static addNullable(builder, nullable) {\n    builder.addFieldInt8(1, +nullable, 0);\n  }\n  static addTypeType(builder, typeType) {\n    builder.addFieldInt8(2, typeType, Type2.NONE);\n  }\n  static addType(builder, typeOffset) {\n    builder.addFieldOffset(3, typeOffset, 0);\n  }\n  static addDictionary(builder, dictionaryOffset) {\n    builder.addFieldOffset(4, dictionaryOffset, 0);\n  }\n  static addChildren(builder, childrenOffset) {\n    builder.addFieldOffset(5, childrenOffset, 0);\n  }\n  static createChildrenVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startChildrenVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(6, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endField(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/schema.mjs\nvar Schema = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsSchema(bb2, obj) {\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsSchema(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * endianness of the buffer\n   * it is Little Endian by default\n   * if endianness doesn't match the underlying system then the vectors need to be converted\n   */\n  endianness() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;\n  }\n  fields(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  fieldsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Features used in the stream/file.\n   */\n  features(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index3 * 8) : this.bb.createLong(0, 0);\n  }\n  featuresLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startSchema(builder) {\n    builder.startObject(4);\n  }\n  static addEndianness(builder, endianness) {\n    builder.addFieldInt16(0, endianness, Endianness.Little);\n  }\n  static addFields(builder, fieldsOffset) {\n    builder.addFieldOffset(1, fieldsOffset, 0);\n  }\n  static createFieldsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFieldsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(2, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addFeatures(builder, featuresOffset) {\n    builder.addFieldOffset(3, featuresOffset, 0);\n  }\n  static createFeaturesVector(builder, data) {\n    builder.startVector(8, data.length, 8);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt64(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFeaturesVector(builder, numElems) {\n    builder.startVector(8, numElems, 8);\n  }\n  static endSchema(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishSchemaBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedSchemaBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {\n    Schema.startSchema(builder);\n    Schema.addEndianness(builder, endianness);\n    Schema.addFields(builder, fieldsOffset);\n    Schema.addCustomMetadata(builder, customMetadataOffset);\n    Schema.addFeatures(builder, featuresOffset);\n    return Schema.endSchema(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/footer.mjs\nvar Footer = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFooter(bb2, obj) {\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFooter(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  schema(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  dictionaries(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  dictionariesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  recordBatches(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  recordBatchesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startFooter(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addSchema(builder, schemaOffset) {\n    builder.addFieldOffset(1, schemaOffset, 0);\n  }\n  static addDictionaries(builder, dictionariesOffset) {\n    builder.addFieldOffset(2, dictionariesOffset, 0);\n  }\n  static startDictionariesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addRecordBatches(builder, recordBatchesOffset) {\n    builder.addFieldOffset(3, recordBatchesOffset, 0);\n  }\n  static startRecordBatchesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endFooter(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishFooterBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedFooterBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n};\n\n// node_modules/apache-arrow/schema.mjs\nvar Schema2 = class {\n  constructor(fields = [], metadata, dictionaries) {\n    this.fields = fields || [];\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n    this.dictionaries = dictionaries;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Schema\";\n  }\n  get names() {\n    return this.fields.map((f) => f.name);\n  }\n  toString() {\n    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(\", \")} }>`;\n  }\n  /**\n   * Construct a new Schema containing only specified fields.\n   *\n   * @param fieldNames Names of fields to keep.\n   * @returns A new Schema of fields matching the specified names.\n   */\n  select(fieldNames) {\n    const names = new Set(fieldNames);\n    const fields = this.fields.filter((f) => names.has(f.name));\n    return new Schema2(fields, this.metadata);\n  }\n  /**\n   * Construct a new Schema containing only fields at the specified indices.\n   *\n   * @param fieldIndices Indices of fields to keep.\n   * @returns A new Schema of fields at the specified indices.\n   */\n  selectAt(fieldIndices) {\n    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);\n    return new Schema2(fields, this.metadata);\n  }\n  assign(...args) {\n    const other = args[0] instanceof Schema2 ? args[0] : Array.isArray(args[0]) ? new Schema2(args[0]) : new Schema2(args);\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter((f2) => {\n      const i = curFields.findIndex((f) => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());\n    return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n};\nSchema2.prototype.fields = null;\nSchema2.prototype.metadata = null;\nSchema2.prototype.dictionaries = null;\nvar Field2 = class {\n  constructor(name, type2, nullable = false, metadata) {\n    this.name = name;\n    this.type = type2;\n    this.nullable = nullable;\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n  }\n  /** @nocollapse */\n  static new(...args) {\n    let [name, type2, nullable, metadata] = args;\n    if (args[0] && typeof args[0] === \"object\") {\n      ({ name } = args[0]);\n      type2 === void 0 && (type2 = args[0].type);\n      nullable === void 0 && (nullable = args[0].nullable);\n      metadata === void 0 && (metadata = args[0].metadata);\n    }\n    return new Field2(`${name}`, type2, nullable, metadata);\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Field\";\n  }\n  toString() {\n    return `${this.name}: ${this.type}`;\n  }\n  clone(...args) {\n    let [name, type2, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== \"object\" ? [name = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type: type2 = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];\n    return Field2.new(name, type2, nullable, metadata);\n  }\n};\nField2.prototype.type = null;\nField2.prototype.name = null;\nField2.prototype.nullable = null;\nField2.prototype.metadata = null;\nfunction mergeMaps(m1, m22) {\n  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m22 || /* @__PURE__ */ new Map()]);\n}\nfunction generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        dictionaries.set(type2.id, type2.dictionary);\n      } else if (dictionaries.get(type2.id) !== type2.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      generateDictionaryMap(type2.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n\n// node_modules/apache-arrow/ipc/metadata/file.mjs\nvar Long2 = Long;\nvar Builder3 = Builder2;\nvar ByteBuffer2 = ByteBuffer;\nvar Footer_ = class {\n  constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {\n    this.schema = schema;\n    this.version = version;\n    recordBatches && (this._recordBatches = recordBatches);\n    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer2(toUint8Array(buf));\n    const footer = Footer.getRootAsFooter(buf);\n    const schema = Schema2.decode(footer.schema());\n    return new OffHeapFooter(schema, footer);\n  }\n  /** @nocollapse */\n  static encode(footer) {\n    const b = new Builder3();\n    const schemaOffset = Schema2.encode(b, footer.schema);\n    Footer.startRecordBatchesVector(b, footer.numRecordBatches);\n    for (const rb of [...footer.recordBatches()].slice().reverse()) {\n      FileBlock.encode(b, rb);\n    }\n    const recordBatchesOffset = b.endVector();\n    Footer.startDictionariesVector(b, footer.numDictionaries);\n    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {\n      FileBlock.encode(b, db);\n    }\n    const dictionaryBatchesOffset = b.endVector();\n    Footer.startFooter(b);\n    Footer.addSchema(b, schemaOffset);\n    Footer.addVersion(b, MetadataVersion.V4);\n    Footer.addRecordBatches(b, recordBatchesOffset);\n    Footer.addDictionaries(b, dictionaryBatchesOffset);\n    Footer.finishFooterBuffer(b, Footer.endFooter(b));\n    return b.asUint8Array();\n  }\n  get numRecordBatches() {\n    return this._recordBatches.length;\n  }\n  get numDictionaries() {\n    return this._dictionaryBatches.length;\n  }\n  *recordBatches() {\n    for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {\n      if (block = this.getRecordBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  *dictionaryBatches() {\n    for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {\n      if (block = this.getDictionaryBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  getRecordBatch(index3) {\n    return index3 >= 0 && index3 < this.numRecordBatches && this._recordBatches[index3] || null;\n  }\n  getDictionaryBatch(index3) {\n    return index3 >= 0 && index3 < this.numDictionaries && this._dictionaryBatches[index3] || null;\n  }\n};\nvar OffHeapFooter = class extends Footer_ {\n  constructor(schema, _footer) {\n    super(schema, _footer.version());\n    this._footer = _footer;\n  }\n  get numRecordBatches() {\n    return this._footer.recordBatchesLength();\n  }\n  get numDictionaries() {\n    return this._footer.dictionariesLength();\n  }\n  getRecordBatch(index3) {\n    if (index3 >= 0 && index3 < this.numRecordBatches) {\n      const fileBlock = this._footer.recordBatches(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n  getDictionaryBatch(index3) {\n    if (index3 >= 0 && index3 < this.numDictionaries) {\n      const fileBlock = this._footer.dictionaries(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n};\nvar FileBlock = class {\n  constructor(metaDataLength, bodyLength, offset2) {\n    this.metaDataLength = metaDataLength;\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static decode(block) {\n    return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());\n  }\n  /** @nocollapse */\n  static encode(b, fileBlock) {\n    const { metaDataLength } = fileBlock;\n    const offset2 = new Long2(fileBlock.offset, 0);\n    const bodyLength = new Long2(fileBlock.bodyLength, 0);\n    return Block.createBlock(b, offset2, metaDataLength, bodyLength);\n  }\n};\n\n// node_modules/apache-arrow/io/interfaces.mjs\nvar ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });\nvar ArrowJSON = class {\n  constructor(_json) {\n    this._json = _json;\n  }\n  get schema() {\n    return this._json[\"schema\"];\n  }\n  get batches() {\n    return this._json[\"batches\"] || [];\n  }\n  get dictionaries() {\n    return this._json[\"dictionaries\"] || [];\n  }\n};\nvar ReadableInterop = class {\n  tee() {\n    return this._getDOMStream().tee();\n  }\n  pipe(writable, options) {\n    return this._getNodeStream().pipe(writable, options);\n  }\n  pipeTo(writable, options) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n  pipeThrough(duplex, options) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n  _getDOMStream() {\n    return this._DOMStream || (this._DOMStream = this.toDOMStream());\n  }\n  _getNodeStream() {\n    return this._nodeStream || (this._nodeStream = this.toNodeStream());\n  }\n};\nvar AsyncQueue = class extends ReadableInterop {\n  constructor() {\n    super();\n    this._values = [];\n    this.resolvers = [];\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  write(value) {\n    if (this._ensureOpen()) {\n      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });\n    }\n  }\n  abort(value) {\n    if (this._closedPromiseResolve) {\n      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });\n    }\n  }\n  close() {\n    if (this._closedPromiseResolve) {\n      const { resolvers } = this;\n      while (resolvers.length > 0) {\n        resolvers.shift().resolve(ITERATOR_DONE);\n      }\n      this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  toDOMStream(options) {\n    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  toNodeStream(options) {\n    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  throw(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.abort(_);\n      return ITERATOR_DONE;\n    });\n  }\n  return(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return ITERATOR_DONE;\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(..._args) {\n    if (this._values.length > 0) {\n      return Promise.resolve({ done: false, value: this._values.shift() });\n    } else if (this._error) {\n      return Promise.reject({ done: true, value: this._error.error });\n    } else if (!this._closedPromiseResolve) {\n      return Promise.resolve(ITERATOR_DONE);\n    } else {\n      return new Promise((resolve, reject) => {\n        this.resolvers.push({ resolve, reject });\n      });\n    }\n  }\n  _ensureOpen() {\n    if (this._closedPromiseResolve) {\n      return true;\n    }\n    throw new Error(`AsyncQueue is closed`);\n  }\n};\n\n// node_modules/apache-arrow/io/stream.mjs\nvar AsyncByteQueue = class extends AsyncQueue {\n  write(value) {\n    if ((value = toUint8Array(value)).byteLength > 0) {\n      return super.write(value);\n    }\n  }\n  toString(sync = false) {\n    return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);\n  }\n  toUint8Array(sync = false) {\n    return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {\n      var e_1, _a5;\n      const buffers = [];\n      let byteLength = 0;\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const chunk = _c2.value;\n          buffers.push(chunk);\n          byteLength += chunk.byteLength;\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return joinUint8Arrays(buffers, byteLength)[0];\n    }))();\n  }\n};\nvar ByteStream = class {\n  constructor(source) {\n    if (source) {\n      this.source = new ByteStreamSource(adapters_default.fromIterable(source));\n    }\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar AsyncByteStream = class {\n  constructor(source) {\n    if (source instanceof AsyncByteStream) {\n      this.source = source.source;\n    } else if (source instanceof AsyncByteQueue) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isReadableNodeStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));\n    } else if (isReadableDOMStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));\n    } else if (isFetchResponse(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));\n    } else if (isIterable2(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));\n    } else if (isPromise(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isAsyncIterable(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  get closed() {\n    return this.source.closed;\n  }\n  cancel(reason) {\n    return this.source.cancel(reason);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar ByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n  }\n  cancel(reason) {\n    this.return(reason);\n  }\n  peek(size) {\n    return this.next(size, \"peek\").value;\n  }\n  read(size) {\n    return this.next(size, \"read\").value;\n  }\n  next(size, cmd = \"read\") {\n    return this.source.next({ cmd, size });\n  }\n  throw(value) {\n    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);\n  }\n  return(value) {\n    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);\n  }\n};\nvar AsyncByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(size, cmd = \"read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.next({ cmd, size });\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n};\n\n// node_modules/apache-arrow/io/file.mjs\nvar RandomAccessFile = class extends ByteStream {\n  constructor(buffer, byteLength) {\n    super();\n    this.position = 0;\n    this.buffer = toUint8Array(buffer);\n    this.size = typeof byteLength === \"undefined\" ? this.buffer.byteLength : byteLength;\n  }\n  readInt32(position2) {\n    const { buffer, byteOffset } = this.readAt(position2, 4);\n    return new DataView(buffer, byteOffset).getInt32(0, true);\n  }\n  seek(position2) {\n    this.position = Math.min(position2, this.size);\n    return position2 < this.size;\n  }\n  read(nBytes) {\n    const { buffer, size, position: position2 } = this;\n    if (buffer && position2 < size) {\n      if (typeof nBytes !== \"number\") {\n        nBytes = Number.POSITIVE_INFINITY;\n      }\n      this.position = Math.min(size, position2 + Math.min(size - position2, nBytes));\n      return buffer.subarray(position2, this.position);\n    }\n    return null;\n  }\n  readAt(position2, nBytes) {\n    const buf = this.buffer;\n    const end = Math.min(this.size, position2 + nBytes);\n    return buf ? buf.subarray(position2, end) : new Uint8Array(nBytes);\n  }\n  close() {\n    this.buffer && (this.buffer = null);\n  }\n  throw(value) {\n    this.close();\n    return { done: true, value };\n  }\n  return(value) {\n    this.close();\n    return { done: true, value };\n  }\n};\nvar AsyncRandomAccessFile = class extends AsyncByteStream {\n  constructor(file, byteLength) {\n    super();\n    this.position = 0;\n    this._handle = file;\n    if (typeof byteLength === \"number\") {\n      this.size = byteLength;\n    } else {\n      this._pending = (() => __awaiter(this, void 0, void 0, function* () {\n        this.size = (yield file.stat()).size;\n        delete this._pending;\n      }))();\n    }\n  }\n  readInt32(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { buffer, byteOffset } = yield this.readAt(position2, 4);\n      return new DataView(buffer, byteOffset).getInt32(0, true);\n    });\n  }\n  seek(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      this.position = Math.min(position2, this.size);\n      return position2 < this.size;\n    });\n  }\n  read(nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size, position: position2 } = this;\n      if (file && position2 < size) {\n        if (typeof nBytes !== \"number\") {\n          nBytes = Number.POSITIVE_INFINITY;\n        }\n        let pos = position2, offset2 = 0, bytesRead = 0;\n        const end = Math.min(size, pos + Math.min(size - pos, nBytes));\n        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));\n        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {\n          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));\n        }\n        return buffer;\n      }\n      return null;\n    });\n  }\n  readAt(position2, nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size } = this;\n      if (file && position2 + nBytes < size) {\n        const end = Math.min(size, position2 + nBytes);\n        const buffer = new Uint8Array(end - position2);\n        return (yield file.read(buffer, 0, nBytes, position2)).buffer;\n      }\n      return new Uint8Array(nBytes);\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const f = this._handle;\n      this._handle = null;\n      f && (yield f.close());\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n};\n\n// node_modules/apache-arrow/util/int.mjs\nvar int_exports = {};\n__export(int_exports, {\n  BaseInt64: () => BaseInt64,\n  Int128: () => Int128,\n  Int64: () => Int642,\n  Uint64: () => Uint642\n});\nvar carryBit16 = 1 << 16;\nfunction intAsHex(value) {\n  if (value < 0) {\n    value = 4294967295 + value + 1;\n  }\n  return `0x${value.toString(16)}`;\n}\nvar kInt32DecimalDigits = 8;\nvar kPowersOfTen = [\n  1,\n  10,\n  100,\n  1e3,\n  1e4,\n  1e5,\n  1e6,\n  1e7,\n  1e8\n];\nvar BaseInt64 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return this.buffer[1];\n  }\n  low() {\n    return this.buffer[0];\n  }\n  _times(other) {\n    const L = new Uint32Array([\n      this.buffer[1] >>> 16,\n      this.buffer[1] & 65535,\n      this.buffer[0] >>> 16,\n      this.buffer[0] & 65535\n    ]);\n    const R = new Uint32Array([\n      other.buffer[1] >>> 16,\n      other.buffer[1] & 65535,\n      other.buffer[0] >>> 16,\n      other.buffer[0] & 65535\n    ]);\n    let product = L[3] * R[3];\n    this.buffer[0] = product & 65535;\n    let sum5 = product >>> 16;\n    product = L[2] * R[3];\n    sum5 += product;\n    product = L[3] * R[2] >>> 0;\n    sum5 += product;\n    this.buffer[0] += sum5 << 16;\n    this.buffer[1] = sum5 >>> 0 < product ? carryBit16 : 0;\n    this.buffer[1] += sum5 >>> 16;\n    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;\n    return this;\n  }\n  _plus(other) {\n    const sum5 = this.buffer[0] + other.buffer[0] >>> 0;\n    this.buffer[1] += other.buffer[1];\n    if (sum5 < this.buffer[0] >>> 0) {\n      ++this.buffer[1];\n    }\n    this.buffer[0] = sum5;\n  }\n  lessThan(other) {\n    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];\n  }\n  equals(other) {\n    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n  }\n  greaterThan(other) {\n    return other.lessThan(this);\n  }\n  hex() {\n    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n};\nvar Uint642 = class extends BaseInt64 {\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const length4 = str.length;\n    const out = new Uint642(out_buffer);\n    for (let posn = 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Uint642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Uint642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int642 = class extends BaseInt64 {\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    return this;\n  }\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  lessThan(other) {\n    const this_high = this.buffer[1] << 0;\n    const other_high = other.buffer[1] << 0;\n    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int642(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Int642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int128 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n  }\n  low() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n  }\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    this.buffer[2] = ~this.buffer[2];\n    this.buffer[3] = ~this.buffer[3];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    if (this.buffer[1] == 0) {\n      ++this.buffer[2];\n    }\n    if (this.buffer[2] == 0) {\n      ++this.buffer[3];\n    }\n    return this;\n  }\n  times(other) {\n    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));\n    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));\n    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));\n    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));\n    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));\n    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));\n    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));\n    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));\n    let product = Uint642.multiply(L3, R3);\n    this.buffer[0] = product.low();\n    const sum5 = new Uint642(new Uint32Array([product.high(), 0]));\n    product = Uint642.multiply(L2, R3);\n    sum5.plus(product);\n    product = Uint642.multiply(L3, R2);\n    sum5.plus(product);\n    this.buffer[1] = sum5.low();\n    this.buffer[3] = sum5.lessThan(product) ? 1 : 0;\n    this.buffer[2] = sum5.high();\n    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));\n    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();\n    return this;\n  }\n  plus(other) {\n    const sums = new Uint32Array(4);\n    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;\n    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;\n    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;\n    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;\n    if (sums[0] < this.buffer[0] >>> 0) {\n      ++sums[1];\n    }\n    if (sums[1] < this.buffer[1] >>> 0) {\n      ++sums[2];\n    }\n    if (sums[2] < this.buffer[2] >>> 0) {\n      ++sums[3];\n    }\n    this.buffer[3] = sums[3];\n    this.buffer[2] = sums[2];\n    this.buffer[1] = sums[1];\n    this.buffer[0] = sums[0];\n    return this;\n  }\n  hex() {\n    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(4)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int128(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));\n      const multiple = new Int128(new Uint32Array([kPowersOfTen[group3], 0, 0, 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 4);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n    }\n    return data;\n  }\n};\n\n// node_modules/apache-arrow/visitor/vectorloader.mjs\nvar VectorLoader = class extends Visitor {\n  constructor(bytes, nodes, buffers, dictionaries) {\n    super();\n    this.nodesIndex = -1;\n    this.buffersIndex = -1;\n    this.bytes = bytes;\n    this.nodes = nodes;\n    this.buffers = buffers;\n    this.dictionaries = dictionaries;\n  }\n  visit(node) {\n    return super.visit(node instanceof Field2 ? node.type : node);\n  }\n  visitNull(type2, { length: length4 } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4 });\n  }\n  visitBool(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitInt(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFloat(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitFixedSizeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDate(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTimestamp(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTime(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDecimal(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  visitStruct(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), children: this.visitMany(type2.children) });\n  }\n  visitUnion(type2) {\n    return type2.mode === UnionMode.Sparse ? this.visitSparseUnion(type2) : this.visitDenseUnion(type2);\n  }\n  visitDenseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), valueOffsets: this.readOffsets(type2), children: this.visitMany(type2.children) });\n  }\n  visitSparseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), children: this.visitMany(type2.children) });\n  }\n  visitDictionary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2.indices), dictionary: this.readDictionary(type2) });\n  }\n  visitInterval(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFixedSizeList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), \"child\": this.visit(type2.children[0]) });\n  }\n  visitMap(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  nextFieldNode() {\n    return this.nodes[++this.nodesIndex];\n  }\n  nextBufferRange() {\n    return this.buffers[++this.buffersIndex];\n  }\n  readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {\n    return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);\n  }\n  readOffsets(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readTypeIds(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readData(_type, { length: length4, offset: offset2 } = this.nextBufferRange()) {\n    return this.bytes.subarray(offset2, offset2 + length4);\n  }\n  readDictionary(type2) {\n    return this.dictionaries.get(type2.id);\n  }\n};\nvar JSONVectorLoader = class extends VectorLoader {\n  constructor(sources, nodes, buffers, dictionaries) {\n    super(new Uint8Array(0), nodes, buffers, dictionaries);\n    this.sources = sources;\n  }\n  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {\n    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);\n  }\n  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset2]));\n  }\n  readTypeIds(type2, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, this.sources[offset2]));\n  }\n  readData(type2, { offset: offset2 } = this.nextBufferRange()) {\n    const { sources } = this;\n    if (DataType.isTimestamp(type2)) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if ((DataType.isInt(type2) || DataType.isTime(type2)) && type2.bitWidth === 64) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDate(type2) && type2.unit === DateUnit.MILLISECOND) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDecimal(type2)) {\n      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));\n    } else if (DataType.isBinary(type2) || DataType.isFixedSizeBinary(type2)) {\n      return binaryDataFromJSON(sources[offset2]);\n    } else if (DataType.isBool(type2)) {\n      return packBools(sources[offset2]);\n    } else if (DataType.isUtf8(type2)) {\n      return encodeUtf8(sources[offset2].join(\"\"));\n    }\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, sources[offset2].map((x4) => +x4)));\n  }\n};\nfunction binaryDataFromJSON(values2) {\n  const joined = values2.join(\"\");\n  const data = new Uint8Array(joined.length / 2);\n  for (let i = 0; i < joined.length; i += 2) {\n    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);\n  }\n  return data;\n}\n\n// node_modules/apache-arrow/builder/binary.mjs\nvar BinaryBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, toUint8Array(value));\n  }\n  _flushPending(pending, pendingLength) {\n    const offsets = this._offsets;\n    const data = this._values.reserve(pendingLength).buffer;\n    let offset2 = 0;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        const length4 = value.length;\n        data.set(value, offset2);\n        offsets.set(index3, length4);\n        offset2 += length4;\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/bool.mjs\nvar BoolBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._values = new BitmapBufferBuilder();\n  }\n  setValue(index3, value) {\n    this._values.set(index3, +value);\n  }\n};\n\n// node_modules/apache-arrow/builder/date.mjs\nvar DateBuilder = class extends FixedWidthBuilder {\n};\nDateBuilder.prototype._setValue = setDate;\nvar DateDayBuilder = class extends DateBuilder {\n};\nDateDayBuilder.prototype._setValue = setDateDay;\nvar DateMillisecondBuilder = class extends DateBuilder {\n};\nDateMillisecondBuilder.prototype._setValue = setDateMillisecond;\n\n// node_modules/apache-arrow/builder/decimal.mjs\nvar DecimalBuilder = class extends FixedWidthBuilder {\n};\nDecimalBuilder.prototype._setValue = setDecimal;\n\n// node_modules/apache-arrow/builder/dictionary.mjs\nvar DictionaryBuilder = class extends Builder {\n  constructor({ \"type\": type2, \"nullValues\": nulls, \"dictionaryHashFunction\": hashFn }) {\n    super({ type: new Dictionary(type2.dictionary, type2.indices, type2.id, type2.isOrdered) });\n    this._nulls = null;\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    this.indices = makeBuilder({ \"type\": this.type.indices, \"nullValues\": nulls });\n    this.dictionary = makeBuilder({ \"type\": this.type.dictionary, \"nullValues\": null });\n    if (typeof hashFn === \"function\") {\n      this.valueToKey = hashFn;\n    }\n  }\n  get values() {\n    return this.indices.values;\n  }\n  get nullCount() {\n    return this.indices.nullCount;\n  }\n  get nullBitmap() {\n    return this.indices.nullBitmap;\n  }\n  get byteLength() {\n    return this.indices.byteLength + this.dictionary.byteLength;\n  }\n  get reservedLength() {\n    return this.indices.reservedLength + this.dictionary.reservedLength;\n  }\n  get reservedByteLength() {\n    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;\n  }\n  isValid(value) {\n    return this.indices.isValid(value);\n  }\n  setValid(index3, valid2) {\n    const indices = this.indices;\n    valid2 = indices.setValid(index3, valid2);\n    this.length = indices.length;\n    return valid2;\n  }\n  setValue(index3, value) {\n    const keysToIndices = this._keysToIndices;\n    const key = this.valueToKey(value);\n    let idx = keysToIndices[key];\n    if (idx === void 0) {\n      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;\n    }\n    return this.indices.setValue(index3, idx);\n  }\n  flush() {\n    const type2 = this.type;\n    const prev = this._dictionary;\n    const curr = this.dictionary.toVector();\n    const data = this.indices.flush().clone(type2);\n    data.dictionary = prev ? prev.concat(curr) : curr;\n    this.finished || (this._dictionaryOffset += curr.length);\n    this._dictionary = data.dictionary;\n    this.clear();\n    return data;\n  }\n  finish() {\n    this.indices.finish();\n    this.dictionary.finish();\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    return super.finish();\n  }\n  clear() {\n    this.indices.clear();\n    this.dictionary.clear();\n    return super.clear();\n  }\n  valueToKey(val) {\n    return typeof val === \"string\" ? val : `${val}`;\n  }\n};\n\n// node_modules/apache-arrow/builder/fixedsizebinary.mjs\nvar FixedSizeBinaryBuilder = class extends FixedWidthBuilder {\n};\nFixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;\n\n// node_modules/apache-arrow/builder/fixedsizelist.mjs\nvar FixedSizeListBuilder = class extends Builder {\n  setValue(index3, value) {\n    const [child] = this.children;\n    const start2 = index3 * this.stride;\n    for (let i = -1, n = value.length; ++i < n; ) {\n      child.set(start2 + i, value[i]);\n    }\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"FixedSizeListBuilder can only have one child.\");\n    }\n    const childIndex = this.children.push(child);\n    this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/float.mjs\nvar FloatBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Float16Builder = class extends FloatBuilder {\n  setValue(index3, value) {\n    super.setValue(index3, float64ToUint16(value));\n  }\n};\nvar Float32Builder = class extends FloatBuilder {\n};\nvar Float64Builder = class extends FloatBuilder {\n};\n\n// node_modules/apache-arrow/builder/interval.mjs\nvar IntervalBuilder = class extends FixedWidthBuilder {\n};\nIntervalBuilder.prototype._setValue = setIntervalValue;\nvar IntervalDayTimeBuilder = class extends IntervalBuilder {\n};\nIntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;\nvar IntervalYearMonthBuilder = class extends IntervalBuilder {\n};\nIntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;\n\n// node_modules/apache-arrow/builder/int.mjs\nvar IntBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Int8Builder = class extends IntBuilder {\n};\nvar Int16Builder = class extends IntBuilder {\n};\nvar Int32Builder = class extends IntBuilder {\n};\nvar Int64Builder = class extends IntBuilder {\n};\nvar Uint8Builder = class extends IntBuilder {\n};\nvar Uint16Builder = class extends IntBuilder {\n};\nvar Uint32Builder = class extends IntBuilder {\n};\nvar Uint64Builder = class extends IntBuilder {\n};\n\n// node_modules/apache-arrow/builder/list.mjs\nvar ListBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new List(new Field2(name, child.type, true));\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (typeof value === \"undefined\") {\n        offsets.set(index3, 0);\n      } else {\n        const n = value.length;\n        const start2 = offsets.set(index3, n).buffer[index3];\n        for (let i = -1; ++i < n; ) {\n          child.set(start2 + i, value[i]);\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/map.mjs\nvar MapBuilder = class extends VariableWidthBuilder {\n  set(index3, value) {\n    return super.set(index3, value);\n  }\n  setValue(index3, value) {\n    const row = value instanceof Map ? value : new Map(Object.entries(value));\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.size);\n    this._pendingLength += row.size;\n    pending.set(index3, row);\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        let { [index3]: idx, [index3 + 1]: end } = offsets.set(index3, value.size).buffer;\n        for (const val of value.entries()) {\n          child.set(idx, val);\n          if (++idx >= end)\n            break;\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/null.mjs\nvar NullBuilder = class extends Builder {\n  // @ts-ignore\n  setValue(index3, value) {\n  }\n  setValid(index3, valid2) {\n    this.length = Math.max(index3 + 1, this.length);\n    return valid2;\n  }\n};\n\n// node_modules/apache-arrow/builder/struct.mjs\nvar StructBuilder = class extends Builder {\n  setValue(index3, value) {\n    const { children: children2, type: type2 } = this;\n    switch (Array.isArray(value) || value.constructor) {\n      case true:\n        return type2.children.forEach((_, i) => children2[i].set(index3, value[i]));\n      case Map:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value.get(f.name)));\n      default:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value[f.name]));\n    }\n  }\n  /** @inheritdoc */\n  setValid(index3, valid2) {\n    if (!super.setValid(index3, valid2)) {\n      this.children.forEach((child) => child.setValid(index3, valid2));\n    }\n    return valid2;\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    const childIndex = this.children.push(child);\n    this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/timestamp.mjs\nvar TimestampBuilder = class extends FixedWidthBuilder {\n};\nTimestampBuilder.prototype._setValue = setTimestamp;\nvar TimestampSecondBuilder = class extends TimestampBuilder {\n};\nTimestampSecondBuilder.prototype._setValue = setTimestampSecond;\nvar TimestampMillisecondBuilder = class extends TimestampBuilder {\n};\nTimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;\nvar TimestampMicrosecondBuilder = class extends TimestampBuilder {\n};\nTimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;\nvar TimestampNanosecondBuilder = class extends TimestampBuilder {\n};\nTimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;\n\n// node_modules/apache-arrow/builder/time.mjs\nvar TimeBuilder = class extends FixedWidthBuilder {\n};\nTimeBuilder.prototype._setValue = setTime;\nvar TimeSecondBuilder = class extends TimeBuilder {\n};\nTimeSecondBuilder.prototype._setValue = setTimeSecond;\nvar TimeMillisecondBuilder = class extends TimeBuilder {\n};\nTimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;\nvar TimeMicrosecondBuilder = class extends TimeBuilder {\n};\nTimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;\nvar TimeNanosecondBuilder = class extends TimeBuilder {\n};\nTimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;\n\n// node_modules/apache-arrow/builder/union.mjs\nvar UnionBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);\n    if (typeof options[\"valueToChildTypeId\"] === \"function\") {\n      this._valueToChildTypeId = options[\"valueToChildTypeId\"];\n    }\n  }\n  get typeIdToChildIndex() {\n    return this.type.typeIdToChildIndex;\n  }\n  append(value, childTypeId) {\n    return this.set(this.length, value, childTypeId);\n  }\n  set(index3, value, childTypeId) {\n    if (childTypeId === void 0) {\n      childTypeId = this._valueToChildTypeId(this, value, index3);\n    }\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value, childTypeId);\n    }\n    return this;\n  }\n  setValue(index3, value, childTypeId) {\n    this._typeIds.set(index3, childTypeId);\n    const childIndex = this.type.typeIdToChildIndex[childTypeId];\n    const child = this.children[childIndex];\n    child === null || child === void 0 ? void 0 : child.set(index3, value);\n  }\n  addChild(child, name = `${this.children.length}`) {\n    const childTypeId = this.children.push(child);\n    const { type: { children: children2, mode: mode2, typeIds } } = this;\n    const fields = [...children2, new Field2(name, child.type)];\n    this.type = new Union_(mode2, [...typeIds, childTypeId], fields);\n    return childTypeId;\n  }\n  /** @ignore */\n  // @ts-ignore\n  _valueToChildTypeId(builder, value, offset2) {\n    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \\`childTypeId\\` as the second argument to unionBuilder.append(), or supply a \\`valueToChildTypeId\\` function as part of the UnionBuilder constructor options.`);\n  }\n};\nvar SparseUnionBuilder = class extends UnionBuilder {\n};\nvar DenseUnionBuilder = class extends UnionBuilder {\n  constructor(options) {\n    super(options);\n    this._offsets = new DataBufferBuilder(new Int32Array(0));\n  }\n  /** @ignore */\n  setValue(index3, value, childTypeId) {\n    const id2 = this._typeIds.set(index3, childTypeId).buffer[index3];\n    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);\n    const denseIndex = this._offsets.set(index3, child.length).buffer[index3];\n    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);\n  }\n};\n\n// node_modules/apache-arrow/builder/utf8.mjs\nvar Utf8Builder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, encodeUtf8(value));\n  }\n  // @ts-ignore\n  _flushPending(pending, pendingLength) {\n  }\n};\nUtf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;\n\n// node_modules/apache-arrow/visitor/builderctor.mjs\nvar GetBuilderCtor = class extends Visitor {\n  visitNull() {\n    return NullBuilder;\n  }\n  visitBool() {\n    return BoolBuilder;\n  }\n  visitInt() {\n    return IntBuilder;\n  }\n  visitInt8() {\n    return Int8Builder;\n  }\n  visitInt16() {\n    return Int16Builder;\n  }\n  visitInt32() {\n    return Int32Builder;\n  }\n  visitInt64() {\n    return Int64Builder;\n  }\n  visitUint8() {\n    return Uint8Builder;\n  }\n  visitUint16() {\n    return Uint16Builder;\n  }\n  visitUint32() {\n    return Uint32Builder;\n  }\n  visitUint64() {\n    return Uint64Builder;\n  }\n  visitFloat() {\n    return FloatBuilder;\n  }\n  visitFloat16() {\n    return Float16Builder;\n  }\n  visitFloat32() {\n    return Float32Builder;\n  }\n  visitFloat64() {\n    return Float64Builder;\n  }\n  visitUtf8() {\n    return Utf8Builder;\n  }\n  visitBinary() {\n    return BinaryBuilder;\n  }\n  visitFixedSizeBinary() {\n    return FixedSizeBinaryBuilder;\n  }\n  visitDate() {\n    return DateBuilder;\n  }\n  visitDateDay() {\n    return DateDayBuilder;\n  }\n  visitDateMillisecond() {\n    return DateMillisecondBuilder;\n  }\n  visitTimestamp() {\n    return TimestampBuilder;\n  }\n  visitTimestampSecond() {\n    return TimestampSecondBuilder;\n  }\n  visitTimestampMillisecond() {\n    return TimestampMillisecondBuilder;\n  }\n  visitTimestampMicrosecond() {\n    return TimestampMicrosecondBuilder;\n  }\n  visitTimestampNanosecond() {\n    return TimestampNanosecondBuilder;\n  }\n  visitTime() {\n    return TimeBuilder;\n  }\n  visitTimeSecond() {\n    return TimeSecondBuilder;\n  }\n  visitTimeMillisecond() {\n    return TimeMillisecondBuilder;\n  }\n  visitTimeMicrosecond() {\n    return TimeMicrosecondBuilder;\n  }\n  visitTimeNanosecond() {\n    return TimeNanosecondBuilder;\n  }\n  visitDecimal() {\n    return DecimalBuilder;\n  }\n  visitList() {\n    return ListBuilder;\n  }\n  visitStruct() {\n    return StructBuilder;\n  }\n  visitUnion() {\n    return UnionBuilder;\n  }\n  visitDenseUnion() {\n    return DenseUnionBuilder;\n  }\n  visitSparseUnion() {\n    return SparseUnionBuilder;\n  }\n  visitDictionary() {\n    return DictionaryBuilder;\n  }\n  visitInterval() {\n    return IntervalBuilder;\n  }\n  visitIntervalDayTime() {\n    return IntervalDayTimeBuilder;\n  }\n  visitIntervalYearMonth() {\n    return IntervalYearMonthBuilder;\n  }\n  visitFixedSizeList() {\n    return FixedSizeListBuilder;\n  }\n  visitMap() {\n    return MapBuilder;\n  }\n};\nvar instance6 = new GetBuilderCtor();\n\n// node_modules/apache-arrow/visitor/typecomparator.mjs\nvar TypeComparator = class extends Visitor {\n  compareSchemas(schema, other) {\n    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);\n  }\n  compareManyFields(fields, others) {\n    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));\n  }\n  compareFields(field2, other) {\n    return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);\n  }\n};\nfunction compareConstructor(type2, other) {\n  return other instanceof type2.constructor;\n}\nfunction compareAny(type2, other) {\n  return type2 === other || compareConstructor(type2, other);\n}\nfunction compareInt(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;\n}\nfunction compareFloat(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.precision === other.precision;\n}\nfunction compareFixedSizeBinary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.byteWidth === other.byteWidth;\n}\nfunction compareDate(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareTimestamp(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;\n}\nfunction compareTime(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;\n}\nfunction compareList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareStruct(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareUnion(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareDictionary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance7.visit(type2.indices, other.indices) && instance7.visit(type2.dictionary, other.dictionary);\n}\nfunction compareInterval(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareFixedSizeList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareMap(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nTypeComparator.prototype.visitNull = compareAny;\nTypeComparator.prototype.visitBool = compareAny;\nTypeComparator.prototype.visitInt = compareInt;\nTypeComparator.prototype.visitInt8 = compareInt;\nTypeComparator.prototype.visitInt16 = compareInt;\nTypeComparator.prototype.visitInt32 = compareInt;\nTypeComparator.prototype.visitInt64 = compareInt;\nTypeComparator.prototype.visitUint8 = compareInt;\nTypeComparator.prototype.visitUint16 = compareInt;\nTypeComparator.prototype.visitUint32 = compareInt;\nTypeComparator.prototype.visitUint64 = compareInt;\nTypeComparator.prototype.visitFloat = compareFloat;\nTypeComparator.prototype.visitFloat16 = compareFloat;\nTypeComparator.prototype.visitFloat32 = compareFloat;\nTypeComparator.prototype.visitFloat64 = compareFloat;\nTypeComparator.prototype.visitUtf8 = compareAny;\nTypeComparator.prototype.visitBinary = compareAny;\nTypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;\nTypeComparator.prototype.visitDate = compareDate;\nTypeComparator.prototype.visitDateDay = compareDate;\nTypeComparator.prototype.visitDateMillisecond = compareDate;\nTypeComparator.prototype.visitTimestamp = compareTimestamp;\nTypeComparator.prototype.visitTimestampSecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;\nTypeComparator.prototype.visitTime = compareTime;\nTypeComparator.prototype.visitTimeSecond = compareTime;\nTypeComparator.prototype.visitTimeMillisecond = compareTime;\nTypeComparator.prototype.visitTimeMicrosecond = compareTime;\nTypeComparator.prototype.visitTimeNanosecond = compareTime;\nTypeComparator.prototype.visitDecimal = compareAny;\nTypeComparator.prototype.visitList = compareList;\nTypeComparator.prototype.visitStruct = compareStruct;\nTypeComparator.prototype.visitUnion = compareUnion;\nTypeComparator.prototype.visitDenseUnion = compareUnion;\nTypeComparator.prototype.visitSparseUnion = compareUnion;\nTypeComparator.prototype.visitDictionary = compareDictionary;\nTypeComparator.prototype.visitInterval = compareInterval;\nTypeComparator.prototype.visitIntervalDayTime = compareInterval;\nTypeComparator.prototype.visitIntervalYearMonth = compareInterval;\nTypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;\nTypeComparator.prototype.visitMap = compareMap;\nvar instance7 = new TypeComparator();\nfunction compareSchemas(schema, other) {\n  return instance7.compareSchemas(schema, other);\n}\nfunction compareFields(field2, other) {\n  return instance7.compareFields(field2, other);\n}\nfunction compareTypes(type2, other) {\n  return instance7.visit(type2, other);\n}\n\n// node_modules/apache-arrow/factories.mjs\nfunction makeBuilder(options) {\n  const type2 = options.type;\n  const builder = new (instance6.getVisitFn(type2)())(options);\n  if (type2.children && type2.children.length > 0) {\n    const children2 = options[\"children\"] || [];\n    const defaultOptions = { \"nullValues\": options[\"nullValues\"] };\n    const getChildOptions = Array.isArray(children2) ? (_, i) => children2[i] || defaultOptions : ({ name }) => children2[name] || defaultOptions;\n    for (const [index3, field2] of type2.children.entries()) {\n      const { type: type3 } = field2;\n      const opts = getChildOptions(field2, index3);\n      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type3 })));\n    }\n  }\n  return builder;\n}\n\n// node_modules/apache-arrow/util/recordbatch.mjs\nfunction distributeVectorsIntoRecordBatches(schema, vecs) {\n  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v2) => v2.data.concat()));\n}\nfunction uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {\n  const fields = [...schema.fields];\n  const batches = [];\n  const memo = { numBatches: cols.reduce((n, c6) => Math.max(n, c6.length), 0) };\n  let numBatches = 0, batchLength = 0;\n  let i = -1;\n  const numColumns = cols.length;\n  let child, children2 = [];\n  while (memo.numBatches-- > 0) {\n    for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {\n      children2[i] = child = cols[i].shift();\n      batchLength = Math.min(batchLength, child ? child.length : batchLength);\n    }\n    if (Number.isFinite(batchLength)) {\n      children2 = distributeChildren(fields, batchLength, children2, cols, memo);\n      if (batchLength > 0) {\n        batches[numBatches++] = makeData({\n          type: new Struct(fields),\n          length: batchLength,\n          nullCount: 0,\n          children: children2.slice()\n        });\n      }\n    }\n  }\n  return [\n    schema = schema.assign(fields),\n    batches.map((data) => new RecordBatch(schema, data))\n  ];\n}\nfunction distributeChildren(fields, batchLength, children2, columns, memo) {\n  var _a5;\n  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;\n  for (let i = -1, n = columns.length; ++i < n; ) {\n    const child = children2[i];\n    const length4 = child === null || child === void 0 ? void 0 : child.length;\n    if (length4 >= batchLength) {\n      if (length4 === batchLength) {\n        children2[i] = child;\n      } else {\n        children2[i] = child.slice(0, batchLength);\n        memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));\n      }\n    } else {\n      const field2 = fields[i];\n      fields[i] = field2.clone({ nullable: true });\n      children2[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({\n        type: field2.type,\n        length: batchLength,\n        nullCount: batchLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return children2;\n}\n\n// node_modules/apache-arrow/table.mjs\nvar _a3;\nvar Table = class {\n  constructor(...args) {\n    var _b2, _c2;\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema2([]);\n      this._offsets = [0];\n      return this;\n    }\n    let schema;\n    let offsets;\n    if (args[0] instanceof Schema2) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    const unwrap = (x4) => {\n      if (x4) {\n        if (x4 instanceof RecordBatch) {\n          return [x4];\n        } else if (x4 instanceof Table) {\n          return x4.batches;\n        } else if (x4 instanceof Data) {\n          if (x4.type instanceof Struct) {\n            return [new RecordBatch(new Schema2(x4.type.children), x4)];\n          }\n        } else if (Array.isArray(x4)) {\n          return x4.flatMap((v2) => unwrap(v2));\n        } else if (typeof x4[Symbol.iterator] === \"function\") {\n          return [...x4].flatMap((v2) => unwrap(v2));\n        } else if (typeof x4 === \"object\") {\n          const keys = Object.keys(x4);\n          const vecs = keys.map((k2) => new Vector2([x4[k2]]));\n          const schema2 = new Schema2(keys.map((k2, i) => new Field2(String(k2), vecs[i].type)));\n          const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);\n          return batches2.length === 0 ? [new RecordBatch(x4)] : batches2;\n        }\n      }\n      return [];\n    };\n    const batches = args.flatMap((v2) => unwrap(v2));\n    schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);\n    if (!(schema instanceof Schema2)) {\n      throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n    }\n    for (const batch of batches) {\n      if (!(batch instanceof RecordBatch)) {\n        throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n      }\n      if (!compareSchemas(schema, batch.schema)) {\n        throw new TypeError(\"Table and inner RecordBatch schemas must be equivalent.\");\n      }\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n   */\n  get data() {\n    return this.batches.map(({ data }) => data);\n  }\n  /**\n   * The number of columns in this Table.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this Table.\n   */\n  get numRows() {\n    return this.data.reduce((numRows, data) => numRows + data.length, 0);\n  }\n  /**\n   * The number of null rows in this Table.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   *\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   *\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   *\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   *\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for rows in this Table.\n   */\n  [Symbol.iterator]() {\n    if (this.batches.length > 0) {\n      return instance4.visit(new Vector2(this.data));\n    }\n    return new Array(0)[Symbol.iterator]();\n  }\n  /**\n   * Return a JavaScript Array of the Table rows.\n   *\n   * @returns An Array of Table rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Table rows.\n   *\n   * @returns A string representation of the Table rows.\n   */\n  toString() {\n    return `[\n  ${this.toArray().join(\",\\n  \")}\n]`;\n  }\n  /**\n   * Combines two or more Tables of the same schema.\n   *\n   * @param others Additional Tables to add to the end of this Tables.\n   */\n  concat(...others) {\n    const schema = this.schema;\n    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));\n    return new Table(schema, data.map((data2) => new RecordBatch(schema, data2)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Table.\n   *\n   * @param begin The beginning of the specified portion of the Table.\n   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const schema = this.schema;\n    [begin, end] = clampRange({ length: this.numRows }, begin, end);\n    const data = sliceChunks(this.data, this._offsets, begin, end);\n    return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   *\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   *\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      const data = this.data.map((data2) => data2.children[index3]);\n      if (data.length === 0) {\n        const { type: type2 } = this.schema.fields[index3];\n        const empty4 = makeData({ type: type2, length: 0, nullCount: 0 });\n        data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));\n      }\n      return new Vector2(data);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   *\n   * @param name The name of the child to overwrite.\n   * @returns A new Table with the supplied child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let batches = [...this.batches];\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      const children2 = this.schema.fields.map((_, i) => this.getChildAt(i));\n      [fields[index3], children2[index3]] = [field2, child];\n      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);\n    }\n    return new Table(schema, batches);\n  }\n  /**\n   * Construct a new Table containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new Table of columns matching the specified names.\n   */\n  select(columnNames) {\n    const nameToIndex = this.schema.fields.reduce((m3, f, i) => m3.set(f.name, i), /* @__PURE__ */ new Map());\n    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));\n  }\n  /**\n   * Construct a new Table containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new Table of columns at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n    return new Table(schema, data);\n  }\n  assign(other) {\n    const fields = this.schema.fields;\n    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n      const [indices2, oldToNew2] = memo;\n      const i = fields.findIndex((f) => f.name === f2.name);\n      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);\n      return memo;\n    }, [[], []]);\n    const schema = this.schema.assign(other.schema);\n    const columns = [\n      ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),\n      ...indices.map((i) => other.getChildAt(i))\n    ].filter(Boolean);\n    return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n  }\n};\n_a3 = Symbol.toStringTag;\nTable[_a3] = ((proto) => {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto[\"isValid\"] = wrapChunkedCall1(isChunkedValid);\n  proto[\"get\"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));\n  proto[\"set\"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));\n  proto[\"indexOf\"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));\n  proto[\"getByteLength\"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));\n  return \"Table\";\n})(Table.prototype);\n\n// node_modules/apache-arrow/recordbatch.mjs\nvar _a4;\nvar RecordBatch = class {\n  constructor(...args) {\n    switch (args.length) {\n      case 2: {\n        [this.schema] = args;\n        if (!(this.schema instanceof Schema2)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [\n          ,\n          this.data = makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n          })\n        ] = args;\n        if (!(this.data instanceof Data)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n        break;\n      }\n      case 1: {\n        const [obj] = args;\n        const { fields, children: children2, length: length4 } = Object.keys(obj).reduce((memo, name, i) => {\n          memo.children[i] = obj[name];\n          memo.length = Math.max(memo.length, obj[name].length);\n          memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });\n          return memo;\n        }, {\n          length: 0,\n          fields: new Array(),\n          children: new Array()\n        });\n        const schema = new Schema2(fields);\n        const data = makeData({ type: new Struct(fields), length: length4, children: children2, nullCount: 0 });\n        [this.schema, this.data] = ensureSameLengthData(schema, data.children, length4);\n        break;\n      }\n      default:\n        throw new TypeError(\"RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.\");\n    }\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n  }\n  /**\n   * The number of columns in this RecordBatch.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this RecordBatch.\n   */\n  get numRows() {\n    return this.data.length;\n  }\n  /**\n   * The number of null rows in this RecordBatch.\n   */\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  isValid(index3) {\n    return this.data.getValid(index3);\n  }\n  /**\n   * Get a row by position.\n   * @param index The index of the element to read.\n   */\n  get(index3) {\n    return instance2.visit(this.data, index3);\n  }\n  /**\n   * Set a row by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  set(index3, value) {\n    return instance.visit(this.data, index3, value);\n  }\n  /**\n   * Retrieve the index of the first occurrence of a row in an RecordBatch.\n   * @param element The row to locate in the RecordBatch.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  indexOf(element, offset2) {\n    return instance3.visit(this.data, element, offset2);\n  }\n  /**\n   * Get the size (in bytes) of a row by index.\n   * @param index The row index for which to compute the byteLength.\n   */\n  getByteLength(index3) {\n    return instance5.visit(this.data, index3);\n  }\n  /**\n   * Iterator for rows in this RecordBatch.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(new Vector2([this.data]));\n  }\n  /**\n   * Return a JavaScript Array of the RecordBatch rows.\n   * @returns An Array of RecordBatch rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Combines two or more RecordBatch of the same schema.\n   * @param others Additional RecordBatch to add to the end of this RecordBatch.\n   */\n  concat(...others) {\n    return new Table(this.schema, [this, ...others]);\n  }\n  /**\n   * Return a zero-copy sub-section of this RecordBatch.\n   * @param start The beginning of the specified portion of the RecordBatch.\n   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const [slice7] = new Vector2([this.data]).slice(begin, end).data;\n    return new RecordBatch(this.schema, slice7);\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      return new Vector2([this.data.children[index3]]);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   * @param name The name of the child to overwrite.\n   * @returns A new RecordBatch with the new child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let data = this.data;\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const children2 = data.children.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      [fields[index3], children2[index3]] = [field2, child.data[0]];\n      schema = new Schema2(fields, new Map(this.schema.metadata));\n      data = makeData({ type: new Struct(fields), children: children2 });\n    }\n    return new RecordBatch(schema, data);\n  }\n  /**\n   * Construct a new RecordBatch containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new RecordBatch of columns matching the specified names.\n   */\n  select(columnNames) {\n    const schema = this.schema.select(columnNames);\n    const type2 = new Struct(schema.fields);\n    const children2 = [];\n    for (const name of columnNames) {\n      const index3 = this.schema.fields.findIndex((f) => f.name === name);\n      if (~index3) {\n        children2[index3] = this.data.children[index3];\n      }\n    }\n    return new RecordBatch(schema, makeData({ type: type2, length: this.numRows, children: children2 }));\n  }\n  /**\n   * Construct a new RecordBatch containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new RecordBatch of columns matching at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n    const subset2 = makeData({ type: new Struct(schema.fields), length: this.numRows, children: children2 });\n    return new RecordBatch(schema, subset2);\n  }\n};\n_a4 = Symbol.toStringTag;\nRecordBatch[_a4] = ((proto) => {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return \"RecordBatch\";\n})(RecordBatch.prototype);\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max5, col) => Math.max(max5, col.length), 0)) {\n  var _b2;\n  const fields = [...schema.fields];\n  const children2 = [...chunks];\n  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  for (const [idx, field2] of schema.fields.entries()) {\n    const chunk = chunks[idx];\n    if (!chunk || chunk.length !== maxLength) {\n      fields[idx] = field2.clone({ nullable: true });\n      children2[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({\n        type: field2.type,\n        length: maxLength,\n        nullCount: maxLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return [\n    schema.assign(fields),\n    makeData({ type: new Struct(fields), length: maxLength, children: children2 })\n  ];\n}\nfunction collectDictionaries(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    const data = children2[i];\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type2.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type2.id) !== data.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      collectDictionaries(type2.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\nvar _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {\n  constructor(schema) {\n    const children2 = schema.fields.map((f) => makeData({ type: f.type }));\n    const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children: children2 });\n    super(schema, data);\n  }\n};\n\n// node_modules/apache-arrow/fb/body-compression-method.mjs\nvar BodyCompressionMethod;\n(function(BodyCompressionMethod2) {\n  BodyCompressionMethod2[BodyCompressionMethod2[\"BUFFER\"] = 0] = \"BUFFER\";\n})(BodyCompressionMethod || (BodyCompressionMethod = {}));\n\n// node_modules/apache-arrow/fb/compression-type.mjs\nvar CompressionType;\n(function(CompressionType2) {\n  CompressionType2[CompressionType2[\"LZ4_FRAME\"] = 0] = \"LZ4_FRAME\";\n  CompressionType2[CompressionType2[\"ZSTD\"] = 1] = \"ZSTD\";\n})(CompressionType || (CompressionType = {}));\n\n// node_modules/apache-arrow/fb/body-compression.mjs\nvar BodyCompression = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBodyCompression(bb2, obj) {\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBodyCompression(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Compressor library.\n   * For LZ4_FRAME, each compressed buffer must consist of a single frame.\n   */\n  codec() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;\n  }\n  /**\n   * Indicates the way the record batch body was compressed\n   */\n  method() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;\n  }\n  static startBodyCompression(builder) {\n    builder.startObject(2);\n  }\n  static addCodec(builder, codec) {\n    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);\n  }\n  static addMethod(builder, method) {\n    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);\n  }\n  static endBodyCompression(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBodyCompression(builder, codec, method) {\n    BodyCompression.startBodyCompression(builder);\n    BodyCompression.addCodec(builder, codec);\n    BodyCompression.addMethod(builder, method);\n    return BodyCompression.endBodyCompression(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/buffer.mjs\nvar Buffer2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The relative offset into the shared memory page where the bytes for this\n   * buffer starts\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The absolute length (in bytes) of the memory buffer. The memory is found\n   * from offset (inclusive) to offset + length (non-inclusive). When building\n   * messages using the encapsulated IPC message, padding bytes may be written\n   * after a buffer, but such padding bytes do not need to be accounted for in\n   * the size here.\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createBuffer(builder, offset2, length4) {\n    builder.prep(8, 16);\n    builder.writeInt64(length4);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/field-node.mjs\nvar FieldNode = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The number of value slots in the Arrow array at this level of a nested\n   * tree\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The number of observed nulls. Fields with null_count == 0 may choose not\n   * to write their physical validity bitmap out as a materialized buffer,\n   * instead setting the length of the bitmap buffer to 0.\n   */\n  nullCount() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createFieldNode(builder, length4, null_count) {\n    builder.prep(8, 16);\n    builder.writeInt64(null_count);\n    builder.writeInt64(length4);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/record-batch.mjs\nvar RecordBatch2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsRecordBatch(bb2, obj) {\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsRecordBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * number of records / rows. The arrays in the batch should all have this\n   * length\n   */\n  length() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * Nodes correspond to the pre-ordered flattened logical schema\n   */\n  nodes(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  nodesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Buffers correspond to the pre-ordered flattened buffer tree\n   *\n   * The number of buffers appended to this list depends on the schema. For\n   * example, most primitive arrays will have 2 buffers, 1 for the validity\n   * bitmap and 1 for the values. For struct arrays, there will only be a\n   * single buffer for the validity (nulls) bitmap\n   */\n  buffers(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  buffersLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Optional compression of the message body\n   */\n  compression(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  static startRecordBatch(builder) {\n    builder.startObject(4);\n  }\n  static addLength(builder, length4) {\n    builder.addFieldInt64(0, length4, builder.createLong(0, 0));\n  }\n  static addNodes(builder, nodesOffset) {\n    builder.addFieldOffset(1, nodesOffset, 0);\n  }\n  static startNodesVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addBuffers(builder, buffersOffset) {\n    builder.addFieldOffset(2, buffersOffset, 0);\n  }\n  static startBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addCompression(builder, compressionOffset) {\n    builder.addFieldOffset(3, compressionOffset, 0);\n  }\n  static endRecordBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-batch.mjs\nvar DictionaryBatch = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryBatch(bb2, obj) {\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  data(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * If isDelta is true the values in the dictionary are to be appended to a\n   * dictionary with the indicated id. If isDelta is false this dictionary\n   * should replace the existing dictionary.\n   */\n  isDelta() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startDictionaryBatch(builder) {\n    builder.startObject(3);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addData(builder, dataOffset) {\n    builder.addFieldOffset(1, dataOffset, 0);\n  }\n  static addIsDelta(builder, isDelta) {\n    builder.addFieldInt8(2, +isDelta, 0);\n  }\n  static endDictionaryBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/message-header.mjs\nvar MessageHeader2;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader2 || (MessageHeader2 = {}));\n\n// node_modules/apache-arrow/fb/message.mjs\nvar Message = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMessage(bb2, obj) {\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMessage(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  headerType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader2.NONE;\n  }\n  // @ts-ignore\n  header(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  bodyLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startMessage(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addHeaderType(builder, headerType) {\n    builder.addFieldInt8(1, headerType, MessageHeader2.NONE);\n  }\n  static addHeader(builder, headerOffset) {\n    builder.addFieldOffset(2, headerOffset, 0);\n  }\n  static addBodyLength(builder, bodyLength) {\n    builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endMessage(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishMessageBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedMessageBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {\n    Message.startMessage(builder);\n    Message.addVersion(builder, version);\n    Message.addHeaderType(builder, headerType);\n    Message.addHeader(builder, headerOffset);\n    Message.addBodyLength(builder, bodyLength);\n    Message.addCustomMetadata(builder, customMetadataOffset);\n    return Message.endMessage(builder);\n  }\n};\n\n// node_modules/apache-arrow/visitor/typeassembler.mjs\nvar Long3 = Long;\nvar TypeAssembler = class extends Visitor {\n  visit(node, builder) {\n    return node == null || builder == null ? void 0 : super.visit(node, builder);\n  }\n  visitNull(_node, b) {\n    Null2.startNull(b);\n    return Null2.endNull(b);\n  }\n  visitInt(node, b) {\n    Int.startInt(b);\n    Int.addBitWidth(b, node.bitWidth);\n    Int.addIsSigned(b, node.isSigned);\n    return Int.endInt(b);\n  }\n  visitFloat(node, b) {\n    FloatingPoint.startFloatingPoint(b);\n    FloatingPoint.addPrecision(b, node.precision);\n    return FloatingPoint.endFloatingPoint(b);\n  }\n  visitBinary(_node, b) {\n    Binary2.startBinary(b);\n    return Binary2.endBinary(b);\n  }\n  visitBool(_node, b) {\n    Bool2.startBool(b);\n    return Bool2.endBool(b);\n  }\n  visitUtf8(_node, b) {\n    Utf82.startUtf8(b);\n    return Utf82.endUtf8(b);\n  }\n  visitDecimal(node, b) {\n    Decimal2.startDecimal(b);\n    Decimal2.addScale(b, node.scale);\n    Decimal2.addPrecision(b, node.precision);\n    Decimal2.addBitWidth(b, node.bitWidth);\n    return Decimal2.endDecimal(b);\n  }\n  visitDate(node, b) {\n    Date2.startDate(b);\n    Date2.addUnit(b, node.unit);\n    return Date2.endDate(b);\n  }\n  visitTime(node, b) {\n    Time.startTime(b);\n    Time.addUnit(b, node.unit);\n    Time.addBitWidth(b, node.bitWidth);\n    return Time.endTime(b);\n  }\n  visitTimestamp(node, b) {\n    const timezone = node.timezone && b.createString(node.timezone) || void 0;\n    Timestamp.startTimestamp(b);\n    Timestamp.addUnit(b, node.unit);\n    if (timezone !== void 0) {\n      Timestamp.addTimezone(b, timezone);\n    }\n    return Timestamp.endTimestamp(b);\n  }\n  visitInterval(node, b) {\n    Interval.startInterval(b);\n    Interval.addUnit(b, node.unit);\n    return Interval.endInterval(b);\n  }\n  visitList(_node, b) {\n    List2.startList(b);\n    return List2.endList(b);\n  }\n  visitStruct(_node, b) {\n    Struct_.startStruct_(b);\n    return Struct_.endStruct_(b);\n  }\n  visitUnion(node, b) {\n    Union.startTypeIdsVector(b, node.typeIds.length);\n    const typeIds = Union.createTypeIdsVector(b, node.typeIds);\n    Union.startUnion(b);\n    Union.addMode(b, node.mode);\n    Union.addTypeIds(b, typeIds);\n    return Union.endUnion(b);\n  }\n  visitDictionary(node, b) {\n    const indexType = this.visit(node.indices, b);\n    DictionaryEncoding.startDictionaryEncoding(b);\n    DictionaryEncoding.addId(b, new Long3(node.id, 0));\n    DictionaryEncoding.addIsOrdered(b, node.isOrdered);\n    if (indexType !== void 0) {\n      DictionaryEncoding.addIndexType(b, indexType);\n    }\n    return DictionaryEncoding.endDictionaryEncoding(b);\n  }\n  visitFixedSizeBinary(node, b) {\n    FixedSizeBinary2.startFixedSizeBinary(b);\n    FixedSizeBinary2.addByteWidth(b, node.byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(b);\n  }\n  visitFixedSizeList(node, b) {\n    FixedSizeList2.startFixedSizeList(b);\n    FixedSizeList2.addListSize(b, node.listSize);\n    return FixedSizeList2.endFixedSizeList(b);\n  }\n  visitMap(node, b) {\n    Map2.startMap(b);\n    Map2.addKeysSorted(b, node.keysSorted);\n    return Map2.endMap(b);\n  }\n};\nvar instance8 = new TypeAssembler();\n\n// node_modules/apache-arrow/ipc/metadata/json.mjs\nfunction schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema[\"customMetadata\"]), dictionaries);\n}\nfunction recordBatchFromJSON(b) {\n  return new RecordBatch3(b[\"count\"], fieldNodesFromJSON(b[\"columns\"]), buffersFromJSON(b[\"columns\"]));\n}\nfunction dictionaryBatchFromJSON(b) {\n  return new DictionaryBatch2(recordBatchFromJSON(b[\"data\"]), b[\"id\"], b[\"isDelta\"]);\n}\nfunction schemaFieldsFromJSON(_schema, dictionaries) {\n  return (_schema[\"fields\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldChildrenFromJSON(_field, dictionaries) {\n  return (_field[\"children\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldNodesFromJSON(xs) {\n  return (xs || []).reduce((fieldNodes, column2) => [\n    ...fieldNodes,\n    new FieldNode2(column2[\"count\"], nullCountFromJSON(column2[\"VALIDITY\"])),\n    ...fieldNodesFromJSON(column2[\"children\"])\n  ], []);\n}\nfunction buffersFromJSON(xs, buffers = []) {\n  for (let i = -1, n = (xs || []).length; ++i < n; ) {\n    const column2 = xs[i];\n    column2[\"VALIDITY\"] && buffers.push(new BufferRegion(buffers.length, column2[\"VALIDITY\"].length));\n    column2[\"TYPE\"] && buffers.push(new BufferRegion(buffers.length, column2[\"TYPE\"].length));\n    column2[\"OFFSET\"] && buffers.push(new BufferRegion(buffers.length, column2[\"OFFSET\"].length));\n    column2[\"DATA\"] && buffers.push(new BufferRegion(buffers.length, column2[\"DATA\"].length));\n    buffers = buffersFromJSON(column2[\"children\"], buffers);\n  }\n  return buffers;\n}\nfunction nullCountFromJSON(validity) {\n  return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);\n}\nfunction fieldFromJSON(_field, dictionaries) {\n  let id2;\n  let keys;\n  let field2;\n  let dictMeta;\n  let type2;\n  let dictType;\n  if (!dictionaries || !(dictMeta = _field[\"dictionary\"])) {\n    type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n    field2 = new Field2(_field[\"name\"], type2, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else if (!dictionaries.has(id2 = dictMeta[\"id\"])) {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictionaries.set(id2, type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  }\n  return field2 || null;\n}\nfunction customMetadataFromJSON(_metadata) {\n  return new Map(Object.entries(_metadata || {}));\n}\nfunction indexTypeFromJSON(_type) {\n  return new Int_(_type[\"isSigned\"], _type[\"bitWidth\"]);\n}\nfunction typeFromJSON(f, children2) {\n  const typeId = f[\"type\"][\"name\"];\n  switch (typeId) {\n    case \"NONE\":\n      return new Null();\n    case \"null\":\n      return new Null();\n    case \"binary\":\n      return new Binary();\n    case \"utf8\":\n      return new Utf8();\n    case \"bool\":\n      return new Bool();\n    case \"list\":\n      return new List((children2 || [])[0]);\n    case \"struct\":\n      return new Struct(children2 || []);\n    case \"struct_\":\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case \"int\": {\n      const t = f[\"type\"];\n      return new Int_(t[\"isSigned\"], t[\"bitWidth\"]);\n    }\n    case \"floatingpoint\": {\n      const t = f[\"type\"];\n      return new Float(Precision[t[\"precision\"]]);\n    }\n    case \"decimal\": {\n      const t = f[\"type\"];\n      return new Decimal(t[\"scale\"], t[\"precision\"], t[\"bitWidth\"]);\n    }\n    case \"date\": {\n      const t = f[\"type\"];\n      return new Date_(DateUnit[t[\"unit\"]]);\n    }\n    case \"time\": {\n      const t = f[\"type\"];\n      return new Time_(TimeUnit[t[\"unit\"]], t[\"bitWidth\"]);\n    }\n    case \"timestamp\": {\n      const t = f[\"type\"];\n      return new Timestamp_(TimeUnit[t[\"unit\"]], t[\"timezone\"]);\n    }\n    case \"interval\": {\n      const t = f[\"type\"];\n      return new Interval_(IntervalUnit[t[\"unit\"]]);\n    }\n    case \"union\": {\n      const t = f[\"type\"];\n      return new Union_(UnionMode[t[\"mode\"]], t[\"typeIds\"] || [], children2 || []);\n    }\n    case \"fixedsizebinary\": {\n      const t = f[\"type\"];\n      return new FixedSizeBinary(t[\"byteWidth\"]);\n    }\n    case \"fixedsizelist\": {\n      const t = f[\"type\"];\n      return new FixedSizeList(t[\"listSize\"], (children2 || [])[0]);\n    }\n    case \"map\": {\n      const t = f[\"type\"];\n      return new Map_((children2 || [])[0], t[\"keysSorted\"]);\n    }\n  }\n  throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n\n// node_modules/apache-arrow/ipc/metadata/message.mjs\nvar Long4 = Long;\nvar Builder4 = Builder2;\nvar ByteBuffer3 = ByteBuffer;\nvar Message2 = class {\n  constructor(bodyLength, version, headerType, header) {\n    this._version = version;\n    this._headerType = headerType;\n    this.body = new Uint8Array(0);\n    header && (this._createHeader = () => header);\n    this._bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static fromJSON(msg, headerType) {\n    const message = new Message2(0, MetadataVersion.V4, headerType);\n    message._createHeader = messageHeaderFromJSON(msg, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer3(toUint8Array(buf));\n    const _message = Message.getRootAsMessage(buf);\n    const bodyLength = _message.bodyLength();\n    const version = _message.version();\n    const headerType = _message.headerType();\n    const message = new Message2(bodyLength, version, headerType);\n    message._createHeader = decodeMessageHeader(_message, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static encode(message) {\n    const b = new Builder4();\n    let headerOffset = -1;\n    if (message.isSchema()) {\n      headerOffset = Schema2.encode(b, message.header());\n    } else if (message.isRecordBatch()) {\n      headerOffset = RecordBatch3.encode(b, message.header());\n    } else if (message.isDictionaryBatch()) {\n      headerOffset = DictionaryBatch2.encode(b, message.header());\n    }\n    Message.startMessage(b);\n    Message.addVersion(b, MetadataVersion.V4);\n    Message.addHeader(b, headerOffset);\n    Message.addHeaderType(b, message.headerType);\n    Message.addBodyLength(b, new Long4(message.bodyLength, 0));\n    Message.finishMessageBuffer(b, Message.endMessage(b));\n    return b.asUint8Array();\n  }\n  /** @nocollapse */\n  static from(header, bodyLength = 0) {\n    if (header instanceof Schema2) {\n      return new Message2(0, MetadataVersion.V4, MessageHeader.Schema, header);\n    }\n    if (header instanceof RecordBatch3) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);\n    }\n    if (header instanceof DictionaryBatch2) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);\n    }\n    throw new Error(`Unrecognized Message header: ${header}`);\n  }\n  get type() {\n    return this.headerType;\n  }\n  get version() {\n    return this._version;\n  }\n  get headerType() {\n    return this._headerType;\n  }\n  get bodyLength() {\n    return this._bodyLength;\n  }\n  header() {\n    return this._createHeader();\n  }\n  isSchema() {\n    return this.headerType === MessageHeader.Schema;\n  }\n  isRecordBatch() {\n    return this.headerType === MessageHeader.RecordBatch;\n  }\n  isDictionaryBatch() {\n    return this.headerType === MessageHeader.DictionaryBatch;\n  }\n};\nvar RecordBatch3 = class {\n  constructor(length4, nodes, buffers) {\n    this._nodes = nodes;\n    this._buffers = buffers;\n    this._length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get length() {\n    return this._length;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n};\nvar DictionaryBatch2 = class {\n  constructor(data, id2, isDelta = false) {\n    this._data = data;\n    this._isDelta = isDelta;\n    this._id = typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get id() {\n    return this._id;\n  }\n  get data() {\n    return this._data;\n  }\n  get isDelta() {\n    return this._isDelta;\n  }\n  get length() {\n    return this.data.length;\n  }\n  get nodes() {\n    return this.data.nodes;\n  }\n  get buffers() {\n    return this.data.buffers;\n  }\n};\nvar BufferRegion = class {\n  constructor(offset2, length4) {\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n};\nvar FieldNode2 = class {\n  constructor(length4, nullCount) {\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n    this.nullCount = typeof nullCount === \"number\" ? nullCount : nullCount.low;\n  }\n};\nfunction messageHeaderFromJSON(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.fromJSON(message);\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.fromJSON(message);\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.fromJSON(message);\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nfunction decodeMessageHeader(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.decode(message.header(new Schema()));\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nField2[\"encode\"] = encodeField;\nField2[\"decode\"] = decodeField;\nField2[\"fromJSON\"] = fieldFromJSON;\nSchema2[\"encode\"] = encodeSchema;\nSchema2[\"decode\"] = decodeSchema;\nSchema2[\"fromJSON\"] = schemaFromJSON;\nRecordBatch3[\"encode\"] = encodeRecordBatch;\nRecordBatch3[\"decode\"] = decodeRecordBatch;\nRecordBatch3[\"fromJSON\"] = recordBatchFromJSON;\nDictionaryBatch2[\"encode\"] = encodeDictionaryBatch;\nDictionaryBatch2[\"decode\"] = decodeDictionaryBatch;\nDictionaryBatch2[\"fromJSON\"] = dictionaryBatchFromJSON;\nFieldNode2[\"encode\"] = encodeFieldNode;\nFieldNode2[\"decode\"] = decodeFieldNode;\nBufferRegion[\"encode\"] = encodeBufferRegion;\nBufferRegion[\"decode\"] = decodeBufferRegion;\nfunction decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  const fields = decodeSchemaFields(_schema, dictionaries);\n  return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);\n}\nfunction decodeRecordBatch(batch, version = MetadataVersion.V4) {\n  if (batch.compression() !== null) {\n    throw new Error(\"Record batch compression not implemented\");\n  }\n  return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));\n}\nfunction decodeDictionaryBatch(batch, version = MetadataVersion.V4) {\n  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());\n}\nfunction decodeBufferRegion(b) {\n  return new BufferRegion(b.offset(), b.length());\n}\nfunction decodeFieldNode(f) {\n  return new FieldNode2(f.length(), f.nullCount());\n}\nfunction decodeFieldNodes(batch) {\n  const nodes = [];\n  for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {\n    if (f = batch.nodes(i)) {\n      nodes[++j] = FieldNode2.decode(f);\n    }\n  }\n  return nodes;\n}\nfunction decodeBuffers(batch, version) {\n  const bufferRegions = [];\n  for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {\n    if (b = batch.buffers(i)) {\n      if (version < MetadataVersion.V4) {\n        b.bb_pos += 8 * (i + 1);\n      }\n      bufferRegions[++j] = BufferRegion.decode(b);\n    }\n  }\n  return bufferRegions;\n}\nfunction decodeSchemaFields(schema, dictionaries) {\n  const fields = [];\n  for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {\n    if (f = schema.fields(i)) {\n      fields[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return fields;\n}\nfunction decodeFieldChildren(field2, dictionaries) {\n  const children2 = [];\n  for (let f, i = -1, j = -1, n = field2.childrenLength(); ++i < n; ) {\n    if (f = field2.children(i)) {\n      children2[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return children2;\n}\nfunction decodeField(f, dictionaries) {\n  let id2;\n  let field2;\n  let type2;\n  let keys;\n  let dictType;\n  let dictMeta;\n  if (!dictionaries || !(dictMeta = f.dictionary())) {\n    type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries));\n    field2 = new Field2(f.name(), type2, f.nullable(), decodeCustomMetadata(f));\n  } else if (!dictionaries.has(id2 = dictMeta.id().low)) {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictionaries.set(id2, type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  } else {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  }\n  return field2 || null;\n}\nfunction decodeCustomMetadata(parent) {\n  const data = /* @__PURE__ */ new Map();\n  if (parent) {\n    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {\n      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {\n        data.set(key, entry.value());\n      }\n    }\n  }\n  return data;\n}\nfunction decodeIndexType(_type) {\n  return new Int_(_type.isSigned(), _type.bitWidth());\n}\nfunction decodeFieldType(f, children2) {\n  const typeId = f.typeType();\n  switch (typeId) {\n    case Type2[\"NONE\"]:\n      return new Null();\n    case Type2[\"Null\"]:\n      return new Null();\n    case Type2[\"Binary\"]:\n      return new Binary();\n    case Type2[\"Utf8\"]:\n      return new Utf8();\n    case Type2[\"Bool\"]:\n      return new Bool();\n    case Type2[\"List\"]:\n      return new List((children2 || [])[0]);\n    case Type2[\"Struct_\"]:\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case Type2[\"Int\"]: {\n      const t = f.type(new Int());\n      return new Int_(t.isSigned(), t.bitWidth());\n    }\n    case Type2[\"FloatingPoint\"]: {\n      const t = f.type(new FloatingPoint());\n      return new Float(t.precision());\n    }\n    case Type2[\"Decimal\"]: {\n      const t = f.type(new Decimal2());\n      return new Decimal(t.scale(), t.precision(), t.bitWidth());\n    }\n    case Type2[\"Date\"]: {\n      const t = f.type(new Date2());\n      return new Date_(t.unit());\n    }\n    case Type2[\"Time\"]: {\n      const t = f.type(new Time());\n      return new Time_(t.unit(), t.bitWidth());\n    }\n    case Type2[\"Timestamp\"]: {\n      const t = f.type(new Timestamp());\n      return new Timestamp_(t.unit(), t.timezone());\n    }\n    case Type2[\"Interval\"]: {\n      const t = f.type(new Interval());\n      return new Interval_(t.unit());\n    }\n    case Type2[\"Union\"]: {\n      const t = f.type(new Union());\n      return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);\n    }\n    case Type2[\"FixedSizeBinary\"]: {\n      const t = f.type(new FixedSizeBinary2());\n      return new FixedSizeBinary(t.byteWidth());\n    }\n    case Type2[\"FixedSizeList\"]: {\n      const t = f.type(new FixedSizeList2());\n      return new FixedSizeList(t.listSize(), (children2 || [])[0]);\n    }\n    case Type2[\"Map\"]: {\n      const t = f.type(new Map2());\n      return new Map_((children2 || [])[0], t.keysSorted());\n    }\n  }\n  throw new Error(`Unrecognized type: \"${Type2[typeId]}\" (${typeId})`);\n}\nfunction encodeSchema(b, schema) {\n  const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));\n  Schema.startFieldsVector(b, fieldOffsets.length);\n  const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);\n  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  Schema.startSchema(b);\n  Schema.addFields(b, fieldsVectorOffset);\n  Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);\n  if (metadataOffset !== -1) {\n    Schema.addCustomMetadata(b, metadataOffset);\n  }\n  return Schema.endSchema(b);\n}\nfunction encodeField(b, field2) {\n  let nameOffset = -1;\n  let typeOffset = -1;\n  let dictionaryOffset = -1;\n  const type2 = field2.type;\n  let typeId = field2.typeId;\n  if (!DataType.isDictionary(type2)) {\n    typeOffset = instance8.visit(type2, b);\n  } else {\n    typeId = type2.dictionary.typeId;\n    dictionaryOffset = instance8.visit(type2, b);\n    typeOffset = instance8.visit(type2.dictionary, b);\n  }\n  const childOffsets = (type2.children || []).map((f) => Field2.encode(b, f));\n  const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);\n  const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field2.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  if (field2.name) {\n    nameOffset = b.createString(field2.name);\n  }\n  Field.startField(b);\n  Field.addType(b, typeOffset);\n  Field.addTypeType(b, typeId);\n  Field.addChildren(b, childrenVectorOffset);\n  Field.addNullable(b, !!field2.nullable);\n  if (nameOffset !== -1) {\n    Field.addName(b, nameOffset);\n  }\n  if (dictionaryOffset !== -1) {\n    Field.addDictionary(b, dictionaryOffset);\n  }\n  if (metadataOffset !== -1) {\n    Field.addCustomMetadata(b, metadataOffset);\n  }\n  return Field.endField(b);\n}\nfunction encodeRecordBatch(b, recordBatch) {\n  const nodes = recordBatch.nodes || [];\n  const buffers = recordBatch.buffers || [];\n  RecordBatch2.startNodesVector(b, nodes.length);\n  for (const n of nodes.slice().reverse())\n    FieldNode2.encode(b, n);\n  const nodesVectorOffset = b.endVector();\n  RecordBatch2.startBuffersVector(b, buffers.length);\n  for (const b_ of buffers.slice().reverse())\n    BufferRegion.encode(b, b_);\n  const buffersVectorOffset = b.endVector();\n  RecordBatch2.startRecordBatch(b);\n  RecordBatch2.addLength(b, new Long4(recordBatch.length, 0));\n  RecordBatch2.addNodes(b, nodesVectorOffset);\n  RecordBatch2.addBuffers(b, buffersVectorOffset);\n  return RecordBatch2.endRecordBatch(b);\n}\nfunction encodeDictionaryBatch(b, dictionaryBatch) {\n  const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);\n  DictionaryBatch.startDictionaryBatch(b);\n  DictionaryBatch.addId(b, new Long4(dictionaryBatch.id, 0));\n  DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);\n  DictionaryBatch.addData(b, dataOffset);\n  return DictionaryBatch.endDictionaryBatch(b);\n}\nfunction encodeFieldNode(b, node) {\n  return FieldNode.createFieldNode(b, new Long4(node.length, 0), new Long4(node.nullCount, 0));\n}\nfunction encodeBufferRegion(b, node) {\n  return Buffer2.createBuffer(b, new Long4(node.offset, 0), new Long4(node.length, 0));\n}\nvar platformIsLittleEndian = (() => {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(\n    0,\n    256,\n    true\n    /* littleEndian */\n  );\n  return new Int16Array(buffer)[0] === 256;\n})();\n\n// node_modules/apache-arrow/ipc/message.mjs\nvar invalidMessageType = (type2) => `Expected ${MessageHeader[type2]} Message in stream, but was null or length 0.`;\nvar nullMessage = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader[type2]} Message is null or length 0.`;\nvar invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\nvar invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\nvar MessageReader = class {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    let r;\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 && /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n  readSchema(throwIfNull = false) {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb2 = buf && new ByteBuffer(buf);\n    const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n    return { done: len === 0, value: len };\n  }\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return { done: false, value: Message2.decode(buf) };\n  }\n};\nvar AsyncMessageReader = class {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if ((r = yield this.readMetadata(r.value)).done) {\n        return ITERATOR_DONE;\n      }\n      return r;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.throw(value);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.return(value);\n    });\n  }\n  readMessage(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.next()).done) {\n        return null;\n      }\n      if (type2 != null && r.value.headerType !== type2) {\n        throw new Error(invalidMessageType(type2));\n      }\n      return r.value;\n    });\n  }\n  readMessageBody(bodyLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (bodyLength <= 0) {\n        return new Uint8Array(0);\n      }\n      const buf = toUint8Array(yield this.source.read(bodyLength));\n      if (buf.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n      }\n      return (\n        /* 1. */\n        buf.byteOffset % 8 === 0 && /* 2. */\n        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n      );\n    });\n  }\n  readSchema(throwIfNull = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type2 = MessageHeader.Schema;\n      const message = yield this.readMessage(type2);\n      const schema = message === null || message === void 0 ? void 0 : message.header();\n      if (throwIfNull && !schema) {\n        throw new Error(nullMessage(type2));\n      }\n      return schema;\n    });\n  }\n  readMetadataLength() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(PADDING);\n      const bb2 = buf && new ByteBuffer(buf);\n      const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n      return { done: len === 0, value: len };\n    });\n  }\n  readMetadata(metadataLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(metadataLength);\n      if (!buf) {\n        return ITERATOR_DONE;\n      }\n      if (buf.byteLength < metadataLength) {\n        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n      }\n      return { done: false, value: Message2.decode(buf) };\n    });\n  }\n};\nvar JSONMessageReader = class extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n  next() {\n    const { _json } = this;\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);\n      return { done: false, value: message };\n    }\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch[\"data\"][\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return { done: false, value: message };\n    }\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch[\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);\n      return { done: false, value: message };\n    }\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column2) => [\n        ...buffers,\n        ...column2[\"VALIDITY\"] && [column2[\"VALIDITY\"]] || [],\n        ...column2[\"TYPE\"] && [column2[\"TYPE\"]] || [],\n        ...column2[\"OFFSET\"] && [column2[\"OFFSET\"]] || [],\n        ...column2[\"DATA\"] && [column2[\"DATA\"]] || [],\n        ...flattenDataSources(column2[\"children\"])\n      ], []);\n    }\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readSchema() {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (!message || !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n};\nvar PADDING = 4;\nvar MAGIC_STR = \"ARROW1\";\nvar MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1) {\n  MAGIC[i] = MAGIC_STR.codePointAt(i);\n}\nfunction checkForMagicArrowString(buffer, index3 = 0) {\n  for (let i = -1, n = MAGIC.length; ++i < n; ) {\n    if (MAGIC[i] !== buffer[index3 + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nvar magicLength = MAGIC.length;\nvar magicAndPadding = magicLength + PADDING;\nvar magicX2AndPadding = magicLength * 2 + PADDING;\n\n// node_modules/apache-arrow/ipc/reader.mjs\nvar RecordBatchReader = class extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n  get closed() {\n    return this._impl.closed;\n  }\n  get schema() {\n    return this._impl.schema;\n  }\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n  isSync() {\n    return this._impl.isSync();\n  }\n  isAsync() {\n    return this._impl.isAsync();\n  }\n  isFile() {\n    return this._impl.isFile();\n  }\n  isStream() {\n    return this._impl.isStream();\n  }\n  next() {\n    return this._impl.next();\n  }\n  throw(value) {\n    return this._impl.throw(value);\n  }\n  return(value) {\n    return this._impl.return(value);\n  }\n  cancel() {\n    return this._impl.cancel();\n  }\n  reset(schema) {\n    this._impl.reset(schema);\n    this._DOMStream = void 0;\n    this._nodeStream = void 0;\n    return this;\n  }\n  open(options) {\n    const opening = this._impl.open(options);\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n  readRecordBatch(index3) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index3) : null;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n  toDOMStream() {\n    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });\n  }\n  toNodeStream() {\n    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (() => __awaiter(this, void 0, void 0, function* () {\n        return yield RecordBatchReader.from(yield source);\n      }))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n    return readAllAsync(source);\n  }\n};\nvar RecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    return [...this];\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return __asyncGenerator(this, arguments, function* _a5() {\n      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));\n    });\n  }\n};\nvar AsyncRecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    var e_1, _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const batches = new Array();\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const batch = _c2.value;\n          batches.push(batch);\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return batches;\n    });\n  }\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n};\nvar RecordBatchFileReader = class extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar RecordBatchReaderImpl = class {\n  constructor(dictionaries = /* @__PURE__ */ new Map()) {\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n  isSync() {\n    return false;\n  }\n  isAsync() {\n    return false;\n  }\n  isFile() {\n    return false;\n  }\n  isStream() {\n    return false;\n  }\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = /* @__PURE__ */ new Map();\n    return this;\n  }\n  _loadRecordBatch(header, body) {\n    const children2 = this._loadVectors(header, body, this.schema.fields);\n    const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children: children2 });\n    return new RecordBatch(this.schema, data);\n  }\n  _loadDictionaryBatch(header, body) {\n    const { id: id2, isDelta } = header;\n    const { dictionaries, schema } = this;\n    const dictionary = dictionaries.get(id2);\n    if (isDelta || !dictionary) {\n      const type2 = schema.dictionaries.get(id2);\n      const data = this._loadVectors(header.data, body, [type2]);\n      return (dictionary && isDelta ? dictionary.concat(new Vector2(data)) : new Vector2(data)).memoize();\n    }\n    return dictionary.memoize();\n  }\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nvar RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n  isSync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n    return this;\n  }\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message;\n    const { _reader: reader } = this;\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return { done: false, value: recordBatch };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n    }\n    return this.return();\n  }\n  _readNextMessageAndValidate(type2) {\n    return this._reader.readMessage(type2);\n  }\n};\nvar AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n  isAsync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && (this.closed = true)) {\n        yield this.reset()._reader.return();\n        this._reader = null;\n        this.dictionaries = null;\n      }\n    });\n  }\n  open(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed) {\n        this.autoDestroy = shouldAutoDestroy(this, options);\n        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {\n          yield this.cancel();\n        }\n      }\n      return this;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.throw(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.return(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return ITERATOR_DONE;\n      }\n      let message;\n      const { _reader: reader } = this;\n      while (message = yield this._readNextMessageAndValidate()) {\n        if (message.isSchema()) {\n          yield this.reset(message.header());\n        } else if (message.isRecordBatch()) {\n          this._recordBatchIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return { done: false, value: recordBatch };\n        } else if (message.isDictionaryBatch()) {\n          this._dictionaryIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n      if (this.schema && this._recordBatchIndex === 0) {\n        this._recordBatchIndex++;\n        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n      }\n      return yield this.return();\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this._reader.readMessage(type2);\n    });\n  }\n};\nvar RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isSync() {\n    return true;\n  }\n  isFile() {\n    return true;\n  }\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n    return super.open(options);\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      this.open();\n    }\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n  }\n  _readFooter() {\n    const { _handle } = this;\n    const offset2 = _handle.size - magicAndPadding;\n    const length4 = _handle.readInt32(offset2);\n    const buffer = _handle.readAt(offset2 - length4, length4);\n    return Footer_.decode(buffer);\n  }\n  _readNextMessageAndValidate(type2) {\n    var _a5;\n    if (!this._footer) {\n      this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type2);\n      }\n    }\n    return null;\n  }\n};\nvar AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source, ...rest) {\n    const byteLength = typeof rest[0] !== \"number\" ? rest.shift() : void 0;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isFile() {\n    return true;\n  }\n  isAsync() {\n    return true;\n  }\n  open(options) {\n    const _super = Object.create(null, {\n      open: { get: () => super.open }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && !this._footer) {\n        this.schema = (this._footer = yield this._readFooter()).schema;\n        for (const block of this._footer.dictionaryBatches()) {\n          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));\n        }\n      }\n      return yield _super.open.call(this, options);\n    });\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return null;\n      }\n      if (!this._footer) {\n        yield this.open();\n      }\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);\n        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return recordBatch;\n        }\n      }\n      return null;\n    });\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);\n        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n    });\n  }\n  _readFooter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { _handle } = this;\n      _handle._pending && (yield _handle._pending);\n      const offset2 = _handle.size - magicAndPadding;\n      const length4 = yield _handle.readInt32(offset2);\n      const buffer = yield _handle.readAt(offset2 - length4, length4);\n      return Footer_.decode(buffer);\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._footer) {\n        yield this.open();\n      }\n      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n        const block = this._footer.getRecordBatch(this._recordBatchIndex);\n        if (block && (yield this._handle.seek(block.offset))) {\n          return yield this._reader.readMessage(type2);\n        }\n      }\n      return null;\n    });\n  }\n};\nvar RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options[\"autoDestroy\"] === \"boolean\" ? options[\"autoDestroy\"] : self[\"autoDestroy\"];\n}\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n  try {\n    if (!reader.open({ autoDestroy: false }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\nfunction readAllAsync(source) {\n  return __asyncGenerator(this, arguments, function* readAllAsync_1() {\n    const reader = yield __await(RecordBatchReader.from(source));\n    try {\n      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {\n        do {\n          yield yield __await(reader);\n        } while (!(yield __await(reader.reset().open())).closed);\n      }\n    } finally {\n      yield __await(reader.cancel());\n    }\n  });\n}\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {\n  }()));\n}\nfunction fromAsyncByteStream(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const bytes = yield source.peek(magicLength + 7 & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {\n      return __asyncGenerator(this, arguments, function* () {\n      });\n    }()));\n  });\n}\nfunction fromFileHandle(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const { size } = yield source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n  });\n}\n\n// node_modules/apache-arrow/visitor/vectorassembler.mjs\nvar VectorAssembler = class extends Visitor {\n  constructor() {\n    super();\n    this._byteLength = 0;\n    this._nodes = [];\n    this._buffers = [];\n    this._bufferRegions = [];\n  }\n  /** @nocollapse */\n  static assemble(...args) {\n    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);\n    const assembler = new VectorAssembler();\n    assembler.visitMany(unwrap(args));\n    return assembler;\n  }\n  visit(data) {\n    if (data instanceof Vector2) {\n      this.visitMany(data.data);\n      return this;\n    }\n    const { type: type2 } = data;\n    if (!DataType.isDictionary(type2)) {\n      const { length: length4, nullCount } = data;\n      if (length4 > 2147483647) {\n        throw new RangeError(\"Cannot write arrays larger than 2^31 - 1 in length\");\n      }\n      if (!DataType.isNull(type2)) {\n        addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length4, data.nullBitmap));\n      }\n      this.nodes.push(new FieldNode2(length4, nullCount));\n    }\n    return super.visit(data);\n  }\n  visitNull(_null) {\n    return this;\n  }\n  visitDictionary(data) {\n    return this.visit(data.clone(data.type.indices));\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferRegions() {\n    return this._bufferRegions;\n  }\n};\nfunction addBuffer(values2) {\n  const byteLength = values2.byteLength + 7 & ~7;\n  this.buffers.push(values2);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\nfunction assembleUnion(data) {\n  const { type: type2, length: length4, typeIds, valueOffsets } = data;\n  addBuffer.call(this, typeIds);\n  if (type2.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, data);\n  } else if (type2.mode === UnionMode.Dense) {\n    if (data.offset <= 0) {\n      addBuffer.call(this, valueOffsets);\n      return assembleNestedVector.call(this, data);\n    } else {\n      const maxChildTypeId = typeIds.reduce((x4, y4) => Math.max(x4, y4), typeIds[0]);\n      const childLengths = new Int32Array(maxChildTypeId + 1);\n      const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      const shiftedOffsets = new Int32Array(length4);\n      const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets);\n      for (let typeId, shift, index3 = -1; ++index3 < length4; ) {\n        if ((shift = childOffsets[typeId = typeIds[index3]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index3] = unshiftedOffsets[index3] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      for (let child, childIndex = -1, numChildren = type2.children.length; ++childIndex < numChildren; ) {\n        if (child = data.children[childIndex]) {\n          const typeId = type2.typeIds[childIndex];\n          const childLength = Math.min(length4, childLengths[typeId]);\n          this.visit(child.slice(childOffsets[typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction assembleBoolVector(data) {\n  let values2;\n  if (data.nullCount >= data.length) {\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values2 = data.values) instanceof Uint8Array) {\n    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values2));\n  }\n  return addBuffer.call(this, packBools(data.values));\n}\nfunction assembleFlatVector(data) {\n  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\nfunction assembleFlatListVector(data) {\n  const { length: length4, values: values2, valueOffsets } = data;\n  const firstOffset = valueOffsets[0];\n  const lastOffset = valueOffsets[length4];\n  const byteLength = Math.min(lastOffset - firstOffset, values2.byteLength - firstOffset);\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets));\n  addBuffer.call(this, values2.subarray(firstOffset, firstOffset + byteLength));\n  return this;\n}\nfunction assembleListVector(data) {\n  const { length: length4, valueOffsets } = data;\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length4, valueOffsets));\n  }\n  return this.visit(data.children[0]);\n}\nfunction assembleNestedVector(data) {\n  return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n\n// node_modules/apache-arrow/ipc/writer.mjs\nvar RecordBatchWriter = class extends ReadableInterop {\n  constructor(options) {\n    super();\n    this._position = 0;\n    this._started = false;\n    this._sink = new AsyncByteQueue();\n    this._schema = null;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    isObject2(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });\n    this._autoDestroy = typeof options.autoDestroy === \"boolean\" ? options.autoDestroy : true;\n    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === \"boolean\" ? options.writeLegacyIpcFormat : false;\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  toString(sync = false) {\n    return this._sink.toString(sync);\n  }\n  toUint8Array(sync = false) {\n    return this._sink.toUint8Array(sync);\n  }\n  writeAll(input) {\n    if (isPromise(input)) {\n      return input.then((x4) => this.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(this, input);\n    }\n    return writeAll(this, input);\n  }\n  get closed() {\n    return this._sink.closed;\n  }\n  [Symbol.asyncIterator]() {\n    return this._sink[Symbol.asyncIterator]();\n  }\n  toDOMStream(options) {\n    return this._sink.toDOMStream(options);\n  }\n  toNodeStream(options) {\n    return this._sink.toNodeStream(options);\n  }\n  close() {\n    return this.reset()._sink.close();\n  }\n  abort(reason) {\n    return this.reset()._sink.abort(reason);\n  }\n  finish() {\n    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);\n    return this;\n  }\n  reset(sink = this._sink, schema = null) {\n    if (sink === this._sink || sink instanceof AsyncByteQueue) {\n      this._sink = sink;\n    } else {\n      this._sink = new AsyncByteQueue();\n      if (sink && isWritableDOMStream(sink)) {\n        this.toDOMStream({ type: \"bytes\" }).pipeTo(sink);\n      } else if (sink && isWritableNodeStream(sink)) {\n        this.toNodeStream({ objectMode: false }).pipe(sink);\n      }\n    }\n    if (this._started && this._schema) {\n      this._writeFooter(this._schema);\n    }\n    this._started = false;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    if (!schema || !compareSchemas(schema, this._schema)) {\n      if (schema == null) {\n        this._position = 0;\n        this._schema = null;\n      } else {\n        this._started = true;\n        this._schema = schema;\n        this._writeSchema(schema);\n      }\n    }\n    return this;\n  }\n  write(payload) {\n    let schema = null;\n    if (!this._sink) {\n      throw new Error(`RecordBatchWriter is closed`);\n    } else if (payload == null) {\n      return this.finish() && void 0;\n    } else if (payload instanceof Table && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    }\n    if (schema && !compareSchemas(schema, this._schema)) {\n      if (this._started && this._autoDestroy) {\n        return this.close();\n      }\n      this.reset(this._sink, schema);\n    }\n    if (payload instanceof RecordBatch) {\n      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {\n        this._writeRecordBatch(payload);\n      }\n    } else if (payload instanceof Table) {\n      this.writeAll(payload.batches);\n    } else if (isIterable2(payload)) {\n      this.writeAll(payload);\n    }\n  }\n  _writeMessage(message, alignment = 8) {\n    const a4 = alignment - 1;\n    const buffer = Message2.encode(message);\n    const flatbufferSize = buffer.byteLength;\n    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;\n    const alignedSize = flatbufferSize + prefixSize + a4 & ~a4;\n    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;\n    if (message.headerType === MessageHeader.RecordBatch) {\n      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    } else if (message.headerType === MessageHeader.DictionaryBatch) {\n      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    }\n    if (!this._writeLegacyIpcFormat) {\n      this._write(Int32Array.of(-1));\n    }\n    this._write(Int32Array.of(alignedSize - prefixSize));\n    if (flatbufferSize > 0) {\n      this._write(buffer);\n    }\n    return this._writePadding(nPaddingBytes);\n  }\n  _write(chunk) {\n    if (this._started) {\n      const buffer = toUint8Array(chunk);\n      if (buffer && buffer.byteLength > 0) {\n        this._sink.write(buffer);\n        this._position += buffer.byteLength;\n      }\n    }\n    return this;\n  }\n  _writeSchema(schema) {\n    return this._writeMessage(Message2.from(schema));\n  }\n  // @ts-ignore\n  _writeFooter(schema) {\n    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));\n  }\n  _writeMagic() {\n    return this._write(MAGIC);\n  }\n  _writePadding(nBytes) {\n    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;\n  }\n  _writeRecordBatch(batch) {\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);\n    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);\n    const message = Message2.from(recordBatch, byteLength);\n    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeDictionaryBatch(dictionary, id2, isDelta = false) {\n    this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector2([dictionary]));\n    const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);\n    const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);\n    const message = Message2.from(dictionaryBatch, byteLength);\n    return this._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeBodyBuffers(buffers) {\n    let buffer;\n    let size, padding;\n    for (let i = -1, n = buffers.length; ++i < n; ) {\n      if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {\n        this._write(buffer);\n        if ((padding = (size + 7 & ~7) - size) > 0) {\n          this._writePadding(padding);\n        }\n      }\n    }\n    return this;\n  }\n  _writeDictionaries(batch) {\n    for (let [id2, dictionary] of batch.dictionaries) {\n      let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;\n      if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {\n        for (const data of dictionary.data) {\n          this._writeDictionaryBatch(data, id2, offset2 > 0);\n          offset2 += data.length;\n        }\n      }\n    }\n    return this;\n  }\n};\nvar RecordBatchStreamWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input, options) {\n    const writer = new RecordBatchStreamWriter(options);\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n};\nvar RecordBatchFileWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input) {\n    const writer = new RecordBatchFileWriter();\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n  constructor() {\n    super();\n    this._autoDestroy = true;\n  }\n  // @ts-ignore\n  _writeSchema(schema) {\n    return this._writeMagic()._writePadding(2);\n  }\n  _writeFooter(schema) {\n    const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));\n    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();\n  }\n};\nfunction writeAll(writer, input) {\n  let chunks = input;\n  if (input instanceof Table) {\n    chunks = input.batches;\n    writer.reset(void 0, input.schema);\n  }\n  for (const batch of chunks) {\n    writer.write(batch);\n  }\n  return writer.finish();\n}\nfunction writeAllAsync(writer, batches) {\n  var batches_1, batches_1_1;\n  var e_1, _a5;\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      for (batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done; ) {\n        const batch = batches_1_1.value;\n        writer.write(batch);\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (batches_1_1 && !batches_1_1.done && (_a5 = batches_1.return))\n          yield _a5.call(batches_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return writer.finish();\n  });\n}\n\n// node_modules/apache-arrow/io/whatwg/iterable.mjs\nfunction toDOMStream(source, options) {\n  if (isAsyncIterable(source)) {\n    return asyncIterableAsReadableDOMStream(source, options);\n  }\n  if (isIterable2(source)) {\n    return iterableAsReadableDOMStream(source, options);\n  }\n  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);\n}\nfunction iterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      next(controller, it || (it = source[Symbol.iterator]()));\n    },\n    pull(controller) {\n      it ? next(controller, it) : controller.close();\n    },\n    cancel() {\n      ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    let buf;\n    let r = null;\n    let size = controller.desiredSize || null;\n    while (!(r = it2.next(bm ? size : null)).done) {\n      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n        size != null && bm && (size = size - buf.byteLength + 1);\n        r.value = buf;\n      }\n      controller.enqueue(r.value);\n      if (size != null && --size <= 0) {\n        return;\n      }\n    }\n    controller.close();\n  }\n}\nfunction asyncIterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, it || (it = source[Symbol.asyncIterator]()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        it ? yield next(controller, it) : controller.close();\n      });\n    },\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);\n      });\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf;\n      let r = null;\n      let size = controller.desiredSize || null;\n      while (!(r = yield it2.next(bm ? size : null)).done) {\n        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n          size != null && bm && (size = size - buf.byteLength + 1);\n          r.value = buf;\n        }\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/builder.mjs\nfunction builderThroughDOMStream(options) {\n  return new BuilderTransform(options);\n}\nvar BuilderTransform = class {\n  constructor(options) {\n    this._numChunks = 0;\n    this._finished = false;\n    this._bufferedSize = 0;\n    const { [\"readableStrategy\"]: readableStrategy, [\"writableStrategy\"]: writableStrategy, [\"queueingStrategy\"]: queueingStrategy = \"count\" } = options, builderOptions = __rest(options, [\"readableStrategy\", \"writableStrategy\", \"queueingStrategy\"]);\n    this._controller = null;\n    this._builder = makeBuilder(builderOptions);\n    this._getSize = queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength;\n    const { [\"highWaterMark\"]: readableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);\n    const { [\"highWaterMark\"]: writableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);\n    this[\"readable\"] = new ReadableStream({\n      [\"cancel\"]: () => {\n        this._builder.clear();\n      },\n      [\"pull\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      },\n      [\"start\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      }\n    }, {\n      \"highWaterMark\": readableHighWaterMark,\n      \"size\": queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength\n    });\n    this[\"writable\"] = new WritableStream({\n      [\"abort\"]: () => {\n        this._builder.clear();\n      },\n      [\"write\"]: () => {\n        this._maybeFlush(this._builder, this._controller);\n      },\n      [\"close\"]: () => {\n        this._maybeFlush(this._builder.finish(), this._controller);\n      }\n    }, {\n      \"highWaterMark\": writableHighWaterMark,\n      \"size\": (value) => this._writeValueAndReturnChunkSize(value)\n    });\n  }\n  _writeValueAndReturnChunkSize(value) {\n    const bufferedSize = this._bufferedSize;\n    this._bufferedSize = this._getSize(this._builder.append(value));\n    return this._bufferedSize - bufferedSize;\n  }\n  _maybeFlush(builder, controller) {\n    if (controller == null) {\n      return;\n    }\n    if (this._bufferedSize >= controller.desiredSize) {\n      ++this._numChunks && this._enqueue(controller, builder.toVector());\n    }\n    if (builder.finished) {\n      if (builder.length > 0 || this._numChunks === 0) {\n        ++this._numChunks && this._enqueue(controller, builder.toVector());\n      }\n      if (!this._finished && (this._finished = true)) {\n        this._enqueue(controller, null);\n      }\n    }\n  }\n  _enqueue(controller, chunk) {\n    this._bufferedSize = 0;\n    this._controller = null;\n    chunk == null ? controller.close() : controller.enqueue(chunk);\n  }\n};\nvar chunkLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;\n};\nvar chunkByteLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;\n};\n\n// node_modules/apache-arrow/io/whatwg/reader.mjs\nfunction recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {\n  const queue = new AsyncByteQueue();\n  let reader = null;\n  const readable = new ReadableStream({\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield queue.close();\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, reader || (reader = yield open()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        reader ? yield next(controller, reader) : controller.close();\n      });\n    }\n  });\n  return { writable: new WritableStream(queue, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, writableStrategy)), readable };\n  function open() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);\n    });\n  }\n  function next(controller, reader2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let size = controller.desiredSize;\n      let r = null;\n      while (!(r = yield reader2.next()).done) {\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/writer.mjs\nfunction recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {\n  const writer = new this(writableStrategy);\n  const reader = new AsyncByteStream(writer);\n  const readable = new ReadableStream({\n    // type: 'bytes',\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield reader.cancel();\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    }\n  }, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, readableStrategy));\n  return { writable: new WritableStream(writer, writableStrategy), readable };\n  function next(controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf = null;\n      let size = controller.desiredSize;\n      while (buf = yield reader.read(size || null)) {\n        controller.enqueue(buf);\n        if (size != null && (size -= buf.byteLength) <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/ipc/serialization.mjs\nfunction tableFromIPC(input) {\n  const reader = RecordBatchReader.from(input);\n  if (isPromise(reader)) {\n    return reader.then((reader2) => tableFromIPC(reader2));\n  }\n  if (reader.isAsync()) {\n    return reader.readAll().then((xs) => new Table(xs));\n  }\n  return new Table(reader.readAll());\n}\n\n// node_modules/apache-arrow/Arrow.mjs\nvar util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {\n  compareSchemas,\n  compareFields,\n  compareTypes\n});\n\n// node_modules/apache-arrow/Arrow.dom.mjs\nadapters_default.toDOMStream = toDOMStream;\nBuilder[\"throughDOM\"] = builderThroughDOMStream;\nRecordBatchReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchFileReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchStreamReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchFileWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchStreamWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\n\n// js/parsing.js\nfunction parse_spec(code, data) {\n  if (code === null) {\n    return null;\n  }\n  if (Array.isArray(code)) {\n    return code.map((d) => parse_spec(d, data));\n  }\n  if (typeof code === \"string\" || code instanceof String) {\n    return code;\n  }\n  if (Object.entries(code).length == 0) {\n    return code;\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame\") {\n    return tableFromIPC(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame-ref\") {\n    return tableFromIPC(data[code[\"value\"]]);\n  }\n  if (code[\"pyobsplot-type\"] == \"function\") {\n    let fun = get_fun(code[\"module\"], code[\"method\"]);\n    return fun.call(null, ...parse_spec(code[\"args\"], data));\n  }\n  if (code[\"pyobsplot-type\"] == \"function-object\") {\n    return get_fun(code[\"module\"], code[\"method\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"js\") {\n    let indirect_eval = eval;\n    return indirect_eval(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"datetime\") {\n    return new Date(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson\") {\n    return code[\"value\"];\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson-ref\") {\n    return data[code[\"value\"]];\n  }\n  let ret = {};\n  for (const [key, value] of Object.entries(code)) {\n    ret[key] = parse_spec(value, data);\n  }\n  return ret;\n}\nfunction get_fun(mod, method) {\n  let fun;\n  switch (mod) {\n    case \"Plot\":\n      fun = dist_exports[method];\n      break;\n    case \"d3\":\n      fun = src_exports[method];\n      break;\n    case \"Math\":\n      fun = Math[method];\n      break;\n    default:\n      throw new Error(`Invalid module: ${mod}`);\n  }\n  if (fun === void 0) {\n    throw new Error(`${mod}.${method} is not defined`);\n  }\n  return fun;\n}\n\n// js/index.js\nfunction render(view) {\n  let spec = () => view.model.get(\"spec\");\n  view.el.appendChild(generate_plot(spec()));\n  view.model.on(\"change:spec\", () => _onValueChanged(view, view.el));\n}\nfunction generate_plot(spec) {\n  let plot2 = document.createElement(\"div\");\n  plot2.classList.add(\"pyobsplot-plot\");\n  let out;\n  try {\n    out = parse_spec(spec[\"code\"], spec[\"data\"]);\n    if (spec[\"code\"][\"pyobsplot-type\"] == \"function\") {\n      if (!(out instanceof Element)) {\n        out = out.plot();\n      }\n    } else {\n      out = plot(out);\n    }\n  } catch (error) {\n    out = document.createElement(\"pre\");\n    out.classList.add(\"pyobsplot-error\");\n    out.textContent = error;\n  }\n  plot2.appendChild(out);\n  return plot2;\n}\nfunction _onValueChanged(view, el) {\n  let plot2 = el.querySelector(\".pyobsplot-plot\");\n  el.removeChild(plot2);\n  let spec = () => view.model.get(\"spec\");\n  el.appendChild(generate_plot(spec()));\n}\nexport {\n  render\n};\n","_model_module":"anywidget","_model_module_version":"0.2.0","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"0.2.0","_view_name":"AnyView","layout":"IPY_MODEL_0d031d2d1d2b4bfca329f13640c78af3","spec":{"code":{"color":{"legend":true},"grid":true,"marks":[{"args":[{"pyobsplot-type":"DataFrame-ref","value":0},{"fill":"island","x":"flipper_length_mm","y":"body_mass_g"}],"method":"dot","module":"Plot","pyobsplot-type":"function"}]},"data":[null]},"tabbable":null,"tooltip":null}},"6054fd49907944938fa8b10e2a74a9c9":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"9a570cdfc8094feda2530889b5fa6afa":{"buffers":[{"data":"QVJST1cxAAD/////2AAAABAAAAAAAAoADAAGAAUACAAKAAAAAAEEAAwAAAAIAAgAAAAEAAgAAAAEAAAAAwAAAHQAAAA0AAAABAAAAKj///8AAAEFEAAAABwAAAAEAAAAAAAAAAQAAAB0eXBlAAAAAAQABAAEAAAA1P///wAAAQIQAAAAFAAAAAQAAAAAAAAAAQAAAHkAAADE////AAAAASAAAAAQABQACAAGAAcADAAAABAAEAAAAAAAAQIQAAAAHAAAAAQAAAAAAAAAAQAAAHgAAAAIAAwACAAHAAgAAAAAAAABIAAAAP/////4AAAAFAAAAAAAAAAMABYABgAFAAgADAAMAAAAAAMEABgAAABwAAAAAAAAAAAACgAYAAwABAAIAAoAAACMAAAAEAAAAAcAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABwAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAIAAAAAAAAABgAAAAAAAAAA4AAAAAAAAAAAAAAAMAAAAHAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAABAAAABQAAAAIAAAAEAAAABgAAAAIAAAAEAAAAAAAAAAIAAAABAAAAAwAAAAQAAAAFAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAAEAAAABgAAAAgAAAAKAAAADAAAAA4AAABUMVQyVDFUMlQxVDFUMgAA/////wAAAAAQAAAADAAUAAYACAAMABAADAAAAAAABAA8AAAAKAAAAAQAAAABAAAA6AAAAAAAAAAAAQAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAACAAIAAAABAAIAAAABAAAAAMAAAB0AAAANAAAAAQAAACo////AAABBRAAAAAcAAAABAAAAAAAAAAEAAAAdHlwZQAAAAAEAAQABAAAANT///8AAAECEAAAABQAAAAEAAAAAAAAAAEAAAB5AAAAxP///wAAAAEgAAAAEAAUAAgABgAHAAwAAAAQABAAAAAAAAECEAAAABwAAAAEAAAAAAAAAAEAAAB4AAAACAAMAAgABwAIAAAAAAAAASAAAAAIAQAAQVJST1cx","encoding":"base64","path":["spec","data",0]}],"model_module":"anywidget","model_module_version":"0.2.0","model_name":"AnyModel","state":{"_anywidget_id":"pyobsplot.widget.Obsplot","_css":"/* js/styles.css */\n.counter-button {\n  background-color: #ea580c;\n}\n.counter-button:hover {\n  background-color: #0000FF;\n}\n.pyobsplot-plot {\n  color: #000;\n  background-color: white;\n}\n.pyobsplot-error {\n  color: #CC0000;\n  padding-left: 1em;\n}\n.pyobsplot-error::before {\n  content: \"\\26a0  \";\n}\n","_dom_classes":[],"_esm":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/binary-search-bounds/search-bounds.js\nvar require_search_bounds = __commonJS({\n  \"node_modules/binary-search-bounds/search-bounds.js\"(exports, module) {\n    \"use strict\";\n    function ge(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p >= 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function gt(a4, y4, c6, l, h) {\n      var i = h + 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p > 0) {\n          i = m3;\n          h = m3 - 1;\n        } else {\n          l = m3 + 1;\n        }\n      }\n      return i;\n    }\n    function lt(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p < 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function le(a4, y4, c6, l, h) {\n      var i = l - 1;\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p <= 0) {\n          i = m3;\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return i;\n    }\n    function eq(a4, y4, c6, l, h) {\n      while (l <= h) {\n        var m3 = l + h >>> 1, x4 = a4[m3];\n        var p = c6 !== void 0 ? c6(x4, y4) : x4 - y4;\n        if (p === 0) {\n          return m3;\n        }\n        if (p <= 0) {\n          l = m3 + 1;\n        } else {\n          h = m3 - 1;\n        }\n      }\n      return -1;\n    }\n    function norm(a4, y4, c6, l, h, f) {\n      if (typeof c6 === \"function\") {\n        return f(a4, y4, c6, l === void 0 ? 0 : l | 0, h === void 0 ? a4.length - 1 : h | 0);\n      }\n      return f(a4, y4, void 0, c6 === void 0 ? 0 : c6 | 0, l === void 0 ? a4.length - 1 : l | 0);\n    }\n    module.exports = {\n      ge: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, ge);\n      },\n      gt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, gt);\n      },\n      lt: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, lt);\n      },\n      le: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, le);\n      },\n      eq: function(a4, y4, c6, l, h) {\n        return norm(a4, y4, c6, l, h, eq);\n      }\n    };\n  }\n});\n\n// node_modules/interval-tree-1d/interval-tree.js\nvar require_interval_tree = __commonJS({\n  \"node_modules/interval-tree-1d/interval-tree.js\"(exports, module) {\n    \"use strict\";\n    var bounds = require_search_bounds();\n    var NOT_FOUND = 0;\n    var SUCCESS = 1;\n    var EMPTY = 2;\n    module.exports = createWrapper;\n    function IntervalTreeNode(mid3, left2, right2, leftPoints, rightPoints) {\n      this.mid = mid3;\n      this.left = left2;\n      this.right = right2;\n      this.leftPoints = leftPoints;\n      this.rightPoints = rightPoints;\n      this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;\n    }\n    var proto = IntervalTreeNode.prototype;\n    function copy3(a4, b) {\n      a4.mid = b.mid;\n      a4.left = b.left;\n      a4.right = b.right;\n      a4.leftPoints = b.leftPoints;\n      a4.rightPoints = b.rightPoints;\n      a4.count = b.count;\n    }\n    function rebuild(node, intervals) {\n      var ntree = createIntervalTree(intervals);\n      node.mid = ntree.mid;\n      node.left = ntree.left;\n      node.right = ntree.right;\n      node.leftPoints = ntree.leftPoints;\n      node.rightPoints = ntree.rightPoints;\n      node.count = ntree.count;\n    }\n    function rebuildWithInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      intervals.push(interval2);\n      rebuild(node, intervals);\n    }\n    function rebuildWithoutInterval(node, interval2) {\n      var intervals = node.intervals([]);\n      var idx = intervals.indexOf(interval2);\n      if (idx < 0) {\n        return NOT_FOUND;\n      }\n      intervals.splice(idx, 1);\n      rebuild(node, intervals);\n      return SUCCESS;\n    }\n    proto.intervals = function(result) {\n      result.push.apply(result, this.leftPoints);\n      if (this.left) {\n        this.left.intervals(result);\n      }\n      if (this.right) {\n        this.right.intervals(result);\n      }\n      return result;\n    };\n    proto.insert = function(interval2) {\n      var weight = this.count - this.leftPoints.length;\n      this.count += 1;\n      if (interval2[1] < this.mid) {\n        if (this.left) {\n          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.left.insert(interval2);\n          }\n        } else {\n          this.left = createIntervalTree([interval2]);\n        }\n      } else if (interval2[0] > this.mid) {\n        if (this.right) {\n          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\n            rebuildWithInterval(this, interval2);\n          } else {\n            this.right.insert(interval2);\n          }\n        } else {\n          this.right = createIntervalTree([interval2]);\n        }\n      } else {\n        var l = bounds.ge(this.leftPoints, interval2, compareBegin);\n        var r = bounds.ge(this.rightPoints, interval2, compareEnd);\n        this.leftPoints.splice(l, 0, interval2);\n        this.rightPoints.splice(r, 0, interval2);\n      }\n    };\n    proto.remove = function(interval2) {\n      var weight = this.count - this.leftPoints;\n      if (interval2[1] < this.mid) {\n        if (!this.left) {\n          return NOT_FOUND;\n        }\n        var rw = this.right ? this.right.count : 0;\n        if (4 * rw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.left.remove(interval2);\n        if (r === EMPTY) {\n          this.left = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else if (interval2[0] > this.mid) {\n        if (!this.right) {\n          return NOT_FOUND;\n        }\n        var lw = this.left ? this.left.count : 0;\n        if (4 * lw > 3 * (weight - 1)) {\n          return rebuildWithoutInterval(this, interval2);\n        }\n        var r = this.right.remove(interval2);\n        if (r === EMPTY) {\n          this.right = null;\n          this.count -= 1;\n          return SUCCESS;\n        } else if (r === SUCCESS) {\n          this.count -= 1;\n        }\n        return r;\n      } else {\n        if (this.count === 1) {\n          if (this.leftPoints[0] === interval2) {\n            return EMPTY;\n          } else {\n            return NOT_FOUND;\n          }\n        }\n        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {\n          if (this.left && this.right) {\n            var p = this;\n            var n = this.left;\n            while (n.right) {\n              p = n;\n              n = n.right;\n            }\n            if (p === this) {\n              n.right = this.right;\n            } else {\n              var l = this.left;\n              var r = this.right;\n              p.count -= n.count;\n              p.right = n.left;\n              n.left = l;\n              n.right = r;\n            }\n            copy3(this, n);\n            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\n          } else if (this.left) {\n            copy3(this, this.left);\n          } else {\n            copy3(this, this.right);\n          }\n          return SUCCESS;\n        }\n        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {\n          if (this.leftPoints[l][0] !== interval2[0]) {\n            break;\n          }\n          if (this.leftPoints[l] === interval2) {\n            this.count -= 1;\n            this.leftPoints.splice(l, 1);\n            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {\n              if (this.rightPoints[r][1] !== interval2[1]) {\n                break;\n              } else if (this.rightPoints[r] === interval2) {\n                this.rightPoints.splice(r, 1);\n                return SUCCESS;\n              }\n            }\n          }\n        }\n        return NOT_FOUND;\n      }\n    };\n    function reportLeftRange(arr, hi, cb) {\n      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRightRange(arr, lo, cb) {\n      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    function reportRange(arr, cb) {\n      for (var i = 0; i < arr.length; ++i) {\n        var r = cb(arr[i]);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    proto.queryPoint = function(x4, cb) {\n      if (x4 < this.mid) {\n        if (this.left) {\n          var r = this.left.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportLeftRange(this.leftPoints, x4, cb);\n      } else if (x4 > this.mid) {\n        if (this.right) {\n          var r = this.right.queryPoint(x4, cb);\n          if (r) {\n            return r;\n          }\n        }\n        return reportRightRange(this.rightPoints, x4, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    proto.queryInterval = function(lo, hi, cb) {\n      if (lo < this.mid && this.left) {\n        var r = this.left.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi > this.mid && this.right) {\n        var r = this.right.queryInterval(lo, hi, cb);\n        if (r) {\n          return r;\n        }\n      }\n      if (hi < this.mid) {\n        return reportLeftRange(this.leftPoints, hi, cb);\n      } else if (lo > this.mid) {\n        return reportRightRange(this.rightPoints, lo, cb);\n      } else {\n        return reportRange(this.leftPoints, cb);\n      }\n    };\n    function compareNumbers(a4, b) {\n      return a4 - b;\n    }\n    function compareBegin(a4, b) {\n      var d = a4[0] - b[0];\n      if (d) {\n        return d;\n      }\n      return a4[1] - b[1];\n    }\n    function compareEnd(a4, b) {\n      var d = a4[1] - b[1];\n      if (d) {\n        return d;\n      }\n      return a4[0] - b[0];\n    }\n    function createIntervalTree(intervals) {\n      if (intervals.length === 0) {\n        return null;\n      }\n      var pts = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        pts.push(intervals[i][0], intervals[i][1]);\n      }\n      pts.sort(compareNumbers);\n      var mid3 = pts[pts.length >> 1];\n      var leftIntervals = [];\n      var rightIntervals = [];\n      var centerIntervals = [];\n      for (var i = 0; i < intervals.length; ++i) {\n        var s2 = intervals[i];\n        if (s2[1] < mid3) {\n          leftIntervals.push(s2);\n        } else if (mid3 < s2[0]) {\n          rightIntervals.push(s2);\n        } else {\n          centerIntervals.push(s2);\n        }\n      }\n      var leftPoints = centerIntervals;\n      var rightPoints = centerIntervals.slice();\n      leftPoints.sort(compareBegin);\n      rightPoints.sort(compareEnd);\n      return new IntervalTreeNode(\n        mid3,\n        createIntervalTree(leftIntervals),\n        createIntervalTree(rightIntervals),\n        leftPoints,\n        rightPoints\n      );\n    }\n    function IntervalTree2(root3) {\n      this.root = root3;\n    }\n    var tproto = IntervalTree2.prototype;\n    tproto.insert = function(interval2) {\n      if (this.root) {\n        this.root.insert(interval2);\n      } else {\n        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);\n      }\n    };\n    tproto.remove = function(interval2) {\n      if (this.root) {\n        var r = this.root.remove(interval2);\n        if (r === EMPTY) {\n          this.root = null;\n        }\n        return r !== NOT_FOUND;\n      }\n      return false;\n    };\n    tproto.queryPoint = function(p, cb) {\n      if (this.root) {\n        return this.root.queryPoint(p, cb);\n      }\n    };\n    tproto.queryInterval = function(lo, hi, cb) {\n      if (lo <= hi && this.root) {\n        return this.root.queryInterval(lo, hi, cb);\n      }\n    };\n    Object.defineProperty(tproto, \"count\", {\n      get: function() {\n        if (this.root) {\n          return this.root.count;\n        }\n        return 0;\n      }\n    });\n    Object.defineProperty(tproto, \"intervals\", {\n      get: function() {\n        if (this.root) {\n          return this.root.intervals([]);\n        }\n        return [];\n      }\n    });\n    function createWrapper(intervals) {\n      if (!intervals || intervals.length === 0) {\n        return new IntervalTree2(null);\n      }\n      return new IntervalTree2(createIntervalTree(intervals));\n    }\n  }\n});\n\n// node_modules/@observablehq/plot/dist/index.js\nvar dist_exports = {};\n__export(dist_exports, {\n  Area: () => Area,\n  Arrow: () => Arrow,\n  BarX: () => BarX,\n  BarY: () => BarY,\n  Cell: () => Cell,\n  Contour: () => Contour,\n  Density: () => Density,\n  Dot: () => Dot,\n  Frame: () => Frame,\n  Geo: () => Geo,\n  Hexgrid: () => Hexgrid,\n  Image: () => Image2,\n  Line: () => Line,\n  Link: () => Link,\n  Mark: () => Mark,\n  Raster: () => Raster,\n  Rect: () => Rect,\n  RuleX: () => RuleX,\n  RuleY: () => RuleY,\n  Text: () => Text,\n  TickX: () => TickX,\n  TickY: () => TickY,\n  Vector: () => Vector,\n  area: () => area,\n  areaX: () => areaX,\n  areaY: () => areaY,\n  arrow: () => arrow,\n  auto: () => auto,\n  autoSpec: () => autoSpec,\n  axisFx: () => axisFx,\n  axisFy: () => axisFy,\n  axisX: () => axisX,\n  axisY: () => axisY,\n  barX: () => barX,\n  barY: () => barY,\n  bin: () => bin2,\n  binX: () => binX,\n  binY: () => binY,\n  boxX: () => boxX,\n  boxY: () => boxY,\n  cell: () => cell,\n  cellX: () => cellX,\n  cellY: () => cellY,\n  centroid: () => centroid,\n  circle: () => circle,\n  cluster: () => cluster,\n  column: () => column,\n  contour: () => contour,\n  delaunayLink: () => delaunayLink,\n  delaunayMesh: () => delaunayMesh,\n  density: () => density,\n  dodgeX: () => dodgeX,\n  dodgeY: () => dodgeY,\n  dot: () => dot,\n  dotX: () => dotX,\n  dotY: () => dotY,\n  filter: () => filter3,\n  formatIsoDate: () => formatIsoDate,\n  formatMonth: () => formatMonth,\n  formatWeekday: () => formatWeekday,\n  frame: () => frame2,\n  geo: () => geo,\n  geoCentroid: () => geoCentroid,\n  graticule: () => graticule2,\n  gridFx: () => gridFx,\n  gridFy: () => gridFy,\n  gridX: () => gridX,\n  gridY: () => gridY,\n  group: () => group2,\n  groupX: () => groupX,\n  groupY: () => groupY,\n  groupZ: () => groupZ,\n  hexagon: () => hexagon,\n  hexbin: () => hexbin,\n  hexgrid: () => hexgrid,\n  hull: () => hull,\n  identity: () => identity6,\n  image: () => image,\n  initializer: () => initializer,\n  interpolateNearest: () => interpolateNearest,\n  interpolateNone: () => interpolateNone,\n  interpolatorBarycentric: () => interpolatorBarycentric,\n  interpolatorRandomWalk: () => interpolatorRandomWalk,\n  legend: () => legend,\n  line: () => line,\n  lineX: () => lineX,\n  lineY: () => lineY,\n  linearRegressionX: () => linearRegressionX,\n  linearRegressionY: () => linearRegressionY,\n  link: () => link3,\n  map: () => map5,\n  mapX: () => mapX,\n  mapY: () => mapY,\n  marks: () => marks,\n  normalize: () => normalize3,\n  normalizeX: () => normalizeX,\n  normalizeY: () => normalizeY,\n  plot: () => plot,\n  raster: () => raster,\n  rect: () => rect,\n  rectX: () => rectX,\n  rectY: () => rectY,\n  reverse: () => reverse2,\n  ruleX: () => ruleX,\n  ruleY: () => ruleY,\n  scale: () => scale2,\n  select: () => select,\n  selectFirst: () => selectFirst,\n  selectLast: () => selectLast,\n  selectMaxX: () => selectMaxX,\n  selectMaxY: () => selectMaxY,\n  selectMinX: () => selectMinX,\n  selectMinY: () => selectMinY,\n  shuffle: () => shuffle2,\n  sort: () => sort2,\n  sphere: () => sphere,\n  spike: () => spike,\n  stackX: () => stackX,\n  stackX1: () => stackX1,\n  stackX2: () => stackX2,\n  stackY: () => stackY,\n  stackY1: () => stackY1,\n  stackY2: () => stackY2,\n  text: () => text,\n  textX: () => textX,\n  textY: () => textY,\n  tickX: () => tickX,\n  tickY: () => tickY,\n  transform: () => basic,\n  tree: () => tree,\n  treeLink: () => treeLink,\n  treeNode: () => treeNode,\n  valueof: () => valueof,\n  vector: () => vector,\n  vectorX: () => vectorX,\n  vectorY: () => vectorY,\n  voronoi: () => voronoi,\n  voronoiMesh: () => voronoiMesh,\n  window: () => window2,\n  windowX: () => windowX,\n  windowY: () => windowY\n});\n\n// node_modules/d3/src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  Adder: () => Adder,\n  Delaunay: () => Delaunay,\n  FormatSpecifier: () => FormatSpecifier,\n  InternMap: () => InternMap,\n  InternSet: () => InternSet,\n  Node: () => Node2,\n  Path: () => Path,\n  Voronoi: () => Voronoi,\n  ZoomTransform: () => Transform,\n  active: () => active_default,\n  arc: () => arc_default,\n  area: () => area_default5,\n  areaRadial: () => areaRadial_default,\n  ascending: () => ascending,\n  autoType: () => autoType,\n  axisBottom: () => axisBottom,\n  axisLeft: () => axisLeft,\n  axisRight: () => axisRight,\n  axisTop: () => axisTop,\n  bin: () => bin,\n  bisect: () => bisect_default,\n  bisectCenter: () => bisectCenter,\n  bisectLeft: () => bisectLeft,\n  bisectRight: () => bisectRight,\n  bisector: () => bisector,\n  blob: () => blob_default,\n  blur: () => blur,\n  blur2: () => blur2,\n  blurImage: () => blurImage,\n  brush: () => brush_default,\n  brushSelection: () => brushSelection,\n  brushX: () => brushX,\n  brushY: () => brushY,\n  buffer: () => buffer_default,\n  chord: () => chord_default,\n  chordDirected: () => chordDirected,\n  chordTranspose: () => chordTranspose,\n  cluster: () => cluster_default,\n  color: () => color,\n  contourDensity: () => density_default,\n  contours: () => contours_default,\n  count: () => count,\n  create: () => create_default,\n  creator: () => creator_default,\n  cross: () => cross,\n  csv: () => csv2,\n  csvFormat: () => csvFormat,\n  csvFormatBody: () => csvFormatBody,\n  csvFormatRow: () => csvFormatRow,\n  csvFormatRows: () => csvFormatRows,\n  csvFormatValue: () => csvFormatValue,\n  csvParse: () => csvParse,\n  csvParseRows: () => csvParseRows,\n  cubehelix: () => cubehelix,\n  cumsum: () => cumsum,\n  curveBasis: () => basis_default2,\n  curveBasisClosed: () => basisClosed_default2,\n  curveBasisOpen: () => basisOpen_default,\n  curveBumpX: () => bumpX,\n  curveBumpY: () => bumpY,\n  curveBundle: () => bundle_default,\n  curveCardinal: () => cardinal_default,\n  curveCardinalClosed: () => cardinalClosed_default,\n  curveCardinalOpen: () => cardinalOpen_default,\n  curveCatmullRom: () => catmullRom_default,\n  curveCatmullRomClosed: () => catmullRomClosed_default,\n  curveCatmullRomOpen: () => catmullRomOpen_default,\n  curveLinear: () => linear_default,\n  curveLinearClosed: () => linearClosed_default,\n  curveMonotoneX: () => monotoneX,\n  curveMonotoneY: () => monotoneY,\n  curveNatural: () => natural_default,\n  curveStep: () => step_default,\n  curveStepAfter: () => stepAfter,\n  curveStepBefore: () => stepBefore,\n  descending: () => descending,\n  deviation: () => deviation,\n  difference: () => difference,\n  disjoint: () => disjoint,\n  dispatch: () => dispatch_default,\n  drag: () => drag_default,\n  dragDisable: () => nodrag_default,\n  dragEnable: () => yesdrag,\n  dsv: () => dsv,\n  dsvFormat: () => dsv_default,\n  easeBack: () => backInOut,\n  easeBackIn: () => backIn,\n  easeBackInOut: () => backInOut,\n  easeBackOut: () => backOut,\n  easeBounce: () => bounceOut,\n  easeBounceIn: () => bounceIn,\n  easeBounceInOut: () => bounceInOut,\n  easeBounceOut: () => bounceOut,\n  easeCircle: () => circleInOut,\n  easeCircleIn: () => circleIn,\n  easeCircleInOut: () => circleInOut,\n  easeCircleOut: () => circleOut,\n  easeCubic: () => cubicInOut,\n  easeCubicIn: () => cubicIn,\n  easeCubicInOut: () => cubicInOut,\n  easeCubicOut: () => cubicOut,\n  easeElastic: () => elasticOut,\n  easeElasticIn: () => elasticIn,\n  easeElasticInOut: () => elasticInOut,\n  easeElasticOut: () => elasticOut,\n  easeExp: () => expInOut,\n  easeExpIn: () => expIn,\n  easeExpInOut: () => expInOut,\n  easeExpOut: () => expOut,\n  easeLinear: () => linear2,\n  easePoly: () => polyInOut,\n  easePolyIn: () => polyIn,\n  easePolyInOut: () => polyInOut,\n  easePolyOut: () => polyOut,\n  easeQuad: () => quadInOut,\n  easeQuadIn: () => quadIn,\n  easeQuadInOut: () => quadInOut,\n  easeQuadOut: () => quadOut,\n  easeSin: () => sinInOut,\n  easeSinIn: () => sinIn,\n  easeSinInOut: () => sinInOut,\n  easeSinOut: () => sinOut,\n  every: () => every,\n  extent: () => extent,\n  fcumsum: () => fcumsum,\n  filter: () => filter,\n  flatGroup: () => flatGroup,\n  flatRollup: () => flatRollup,\n  forceCenter: () => center_default,\n  forceCollide: () => collide_default,\n  forceLink: () => link_default,\n  forceManyBody: () => manyBody_default,\n  forceRadial: () => radial_default,\n  forceSimulation: () => simulation_default,\n  forceX: () => x_default2,\n  forceY: () => y_default2,\n  format: () => format,\n  formatDefaultLocale: () => defaultLocale,\n  formatLocale: () => locale_default,\n  formatPrefix: () => formatPrefix,\n  formatSpecifier: () => formatSpecifier,\n  fsum: () => fsum,\n  geoAlbers: () => albers_default,\n  geoAlbersUsa: () => albersUsa_default,\n  geoArea: () => area_default2,\n  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,\n  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,\n  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,\n  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,\n  geoBounds: () => bounds_default,\n  geoCentroid: () => centroid_default,\n  geoCircle: () => circle_default,\n  geoClipAntimeridian: () => antimeridian_default,\n  geoClipCircle: () => circle_default2,\n  geoClipExtent: () => extent_default2,\n  geoClipRectangle: () => clipRectangle,\n  geoConicConformal: () => conicConformal_default,\n  geoConicConformalRaw: () => conicConformalRaw,\n  geoConicEqualArea: () => conicEqualArea_default,\n  geoConicEqualAreaRaw: () => conicEqualAreaRaw,\n  geoConicEquidistant: () => conicEquidistant_default,\n  geoConicEquidistantRaw: () => conicEquidistantRaw,\n  geoContains: () => contains_default2,\n  geoDistance: () => distance_default,\n  geoEqualEarth: () => equalEarth_default,\n  geoEqualEarthRaw: () => equalEarthRaw,\n  geoEquirectangular: () => equirectangular_default,\n  geoEquirectangularRaw: () => equirectangularRaw,\n  geoGnomonic: () => gnomonic_default,\n  geoGnomonicRaw: () => gnomonicRaw,\n  geoGraticule: () => graticule,\n  geoGraticule10: () => graticule10,\n  geoIdentity: () => identity_default4,\n  geoInterpolate: () => interpolate_default2,\n  geoLength: () => length_default,\n  geoMercator: () => mercator_default,\n  geoMercatorRaw: () => mercatorRaw,\n  geoNaturalEarth1: () => naturalEarth1_default,\n  geoNaturalEarth1Raw: () => naturalEarth1Raw,\n  geoOrthographic: () => orthographic_default,\n  geoOrthographicRaw: () => orthographicRaw,\n  geoPath: () => path_default,\n  geoProjection: () => projection,\n  geoProjectionMutator: () => projectionMutator,\n  geoRotation: () => rotation_default,\n  geoStereographic: () => stereographic_default,\n  geoStereographicRaw: () => stereographicRaw,\n  geoStream: () => stream_default,\n  geoTransform: () => transform_default,\n  geoTransverseMercator: () => transverseMercator_default,\n  geoTransverseMercatorRaw: () => transverseMercatorRaw,\n  gray: () => gray,\n  greatest: () => greatest,\n  greatestIndex: () => greatestIndex,\n  group: () => group,\n  groupSort: () => groupSort,\n  groups: () => groups,\n  hcl: () => hcl,\n  hierarchy: () => hierarchy,\n  histogram: () => bin,\n  hsl: () => hsl,\n  html: () => html,\n  image: () => image_default,\n  index: () => index,\n  indexes: () => indexes,\n  interpolate: () => value_default,\n  interpolateArray: () => array_default,\n  interpolateBasis: () => basis_default,\n  interpolateBasisClosed: () => basisClosed_default,\n  interpolateBlues: () => Blues_default,\n  interpolateBrBG: () => BrBG_default,\n  interpolateBuGn: () => BuGn_default,\n  interpolateBuPu: () => BuPu_default,\n  interpolateCividis: () => cividis_default,\n  interpolateCool: () => cool,\n  interpolateCubehelix: () => cubehelix_default,\n  interpolateCubehelixDefault: () => cubehelix_default2,\n  interpolateCubehelixLong: () => cubehelixLong,\n  interpolateDate: () => date_default,\n  interpolateDiscrete: () => discrete_default,\n  interpolateGnBu: () => GnBu_default,\n  interpolateGreens: () => Greens_default,\n  interpolateGreys: () => Greys_default,\n  interpolateHcl: () => hcl_default,\n  interpolateHclLong: () => hclLong,\n  interpolateHsl: () => hsl_default,\n  interpolateHslLong: () => hslLong,\n  interpolateHue: () => hue_default,\n  interpolateInferno: () => inferno,\n  interpolateLab: () => lab2,\n  interpolateMagma: () => magma,\n  interpolateNumber: () => number_default,\n  interpolateNumberArray: () => numberArray_default,\n  interpolateObject: () => object_default,\n  interpolateOrRd: () => OrRd_default,\n  interpolateOranges: () => Oranges_default,\n  interpolatePRGn: () => PRGn_default,\n  interpolatePiYG: () => PiYG_default,\n  interpolatePlasma: () => plasma,\n  interpolatePuBu: () => PuBu_default,\n  interpolatePuBuGn: () => PuBuGn_default,\n  interpolatePuOr: () => PuOr_default,\n  interpolatePuRd: () => PuRd_default,\n  interpolatePurples: () => Purples_default,\n  interpolateRainbow: () => rainbow_default,\n  interpolateRdBu: () => RdBu_default,\n  interpolateRdGy: () => RdGy_default,\n  interpolateRdPu: () => RdPu_default,\n  interpolateRdYlBu: () => RdYlBu_default,\n  interpolateRdYlGn: () => RdYlGn_default,\n  interpolateReds: () => Reds_default,\n  interpolateRgb: () => rgb_default,\n  interpolateRgbBasis: () => rgbBasis,\n  interpolateRgbBasisClosed: () => rgbBasisClosed,\n  interpolateRound: () => round_default,\n  interpolateSinebow: () => sinebow_default,\n  interpolateSpectral: () => Spectral_default,\n  interpolateString: () => string_default,\n  interpolateTransformCss: () => interpolateTransformCss,\n  interpolateTransformSvg: () => interpolateTransformSvg,\n  interpolateTurbo: () => turbo_default,\n  interpolateViridis: () => viridis_default,\n  interpolateWarm: () => warm,\n  interpolateYlGn: () => YlGn_default,\n  interpolateYlGnBu: () => YlGnBu_default,\n  interpolateYlOrBr: () => YlOrBr_default,\n  interpolateYlOrRd: () => YlOrRd_default,\n  interpolateZoom: () => zoom_default,\n  interrupt: () => interrupt_default,\n  intersection: () => intersection,\n  interval: () => interval_default,\n  isoFormat: () => isoFormat_default,\n  isoParse: () => isoParse_default,\n  json: () => json_default,\n  lab: () => lab,\n  lch: () => lch,\n  least: () => least,\n  leastIndex: () => leastIndex,\n  line: () => line_default2,\n  lineRadial: () => lineRadial_default,\n  link: () => link2,\n  linkHorizontal: () => linkHorizontal,\n  linkRadial: () => linkRadial,\n  linkVertical: () => linkVertical,\n  local: () => local,\n  map: () => map2,\n  matcher: () => matcher_default,\n  max: () => max,\n  maxIndex: () => maxIndex,\n  mean: () => mean,\n  median: () => median,\n  medianIndex: () => medianIndex,\n  merge: () => merge,\n  min: () => min,\n  minIndex: () => minIndex,\n  mode: () => mode,\n  namespace: () => namespace_default,\n  namespaces: () => namespaces_default,\n  nice: () => nice,\n  now: () => now,\n  pack: () => pack_default,\n  packEnclose: () => enclose_default,\n  packSiblings: () => siblings_default,\n  pairs: () => pairs,\n  partition: () => partition_default,\n  path: () => path,\n  pathRound: () => pathRound,\n  permute: () => permute,\n  pie: () => pie_default,\n  piecewise: () => piecewise,\n  pointRadial: () => pointRadial_default,\n  pointer: () => pointer_default,\n  pointers: () => pointers_default,\n  polygonArea: () => area_default4,\n  polygonCentroid: () => centroid_default3,\n  polygonContains: () => contains_default3,\n  polygonHull: () => hull_default,\n  polygonLength: () => length_default2,\n  precisionFixed: () => precisionFixed_default,\n  precisionPrefix: () => precisionPrefix_default,\n  precisionRound: () => precisionRound_default,\n  quadtree: () => quadtree,\n  quantile: () => quantile,\n  quantileIndex: () => quantileIndex,\n  quantileSorted: () => quantileSorted,\n  quantize: () => quantize_default,\n  quickselect: () => quickselect,\n  radialArea: () => areaRadial_default,\n  radialLine: () => lineRadial_default,\n  randomBates: () => bates_default,\n  randomBernoulli: () => bernoulli_default,\n  randomBeta: () => beta_default,\n  randomBinomial: () => binomial_default,\n  randomCauchy: () => cauchy_default,\n  randomExponential: () => exponential_default,\n  randomGamma: () => gamma_default,\n  randomGeometric: () => geometric_default,\n  randomInt: () => int_default,\n  randomIrwinHall: () => irwinHall_default,\n  randomLcg: () => lcg,\n  randomLogNormal: () => logNormal_default,\n  randomLogistic: () => logistic_default,\n  randomNormal: () => normal_default,\n  randomPareto: () => pareto_default,\n  randomPoisson: () => poisson_default,\n  randomUniform: () => uniform_default,\n  randomWeibull: () => weibull_default,\n  range: () => range,\n  rank: () => rank,\n  reduce: () => reduce,\n  reverse: () => reverse,\n  rgb: () => rgb,\n  ribbon: () => ribbon_default,\n  ribbonArrow: () => ribbonArrow,\n  rollup: () => rollup,\n  rollups: () => rollups,\n  scaleBand: () => band,\n  scaleDiverging: () => diverging,\n  scaleDivergingLog: () => divergingLog,\n  scaleDivergingPow: () => divergingPow,\n  scaleDivergingSqrt: () => divergingSqrt,\n  scaleDivergingSymlog: () => divergingSymlog,\n  scaleIdentity: () => identity4,\n  scaleImplicit: () => implicit,\n  scaleLinear: () => linear3,\n  scaleLog: () => log2,\n  scaleOrdinal: () => ordinal,\n  scalePoint: () => point,\n  scalePow: () => pow3,\n  scaleQuantile: () => quantile2,\n  scaleQuantize: () => quantize,\n  scaleRadial: () => radial,\n  scaleSequential: () => sequential,\n  scaleSequentialLog: () => sequentialLog,\n  scaleSequentialPow: () => sequentialPow,\n  scaleSequentialQuantile: () => sequentialQuantile,\n  scaleSequentialSqrt: () => sequentialSqrt,\n  scaleSequentialSymlog: () => sequentialSymlog,\n  scaleSqrt: () => sqrt2,\n  scaleSymlog: () => symlog,\n  scaleThreshold: () => threshold,\n  scaleTime: () => time,\n  scaleUtc: () => utcTime,\n  scan: () => scan,\n  schemeAccent: () => Accent_default,\n  schemeBlues: () => scheme22,\n  schemeBrBG: () => scheme,\n  schemeBuGn: () => scheme10,\n  schemeBuPu: () => scheme11,\n  schemeCategory10: () => category10_default,\n  schemeDark2: () => Dark2_default,\n  schemeGnBu: () => scheme12,\n  schemeGreens: () => scheme23,\n  schemeGreys: () => scheme24,\n  schemeOrRd: () => scheme13,\n  schemeOranges: () => scheme27,\n  schemePRGn: () => scheme2,\n  schemePaired: () => Paired_default,\n  schemePastel1: () => Pastel1_default,\n  schemePastel2: () => Pastel2_default,\n  schemePiYG: () => scheme3,\n  schemePuBu: () => scheme15,\n  schemePuBuGn: () => scheme14,\n  schemePuOr: () => scheme4,\n  schemePuRd: () => scheme16,\n  schemePurples: () => scheme25,\n  schemeRdBu: () => scheme5,\n  schemeRdGy: () => scheme6,\n  schemeRdPu: () => scheme17,\n  schemeRdYlBu: () => scheme7,\n  schemeRdYlGn: () => scheme8,\n  schemeReds: () => scheme26,\n  schemeSet1: () => Set1_default,\n  schemeSet2: () => Set2_default,\n  schemeSet3: () => Set3_default,\n  schemeSpectral: () => scheme9,\n  schemeTableau10: () => Tableau10_default,\n  schemeYlGn: () => scheme19,\n  schemeYlGnBu: () => scheme18,\n  schemeYlOrBr: () => scheme20,\n  schemeYlOrRd: () => scheme21,\n  select: () => select_default2,\n  selectAll: () => selectAll_default2,\n  selection: () => selection_default,\n  selector: () => selector_default,\n  selectorAll: () => selectorAll_default,\n  shuffle: () => shuffle_default,\n  shuffler: () => shuffler,\n  some: () => some,\n  sort: () => sort,\n  stack: () => stack_default,\n  stackOffsetDiverging: () => diverging_default,\n  stackOffsetExpand: () => expand_default,\n  stackOffsetNone: () => none_default,\n  stackOffsetSilhouette: () => silhouette_default,\n  stackOffsetWiggle: () => wiggle_default,\n  stackOrderAppearance: () => appearance_default,\n  stackOrderAscending: () => ascending_default2,\n  stackOrderDescending: () => descending_default2,\n  stackOrderInsideOut: () => insideOut_default,\n  stackOrderNone: () => none_default2,\n  stackOrderReverse: () => reverse_default,\n  stratify: () => stratify_default,\n  style: () => styleValue,\n  subset: () => subset,\n  sum: () => sum,\n  superset: () => superset,\n  svg: () => svg,\n  symbol: () => Symbol2,\n  symbolAsterisk: () => asterisk_default,\n  symbolCircle: () => circle_default3,\n  symbolCross: () => cross_default2,\n  symbolDiamond: () => diamond_default,\n  symbolDiamond2: () => diamond2_default,\n  symbolPlus: () => plus_default,\n  symbolSquare: () => square_default,\n  symbolSquare2: () => square2_default,\n  symbolStar: () => star_default,\n  symbolTimes: () => times_default,\n  symbolTriangle: () => triangle_default,\n  symbolTriangle2: () => triangle2_default,\n  symbolWye: () => wye_default,\n  symbolX: () => times_default,\n  symbols: () => symbolsFill,\n  symbolsFill: () => symbolsFill,\n  symbolsStroke: () => symbolsStroke,\n  text: () => text_default3,\n  thresholdFreedmanDiaconis: () => thresholdFreedmanDiaconis,\n  thresholdScott: () => thresholdScott,\n  thresholdSturges: () => thresholdSturges,\n  tickFormat: () => tickFormat,\n  tickIncrement: () => tickIncrement,\n  tickStep: () => tickStep,\n  ticks: () => ticks,\n  timeDay: () => timeDay,\n  timeDays: () => timeDays,\n  timeFormat: () => timeFormat,\n  timeFormatDefaultLocale: () => defaultLocale2,\n  timeFormatLocale: () => formatLocale,\n  timeFriday: () => timeFriday,\n  timeFridays: () => timeFridays,\n  timeHour: () => timeHour,\n  timeHours: () => timeHours,\n  timeInterval: () => timeInterval,\n  timeMillisecond: () => millisecond,\n  timeMilliseconds: () => milliseconds,\n  timeMinute: () => timeMinute,\n  timeMinutes: () => timeMinutes,\n  timeMonday: () => timeMonday,\n  timeMondays: () => timeMondays,\n  timeMonth: () => timeMonth,\n  timeMonths: () => timeMonths,\n  timeParse: () => timeParse,\n  timeSaturday: () => timeSaturday,\n  timeSaturdays: () => timeSaturdays,\n  timeSecond: () => second,\n  timeSeconds: () => seconds,\n  timeSunday: () => timeSunday,\n  timeSundays: () => timeSundays,\n  timeThursday: () => timeThursday,\n  timeThursdays: () => timeThursdays,\n  timeTickInterval: () => timeTickInterval,\n  timeTicks: () => timeTicks,\n  timeTuesday: () => timeTuesday,\n  timeTuesdays: () => timeTuesdays,\n  timeWednesday: () => timeWednesday,\n  timeWednesdays: () => timeWednesdays,\n  timeWeek: () => timeSunday,\n  timeWeeks: () => timeSundays,\n  timeYear: () => timeYear,\n  timeYears: () => timeYears,\n  timeout: () => timeout_default,\n  timer: () => timer,\n  timerFlush: () => timerFlush,\n  transition: () => transition,\n  transpose: () => transpose,\n  tree: () => tree_default,\n  treemap: () => treemap_default,\n  treemapBinary: () => binary_default,\n  treemapDice: () => dice_default,\n  treemapResquarify: () => resquarify_default,\n  treemapSlice: () => slice_default,\n  treemapSliceDice: () => sliceDice_default,\n  treemapSquarify: () => squarify_default,\n  tsv: () => tsv2,\n  tsvFormat: () => tsvFormat,\n  tsvFormatBody: () => tsvFormatBody,\n  tsvFormatRow: () => tsvFormatRow,\n  tsvFormatRows: () => tsvFormatRows,\n  tsvFormatValue: () => tsvFormatValue,\n  tsvParse: () => tsvParse,\n  tsvParseRows: () => tsvParseRows,\n  union: () => union,\n  unixDay: () => unixDay,\n  unixDays: () => unixDays,\n  utcDay: () => utcDay,\n  utcDays: () => utcDays,\n  utcFormat: () => utcFormat,\n  utcFriday: () => utcFriday,\n  utcFridays: () => utcFridays,\n  utcHour: () => utcHour,\n  utcHours: () => utcHours,\n  utcMillisecond: () => millisecond,\n  utcMilliseconds: () => milliseconds,\n  utcMinute: () => utcMinute,\n  utcMinutes: () => utcMinutes,\n  utcMonday: () => utcMonday,\n  utcMondays: () => utcMondays,\n  utcMonth: () => utcMonth,\n  utcMonths: () => utcMonths,\n  utcParse: () => utcParse,\n  utcSaturday: () => utcSaturday,\n  utcSaturdays: () => utcSaturdays,\n  utcSecond: () => second,\n  utcSeconds: () => seconds,\n  utcSunday: () => utcSunday,\n  utcSundays: () => utcSundays,\n  utcThursday: () => utcThursday,\n  utcThursdays: () => utcThursdays,\n  utcTickInterval: () => utcTickInterval,\n  utcTicks: () => utcTicks,\n  utcTuesday: () => utcTuesday,\n  utcTuesdays: () => utcTuesdays,\n  utcWednesday: () => utcWednesday,\n  utcWednesdays: () => utcWednesdays,\n  utcWeek: () => utcSunday,\n  utcWeeks: () => utcSundays,\n  utcYear: () => utcYear,\n  utcYears: () => utcYears,\n  variance: () => variance,\n  window: () => window_default,\n  xml: () => xml_default,\n  zip: () => zip,\n  zoom: () => zoom_default2,\n  zoomIdentity: () => identity5,\n  zoomTransform: () => transform\n});\n\n// node_modules/d3-array/src/ascending.js\nfunction ascending(a4, b) {\n  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/descending.js\nfunction descending(a4, b) {\n  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-array/src/bisector.js\nfunction bisector(f) {\n  let compare1, compare2, delta;\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x4) => ascending(f(d), x4);\n    delta = (d, x4) => f(d) - x4;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n  function left2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) < 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function right2(a4, x4, lo = 0, hi = a4.length) {\n    if (lo < hi) {\n      if (compare1(x4, x4) !== 0)\n        return hi;\n      do {\n        const mid3 = lo + hi >>> 1;\n        if (compare2(a4[mid3], x4) <= 0)\n          lo = mid3 + 1;\n        else\n          hi = mid3;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n  function center2(a4, x4, lo = 0, hi = a4.length) {\n    const i = left2(a4, x4, lo, hi - 1);\n    return i > lo && delta(a4[i - 1], x4) > -delta(a4[i], x4) ? i - 1 : i;\n  }\n  return { left: left2, center: center2, right: right2 };\n}\nfunction zero() {\n  return 0;\n}\n\n// node_modules/d3-array/src/number.js\nfunction number(x4) {\n  return x4 === null ? NaN : +x4;\n}\nfunction* numbers(values2, valueof2) {\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n\n// node_modules/d3-array/src/bisect.js\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\nvar bisectCenter = bisector(number).center;\nvar bisect_default = bisectRight;\n\n// node_modules/d3-array/src/blur.js\nfunction blur(values2, r) {\n  if (!((r = +r) >= 0))\n    throw new RangeError(\"invalid r\");\n  let length4 = values2.length;\n  if (!((length4 = Math.floor(length4)) >= 0))\n    throw new RangeError(\"invalid length\");\n  if (!length4 || !r)\n    return values2;\n  const blur3 = blurf(r);\n  const temp = values2.slice();\n  blur3(values2, temp, 0, length4, 1);\n  blur3(temp, values2, 0, length4, 1);\n  blur3(values2, temp, 0, length4, 1);\n  return values2;\n}\nvar blur2 = Blur2(blurf);\nvar blurImage = Blur2(blurfImage);\nfunction Blur2(blur3) {\n  return function(data, rx, ry = rx) {\n    if (!((rx = +rx) >= 0))\n      throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0))\n      throw new RangeError(\"invalid ry\");\n    let { data: values2, width, height } = data;\n    if (!((width = Math.floor(width)) >= 0))\n      throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0))\n      throw new RangeError(\"invalid height\");\n    if (!width || !height || !rx && !ry)\n      return data;\n    const blurx = rx && blur3(rx);\n    const blury = ry && blur3(ry);\n    const temp = values2.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values2, temp, width, height);\n      blurh(blurx, temp, values2, width, height);\n      blurh(blurx, values2, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values2, temp, width, height);\n      blurv(blury, temp, values2, width, height);\n      blurv(blury, values2, temp, width, height);\n    }\n    return data;\n  };\n}\nfunction blurh(blur3, T, S, w, h) {\n  for (let y4 = 0, n = w * h; y4 < n; ) {\n    blur3(T, S, y4, y4 += w, 1);\n  }\n}\nfunction blurv(blur3, T, S, w, h) {\n  for (let x4 = 0, n = w * h; x4 < w; ++x4) {\n    blur3(T, S, x4, x4 + n, w);\n  }\n}\nfunction blurfImage(radius2) {\n  const blur3 = blurf(radius2);\n  return (T, S, start2, stop, step) => {\n    start2 <<= 2, stop <<= 2, step <<= 2;\n    blur3(T, S, start2 + 0, stop + 0, step);\n    blur3(T, S, start2 + 1, stop + 1, step);\n    blur3(T, S, start2 + 2, stop + 2, step);\n    blur3(T, S, start2 + 3, stop + 3, step);\n  };\n}\nfunction blurf(radius2) {\n  const radius0 = Math.floor(radius2);\n  if (radius0 === radius2)\n    return bluri(radius2);\n  const t = radius2 - radius0;\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius0 * S[start2];\n    const s0 = step * radius0;\n    const s1 = s0 + step;\n    for (let i = start2, j = start2 + s0; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s0)];\n      T[i] = (sum5 + t * (S[Math.max(start2, i - s1)] + S[Math.min(stop, i + s1)])) / w;\n      sum5 -= S[Math.max(start2, i - s0)];\n    }\n  };\n}\nfunction bluri(radius2) {\n  const w = 2 * radius2 + 1;\n  return (T, S, start2, stop, step) => {\n    if (!((stop -= step) >= start2))\n      return;\n    let sum5 = radius2 * S[start2];\n    const s2 = step * radius2;\n    for (let i = start2, j = start2 + s2; i < j; i += step) {\n      sum5 += S[Math.min(stop, i)];\n    }\n    for (let i = start2, j = stop; i <= j; i += step) {\n      sum5 += S[Math.min(stop, i + s2)];\n      T[i] = sum5 / w;\n      sum5 -= S[Math.max(start2, i - s2)];\n    }\n  };\n}\n\n// node_modules/d3-array/src/count.js\nfunction count(values2, valueof2) {\n  let count3 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3;\n      }\n    }\n  }\n  return count3;\n}\n\n// node_modules/d3-array/src/cross.js\nfunction length(array4) {\n  return array4.length | 0;\n}\nfunction empty(length4) {\n  return !(length4 > 0);\n}\nfunction arrayify(values2) {\n  return typeof values2 !== \"object\" || \"length\" in values2 ? values2 : Array.from(values2);\n}\nfunction reducer(reduce2) {\n  return (values2) => reduce2(...values2);\n}\nfunction cross(...values2) {\n  const reduce2 = typeof values2[values2.length - 1] === \"function\" && reducer(values2.pop());\n  values2 = values2.map(arrayify);\n  const lengths = values2.map(length);\n  const j = values2.length - 1;\n  const index3 = new Array(j + 1).fill(0);\n  const product = [];\n  if (j < 0 || lengths.some(empty))\n    return product;\n  while (true) {\n    product.push(index3.map((j2, i2) => values2[i2][j2]));\n    let i = j;\n    while (++index3[i] === lengths[i]) {\n      if (i === 0)\n        return reduce2 ? product.map(reduce2) : product;\n      index3[i--] = 0;\n    }\n  }\n}\n\n// node_modules/d3-array/src/cumsum.js\nfunction cumsum(values2, valueof2) {\n  var sum5 = 0, index3 = 0;\n  return Float64Array.from(values2, valueof2 === void 0 ? (v2) => sum5 += +v2 || 0 : (v2) => sum5 += +valueof2(v2, index3++, values2) || 0);\n}\n\n// node_modules/d3-array/src/variance.js\nfunction variance(values2, valueof2) {\n  let count3 = 0;\n  let delta;\n  let mean2 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        delta = value - mean2;\n        mean2 += delta / ++count3;\n        sum5 += delta * (value - mean2);\n      }\n    }\n  }\n  if (count3 > 1)\n    return sum5 / (count3 - 1);\n}\n\n// node_modules/d3-array/src/deviation.js\nfunction deviation(values2, valueof2) {\n  const v2 = variance(values2, valueof2);\n  return v2 ? Math.sqrt(v2) : v2;\n}\n\n// node_modules/d3-array/src/extent.js\nfunction extent(values2, valueof2) {\n  let min4;\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null) {\n        if (min4 === void 0) {\n          if (value >= value)\n            min4 = max5 = value;\n        } else {\n          if (min4 > value)\n            min4 = value;\n          if (max5 < value)\n            max5 = value;\n        }\n      }\n    }\n  }\n  return [min4, max5];\n}\n\n// node_modules/d3-array/src/fsum.js\nvar Adder = class {\n  constructor() {\n    this._partials = new Float64Array(32);\n    this._n = 0;\n  }\n  add(x4) {\n    const p = this._partials;\n    let i = 0;\n    for (let j = 0; j < this._n && j < 32; j++) {\n      const y4 = p[j], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);\n      if (lo)\n        p[i++] = lo;\n      x4 = hi;\n    }\n    p[i] = x4;\n    this._n = i + 1;\n    return this;\n  }\n  valueOf() {\n    const p = this._partials;\n    let n = this._n, x4, y4, lo, hi = 0;\n    if (n > 0) {\n      hi = p[--n];\n      while (n > 0) {\n        x4 = hi;\n        y4 = p[--n];\n        hi = x4 + y4;\n        lo = y4 - (hi - x4);\n        if (lo)\n          break;\n      }\n      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {\n        y4 = lo * 2;\n        x4 = hi + y4;\n        if (y4 == x4 - hi)\n          hi = x4;\n      }\n    }\n    return hi;\n  }\n};\nfunction fsum(values2, valueof2) {\n  const adder = new Adder();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        adder.add(value);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        adder.add(value);\n      }\n    }\n  }\n  return +adder;\n}\nfunction fcumsum(values2, valueof2) {\n  const adder = new Adder();\n  let index3 = -1;\n  return Float64Array.from(\n    values2,\n    valueof2 === void 0 ? (v2) => adder.add(+v2 || 0) : (v2) => adder.add(+valueof2(v2, ++index3, values2) || 0)\n  );\n}\n\n// node_modules/internmap/src/index.js\nvar InternMap = class extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (entries != null)\n      for (const [key2, value] of entries)\n        this.set(key2, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n};\nvar InternSet = class extends Set {\n  constructor(values2, key = keyof) {\n    super();\n    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });\n    if (values2 != null)\n      for (const value of values2)\n        this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n};\nfunction intern_get({ _intern, _key }, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\nfunction intern_set({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key))\n    return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\nfunction intern_delete({ _intern, _key }, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/identity.js\nfunction identity(x4) {\n  return x4;\n}\n\n// node_modules/d3-array/src/group.js\nfunction group(values2, ...keys) {\n  return nest(values2, identity, identity, keys);\n}\nfunction groups(values2, ...keys) {\n  return nest(values2, Array.from, identity, keys);\n}\nfunction flatten(groups2, keys) {\n  for (let i = 1, n = keys.length; i < n; ++i) {\n    groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));\n  }\n  return groups2;\n}\nfunction flatGroup(values2, ...keys) {\n  return flatten(groups(values2, ...keys), keys);\n}\nfunction flatRollup(values2, reduce2, ...keys) {\n  return flatten(rollups(values2, reduce2, ...keys), keys);\n}\nfunction rollup(values2, reduce2, ...keys) {\n  return nest(values2, identity, reduce2, keys);\n}\nfunction rollups(values2, reduce2, ...keys) {\n  return nest(values2, Array.from, reduce2, keys);\n}\nfunction index(values2, ...keys) {\n  return nest(values2, identity, unique, keys);\n}\nfunction indexes(values2, ...keys) {\n  return nest(values2, Array.from, unique, keys);\n}\nfunction unique(values2) {\n  if (values2.length !== 1)\n    throw new Error(\"duplicate key\");\n  return values2[0];\n}\nfunction nest(values2, map6, reduce2, keys) {\n  return function regroup(values3, i) {\n    if (i >= keys.length)\n      return reduce2(values3);\n    const groups2 = new InternMap();\n    const keyof3 = keys[i++];\n    let index3 = -1;\n    for (const value of values3) {\n      const key = keyof3(value, ++index3, values3);\n      const group3 = groups2.get(key);\n      if (group3)\n        group3.push(value);\n      else\n        groups2.set(key, [value]);\n    }\n    for (const [key, values4] of groups2) {\n      groups2.set(key, regroup(values4, i));\n    }\n    return map6(groups2);\n  }(values2, 0);\n}\n\n// node_modules/d3-array/src/permute.js\nfunction permute(source, keys) {\n  return Array.from(keys, (key) => source[key]);\n}\n\n// node_modules/d3-array/src/sort.js\nfunction sort(values2, ...F) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  values2 = Array.from(values2);\n  let [f] = F;\n  if (f && f.length !== 2 || F.length > 1) {\n    const index3 = Uint32Array.from(values2, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map((f2) => values2.map(f2));\n      index3.sort((i, j) => {\n        for (const f2 of F) {\n          const c6 = ascendingDefined(f2[i], f2[j]);\n          if (c6)\n            return c6;\n        }\n      });\n    } else {\n      f = values2.map(f);\n      index3.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values2, index3);\n  }\n  return values2.sort(compareDefined(f));\n}\nfunction compareDefined(compare = ascending) {\n  if (compare === ascending)\n    return ascendingDefined;\n  if (typeof compare !== \"function\")\n    throw new TypeError(\"compare is not a function\");\n  return (a4, b) => {\n    const x4 = compare(a4, b);\n    if (x4 || x4 === 0)\n      return x4;\n    return (compare(b, b) === 0) - (compare(a4, a4) === 0);\n  };\n}\nfunction ascendingDefined(a4, b) {\n  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);\n}\n\n// node_modules/d3-array/src/groupSort.js\nfunction groupSort(values2, reduce2, key) {\n  return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);\n}\n\n// node_modules/d3-array/src/array.js\nvar array = Array.prototype;\nvar slice = array.slice;\nvar map = array.map;\n\n// node_modules/d3-array/src/constant.js\nfunction constant(x4) {\n  return () => x4;\n}\n\n// node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\nfunction tickSpec(start2, stop, count3) {\n  const step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;\n  let i1, i2, inc2;\n  if (power < 0) {\n    inc2 = Math.pow(10, -power) / factor;\n    i1 = Math.round(start2 * inc2);\n    i2 = Math.round(stop * inc2);\n    if (i1 / inc2 < start2)\n      ++i1;\n    if (i2 / inc2 > stop)\n      --i2;\n    inc2 = -inc2;\n  } else {\n    inc2 = Math.pow(10, power) * factor;\n    i1 = Math.round(start2 / inc2);\n    i2 = Math.round(stop / inc2);\n    if (i1 * inc2 < start2)\n      ++i1;\n    if (i2 * inc2 > stop)\n      --i2;\n  }\n  if (i2 < i1 && 0.5 <= count3 && count3 < 2)\n    return tickSpec(start2, stop, count3 * 2);\n  return [i1, i2, inc2];\n}\nfunction ticks(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  if (!(count3 > 0))\n    return [];\n  if (start2 === stop)\n    return [start2];\n  const reverse3 = stop < start2, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);\n  if (!(i2 >= i1))\n    return [];\n  const n = i2 - i1 + 1, ticks2 = new Array(n);\n  if (reverse3) {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i2 - i) * inc2;\n  } else {\n    if (inc2 < 0)\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) / -inc2;\n    else\n      for (let i = 0; i < n; ++i)\n        ticks2[i] = (i1 + i) * inc2;\n  }\n  return ticks2;\n}\nfunction tickIncrement(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  return tickSpec(start2, stop, count3)[2];\n}\nfunction tickStep(start2, stop, count3) {\n  stop = +stop, start2 = +start2, count3 = +count3;\n  const reverse3 = stop < start2, inc2 = reverse3 ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);\n  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);\n}\n\n// node_modules/d3-array/src/nice.js\nfunction nice(start2, stop, count3) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start2, stop, count3);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start2, stop];\n    } else if (step > 0) {\n      start2 = Math.floor(start2 / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start2 = Math.ceil(start2 * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n\n// node_modules/d3-array/src/threshold/sturges.js\nfunction thresholdSturges(values2) {\n  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);\n}\n\n// node_modules/d3-array/src/bin.js\nfunction bin() {\n  var value = identity, domain = extent, threshold2 = thresholdSturges;\n  function histogram(data) {\n    if (!Array.isArray(data))\n      data = Array.from(data);\n    var i, n = data.length, x4, step, values2 = new Array(n);\n    for (i = 0; i < n; ++i) {\n      values2[i] = value(data[i], i, data);\n    }\n    var xz = domain(values2), x06 = xz[0], x12 = xz[1], tz = threshold2(values2, x06, x12);\n    if (!Array.isArray(tz)) {\n      const max5 = x12, tn = +tz;\n      if (domain === extent)\n        [x06, x12] = nice(x06, x12, tn);\n      tz = ticks(x06, x12, tn);\n      if (tz[0] <= x06)\n        step = tickIncrement(x06, x12, tn);\n      if (tz[tz.length - 1] >= x12) {\n        if (max5 >= x12 && domain === extent) {\n          const step2 = tickIncrement(x06, x12, tn);\n          if (isFinite(step2)) {\n            if (step2 > 0) {\n              x12 = (Math.floor(x12 / step2) + 1) * step2;\n            } else if (step2 < 0) {\n              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n    var m3 = tz.length, a4 = 0, b = m3;\n    while (tz[a4] <= x06)\n      ++a4;\n    while (tz[b - 1] > x12)\n      --b;\n    if (a4 || b < m3)\n      tz = tz.slice(a4, b), m3 = b - a4;\n    var bins = new Array(m3 + 1), bin3;\n    for (i = 0; i <= m3; ++i) {\n      bin3 = bins[i] = [];\n      bin3.x0 = i > 0 ? tz[i - 1] : x06;\n      bin3.x1 = i < m3 ? tz[i] : x12;\n    }\n    if (isFinite(step)) {\n      if (step > 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            bins[Math.min(m3, Math.floor((x4 - x06) / step))].push(data[i]);\n          }\n        }\n      } else if (step < 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n            const j = Math.floor((x06 - x4) * step);\n            bins[Math.min(m3, j + (tz[j] <= x4))].push(data[i]);\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        if ((x4 = values2[i]) != null && x06 <= x4 && x4 <= x12) {\n          bins[bisect_default(tz, x4, 0, m3)].push(data[i]);\n        }\n      }\n    }\n    return bins;\n  }\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;\n  };\n  return histogram;\n}\n\n// node_modules/d3-array/src/max.js\nfunction max(values2, valueof2) {\n  let max5;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/maxIndex.js\nfunction maxIndex(values2, valueof2) {\n  let max5;\n  let maxIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (max5 < value || max5 === void 0 && value >= value)) {\n        max5 = value, maxIndex2 = index3;\n      }\n    }\n  }\n  return maxIndex2;\n}\n\n// node_modules/d3-array/src/min.js\nfunction min(values2, valueof2) {\n  let min4;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/minIndex.js\nfunction minIndex(values2, valueof2) {\n  let min4;\n  let minIndex2 = -1;\n  let index3 = -1;\n  if (valueof2 === void 0) {\n    for (const value of values2) {\n      ++index3;\n      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  } else {\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {\n        min4 = value, minIndex2 = index3;\n      }\n    }\n  }\n  return minIndex2;\n}\n\n// node_modules/d3-array/src/quickselect.js\nfunction quickselect(array4, k2, left2 = 0, right2 = Infinity, compare) {\n  k2 = Math.floor(k2);\n  left2 = Math.floor(Math.max(0, left2));\n  right2 = Math.floor(Math.min(array4.length - 1, right2));\n  if (!(left2 <= k2 && k2 <= right2))\n    return array4;\n  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);\n  while (right2 > left2) {\n    if (right2 - left2 > 600) {\n      const n = right2 - left2 + 1;\n      const m3 = k2 - left2 + 1;\n      const z = Math.log(n);\n      const s2 = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s2 / n + sd));\n      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s2 / n + sd));\n      quickselect(array4, k2, newLeft, newRight, compare);\n    }\n    const t = array4[k2];\n    let i = left2;\n    let j = right2;\n    swap(array4, left2, k2);\n    if (compare(array4[right2], t) > 0)\n      swap(array4, left2, right2);\n    while (i < j) {\n      swap(array4, i, j), ++i, --j;\n      while (compare(array4[i], t) < 0)\n        ++i;\n      while (compare(array4[j], t) > 0)\n        --j;\n    }\n    if (compare(array4[left2], t) === 0)\n      swap(array4, left2, j);\n    else\n      ++j, swap(array4, j, right2);\n    if (j <= k2)\n      left2 = j + 1;\n    if (k2 <= j)\n      right2 = j - 1;\n  }\n  return array4;\n}\nfunction swap(array4, i, j) {\n  const t = array4[i];\n  array4[i] = array4[j];\n  array4[j] = t;\n}\n\n// node_modules/d3-array/src/greatest.js\nfunction greatest(values2, compare = ascending) {\n  let max5;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let maxValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {\n        max5 = element;\n        maxValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, max5) > 0 : compare(value, value) === 0) {\n        max5 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/quantile.js\nfunction quantile(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return min(values2);\n  if (p >= 1)\n    return max(values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileSorted(values2, p, valueof2 = number) {\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return +valueof2(values2[0], 0, values2);\n  if (p >= 1)\n    return +valueof2(values2[n - 1], n - 1, values2);\n  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileIndex(values2, p, valueof2) {\n  values2 = Float64Array.from(numbers(values2, valueof2));\n  if (!(n = values2.length) || isNaN(p = +p))\n    return;\n  if (p <= 0 || n < 2)\n    return minIndex(values2);\n  if (p >= 1)\n    return maxIndex(values2);\n  var n, i = Math.floor((n - 1) * p), order = (i2, j) => ascendingDefined(values2[i2], values2[j]), index3 = quickselect(Uint32Array.from(values2, (_, i2) => i2), i, 0, n - 1, order);\n  return greatest(index3.subarray(0, i + 1), (i2) => values2[i2]);\n}\n\n// node_modules/d3-array/src/threshold/freedmanDiaconis.js\nfunction thresholdFreedmanDiaconis(values2, min4, max5) {\n  const c6 = count(values2), d = quantile(values2, 0.75) - quantile(values2, 0.25);\n  return c6 && d ? Math.ceil((max5 - min4) / (2 * d * Math.pow(c6, -1 / 3))) : 1;\n}\n\n// node_modules/d3-array/src/threshold/scott.js\nfunction thresholdScott(values2, min4, max5) {\n  const c6 = count(values2), d = deviation(values2);\n  return c6 && d ? Math.ceil((max5 - min4) * Math.cbrt(c6) / (3.49 * d)) : 1;\n}\n\n// node_modules/d3-array/src/mean.js\nfunction mean(values2, valueof2) {\n  let count3 = 0;\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && (value = +value) >= value) {\n        ++count3, sum5 += value;\n      }\n    }\n  }\n  if (count3)\n    return sum5 / count3;\n}\n\n// node_modules/d3-array/src/median.js\nfunction median(values2, valueof2) {\n  return quantile(values2, 0.5, valueof2);\n}\nfunction medianIndex(values2, valueof2) {\n  return quantileIndex(values2, 0.5, valueof2);\n}\n\n// node_modules/d3-array/src/merge.js\nfunction* flatten2(arrays) {\n  for (const array4 of arrays) {\n    yield* array4;\n  }\n}\nfunction merge(arrays) {\n  return Array.from(flatten2(arrays));\n}\n\n// node_modules/d3-array/src/mode.js\nfunction mode(values2, valueof2) {\n  const counts = new InternMap();\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if ((value = valueof2(value, ++index3, values2)) != null && value >= value) {\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    }\n  }\n  let modeValue;\n  let modeCount = 0;\n  for (const [value, count3] of counts) {\n    if (count3 > modeCount) {\n      modeCount = count3;\n      modeValue = value;\n    }\n  }\n  return modeValue;\n}\n\n// node_modules/d3-array/src/pairs.js\nfunction pairs(values2, pairof = pair) {\n  const pairs2 = [];\n  let previous;\n  let first2 = false;\n  for (const value of values2) {\n    if (first2)\n      pairs2.push(pairof(previous, value));\n    previous = value;\n    first2 = true;\n  }\n  return pairs2;\n}\nfunction pair(a4, b) {\n  return [a4, b];\n}\n\n// node_modules/d3-array/src/range.js\nfunction range(start2, stop, step) {\n  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;\n  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range5 = new Array(n);\n  while (++i < n) {\n    range5[i] = start2 + i * step;\n  }\n  return range5;\n}\n\n// node_modules/d3-array/src/rank.js\nfunction rank(values2, valueof2 = ascending) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  let V = Array.from(values2);\n  const R = new Float64Array(V.length);\n  if (valueof2.length !== 2)\n    V = V.map(valueof2), valueof2 = ascending;\n  const compareIndex = (i, j) => valueof2(V[i], V[j]);\n  let k2, r;\n  values2 = Uint32Array.from(V, (_, i) => i);\n  values2.sort(valueof2 === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));\n  values2.forEach((j, i) => {\n    const c6 = compareIndex(j, k2 === void 0 ? j : k2);\n    if (c6 >= 0) {\n      if (k2 === void 0 || c6 > 0)\n        k2 = j, r = i;\n      R[j] = r;\n    } else {\n      R[j] = NaN;\n    }\n  });\n  return R;\n}\n\n// node_modules/d3-array/src/least.js\nfunction least(values2, compare = ascending) {\n  let min4;\n  let defined2 = false;\n  if (compare.length === 1) {\n    let minValue;\n    for (const element of values2) {\n      const value = compare(element);\n      if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {\n        min4 = element;\n        minValue = value;\n        defined2 = true;\n      }\n    }\n  } else {\n    for (const value of values2) {\n      if (defined2 ? compare(value, min4) < 0 : compare(value, value) === 0) {\n        min4 = value;\n        defined2 = true;\n      }\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/leastIndex.js\nfunction leastIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return minIndex(values2, compare);\n  let minValue;\n  let min4 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (min4 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n      minValue = value;\n      min4 = index3;\n    }\n  }\n  return min4;\n}\n\n// node_modules/d3-array/src/greatestIndex.js\nfunction greatestIndex(values2, compare = ascending) {\n  if (compare.length === 1)\n    return maxIndex(values2, compare);\n  let maxValue;\n  let max5 = -1;\n  let index3 = -1;\n  for (const value of values2) {\n    ++index3;\n    if (max5 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {\n      maxValue = value;\n      max5 = index3;\n    }\n  }\n  return max5;\n}\n\n// node_modules/d3-array/src/scan.js\nfunction scan(values2, compare) {\n  const index3 = leastIndex(values2, compare);\n  return index3 < 0 ? void 0 : index3;\n}\n\n// node_modules/d3-array/src/shuffle.js\nvar shuffle_default = shuffler(Math.random);\nfunction shuffler(random) {\n  return function shuffle3(array4, i0 = 0, i1 = array4.length) {\n    let m3 = i1 - (i0 = +i0);\n    while (m3) {\n      const i = random() * m3-- | 0, t = array4[m3 + i0];\n      array4[m3 + i0] = array4[i + i0];\n      array4[i + i0] = t;\n    }\n    return array4;\n  };\n}\n\n// node_modules/d3-array/src/sum.js\nfunction sum(values2, valueof2) {\n  let sum5 = 0;\n  if (valueof2 === void 0) {\n    for (let value of values2) {\n      if (value = +value) {\n        sum5 += value;\n      }\n    }\n  } else {\n    let index3 = -1;\n    for (let value of values2) {\n      if (value = +valueof2(value, ++index3, values2)) {\n        sum5 += value;\n      }\n    }\n  }\n  return sum5;\n}\n\n// node_modules/d3-array/src/transpose.js\nfunction transpose(matrix) {\n  if (!(n = matrix.length))\n    return [];\n  for (var i = -1, m3 = min(matrix, length2), transpose2 = new Array(m3); ++i < m3; ) {\n    for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose2;\n}\nfunction length2(d) {\n  return d.length;\n}\n\n// node_modules/d3-array/src/zip.js\nfunction zip() {\n  return transpose(arguments);\n}\n\n// node_modules/d3-array/src/every.js\nfunction every(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (!test(value, ++index3, values2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/some.js\nfunction some(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// node_modules/d3-array/src/filter.js\nfunction filter(values2, test) {\n  if (typeof test !== \"function\")\n    throw new TypeError(\"test is not a function\");\n  const array4 = [];\n  let index3 = -1;\n  for (const value of values2) {\n    if (test(value, ++index3, values2)) {\n      array4.push(value);\n    }\n  }\n  return array4;\n}\n\n// node_modules/d3-array/src/map.js\nfunction map2(values2, mapper) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  if (typeof mapper !== \"function\")\n    throw new TypeError(\"mapper is not a function\");\n  return Array.from(values2, (value, index3) => mapper(value, index3, values2));\n}\n\n// node_modules/d3-array/src/reduce.js\nfunction reduce(values2, reducer2, value) {\n  if (typeof reducer2 !== \"function\")\n    throw new TypeError(\"reducer is not a function\");\n  const iterator = values2[Symbol.iterator]();\n  let done, next, index3 = -1;\n  if (arguments.length < 3) {\n    ({ done, value } = iterator.next());\n    if (done)\n      return;\n    ++index3;\n  }\n  while ({ done, value: next } = iterator.next(), !done) {\n    value = reducer2(value, next, ++index3, values2);\n  }\n  return value;\n}\n\n// node_modules/d3-array/src/reverse.js\nfunction reverse(values2) {\n  if (typeof values2[Symbol.iterator] !== \"function\")\n    throw new TypeError(\"values is not iterable\");\n  return Array.from(values2).reverse();\n}\n\n// node_modules/d3-array/src/difference.js\nfunction difference(values2, ...others) {\n  values2 = new InternSet(values2);\n  for (const other of others) {\n    for (const value of other) {\n      values2.delete(value);\n    }\n  }\n  return values2;\n}\n\n// node_modules/d3-array/src/disjoint.js\nfunction disjoint(values2, other) {\n  const iterator = other[Symbol.iterator](), set4 = new InternSet();\n  for (const v2 of values2) {\n    if (set4.has(v2))\n      return false;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        break;\n      if (Object.is(v2, value))\n        return false;\n      set4.add(value);\n    }\n  }\n  return true;\n}\n\n// node_modules/d3-array/src/intersection.js\nfunction intersection(values2, ...others) {\n  values2 = new InternSet(values2);\n  others = others.map(set);\n  out:\n    for (const value of values2) {\n      for (const other of others) {\n        if (!other.has(value)) {\n          values2.delete(value);\n          continue out;\n        }\n      }\n    }\n  return values2;\n}\nfunction set(values2) {\n  return values2 instanceof InternSet ? values2 : new InternSet(values2);\n}\n\n// node_modules/d3-array/src/superset.js\nfunction superset(values2, other) {\n  const iterator = values2[Symbol.iterator](), set4 = /* @__PURE__ */ new Set();\n  for (const o of other) {\n    const io = intern(o);\n    if (set4.has(io))\n      continue;\n    let value, done;\n    while ({ value, done } = iterator.next()) {\n      if (done)\n        return false;\n      const ivalue = intern(value);\n      set4.add(ivalue);\n      if (Object.is(io, ivalue))\n        break;\n    }\n  }\n  return true;\n}\nfunction intern(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\n// node_modules/d3-array/src/subset.js\nfunction subset(values2, other) {\n  return superset(other, values2);\n}\n\n// node_modules/d3-array/src/union.js\nfunction union(...others) {\n  const set4 = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set4.add(o);\n    }\n  }\n  return set4;\n}\n\n// node_modules/d3-axis/src/identity.js\nfunction identity_default(x4) {\n  return x4;\n}\n\n// node_modules/d3-axis/src/axis.js\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon = 1e-6;\nfunction translateX(x4) {\n  return \"translate(\" + x4 + \",0)\";\n}\nfunction translateY(y4) {\n  return \"translate(0,\" + y4 + \")\";\n}\nfunction number2(scale3) {\n  return (d) => +scale3(d);\n}\nfunction center(scale3, offset2) {\n  offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;\n  if (scale3.round())\n    offset2 = Math.round(offset2);\n  return (d) => +scale3(d) + offset2;\n}\nfunction entering() {\n  return !this.__axis;\n}\nfunction axis(orient, scale3) {\n  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x4 = orient === left || orient === right ? \"x\" : \"y\", transform2 = orient === top || orient === bottom ? translateX : translateY;\n  function axis2(context) {\n    var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues, format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range5 = scale3.range(), range0 = +range5[0] + offset2, range1 = +range5[range5.length - 1] + offset2, position2 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(\".domain\").data([null]), tick = selection2.selectAll(\".tick\").data(values2, scale3).order(), tickExit = tick.exit(), tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"), line2 = tick.select(\"line\"), text2 = tick.select(\"text\");\n    path2 = path2.merge(path2.enter().insert(\"path\", \".tick\").attr(\"class\", \"domain\").attr(\"stroke\", \"currentColor\"));\n    tick = tick.merge(tickEnter);\n    line2 = line2.merge(tickEnter.append(\"line\").attr(\"stroke\", \"currentColor\").attr(x4 + \"2\", k2 * tickSizeInner));\n    text2 = text2.merge(tickEnter.append(\"text\").attr(\"fill\", \"currentColor\").attr(x4, k2 * spacing).attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n    if (context !== selection2) {\n      path2 = path2.transition(context);\n      tick = tick.transition(context);\n      line2 = line2.transition(context);\n      text2 = text2.transition(context);\n      tickExit = tickExit.transition(context).attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute(\"transform\");\n      });\n      tickEnter.attr(\"opacity\", epsilon).attr(\"transform\", function(d) {\n        var p = this.parentNode.__axis;\n        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);\n      });\n    }\n    tickExit.remove();\n    path2.attr(\"d\", orient === left || orient === right ? tickSizeOuter ? \"M\" + k2 * tickSizeOuter + \",\" + range0 + \"H\" + offset2 + \"V\" + range1 + \"H\" + k2 * tickSizeOuter : \"M\" + offset2 + \",\" + range0 + \"V\" + range1 : tickSizeOuter ? \"M\" + range0 + \",\" + k2 * tickSizeOuter + \"V\" + offset2 + \"H\" + range1 + \"V\" + k2 * tickSizeOuter : \"M\" + range0 + \",\" + offset2 + \"H\" + range1);\n    tick.attr(\"opacity\", 1).attr(\"transform\", function(d) {\n      return transform2(position2(d) + offset2);\n    });\n    line2.attr(x4 + \"2\", k2 * tickSizeInner);\n    text2.attr(x4, k2 * spacing).text(format3);\n    selection2.filter(entering).attr(\"fill\", \"none\").attr(\"font-size\", 10).attr(\"font-family\", \"sans-serif\").attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n    selection2.each(function() {\n      this.__axis = position2;\n    });\n  }\n  axis2.scale = function(_) {\n    return arguments.length ? (scale3 = _, axis2) : scale3;\n  };\n  axis2.ticks = function() {\n    return tickArguments = Array.from(arguments), axis2;\n  };\n  axis2.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();\n  };\n  axis2.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();\n  };\n  axis2.tickFormat = function(_) {\n    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;\n  };\n  axis2.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;\n  };\n  axis2.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;\n  };\n  axis2.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;\n  };\n  axis2.offset = function(_) {\n    return arguments.length ? (offset2 = +_, axis2) : offset2;\n  };\n  return axis2;\n}\nfunction axisTop(scale3) {\n  return axis(top, scale3);\n}\nfunction axisRight(scale3) {\n  return axis(right, scale3);\n}\nfunction axisBottom(scale3) {\n  return axis(bottom, scale3);\n}\nfunction axisLeft(scale3) {\n  return axis(left, scale3);\n}\n\n// node_modules/d3-dispatch/src/dispatch.js\nvar noop = { value: () => {\n} };\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || t in _ || /[\\s.]/.test(t))\n      throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\nfunction Dispatch(_) {\n  this._ = _;\n}\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t))\n      throw new Error(\"unknown type: \" + t);\n    return { type: t, name };\n  });\n}\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._, T = parseTypenames(typename + \"\", _), t, i = -1, n = T.length;\n    if (arguments.length < 2) {\n      while (++i < n)\n        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))\n          return t;\n      return;\n    }\n    if (callback != null && typeof callback !== \"function\")\n      throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type)\n        _[t] = set2(_[t], typename.name, callback);\n      else if (callback == null)\n        for (t in _)\n          _[t] = set2(_[t], typename.name, null);\n    }\n    return this;\n  },\n  copy: function() {\n    var copy3 = {}, _ = this._;\n    for (var t in _)\n      copy3[t] = _[t].slice();\n    return new Dispatch(copy3);\n  },\n  call: function(type2, that) {\n    if ((n = arguments.length - 2) > 0)\n      for (var args = new Array(n), i = 0, n, t; i < n; ++i)\n        args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  },\n  apply: function(type2, that, args) {\n    if (!this._.hasOwnProperty(type2))\n      throw new Error(\"unknown type: \" + type2);\n    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)\n      t[i].value.apply(that, args);\n  }\n};\nfunction get(type2, name) {\n  for (var i = 0, n = type2.length, c6; i < n; ++i) {\n    if ((c6 = type2[i]).name === name) {\n      return c6.value;\n    }\n  }\n}\nfunction set2(type2, name, callback) {\n  for (var i = 0, n = type2.length; i < n; ++i) {\n    if (type2[i].name === name) {\n      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null)\n    type2.push({ name, value: callback });\n  return type2;\n}\nvar dispatch_default = dispatch;\n\n// node_modules/d3-selection/src/namespaces.js\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\nvar namespaces_default = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\n// node_modules/d3-selection/src/namespace.js\nfunction namespace_default(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\")\n    name = name.slice(i + 1);\n  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;\n}\n\n// node_modules/d3-selection/src/creator.js\nfunction creatorInherit(name) {\n  return function() {\n    var document2 = this.ownerDocument, uri = this.namespaceURI;\n    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);\n  };\n}\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\nfunction creator_default(name) {\n  var fullname = namespace_default(name);\n  return (fullname.local ? creatorFixed : creatorInherit)(fullname);\n}\n\n// node_modules/d3-selection/src/selector.js\nfunction none() {\n}\nfunction selector_default(selector) {\n  return selector == null ? none : function() {\n    return this.querySelector(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/select.js\nfunction select_default(select2) {\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/array.js\nfunction array2(x4) {\n  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-selection/src/selectorAll.js\nfunction empty2() {\n  return [];\n}\nfunction selectorAll_default(selector) {\n  return selector == null ? empty2 : function() {\n    return this.querySelectorAll(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectAll.js\nfunction arrayAll(select2) {\n  return function() {\n    return array2(select2.apply(this, arguments));\n  };\n}\nfunction selectAll_default(select2) {\n  if (typeof select2 === \"function\")\n    select2 = arrayAll(select2);\n  else\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        subgroups.push(select2.call(node, node.__data__, i, group3));\n        parents.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, parents);\n}\n\n// node_modules/d3-selection/src/matcher.js\nfunction matcher_default(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n}\nfunction childMatcher(selector) {\n  return function(node) {\n    return node.matches(selector);\n  };\n}\n\n// node_modules/d3-selection/src/selection/selectChild.js\nvar find = Array.prototype.find;\nfunction childFind(match) {\n  return function() {\n    return find.call(this.children, match);\n  };\n}\nfunction childFirst() {\n  return this.firstElementChild;\n}\nfunction selectChild_default(match) {\n  return this.select(match == null ? childFirst : childFind(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/selectChildren.js\nvar filter2 = Array.prototype.filter;\nfunction children() {\n  return Array.from(this.children);\n}\nfunction childrenFilter(match) {\n  return function() {\n    return filter2.call(this.children, match);\n  };\n}\nfunction selectChildren_default(match) {\n  return this.selectAll(match == null ? children : childrenFilter(typeof match === \"function\" ? match : childMatcher(match)));\n}\n\n// node_modules/d3-selection/src/selection/filter.js\nfunction filter_default(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Selection(subgroups, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/sparse.js\nfunction sparse_default(update) {\n  return new Array(update.length);\n}\n\n// node_modules/d3-selection/src/selection/enter.js\nfunction enter_default() {\n  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);\n}\nfunction EnterNode(parent, datum2) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum2;\n}\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) {\n    return this._parent.insertBefore(child, this._next);\n  },\n  insertBefore: function(child, next) {\n    return this._parent.insertBefore(child, next);\n  },\n  querySelector: function(selector) {\n    return this._parent.querySelector(selector);\n  },\n  querySelectorAll: function(selector) {\n    return this._parent.querySelectorAll(selector);\n  }\n};\n\n// node_modules/d3-selection/src/constant.js\nfunction constant_default(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-selection/src/selection/data.js\nfunction bindIndex(parent, group3, enter, update, exit, data) {\n  var i = 0, node, groupLength = group3.length, dataLength = data.length;\n  for (; i < dataLength; ++i) {\n    if (node = group3[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      exit[i] = node;\n    }\n  }\n}\nfunction bindKey(parent, group3, enter, update, exit, data, key) {\n  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group3[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\nfunction datum(node) {\n  return node.__data__;\n}\nfunction data_default(value, key) {\n  if (!arguments.length)\n    return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;\n  if (typeof value !== \"function\")\n    value = constant_default(value);\n  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j = 0; j < m3; ++j) {\n    var parent = parents[j], group3 = groups2[j], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1)\n          i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength)\n          ;\n        previous._next = next || null;\n      }\n    }\n  }\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data ? data : Array.from(data);\n}\n\n// node_modules/d3-selection/src/selection/exit.js\nfunction exit_default() {\n  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);\n}\n\n// node_modules/d3-selection/src/selection/join.js\nfunction join_default(onenter, onupdate, onexit) {\n  var enter = this.enter(), update = this, exit = this.exit();\n  if (typeof onenter === \"function\") {\n    enter = onenter(enter);\n    if (enter)\n      enter = enter.selection();\n  } else {\n    enter = enter.append(onenter + \"\");\n  }\n  if (onupdate != null) {\n    update = onupdate(update);\n    if (update)\n      update = update.selection();\n  }\n  if (onexit == null)\n    exit.remove();\n  else\n    onexit(exit);\n  return enter && update ? enter.merge(update).order() : update;\n}\n\n// node_modules/d3-selection/src/selection/merge.js\nfunction merge_default(context) {\n  var selection2 = context.selection ? context.selection() : context;\n  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Selection(merges, this._parents);\n}\n\n// node_modules/d3-selection/src/selection/order.js\nfunction order_default() {\n  for (var groups2 = this._groups, j = -1, m3 = groups2.length; ++j < m3; ) {\n    for (var group3 = groups2[j], i = group3.length - 1, next = group3[i], node; --i >= 0; ) {\n      if (node = group3[i]) {\n        if (next && node.compareDocumentPosition(next) ^ 4)\n          next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/sort.js\nfunction sort_default(compare) {\n  if (!compare)\n    compare = ascending2;\n  function compareNode(a4, b) {\n    return a4 && b ? compare(a4.__data__, b.__data__) : !a4 - !b;\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n  return new Selection(sortgroups, this._parents).order();\n}\nfunction ascending2(a4, b) {\n  return a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;\n}\n\n// node_modules/d3-selection/src/selection/call.js\nfunction call_default() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/nodes.js\nfunction nodes_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-selection/src/selection/node.js\nfunction node_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length; i < n; ++i) {\n      var node = group3[i];\n      if (node)\n        return node;\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-selection/src/selection/size.js\nfunction size_default() {\n  let size = 0;\n  for (const node of this)\n    ++size;\n  return size;\n}\n\n// node_modules/d3-selection/src/selection/empty.js\nfunction empty_default() {\n  return !this.node();\n}\n\n// node_modules/d3-selection/src/selection/each.js\nfunction each_default(callback) {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        callback.call(node, node.__data__, i, group3);\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/attr.js\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\nfunction attrFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttribute(name);\n    else\n      this.setAttribute(name, v2);\n  };\n}\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.removeAttributeNS(fullname.space, fullname.local);\n    else\n      this.setAttributeNS(fullname.space, fullname.local, v2);\n  };\n}\nfunction attr_default(name, value) {\n  var fullname = namespace_default(name);\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);\n  }\n  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === \"function\" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));\n}\n\n// node_modules/d3-selection/src/window.js\nfunction window_default(node) {\n  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;\n}\n\n// node_modules/d3-selection/src/selection/style.js\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      this.style.removeProperty(name);\n    else\n      this.style.setProperty(name, v2, priority);\n  };\n}\nfunction style_default(name, value, priority) {\n  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === \"function\" ? styleFunction : styleConstant)(name, value, priority == null ? \"\" : priority)) : styleValue(this.node(), name);\n}\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\n// node_modules/d3-selection/src/selection/property.js\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\nfunction propertyFunction(name, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (v2 == null)\n      delete this[name];\n    else\n      this[name] = v2;\n  };\n}\nfunction property_default(name, value) {\n  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === \"function\" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];\n}\n\n// node_modules/d3-selection/src/selection/classed.js\nfunction classArray(string2) {\n  return string2.trim().split(/^|\\s+/);\n}\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.add(names[i]);\n}\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n)\n    list.remove(names[i]);\n}\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\nfunction classed_default(name, value) {\n  var names = classArray(name + \"\");\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n)\n      if (!list.contains(names[i]))\n        return false;\n    return true;\n  }\n  return this.each((typeof value === \"function\" ? classedFunction : value ? classedTrue : classedFalse)(names, value));\n}\n\n// node_modules/d3-selection/src/selection/text.js\nfunction textRemove() {\n  this.textContent = \"\";\n}\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.textContent = v2 == null ? \"\" : v2;\n  };\n}\nfunction text_default(value) {\n  return arguments.length ? this.each(value == null ? textRemove : (typeof value === \"function\" ? textFunction : textConstant)(value)) : this.node().textContent;\n}\n\n// node_modules/d3-selection/src/selection/html.js\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\nfunction htmlFunction(value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    this.innerHTML = v2 == null ? \"\" : v2;\n  };\n}\nfunction html_default(value) {\n  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === \"function\" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;\n}\n\n// node_modules/d3-selection/src/selection/raise.js\nfunction raise() {\n  if (this.nextSibling)\n    this.parentNode.appendChild(this);\n}\nfunction raise_default() {\n  return this.each(raise);\n}\n\n// node_modules/d3-selection/src/selection/lower.js\nfunction lower() {\n  if (this.previousSibling)\n    this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\nfunction lower_default() {\n  return this.each(lower);\n}\n\n// node_modules/d3-selection/src/selection/append.js\nfunction append_default(name) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name);\n  return this.select(function() {\n    return this.appendChild(create3.apply(this, arguments));\n  });\n}\n\n// node_modules/d3-selection/src/selection/insert.js\nfunction constantNull() {\n  return null;\n}\nfunction insert_default(name, before) {\n  var create3 = typeof name === \"function\" ? name : creator_default(name), select2 = before == null ? constantNull : typeof before === \"function\" ? before : selector_default(before);\n  return this.select(function() {\n    return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);\n  });\n}\n\n// node_modules/d3-selection/src/selection/remove.js\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent)\n    parent.removeChild(this);\n}\nfunction remove_default() {\n  return this.each(remove);\n}\n\n// node_modules/d3-selection/src/selection/clone.js\nfunction selection_cloneShallow() {\n  var clone = this.cloneNode(false), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction selection_cloneDeep() {\n  var clone = this.cloneNode(true), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction clone_default(deep) {\n  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);\n}\n\n// node_modules/d3-selection/src/selection/datum.js\nfunction datum_default(value) {\n  return arguments.length ? this.property(\"__data__\", value) : this.node().__data__;\n}\n\n// node_modules/d3-selection/src/selection/on.js\nfunction contextListener(listener) {\n  return function(event) {\n    listener.call(this, event, this.__data__);\n  };\n}\nfunction parseTypenames2(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0)\n      name = t.slice(i + 1), t = t.slice(0, i);\n    return { type: t, name };\n  });\n}\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on)\n      return;\n    for (var j = 0, i = -1, m3 = on.length, o; j < m3; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.options);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i)\n      on.length = i;\n    else\n      delete this.__on;\n  };\n}\nfunction onAdd(typename, value, options) {\n  return function() {\n    var on = this.__on, o, listener = contextListener(value);\n    if (on)\n      for (var j = 0, m3 = on.length; j < m3; ++j) {\n        if ((o = on[j]).type === typename.type && o.name === typename.name) {\n          this.removeEventListener(o.type, o.listener, o.options);\n          this.addEventListener(o.type, o.listener = listener, o.options = options);\n          o.value = value;\n          return;\n        }\n      }\n    this.addEventListener(typename.type, listener, options);\n    o = { type: typename.type, name: typename.name, value, listener, options };\n    if (!on)\n      this.__on = [o];\n    else\n      on.push(o);\n  };\n}\nfunction on_default(typename, value, options) {\n  var typenames = parseTypenames2(typename + \"\"), i, n = typenames.length, t;\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on)\n      for (var j = 0, m3 = on.length, o; j < m3; ++j) {\n        for (i = 0, o = on[j]; i < n; ++i) {\n          if ((t = typenames[i]).type === o.type && t.name === o.name) {\n            return o.value;\n          }\n        }\n      }\n    return;\n  }\n  on = value ? onAdd : onRemove;\n  for (i = 0; i < n; ++i)\n    this.each(on(typenames[i], value, options));\n  return this;\n}\n\n// node_modules/d3-selection/src/selection/dispatch.js\nfunction dispatchEvent(node, type2, params) {\n  var window3 = window_default(node), event = window3.CustomEvent;\n  if (typeof event === \"function\") {\n    event = new event(type2, params);\n  } else {\n    event = window3.document.createEvent(\"Event\");\n    if (params)\n      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;\n    else\n      event.initEvent(type2, false, false);\n  }\n  node.dispatchEvent(event);\n}\nfunction dispatchConstant(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params);\n  };\n}\nfunction dispatchFunction(type2, params) {\n  return function() {\n    return dispatchEvent(this, type2, params.apply(this, arguments));\n  };\n}\nfunction dispatch_default2(type2, params) {\n  return this.each((typeof params === \"function\" ? dispatchFunction : dispatchConstant)(type2, params));\n}\n\n// node_modules/d3-selection/src/selection/iterator.js\nfunction* iterator_default() {\n  for (var groups2 = this._groups, j = 0, m3 = groups2.length; j < m3; ++j) {\n    for (var group3 = groups2[j], i = 0, n = group3.length, node; i < n; ++i) {\n      if (node = group3[i])\n        yield node;\n    }\n  }\n}\n\n// node_modules/d3-selection/src/selection/index.js\nvar root = [null];\nfunction Selection(groups2, parents) {\n  this._groups = groups2;\n  this._parents = parents;\n}\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\nfunction selection_selection() {\n  return this;\n}\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: select_default,\n  selectAll: selectAll_default,\n  selectChild: selectChild_default,\n  selectChildren: selectChildren_default,\n  filter: filter_default,\n  data: data_default,\n  enter: enter_default,\n  exit: exit_default,\n  join: join_default,\n  merge: merge_default,\n  selection: selection_selection,\n  order: order_default,\n  sort: sort_default,\n  call: call_default,\n  nodes: nodes_default,\n  node: node_default,\n  size: size_default,\n  empty: empty_default,\n  each: each_default,\n  attr: attr_default,\n  style: style_default,\n  property: property_default,\n  classed: classed_default,\n  text: text_default,\n  html: html_default,\n  raise: raise_default,\n  lower: lower_default,\n  append: append_default,\n  insert: insert_default,\n  remove: remove_default,\n  clone: clone_default,\n  datum: datum_default,\n  on: on_default,\n  dispatch: dispatch_default2,\n  [Symbol.iterator]: iterator_default\n};\nvar selection_default = selection;\n\n// node_modules/d3-selection/src/select.js\nfunction select_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);\n}\n\n// node_modules/d3-selection/src/create.js\nfunction create_default(name) {\n  return select_default2(creator_default(name).call(document.documentElement));\n}\n\n// node_modules/d3-selection/src/local.js\nvar nextId = 0;\nfunction local() {\n  return new Local();\n}\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id2 = this._;\n    while (!(id2 in node))\n      if (!(node = node.parentNode))\n        return;\n    return node[id2];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\n// node_modules/d3-selection/src/sourceEvent.js\nfunction sourceEvent_default(event) {\n  let sourceEvent;\n  while (sourceEvent = event.sourceEvent)\n    event = sourceEvent;\n  return event;\n}\n\n// node_modules/d3-selection/src/pointer.js\nfunction pointer_default(event, node) {\n  event = sourceEvent_default(event);\n  if (node === void 0)\n    node = event.currentTarget;\n  if (node) {\n    var svg2 = node.ownerSVGElement || node;\n    if (svg2.createSVGPoint) {\n      var point6 = svg2.createSVGPoint();\n      point6.x = event.clientX, point6.y = event.clientY;\n      point6 = point6.matrixTransform(node.getScreenCTM().inverse());\n      return [point6.x, point6.y];\n    }\n    if (node.getBoundingClientRect) {\n      var rect2 = node.getBoundingClientRect();\n      return [event.clientX - rect2.left - node.clientLeft, event.clientY - rect2.top - node.clientTop];\n    }\n  }\n  return [event.pageX, event.pageY];\n}\n\n// node_modules/d3-selection/src/pointers.js\nfunction pointers_default(events, node) {\n  if (events.target) {\n    events = sourceEvent_default(events);\n    if (node === void 0)\n      node = events.currentTarget;\n    events = events.touches || [events];\n  }\n  return Array.from(events, (event) => pointer_default(event, node));\n}\n\n// node_modules/d3-selection/src/selectAll.js\nfunction selectAll_default2(selector) {\n  return typeof selector === \"string\" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array2(selector)], root);\n}\n\n// node_modules/d3-drag/src/noevent.js\nvar nonpassive = { passive: false };\nvar nonpassivecapture = { capture: true, passive: false };\nfunction nopropagation(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-drag/src/nodrag.js\nfunction nodrag_default(view) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", noevent_default, nonpassivecapture);\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", noevent_default, nonpassivecapture);\n  } else {\n    root3.__noselect = root3.style.MozUserSelect;\n    root3.style.MozUserSelect = \"none\";\n  }\n}\nfunction yesdrag(view, noclick) {\n  var root3 = view.document.documentElement, selection2 = select_default2(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection2.on(\"click.drag\", noevent_default, nonpassivecapture);\n    setTimeout(function() {\n      selection2.on(\"click.drag\", null);\n    }, 0);\n  }\n  if (\"onselectstart\" in root3) {\n    selection2.on(\"selectstart.drag\", null);\n  } else {\n    root3.style.MozUserSelect = root3.__noselect;\n    delete root3.__noselect;\n  }\n}\n\n// node_modules/d3-drag/src/constant.js\nvar constant_default2 = (x4) => () => x4;\n\n// node_modules/d3-drag/src/event.js\nfunction DragEvent(type2, {\n  sourceEvent,\n  subject,\n  target,\n  identifier,\n  active,\n  x: x4,\n  y: y4,\n  dx,\n  dy,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    subject: { value: subject, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    identifier: { value: identifier, enumerable: true, configurable: true },\n    active: { value: active, enumerable: true, configurable: true },\n    x: { value: x4, enumerable: true, configurable: true },\n    y: { value: y4, enumerable: true, configurable: true },\n    dx: { value: dx, enumerable: true, configurable: true },\n    dy: { value: dy, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// node_modules/d3-drag/src/drag.js\nfunction defaultFilter(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultContainer() {\n  return this.parentNode;\n}\nfunction defaultSubject(event, d) {\n  return d == null ? { x: event.x, y: event.y } : d;\n}\nfunction defaultTouchable() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction drag_default() {\n  var filter4 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default(\"start\", \"drag\", \"end\"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;\n  function drag(selection2) {\n    selection2.on(\"mousedown.drag\", mousedowned).filter(touchable).on(\"touchstart.drag\", touchstarted).on(\"touchmove.drag\", touchmoved, nonpassive).on(\"touchend.drag touchcancel.drag\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  function mousedowned(event, d) {\n    if (touchending || !filter4.call(this, event, d))\n      return;\n    var gesture = beforestart(this, container.call(this, event, d), event, d, \"mouse\");\n    if (!gesture)\n      return;\n    select_default2(event.view).on(\"mousemove.drag\", mousemoved, nonpassivecapture).on(\"mouseup.drag\", mouseupped, nonpassivecapture);\n    nodrag_default(event.view);\n    nopropagation(event);\n    mousemoving = false;\n    mousedownx = event.clientX;\n    mousedowny = event.clientY;\n    gesture(\"start\", event);\n  }\n  function mousemoved(event) {\n    noevent_default(event);\n    if (!mousemoving) {\n      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\", event);\n  }\n  function mouseupped(event) {\n    select_default2(event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(event.view, mousemoving);\n    noevent_default(event);\n    gestures.mouse(\"end\", event);\n  }\n  function touchstarted(event, d) {\n    if (!filter4.call(this, event, d))\n      return;\n    var touches = event.changedTouches, c6 = container.call(this, event, d), n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(this, c6, event, d, touches[i].identifier, touches[i])) {\n        nopropagation(event);\n        gesture(\"start\", event, touches[i]);\n      }\n    }\n  }\n  function touchmoved(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        noevent_default(event);\n        gesture(\"drag\", event, touches[i]);\n      }\n    }\n  }\n  function touchended(event) {\n    var touches = event.changedTouches, n = touches.length, i, gesture;\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, 500);\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        nopropagation(event);\n        gesture(\"end\", event, touches[i]);\n      }\n    }\n  }\n  function beforestart(that, container2, event, d, identifier, touch) {\n    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s2;\n    if ((s2 = subject.call(that, new DragEvent(\"beforestart\", {\n      sourceEvent: event,\n      target: drag,\n      identifier,\n      active,\n      x: p[0],\n      y: p[1],\n      dx: 0,\n      dy: 0,\n      dispatch: dispatch2\n    }), d)) == null)\n      return;\n    dx = s2.x - p[0] || 0;\n    dy = s2.y - p[1] || 0;\n    return function gesture(type2, event2, touch2) {\n      var p02 = p, n;\n      switch (type2) {\n        case \"start\":\n          gestures[identifier] = gesture, n = active++;\n          break;\n        case \"end\":\n          delete gestures[identifier], --active;\n        case \"drag\":\n          p = pointer_default(touch2 || event2, container2), n = active;\n          break;\n      }\n      dispatch2.call(\n        type2,\n        that,\n        new DragEvent(type2, {\n          sourceEvent: event2,\n          subject: s2,\n          target: drag,\n          identifier,\n          active: n,\n          x: p[0] + dx,\n          y: p[1] + dy,\n          dx: p[0] - p02[0],\n          dy: p[1] - p02[1],\n          dispatch: dispatch2\n        }),\n        d\n      );\n    };\n  }\n  drag.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : filter4;\n  };\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant_default2(_), drag) : container;\n  };\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant_default2(_), drag) : subject;\n  };\n  drag.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default2(!!_), drag) : touchable;\n  };\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n  return drag;\n}\n\n// node_modules/d3-color/src/define.js\nfunction define_default(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition)\n    prototype[key] = definition[key];\n  return prototype;\n}\n\n// node_modules/d3-color/src/color.js\nfunction Color() {\n}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\";\nvar reN = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\";\nvar reP = \"\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\";\nvar reHex = /^#([0-9a-f]{3,8})$/;\nvar reRgbInteger = new RegExp(`^rgb\\\\(${reI},${reI},${reI}\\\\)$`);\nvar reRgbPercent = new RegExp(`^rgb\\\\(${reP},${reP},${reP}\\\\)$`);\nvar reRgbaInteger = new RegExp(`^rgba\\\\(${reI},${reI},${reI},${reN}\\\\)$`);\nvar reRgbaPercent = new RegExp(`^rgba\\\\(${reP},${reP},${reP},${reN}\\\\)$`);\nvar reHslPercent = new RegExp(`^hsl\\\\(${reN},${reP},${reP}\\\\)$`);\nvar reHslaPercent = new RegExp(`^hsla\\\\(${reN},${reP},${reP},${reN}\\\\)$`);\nvar named = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\ndefine_default(Color, color, {\n  copy(channels) {\n    return Object.assign(new this.constructor(), this, channels);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: color_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: color_formatHex,\n  formatHex8: color_formatHex8,\n  formatHsl: color_formatHsl,\n  formatRgb: color_formatRgb,\n  toString: color_formatRgb\n});\nfunction color_formatHex() {\n  return this.rgb().formatHex();\n}\nfunction color_formatHex8() {\n  return this.rgb().formatHex8();\n}\nfunction color_formatHsl() {\n  return hslConvert(this).formatHsl();\n}\nfunction color_formatRgb() {\n  return this.rgb().formatRgb();\n}\nfunction color(format3) {\n  var m3, l;\n  format3 = (format3 + \"\").trim().toLowerCase();\n  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);\n}\nfunction rgba(r, g, b, a4) {\n  if (a4 <= 0)\n    r = g = b = NaN;\n  return new Rgb(r, g, b, a4);\n}\nfunction rgbConvert(o) {\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Rgb();\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity2) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Rgb(r, g, b, opacity2) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Rgb, rgb, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: rgb_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: rgb_formatHex,\n  formatHex8: rgb_formatHex8,\n  formatRgb: rgb_formatRgb,\n  toString: rgb_formatRgb\n}));\nfunction rgb_formatHex() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;\n}\nfunction rgb_formatHex8() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction rgb_formatRgb() {\n  const a4 = clampa(this.opacity);\n  return `${a4 === 1 ? \"rgb(\" : \"rgba(\"}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? \")\" : `, ${a4})`}`;\n}\nfunction clampa(opacity2) {\n  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));\n}\nfunction clampi(value) {\n  return Math.max(0, Math.min(255, Math.round(value) || 0));\n}\nfunction hex(value) {\n  value = clampi(value);\n  return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\nfunction hsla(h, s2, l, a4) {\n  if (a4 <= 0)\n    h = s2 = l = NaN;\n  else if (l <= 0 || l >= 1)\n    h = s2 = NaN;\n  else if (s2 <= 0)\n    h = NaN;\n  return new Hsl(h, s2, l, a4);\n}\nfunction hslConvert(o) {\n  if (o instanceof Hsl)\n    return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color))\n    o = color(o);\n  if (!o)\n    return new Hsl();\n  if (o instanceof Hsl)\n    return o;\n  o = o.rgb();\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s2 = max5 - min4, l = (max5 + min4) / 2;\n  if (s2) {\n    if (r === max5)\n      h = (g - b) / s2 + (g < b) * 6;\n    else if (g === max5)\n      h = (b - r) / s2 + 2;\n    else\n      h = (r - g) / s2 + 4;\n    s2 /= l < 0.5 ? max5 + min4 : 2 - max5 - min4;\n    h *= 60;\n  } else {\n    s2 = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s2, l, o.opacity);\n}\nfunction hsl(h, s2, l, opacity2) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hsl(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Hsl, hsl, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Hsl(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),\n      hsl2rgb(h, m1, m22),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  formatHsl() {\n    const a4 = clampa(this.opacity);\n    return `${a4 === 1 ? \"hsl(\" : \"hsla(\"}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? \")\" : `, ${a4})`}`;\n  }\n}));\nfunction clamph(value) {\n  value = (value || 0) % 360;\n  return value < 0 ? value + 360 : value;\n}\nfunction clampt(value) {\n  return Math.max(0, Math.min(1, value || 0));\n}\nfunction hsl2rgb(h, m1, m22) {\n  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;\n}\n\n// node_modules/d3-color/src/math.js\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\n\n// node_modules/d3-color/src/lab.js\nvar K = 18;\nvar Xn = 0.96422;\nvar Yn = 1;\nvar Zn = 0.82521;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\nfunction labConvert(o) {\n  if (o instanceof Lab)\n    return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl)\n    return hcl2lab(o);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x4, z;\n  if (r === g && g === b)\n    x4 = z = y4;\n  else {\n    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n  }\n  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z), o.opacity);\n}\nfunction gray(l, opacity2) {\n  return new Lab(l, 0, 0, opacity2 == null ? 1 : opacity2);\n}\nfunction lab(l, a4, b, opacity2) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity2 == null ? 1 : opacity2);\n}\nfunction Lab(l, a4, b, opacity2) {\n  this.l = +l;\n  this.a = +a4;\n  this.b = +b;\n  this.opacity = +opacity2;\n}\ndefine_default(Lab, lab, extend(Color, {\n  brighter(k2) {\n    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  darker(k2) {\n    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);\n  },\n  rgb() {\n    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;\n    x4 = Xn * lab2xyz(x4);\n    y4 = Yn * lab2xyz(y4);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z),\n      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z),\n      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z),\n      this.opacity\n    );\n  }\n}));\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\nfunction lrgb2rgb(x4) {\n  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);\n}\nfunction rgb2lrgb(x4) {\n  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);\n}\nfunction hclConvert(o) {\n  if (o instanceof Hcl)\n    return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab))\n    o = labConvert(o);\n  if (o.a === 0 && o.b === 0)\n    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);\n  var h = Math.atan2(o.b, o.a) * degrees;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\nfunction lch(l, c6, h, opacity2) {\n  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction hcl(h, c6, l, opacity2) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c6, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Hcl(h, c6, l, opacity2) {\n  this.h = +h;\n  this.c = +c6;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\nfunction hcl2lab(o) {\n  if (isNaN(o.h))\n    return new Lab(o.l, 0, 0, o.opacity);\n  var h = o.h * radians;\n  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n}\ndefine_default(Hcl, hcl, extend(Color, {\n  brighter(k2) {\n    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  darker(k2) {\n    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);\n  },\n  rgb() {\n    return hcl2lab(this).rgb();\n  }\n}));\n\n// node_modules/d3-color/src/cubehelix.js\nvar A = -0.14861;\nvar B = 1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = 1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix)\n    return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb))\n    o = rgbConvert(o);\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);\n}\nfunction cubehelix(h, s2, l, opacity2) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity2 == null ? 1 : opacity2);\n}\nfunction Cubehelix(h, s2, l, opacity2) {\n  this.h = +h;\n  this.s = +s2;\n  this.l = +l;\n  this.opacity = +opacity2;\n}\ndefine_default(Cubehelix, cubehelix, extend(Color, {\n  brighter(k2) {\n    k2 = k2 == null ? brighter : Math.pow(brighter, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  darker(k2) {\n    k2 = k2 == null ? darker : Math.pow(darker, k2);\n    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);\n  },\n  rgb() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);\n    return new Rgb(\n      255 * (l + a4 * (A * cosh2 + B * sinh2)),\n      255 * (l + a4 * (C * cosh2 + D * sinh2)),\n      255 * (l + a4 * (E * cosh2)),\n      this.opacity\n    );\n  }\n}));\n\n// node_modules/d3-interpolate/src/basis.js\nfunction basis(t13, v0, v1, v2, v3) {\n  var t22 = t13 * t13, t32 = t22 * t13;\n  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;\n}\nfunction basis_default(values2) {\n  var n = values2.length - 1;\n  return function(t) {\n    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/basisClosed.js\nfunction basisClosed_default(values2) {\n  var n = values2.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n\n// node_modules/d3-interpolate/src/constant.js\nvar constant_default3 = (x4) => () => x4;\n\n// node_modules/d3-interpolate/src/color.js\nfunction linear(a4, d) {\n  return function(t) {\n    return a4 + t * d;\n  };\n}\nfunction exponential(a4, b, y4) {\n  return a4 = Math.pow(a4, y4), b = Math.pow(b, y4) - a4, y4 = 1 / y4, function(t) {\n    return Math.pow(a4 + t * b, y4);\n  };\n}\nfunction hue(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b : a4);\n}\nfunction gamma(y4) {\n  return (y4 = +y4) === 1 ? nogamma : function(a4, b) {\n    return b - a4 ? exponential(a4, b, y4) : constant_default3(isNaN(a4) ? b : a4);\n  };\n}\nfunction nogamma(a4, b) {\n  var d = b - a4;\n  return d ? linear(a4, d) : constant_default3(isNaN(a4) ? b : a4);\n}\n\n// node_modules/d3-interpolate/src/rgb.js\nvar rgb_default = function rgbGamma(y4) {\n  var color3 = gamma(y4);\n  function rgb2(start2, end) {\n    var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.r = r(t);\n      start2.g = g(t);\n      start2.b = b(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  }\n  rgb2.gamma = rgbGamma;\n  return rgb2;\n}(1);\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;\n    for (i = 0; i < n; ++i) {\n      color3 = rgb(colors[i]);\n      r[i] = color3.r || 0;\n      g[i] = color3.g || 0;\n      b[i] = color3.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color3.opacity = 1;\n    return function(t) {\n      color3.r = r(t);\n      color3.g = g(t);\n      color3.b = b(t);\n      return color3 + \"\";\n    };\n  };\n}\nvar rgbBasis = rgbSpline(basis_default);\nvar rgbBasisClosed = rgbSpline(basisClosed_default);\n\n// node_modules/d3-interpolate/src/numberArray.js\nfunction numberArray_default(a4, b) {\n  if (!b)\n    b = [];\n  var n = a4 ? Math.min(b.length, a4.length) : 0, c6 = b.slice(), i;\n  return function(t) {\n    for (i = 0; i < n; ++i)\n      c6[i] = a4[i] * (1 - t) + b[i] * t;\n    return c6;\n  };\n}\nfunction isNumberArray(x4) {\n  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);\n}\n\n// node_modules/d3-interpolate/src/array.js\nfunction array_default(a4, b) {\n  return (isNumberArray(b) ? numberArray_default : genericArray)(a4, b);\n}\nfunction genericArray(a4, b) {\n  var nb = b ? b.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x4 = new Array(na), c6 = new Array(nb), i;\n  for (i = 0; i < na; ++i)\n    x4[i] = value_default(a4[i], b[i]);\n  for (; i < nb; ++i)\n    c6[i] = b[i];\n  return function(t) {\n    for (i = 0; i < na; ++i)\n      c6[i] = x4[i](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/date.js\nfunction date_default(a4, b) {\n  var d = /* @__PURE__ */ new Date();\n  return a4 = +a4, b = +b, function(t) {\n    return d.setTime(a4 * (1 - t) + b * t), d;\n  };\n}\n\n// node_modules/d3-interpolate/src/number.js\nfunction number_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return a4 * (1 - t) + b * t;\n  };\n}\n\n// node_modules/d3-interpolate/src/object.js\nfunction object_default(a4, b) {\n  var i = {}, c6 = {}, k2;\n  if (a4 === null || typeof a4 !== \"object\")\n    a4 = {};\n  if (b === null || typeof b !== \"object\")\n    b = {};\n  for (k2 in b) {\n    if (k2 in a4) {\n      i[k2] = value_default(a4[k2], b[k2]);\n    } else {\n      c6[k2] = b[k2];\n    }\n  }\n  return function(t) {\n    for (k2 in i)\n      c6[k2] = i[k2](t);\n    return c6;\n  };\n}\n\n// node_modules/d3-interpolate/src/string.js\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\nfunction zero2(b) {\n  return function() {\n    return b;\n  };\n}\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\nfunction string_default(a4, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];\n  a4 = a4 + \"\", b = b + \"\";\n  while ((am = reA.exec(a4)) && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) {\n      bs = b.slice(bi, bs);\n      if (s2[i])\n        s2[i] += bs;\n      else\n        s2[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) {\n      if (s2[i])\n        s2[i] += bm;\n      else\n        s2[++i] = bm;\n    } else {\n      s2[++i] = null;\n      q.push({ i, x: number_default(am, bm) });\n    }\n    bi = reB.lastIndex;\n  }\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s2[i])\n      s2[i] += bs;\n    else\n      s2[++i] = bs;\n  }\n  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {\n    for (var i2 = 0, o; i2 < b; ++i2)\n      s2[(o = q[i2]).i] = o.x(t);\n    return s2.join(\"\");\n  });\n}\n\n// node_modules/d3-interpolate/src/value.js\nfunction value_default(a4, b) {\n  var t = typeof b, c6;\n  return b == null || t === \"boolean\" ? constant_default3(b) : (t === \"number\" ? number_default : t === \"string\" ? (c6 = color(b)) ? (b = c6, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object_default : number_default)(a4, b);\n}\n\n// node_modules/d3-interpolate/src/discrete.js\nfunction discrete_default(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\n// node_modules/d3-interpolate/src/hue.js\nfunction hue_default(a4, b) {\n  var i = hue(+a4, +b);\n  return function(t) {\n    var x4 = i(t);\n    return x4 - 360 * Math.floor(x4 / 360);\n  };\n}\n\n// node_modules/d3-interpolate/src/round.js\nfunction round_default(a4, b) {\n  return a4 = +a4, b = +b, function(t) {\n    return Math.round(a4 * (1 - t) + b * t);\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/decompose.js\nvar degrees2 = 180 / Math.PI;\nvar identity2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\nfunction decompose_default(a4, b, c6, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a4 * a4 + b * b))\n    a4 /= scaleX, b /= scaleX;\n  if (skewX = a4 * c6 + b * d)\n    c6 -= a4 * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c6 * c6 + d * d))\n    c6 /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a4 * d < b * c6)\n    a4 = -a4, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a4) * degrees2,\n    skewX: Math.atan(skewX) * degrees2,\n    scaleX,\n    scaleY\n  };\n}\n\n// node_modules/d3-interpolate/src/transform/parse.js\nvar svgNode;\nfunction parseCss(value) {\n  const m3 = new (typeof DOMMatrix === \"function\" ? DOMMatrix : WebKitCSSMatrix)(value + \"\");\n  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);\n}\nfunction parseSvg(value) {\n  if (value == null)\n    return identity2;\n  if (!svgNode)\n    svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate()))\n    return identity2;\n  value = value.matrix;\n  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\n// node_modules/d3-interpolate/src/transform/index.js\nfunction interpolateTransform(parse2, pxComma, pxParen, degParen) {\n  function pop(s2) {\n    return s2.length ? s2.pop() + \" \" : \"\";\n  }\n  function translate(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb || yb) {\n      s2.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n  function rotate(a4, b, s2, q) {\n    if (a4 !== b) {\n      if (a4 - b > 180)\n        b += 360;\n      else if (b - a4 > 180)\n        a4 += 360;\n      q.push({ i: s2.push(pop(s2) + \"rotate(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"rotate(\" + b + degParen);\n    }\n  }\n  function skewX(a4, b, s2, q) {\n    if (a4 !== b) {\n      q.push({ i: s2.push(pop(s2) + \"skewX(\", null, degParen) - 2, x: number_default(a4, b) });\n    } else if (b) {\n      s2.push(pop(s2) + \"skewX(\" + b + degParen);\n    }\n  }\n  function scale3(xa, ya, xb, yb, s2, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s2.push(pop(s2) + \"scale(\", null, \",\", null, \")\");\n      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });\n    } else if (xb !== 1 || yb !== 1) {\n      s2.push(pop(s2) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n  return function(a4, b) {\n    var s2 = [], q = [];\n    a4 = parse2(a4), b = parse2(b);\n    translate(a4.translateX, a4.translateY, b.translateX, b.translateY, s2, q);\n    rotate(a4.rotate, b.rotate, s2, q);\n    skewX(a4.skewX, b.skewX, s2, q);\n    scale3(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s2, q);\n    a4 = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n)\n        s2[(o = q[i]).i] = o.x(t);\n      return s2.join(\"\");\n    };\n  };\n}\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\n// node_modules/d3-interpolate/src/zoom.js\nvar epsilon2 = 1e-12;\nfunction cosh(x4) {\n  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;\n}\nfunction sinh(x4) {\n  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;\n}\nfunction tanh(x4) {\n  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);\n}\nvar zoom_default = function zoomRho(rho, rho2, rho4) {\n  function zoom(p02, p1) {\n    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < epsilon2) {\n      S = Math.log(w1 / w0) / rho;\n      i = function(t) {\n        return [\n          ux0 + t * dx,\n          uy0 + t * dy,\n          w0 * Math.exp(rho * t * S)\n        ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);\n      S = (r1 - r0) / rho;\n      i = function(t) {\n        var s2 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));\n        return [\n          ux0 + u4 * dx,\n          uy0 + u4 * dy,\n          w0 * coshr0 / cosh(rho * s2 + r0)\n        ];\n      };\n    }\n    i.duration = S * 1e3 * rho / Math.SQRT2;\n    return i;\n  }\n  zoom.rho = function(_) {\n    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;\n    return zoomRho(_1, _2, _4);\n  };\n  return zoom;\n}(Math.SQRT2, 2, 4);\n\n// node_modules/d3-interpolate/src/hsl.js\nfunction hsl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.s = s2(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hsl_default = hsl2(hue);\nvar hslLong = hsl2(nogamma);\n\n// node_modules/d3-interpolate/src/lab.js\nfunction lab2(start2, end) {\n  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);\n  return function(t) {\n    start2.l = l(t);\n    start2.a = a4(t);\n    start2.b = b(t);\n    start2.opacity = opacity2(t);\n    return start2 + \"\";\n  };\n}\n\n// node_modules/d3-interpolate/src/hcl.js\nfunction hcl2(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.c = c6(t);\n      start2.l = l(t);\n      start2.opacity = opacity2(t);\n      return start2 + \"\";\n    };\n  };\n}\nvar hcl_default = hcl2(hue);\nvar hclLong = hcl2(nogamma);\n\n// node_modules/d3-interpolate/src/cubehelix.js\nfunction cubehelix2(hue2) {\n  return function cubehelixGamma(y4) {\n    y4 = +y4;\n    function cubehelix3(start2, end) {\n      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);\n      return function(t) {\n        start2.h = h(t);\n        start2.s = s2(t);\n        start2.l = l(Math.pow(t, y4));\n        start2.opacity = opacity2(t);\n        return start2 + \"\";\n      };\n    }\n    cubehelix3.gamma = cubehelixGamma;\n    return cubehelix3;\n  }(1);\n}\nvar cubehelix_default = cubehelix2(hue);\nvar cubehelixLong = cubehelix2(nogamma);\n\n// node_modules/d3-interpolate/src/piecewise.js\nfunction piecewise(interpolate, values2) {\n  if (values2 === void 0)\n    values2 = interpolate, interpolate = value_default;\n  var i = 0, n = values2.length - 1, v2 = values2[0], I = new Array(n < 0 ? 0 : n);\n  while (i < n)\n    I[i] = interpolate(v2, v2 = values2[++i]);\n  return function(t) {\n    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));\n    return I[i2](t - i2);\n  };\n}\n\n// node_modules/d3-interpolate/src/quantize.js\nfunction quantize_default(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i)\n    samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n\n// node_modules/d3-timer/src/timer.js\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1e3;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {\n  setTimeout(f, 17);\n};\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\nfunction clearNow() {\n  clockNow = 0;\n}\nfunction Timer() {\n  this._call = this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time2) {\n    if (typeof callback !== \"function\")\n      throw new TypeError(\"callback is not a function\");\n    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail)\n        taskTail._next = this;\n      else\n        taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time2;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction timer(callback, delay, time2) {\n  var t = new Timer();\n  t.restart(callback, delay, time2);\n  return t;\n}\nfunction timerFlush() {\n  now();\n  ++frame;\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0)\n      t._call.call(void 0, e);\n    t = t._next;\n  }\n  --frame;\n}\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\nfunction poke() {\n  var now2 = clock.now(), delay = now2 - clockLast;\n  if (delay > pokeDelay)\n    clockSkew -= delay, clockLast = now2;\n}\nfunction nap() {\n  var t03, t13 = taskHead, t22, time2 = Infinity;\n  while (t13) {\n    if (t13._call) {\n      if (time2 > t13._time)\n        time2 = t13._time;\n      t03 = t13, t13 = t13._next;\n    } else {\n      t22 = t13._next, t13._next = null;\n      t13 = t03 ? t03._next = t22 : taskHead = t22;\n    }\n  }\n  taskTail = t03;\n  sleep(time2);\n}\nfunction sleep(time2) {\n  if (frame)\n    return;\n  if (timeout)\n    timeout = clearTimeout(timeout);\n  var delay = time2 - clockNow;\n  if (delay > 24) {\n    if (time2 < Infinity)\n      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);\n    if (interval)\n      interval = clearInterval(interval);\n  } else {\n    if (!interval)\n      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\n// node_modules/d3-timer/src/timeout.js\nfunction timeout_default(callback, delay, time2) {\n  var t = new Timer();\n  delay = delay == null ? 0 : +delay;\n  t.restart((elapsed) => {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time2);\n  return t;\n}\n\n// node_modules/d3-timer/src/interval.js\nfunction interval_default(callback, delay, time2) {\n  var t = new Timer(), total = delay;\n  if (delay == null)\n    return t.restart(callback, delay, time2), t;\n  t._restart = t.restart;\n  t.restart = function(callback2, delay2, time3) {\n    delay2 = +delay2, time3 = time3 == null ? now() : +time3;\n    t._restart(function tick(elapsed) {\n      elapsed += total;\n      t._restart(tick, total += delay2, time3);\n      callback2(elapsed);\n    }, delay2, time3);\n  };\n  t.restart(callback, delay, time2);\n  return t;\n}\n\n// node_modules/d3-transition/src/transition/schedule.js\nvar emptyOn = dispatch_default(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\nfunction schedule_default(node, name, id2, index3, group3, timing) {\n  var schedules = node.__transition;\n  if (!schedules)\n    node.__transition = {};\n  else if (id2 in schedules)\n    return;\n  create(node, id2, {\n    name,\n    index: index3,\n    // For context during callback.\n    group: group3,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nfunction init(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > CREATED)\n    throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nfunction set3(node, id2) {\n  var schedule = get2(node, id2);\n  if (schedule.state > STARTED)\n    throw new Error(\"too late; already running\");\n  return schedule;\n}\nfunction get2(node, id2) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id2]))\n    throw new Error(\"transition not found\");\n  return schedule;\n}\nfunction create(node, id2, self) {\n  var schedules = node.__transition, tween;\n  schedules[id2] = self;\n  self.timer = timer(schedule, 0, self.time);\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start2, self.delay, self.time);\n    if (self.delay <= elapsed)\n      start2(elapsed - self.delay);\n  }\n  function start2(elapsed) {\n    var i, j, n, o;\n    if (self.state !== SCHEDULED)\n      return stop();\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name)\n        continue;\n      if (o.state === STARTED)\n        return timeout_default(start2);\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } else if (+i < id2) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n    timeout_default(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING)\n      return;\n    self.state = STARTED;\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id2];\n    for (var i in schedules)\n      return;\n    delete node.__transition;\n  }\n}\n\n// node_modules/d3-transition/src/interrupt.js\nfunction interrupt_default(node, name) {\n  var schedules = node.__transition, schedule, active, empty4 = true, i;\n  if (!schedules)\n    return;\n  name = name == null ? null : name + \"\";\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) {\n      empty4 = false;\n      continue;\n    }\n    active = schedule.state > STARTING && schedule.state < ENDING;\n    schedule.state = ENDED;\n    schedule.timer.stop();\n    schedule.on.call(active ? \"interrupt\" : \"cancel\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n  if (empty4)\n    delete node.__transition;\n}\n\n// node_modules/d3-transition/src/selection/interrupt.js\nfunction interrupt_default2(name) {\n  return this.each(function() {\n    interrupt_default(this, name);\n  });\n}\n\n// node_modules/d3-transition/src/transition/tween.js\nfunction tweenRemove(id2, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tweenFunction(id2, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    var schedule = set3(this, id2), tween = schedule.tween;\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n)\n        tween1.push(t);\n    }\n    schedule.tween = tween1;\n  };\n}\nfunction tween_default(name, value) {\n  var id2 = this._id;\n  name += \"\";\n  if (arguments.length < 2) {\n    var tween = get2(this.node(), id2).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));\n}\nfunction tweenValue(transition2, name, value) {\n  var id2 = transition2._id;\n  transition2.each(function() {\n    var schedule = set3(this, id2);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n  return function(node) {\n    return get2(node, id2).value[name];\n  };\n}\n\n// node_modules/d3-transition/src/transition/interpolate.js\nfunction interpolate_default(a4, b) {\n  var c6;\n  return (typeof b === \"number\" ? number_default : b instanceof color ? rgb_default : (c6 = color(b)) ? (b = c6, rgb_default) : string_default)(a4, b);\n}\n\n// node_modules/d3-transition/src/transition/attr.js\nfunction attrRemove2(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS2(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttribute(name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrConstantNS2(fullname, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = this.getAttributeNS(fullname.space, fullname.local);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction attrFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttribute(name);\n    string0 = this.getAttribute(name);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attrFunctionNS2(fullname, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null)\n      return void this.removeAttributeNS(fullname.space, fullname.local);\n    string0 = this.getAttributeNS(fullname.space, fullname.local);\n    string1 = value1 + \"\";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction attr_default2(name, value) {\n  var fullname = namespace_default(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate_default;\n  return this.attrTween(name, typeof value === \"function\" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, \"attr.\" + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));\n}\n\n// node_modules/d3-transition/src/transition/attrTween.js\nfunction attrInterpolate(name, i) {\n  return function(t) {\n    this.setAttribute(name, i.call(this, t));\n  };\n}\nfunction attrInterpolateNS(fullname, i) {\n  return function(t) {\n    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));\n  };\n}\nfunction attrTweenNS(fullname, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolateNS(fullname, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween(name, value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && attrInterpolate(name, i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween_default(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  var fullname = namespace_default(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n}\n\n// node_modules/d3-transition/src/transition/delay.js\nfunction delayFunction(id2, value) {\n  return function() {\n    init(this, id2).delay = +value.apply(this, arguments);\n  };\n}\nfunction delayConstant(id2, value) {\n  return value = +value, function() {\n    init(this, id2).delay = value;\n  };\n}\nfunction delay_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;\n}\n\n// node_modules/d3-transition/src/transition/duration.js\nfunction durationFunction(id2, value) {\n  return function() {\n    set3(this, id2).duration = +value.apply(this, arguments);\n  };\n}\nfunction durationConstant(id2, value) {\n  return value = +value, function() {\n    set3(this, id2).duration = value;\n  };\n}\nfunction duration_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;\n}\n\n// node_modules/d3-transition/src/transition/ease.js\nfunction easeConstant(id2, value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return function() {\n    set3(this, id2).ease = value;\n  };\n}\nfunction ease_default(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;\n}\n\n// node_modules/d3-transition/src/transition/easeVarying.js\nfunction easeVarying(id2, value) {\n  return function() {\n    var v2 = value.apply(this, arguments);\n    if (typeof v2 !== \"function\")\n      throw new Error();\n    set3(this, id2).ease = v2;\n  };\n}\nfunction easeVarying_default(value) {\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.each(easeVarying(this._id, value));\n}\n\n// node_modules/d3-transition/src/transition/filter.js\nfunction filter_default2(match) {\n  if (typeof match !== \"function\")\n    match = matcher_default(match);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/merge.js\nfunction merge_default2(transition2) {\n  if (transition2._id !== this._id)\n    throw new Error();\n  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m3; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge2[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Transition(merges, this._parents, this._name, this._id);\n}\n\n// node_modules/d3-transition/src/transition/on.js\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0)\n      t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\nfunction onFunction(id2, name, listener) {\n  var on0, on1, sit = start(name) ? init : set3;\n  return function() {\n    var schedule = sit(this, id2), on = schedule.on;\n    if (on !== on0)\n      (on1 = (on0 = on).copy()).on(name, listener);\n    schedule.on = on1;\n  };\n}\nfunction on_default2(name, listener) {\n  var id2 = this._id;\n  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));\n}\n\n// node_modules/d3-transition/src/transition/remove.js\nfunction removeFunction(id2) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition)\n      if (+i !== id2)\n        return;\n    if (parent)\n      parent.removeChild(this);\n  };\n}\nfunction remove_default2() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n}\n\n// node_modules/d3-transition/src/transition/select.js\nfunction select_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selector_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {\n        if (\"__data__\" in node)\n          subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selectAll.js\nfunction selectAll_default3(select2) {\n  var name = this._name, id2 = this._id;\n  if (typeof select2 !== \"function\")\n    select2 = selectorAll_default(select2);\n  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {\n          if (child = children2[k2]) {\n            schedule_default(child, name, id2, k2, children2, inherit3);\n          }\n        }\n        subgroups.push(children2);\n        parents.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, parents, name, id2);\n}\n\n// node_modules/d3-transition/src/transition/selection.js\nvar Selection2 = selection_default.prototype.constructor;\nfunction selection_default2() {\n  return new Selection2(this._groups, this._parents);\n}\n\n// node_modules/d3-transition/src/transition/style.js\nfunction styleNull(name, interpolate) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);\n  };\n}\nfunction styleRemove2(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant2(name, interpolate, value1) {\n  var string00, string1 = value1 + \"\", interpolate0;\n  return function() {\n    var string0 = styleValue(this, name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);\n  };\n}\nfunction styleFunction2(name, interpolate, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + \"\";\n    if (value1 == null)\n      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));\n  };\n}\nfunction styleMaybeRemove(id2, name) {\n  var on0, on1, listener0, key = \"style.\" + name, event = \"end.\" + key, remove2;\n  return function() {\n    var schedule = set3(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;\n    if (on !== on0 || listener0 !== listener)\n      (on1 = (on0 = on).copy()).on(event, listener0 = listener);\n    schedule.on = on1;\n  };\n}\nfunction style_default2(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate_default;\n  return value == null ? this.styleTween(name, styleNull(name, i)).on(\"end.style.\" + name, styleRemove2(name)) : typeof value === \"function\" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, \"style.\" + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on(\"end.style.\" + name, null);\n}\n\n// node_modules/d3-transition/src/transition/styleTween.js\nfunction styleInterpolate(name, i, priority) {\n  return function(t) {\n    this.style.setProperty(name, i.call(this, t), priority);\n  };\n}\nfunction styleTween(name, value, priority) {\n  var t, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t = (i0 = i) && styleInterpolate(name, i, priority);\n    return t;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction styleTween_default(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n}\n\n// node_modules/d3-transition/src/transition/text.js\nfunction textConstant2(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction2(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\nfunction text_default2(value) {\n  return this.tween(\"text\", typeof value === \"function\" ? textFunction2(tweenValue(this, \"text\", value)) : textConstant2(value == null ? \"\" : value + \"\"));\n}\n\n// node_modules/d3-transition/src/transition/textTween.js\nfunction textInterpolate(i) {\n  return function(t) {\n    this.textContent = i.call(this, t);\n  };\n}\nfunction textTween(value) {\n  var t03, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0)\n      t03 = (i0 = i) && textInterpolate(i);\n    return t03;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction textTween_default(value) {\n  var key = \"text\";\n  if (arguments.length < 1)\n    return (key = this.tween(key)) && key._value;\n  if (value == null)\n    return this.tween(key, null);\n  if (typeof value !== \"function\")\n    throw new Error();\n  return this.tween(key, textTween(value));\n}\n\n// node_modules/d3-transition/src/transition/transition.js\nfunction transition_default() {\n  var name = this._name, id0 = this._id, id1 = newId();\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        var inherit3 = get2(node, id0);\n        schedule_default(node, name, id1, i, group3, {\n          time: inherit3.time + inherit3.delay + inherit3.duration,\n          delay: 0,\n          duration: inherit3.duration,\n          ease: inherit3.ease\n        });\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id1);\n}\n\n// node_modules/d3-transition/src/transition/end.js\nfunction end_default() {\n  var on0, on1, that = this, id2 = that._id, size = that.size();\n  return new Promise(function(resolve, reject) {\n    var cancel = { value: reject }, end = { value: function() {\n      if (--size === 0)\n        resolve();\n    } };\n    that.each(function() {\n      var schedule = set3(this, id2), on = schedule.on;\n      if (on !== on0) {\n        on1 = (on0 = on).copy();\n        on1._.cancel.push(cancel);\n        on1._.interrupt.push(cancel);\n        on1._.end.push(end);\n      }\n      schedule.on = on1;\n    });\n    if (size === 0)\n      resolve();\n  });\n}\n\n// node_modules/d3-transition/src/transition/index.js\nvar id = 0;\nfunction Transition(groups2, parents, name, id2) {\n  this._groups = groups2;\n  this._parents = parents;\n  this._name = name;\n  this._id = id2;\n}\nfunction transition(name) {\n  return selection_default().transition(name);\n}\nfunction newId() {\n  return ++id;\n}\nvar selection_prototype = selection_default.prototype;\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: select_default3,\n  selectAll: selectAll_default3,\n  selectChild: selection_prototype.selectChild,\n  selectChildren: selection_prototype.selectChildren,\n  filter: filter_default2,\n  merge: merge_default2,\n  selection: selection_default2,\n  transition: transition_default,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: on_default2,\n  attr: attr_default2,\n  attrTween: attrTween_default,\n  style: style_default2,\n  styleTween: styleTween_default,\n  text: text_default2,\n  textTween: textTween_default,\n  remove: remove_default2,\n  tween: tween_default,\n  delay: delay_default,\n  duration: duration_default,\n  ease: ease_default,\n  easeVarying: easeVarying_default,\n  end: end_default,\n  [Symbol.iterator]: selection_prototype[Symbol.iterator]\n};\n\n// node_modules/d3-ease/src/linear.js\nvar linear2 = (t) => +t;\n\n// node_modules/d3-ease/src/quad.js\nfunction quadIn(t) {\n  return t * t;\n}\nfunction quadOut(t) {\n  return t * (2 - t);\n}\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/cubic.js\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\n// node_modules/d3-ease/src/poly.js\nvar exponent = 3;\nvar polyIn = function custom(e) {\n  e = +e;\n  function polyIn2(t) {\n    return Math.pow(t, e);\n  }\n  polyIn2.exponent = custom;\n  return polyIn2;\n}(exponent);\nvar polyOut = function custom2(e) {\n  e = +e;\n  function polyOut2(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n  polyOut2.exponent = custom2;\n  return polyOut2;\n}(exponent);\nvar polyInOut = function custom3(e) {\n  e = +e;\n  function polyInOut2(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n  polyInOut2.exponent = custom3;\n  return polyInOut2;\n}(exponent);\n\n// node_modules/d3-ease/src/sin.js\nvar pi = Math.PI;\nvar halfPi = pi / 2;\nfunction sinIn(t) {\n  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);\n}\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\n// node_modules/d3-ease/src/math.js\nfunction tpmt(x4) {\n  return (Math.pow(2, -10 * x4) - 9765625e-10) * 1.0009775171065494;\n}\n\n// node_modules/d3-ease/src/exp.js\nfunction expIn(t) {\n  return tpmt(1 - +t);\n}\nfunction expOut(t) {\n  return 1 - tpmt(t);\n}\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;\n}\n\n// node_modules/d3-ease/src/circle.js\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/bounce.js\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\n// node_modules/d3-ease/src/back.js\nvar overshoot = 1.70158;\nvar backIn = function custom4(s2) {\n  s2 = +s2;\n  function backIn2(t) {\n    return (t = +t) * t * (s2 * (t - 1) + t);\n  }\n  backIn2.overshoot = custom4;\n  return backIn2;\n}(overshoot);\nvar backOut = function custom5(s2) {\n  s2 = +s2;\n  function backOut2(t) {\n    return --t * t * ((t + 1) * s2 + t) + 1;\n  }\n  backOut2.overshoot = custom5;\n  return backOut2;\n}(overshoot);\nvar backInOut = function custom6(s2) {\n  s2 = +s2;\n  function backInOut2(t) {\n    return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;\n  }\n  backInOut2.overshoot = custom6;\n  return backInOut2;\n}(overshoot);\n\n// node_modules/d3-ease/src/elastic.js\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\nvar elasticIn = function custom7(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticIn2(t) {\n    return a4 * tpmt(- --t) * Math.sin((s2 - t) / p);\n  }\n  elasticIn2.amplitude = function(a5) {\n    return custom7(a5, p * tau);\n  };\n  elasticIn2.period = function(p2) {\n    return custom7(a4, p2);\n  };\n  return elasticIn2;\n}(amplitude, period);\nvar elasticOut = function custom8(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticOut2(t) {\n    return 1 - a4 * tpmt(t = +t) * Math.sin((t + s2) / p);\n  }\n  elasticOut2.amplitude = function(a5) {\n    return custom8(a5, p * tau);\n  };\n  elasticOut2.period = function(p2) {\n    return custom8(a4, p2);\n  };\n  return elasticOut2;\n}(amplitude, period);\nvar elasticInOut = function custom9(a4, p) {\n  var s2 = Math.asin(1 / (a4 = Math.max(1, a4))) * (p /= tau);\n  function elasticInOut2(t) {\n    return ((t = t * 2 - 1) < 0 ? a4 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a4 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;\n  }\n  elasticInOut2.amplitude = function(a5) {\n    return custom9(a5, p * tau);\n  };\n  elasticInOut2.period = function(p2) {\n    return custom9(a4, p2);\n  };\n  return elasticInOut2;\n}(amplitude, period);\n\n// node_modules/d3-transition/src/selection/transition.js\nvar defaultTiming = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\nfunction inherit(node, id2) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id2])) {\n    if (!(node = node.parentNode)) {\n      throw new Error(`transition ${id2} not found`);\n    }\n  }\n  return timing;\n}\nfunction transition_default2(name) {\n  var id2, timing;\n  if (name instanceof Transition) {\n    id2 = name._id, name = name._name;\n  } else {\n    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n  for (var groups2 = this._groups, m3 = groups2.length, j = 0; j < m3; ++j) {\n    for (var group3 = groups2[j], n = group3.length, node, i = 0; i < n; ++i) {\n      if (node = group3[i]) {\n        schedule_default(node, name, id2, i, group3, timing || inherit(node, id2));\n      }\n    }\n  }\n  return new Transition(groups2, this._parents, name, id2);\n}\n\n// node_modules/d3-transition/src/selection/index.js\nselection_default.prototype.interrupt = interrupt_default2;\nselection_default.prototype.transition = transition_default2;\n\n// node_modules/d3-transition/src/active.js\nvar root2 = [null];\nfunction active_default(node, name) {\n  var schedules = node.__transition, schedule, i;\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n        return new Transition([[node]], root2, name, +i);\n      }\n    }\n  }\n  return null;\n}\n\n// node_modules/d3-brush/src/constant.js\nvar constant_default4 = (x4) => () => x4;\n\n// node_modules/d3-brush/src/event.js\nfunction BrushEvent(type2, {\n  sourceEvent,\n  target,\n  selection: selection2,\n  mode: mode2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    selection: { value: selection2, enumerable: true, configurable: true },\n    mode: { value: mode2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-brush/src/noevent.js\nfunction nopropagation2(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default2(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-brush/src/brush.js\nvar MODE_DRAG = { name: \"drag\" };\nvar MODE_SPACE = { name: \"space\" };\nvar MODE_HANDLE = { name: \"handle\" };\nvar MODE_CENTER = { name: \"center\" };\nvar { abs, max: max2, min: min2 } = Math;\nfunction number1(e) {\n  return [+e[0], +e[1]];\n}\nfunction number22(e) {\n  return [number1(e[0]), number1(e[1])];\n}\nvar X = {\n  name: \"x\",\n  handles: [\"w\", \"e\"].map(type),\n  input: function(x4, e) {\n    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][0], xy[1][0]];\n  }\n};\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y4, e) {\n    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];\n  },\n  output: function(xy) {\n    return xy && [xy[0][1], xy[1][1]];\n  }\n};\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"w\", \"e\", \"s\", \"nw\", \"ne\", \"sw\", \"se\"].map(type),\n  input: function(xy) {\n    return xy == null ? null : number22(xy);\n  },\n  output: function(xy) {\n    return xy;\n  }\n};\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\nvar signsX = {\n  overlay: 1,\n  selection: 1,\n  n: null,\n  e: 1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: 1,\n  se: 1,\n  sw: -1\n};\nvar signsY = {\n  overlay: 1,\n  selection: 1,\n  n: -1,\n  e: null,\n  s: 1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: 1,\n  sw: 1\n};\nfunction type(t) {\n  return { type: t };\n}\nfunction defaultFilter2(event) {\n  return !event.ctrlKey && !event.button;\n}\nfunction defaultExtent() {\n  var svg2 = this.ownerSVGElement || this;\n  if (svg2.hasAttribute(\"viewBox\")) {\n    svg2 = svg2.viewBox.baseVal;\n    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];\n  }\n  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];\n}\nfunction defaultTouchable2() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction local2(node) {\n  while (!node.__brush)\n    if (!(node = node.parentNode))\n      return;\n  return node.__brush;\n}\nfunction empty3(extent3) {\n  return extent3[0][0] === extent3[1][0] || extent3[0][1] === extent3[1][1];\n}\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\nfunction brushX() {\n  return brush(X);\n}\nfunction brushY() {\n  return brush(Y);\n}\nfunction brush_default() {\n  return brush(XY);\n}\nfunction brush(dim) {\n  var extent3 = defaultExtent, filter4 = defaultFilter2, touchable = defaultTouchable2, keys = true, listeners = dispatch_default(\"start\", \"brush\", \"end\"), handleSize = 6, touchending;\n  function brush2(group3) {\n    var overlay = group3.property(\"__brush\", initialize).selectAll(\".overlay\").data([type(\"overlay\")]);\n    overlay.enter().append(\"rect\").attr(\"class\", \"overlay\").attr(\"pointer-events\", \"all\").attr(\"cursor\", cursors.overlay).merge(overlay).each(function() {\n      var extent4 = local2(this).extent;\n      select_default2(this).attr(\"x\", extent4[0][0]).attr(\"y\", extent4[0][1]).attr(\"width\", extent4[1][0] - extent4[0][0]).attr(\"height\", extent4[1][1] - extent4[0][1]);\n    });\n    group3.selectAll(\".selection\").data([type(\"selection\")]).enter().append(\"rect\").attr(\"class\", \"selection\").attr(\"cursor\", cursors.selection).attr(\"fill\", \"#777\").attr(\"fill-opacity\", 0.3).attr(\"stroke\", \"#fff\").attr(\"shape-rendering\", \"crispEdges\");\n    var handle = group3.selectAll(\".handle\").data(dim.handles, function(d) {\n      return d.type;\n    });\n    handle.exit().remove();\n    handle.enter().append(\"rect\").attr(\"class\", function(d) {\n      return \"handle handle--\" + d.type;\n    }).attr(\"cursor\", function(d) {\n      return cursors[d.type];\n    });\n    group3.each(redraw).attr(\"fill\", \"none\").attr(\"pointer-events\", \"all\").on(\"mousedown.brush\", started).filter(touchable).on(\"touchstart.brush\", started).on(\"touchmove.brush\", touchmoved).on(\"touchend.brush touchcancel.brush\", touchended).style(\"touch-action\", \"none\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  brush2.move = function(group3, selection2, event) {\n    if (group3.tween) {\n      group3.on(\"start.brush\", function(event2) {\n        emitter(this, arguments).beforestart().start(event2);\n      }).on(\"interrupt.brush end.brush\", function(event2) {\n        emitter(this, arguments).end(event2);\n      }).tween(\"brush\", function() {\n        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(this, arguments) : selection2, state.extent), i = value_default(selection0, selection1);\n        function tween(t) {\n          state.selection = t === 1 && selection1 === null ? null : i(t);\n          redraw.call(that);\n          emit.brush();\n        }\n        return selection0 !== null && selection1 !== null ? tween : tween(1);\n      });\n    } else {\n      group3.each(function() {\n        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === \"function\" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();\n        interrupt_default(that);\n        state.selection = selection1 === null ? null : selection1;\n        redraw.call(that);\n        emit.start(event).brush(event).end(event);\n      });\n    }\n  };\n  brush2.clear = function(group3, event) {\n    brush2.move(group3, null, event);\n  };\n  function redraw() {\n    var group3 = select_default2(this), selection2 = local2(this).selection;\n    if (selection2) {\n      group3.selectAll(\".selection\").style(\"display\", null).attr(\"x\", selection2[0][0]).attr(\"y\", selection2[0][1]).attr(\"width\", selection2[1][0] - selection2[0][0]).attr(\"height\", selection2[1][1] - selection2[0][1]);\n      group3.selectAll(\".handle\").style(\"display\", null).attr(\"x\", function(d) {\n        return d.type[d.type.length - 1] === \"e\" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;\n      }).attr(\"y\", function(d) {\n        return d.type[0] === \"s\" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;\n      }).attr(\"width\", function(d) {\n        return d.type === \"n\" || d.type === \"s\" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;\n      }).attr(\"height\", function(d) {\n        return d.type === \"e\" || d.type === \"w\" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;\n      });\n    } else {\n      group3.selectAll(\".selection,.handle\").style(\"display\", \"none\").attr(\"x\", null).attr(\"y\", null).attr(\"width\", null).attr(\"height\", null);\n    }\n  }\n  function emitter(that, args, clean) {\n    var emit = that.__brush.emitter;\n    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);\n  }\n  function Emitter(that, args, clean) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n    this.clean = clean;\n  }\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1)\n        this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function(event, mode2) {\n      if (this.starting)\n        this.starting = false, this.emit(\"start\", event, mode2);\n      else\n        this.emit(\"brush\", event);\n      return this;\n    },\n    brush: function(event, mode2) {\n      this.emit(\"brush\", event, mode2);\n      return this;\n    },\n    end: function(event, mode2) {\n      if (--this.active === 0)\n        delete this.state.emitter, this.emit(\"end\", event, mode2);\n      return this;\n    },\n    emit: function(type2, event, mode2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new BrushEvent(type2, {\n          sourceEvent: event,\n          target: brush2,\n          selection: dim.output(this.state.selection),\n          mode: mode2,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function started(event) {\n    if (touchending && !event.touches)\n      return;\n    if (!filter4.apply(this, arguments))\n      return;\n    var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = \"overlay\" : type2) === \"selection\" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local2(that), extent4 = state.extent, selection2 = state.selection, W = extent4[0][0], w0, w1, N = extent4[0][1], n0, n1, E2 = extent4[1][0], e0, e1, S = extent4[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {\n      const i = t.identifier;\n      t = pointer_default(t, that);\n      t.point0 = t.slice();\n      t.identifier = i;\n      return t;\n    });\n    interrupt_default(that);\n    var emit = emitter(that, arguments, true).beforestart();\n    if (type2 === \"overlay\") {\n      if (selection2)\n        moving = true;\n      const pts = [points[0], points[1] || points[0]];\n      state.selection = selection2 = [[\n        w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]),\n        n0 = dim === X ? N : min2(pts[0][1], pts[1][1])\n      ], [\n        e0 = dim === Y ? E2 : max2(pts[0][0], pts[1][0]),\n        s0 = dim === X ? S : max2(pts[0][1], pts[1][1])\n      ]];\n      if (points.length > 1)\n        move(event);\n    } else {\n      w0 = selection2[0][0];\n      n0 = selection2[0][1];\n      e0 = selection2[1][0];\n      s0 = selection2[1][1];\n    }\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n    var group3 = select_default2(that).attr(\"pointer-events\", \"none\");\n    var overlay = group3.selectAll(\".overlay\").attr(\"cursor\", cursors[type2]);\n    if (event.touches) {\n      emit.moved = moved;\n      emit.ended = ended;\n    } else {\n      var view = select_default2(event.view).on(\"mousemove.brush\", moved, true).on(\"mouseup.brush\", ended, true);\n      if (keys)\n        view.on(\"keydown.brush\", keydowned, true).on(\"keyup.brush\", keyupped, true);\n      nodrag_default(event.view);\n    }\n    redraw.call(that);\n    emit.start(event, mode2.name);\n    function moved(event2) {\n      for (const p of event2.changedTouches || [event2]) {\n        for (const d of points)\n          if (d.identifier === p.identifier)\n            d.cur = pointer_default(p, that);\n      }\n      if (shifting && !lockX && !lockY && points.length === 1) {\n        const point6 = points[0];\n        if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))\n          lockY = true;\n        else\n          lockX = true;\n      }\n      for (const point6 of points)\n        if (point6.cur)\n          point6[0] = point6.cur[0], point6[1] = point6.cur[1];\n      moving = true;\n      noevent_default2(event2);\n      move(event2);\n    }\n    function move(event2) {\n      const point6 = points[0], point0 = point6.point0;\n      var t;\n      dx = point6[0] - point0[0];\n      dy = point6[1] - point0[1];\n      switch (mode2) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX)\n            dx = max2(W - w0, min2(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY)\n            dy = max2(N - n0, min2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (points[1]) {\n            if (signX)\n              w1 = max2(W, min2(E2, points[0][0])), e1 = max2(W, min2(E2, points[1][0])), signX = 1;\n            if (signY)\n              n1 = max2(N, min2(S, points[0][1])), s1 = max2(N, min2(S, points[1][1])), signY = 1;\n          } else {\n            if (signX < 0)\n              dx = max2(W - w0, min2(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;\n            else if (signX > 0)\n              dx = max2(W - e0, min2(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;\n            if (signY < 0)\n              dy = max2(N - n0, min2(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n            else if (signY > 0)\n              dy = max2(N - s0, min2(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          }\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX)\n            w1 = max2(W, min2(E2, w0 - dx * signX)), e1 = max2(W, min2(E2, e0 + dx * signX));\n          if (signY)\n            n1 = max2(N, min2(S, n0 - dy * signY)), s1 = max2(N, min2(S, s0 + dy * signY));\n          break;\n        }\n      }\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type2 in flipX)\n          overlay.attr(\"cursor\", cursors[type2 = flipX[type2]]);\n      }\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type2 in flipY)\n          overlay.attr(\"cursor\", cursors[type2 = flipY[type2]]);\n      }\n      if (state.selection)\n        selection2 = state.selection;\n      if (lockX)\n        w1 = selection2[0][0], e1 = selection2[1][0];\n      if (lockY)\n        n1 = selection2[0][1], s1 = selection2[1][1];\n      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush(event2, mode2.name);\n      }\n    }\n    function ended(event2) {\n      nopropagation2(event2);\n      if (event2.touches) {\n        if (event2.touches.length)\n          return;\n        if (touchending)\n          clearTimeout(touchending);\n        touchending = setTimeout(function() {\n          touchending = null;\n        }, 500);\n      } else {\n        yesdrag(event2.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group3.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection)\n        selection2 = state.selection;\n      if (empty3(selection2))\n        state.selection = null, redraw.call(that);\n      emit.end(event2, mode2.name);\n    }\n    function keydowned(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          shifting = signX && signY;\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_HANDLE) {\n            if (signX)\n              e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY)\n              s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode2 = MODE_CENTER;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1 - dx;\n            else if (signX > 0)\n              w0 = w1 - dx;\n            if (signY < 0)\n              s0 = s1 - dy;\n            else if (signY > 0)\n              n0 = n1 - dy;\n            mode2 = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n    function keyupped(event2) {\n      switch (event2.keyCode) {\n        case 16: {\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move(event2);\n          }\n          break;\n        }\n        case 18: {\n          if (mode2 === MODE_CENTER) {\n            if (signX < 0)\n              e0 = e1;\n            else if (signX > 0)\n              w0 = w1;\n            if (signY < 0)\n              s0 = s1;\n            else if (signY > 0)\n              n0 = n1;\n            mode2 = MODE_HANDLE;\n            move(event2);\n          }\n          break;\n        }\n        case 32: {\n          if (mode2 === MODE_SPACE) {\n            if (event2.altKey) {\n              if (signX)\n                e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY)\n                s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode2 = MODE_CENTER;\n            } else {\n              if (signX < 0)\n                e0 = e1;\n              else if (signX > 0)\n                w0 = w1;\n              if (signY < 0)\n                s0 = s1;\n              else if (signY > 0)\n                n0 = n1;\n              mode2 = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type2]);\n            move(event2);\n          }\n          break;\n        }\n        default:\n          return;\n      }\n      noevent_default2(event2);\n    }\n  }\n  function touchmoved(event) {\n    emitter(this, arguments).moved(event);\n  }\n  function touchended(event) {\n    emitter(this, arguments).ended(event);\n  }\n  function initialize() {\n    var state = this.__brush || { selection: null };\n    state.extent = number22(extent3.apply(this, arguments));\n    state.dim = dim;\n    return state;\n  }\n  brush2.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default4(number22(_)), brush2) : extent3;\n  };\n  brush2.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : filter4;\n  };\n  brush2.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default4(!!_), brush2) : touchable;\n  };\n  brush2.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush2) : handleSize;\n  };\n  brush2.keyModifiers = function(_) {\n    return arguments.length ? (keys = !!_, brush2) : keys;\n  };\n  brush2.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush2 : value;\n  };\n  return brush2;\n}\n\n// node_modules/d3-chord/src/math.js\nvar abs2 = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi2 = Math.PI;\nvar halfPi2 = pi2 / 2;\nvar tau2 = pi2 * 2;\nvar max3 = Math.max;\nvar epsilon3 = 1e-12;\n\n// node_modules/d3-chord/src/chord.js\nfunction range2(i, j) {\n  return Array.from({ length: j - i }, (_, k2) => i + k2);\n}\nfunction compareValue(compare) {\n  return function(a4, b) {\n    return compare(\n      a4.source.value + a4.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\nfunction chord_default() {\n  return chord(false, false);\n}\nfunction chordTranspose() {\n  return chord(false, true);\n}\nfunction chordDirected() {\n  return chord(true, false);\n}\nfunction chord(directed, transpose2) {\n  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;\n  function chord2(matrix) {\n    var n = matrix.length, groupSums = new Array(n), groupIndex2 = range2(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;\n    matrix = Float64Array.from({ length: n * n }, transpose2 ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);\n    for (let i = 0; i < n; ++i) {\n      let x4 = 0;\n      for (let j = 0; j < n; ++j)\n        x4 += matrix[i * n + j] + directed * matrix[j * n + i];\n      k2 += groupSums[i] = x4;\n    }\n    k2 = max3(0, tau2 - padAngle * n) / k2;\n    dx = k2 ? padAngle : tau2 / n;\n    {\n      let x4 = 0;\n      if (sortGroups)\n        groupIndex2.sort((a4, b) => sortGroups(groupSums[a4], groupSums[b]));\n      for (const i of groupIndex2) {\n        const x06 = x4;\n        if (directed) {\n          const subgroupIndex = range2(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(a4 < 0 ? -matrix[~a4 * n + i] : matrix[i * n + a4], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            if (j < 0) {\n              const chord3 = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[~j * n + i] * k2, value: matrix[~j * n + i] };\n            } else {\n              const chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        } else {\n          const subgroupIndex = range2(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);\n          if (sortSubgroups)\n            subgroupIndex.sort((a4, b) => sortSubgroups(matrix[i * n + a4], matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            let chord3;\n            if (i < j) {\n              chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord3.source = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n            } else {\n              chord3 = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });\n              chord3.target = { index: i, startAngle: x4, endAngle: x4 += matrix[i * n + j] * k2, value: matrix[i * n + j] };\n              if (i === j)\n                chord3.source = chord3.target;\n            }\n            if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {\n              const source = chord3.source;\n              chord3.source = chord3.target;\n              chord3.target = source;\n            }\n          }\n          groups2[i] = { index: i, startAngle: x06, endAngle: x4, value: groupSums[i] };\n        }\n        x4 += dx;\n      }\n    }\n    chords = Object.values(chords);\n    chords.groups = groups2;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n  chord2.padAngle = function(_) {\n    return arguments.length ? (padAngle = max3(0, _), chord2) : padAngle;\n  };\n  chord2.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord2) : sortGroups;\n  };\n  chord2.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord2) : sortSubgroups;\n  };\n  chord2.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord2) : sortChords && sortChords._;\n  };\n  return chord2;\n}\n\n// node_modules/d3-path/src/path.js\nvar pi3 = Math.PI;\nvar tau3 = 2 * pi3;\nvar epsilon4 = 1e-6;\nvar tauEpsilon = tau3 - epsilon4;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new Error(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append;\n  const k2 = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n    }\n  };\n}\nvar Path = class {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x4, y4) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x4, y4) {\n    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  quadraticCurveTo(x12, y12, x4, y4) {\n    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  bezierCurveTo(x12, y12, x22, y22, x4, y4) {\n    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arcTo(x12, y12, x22, y22, r) {\n    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x12},${this._y1 = y12}`;\n    } else if (!(l01_2 > epsilon4))\n      ;\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon4) || !r) {\n      this._append`L${this._x1 = x12},${this._y1 = y12}`;\n    } else {\n      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;\n      if (Math.abs(t01 - 1) > epsilon4) {\n        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;\n      }\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;\n    }\n  }\n  arc(x4, y4, r, a0, a1, ccw) {\n    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;\n    if (r < 0)\n      throw new Error(`negative radius: ${r}`);\n    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;\n    if (this._x1 === null) {\n      this._append`M${x06},${y06}`;\n    } else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) {\n      this._append`L${x06},${y06}`;\n    }\n    if (!r)\n      return;\n    if (da2 < 0)\n      da2 = da2 % tau3 + tau3;\n    if (da2 > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;\n    } else if (da2 > epsilon4) {\n      this._append`A${r},${r},0,${+(da2 >= pi3)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x4, y4, w, h) {\n    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n};\nfunction path() {\n  return new Path();\n}\npath.prototype = Path.prototype;\nfunction pathRound(digits = 3) {\n  return new Path(+digits);\n}\n\n// node_modules/d3-chord/src/array.js\nvar slice2 = Array.prototype.slice;\n\n// node_modules/d3-chord/src/constant.js\nfunction constant_default5(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-chord/src/ribbon.js\nfunction defaultSource(d) {\n  return d.source;\n}\nfunction defaultTarget(d) {\n  return d.target;\n}\nfunction defaultRadius(d) {\n  return d.radius;\n}\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\nfunction defaultPadAngle() {\n  return 0;\n}\nfunction defaultArrowheadRadius() {\n  return 10;\n}\nfunction ribbon(headRadius) {\n  var source = defaultSource, target = defaultTarget, sourceRadius = defaultRadius, targetRadius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;\n  function ribbon2() {\n    var buffer, s2 = source.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice2.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi2, sa1 = endAngle.apply(this, argv) - halfPi2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi2, ta1 = endAngle.apply(this, argv) - halfPi2;\n    if (!context)\n      context = buffer = path();\n    if (ap > epsilon3) {\n      if (abs2(sa1 - sa0) > ap * 2 + epsilon3)\n        sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);\n      else\n        sa0 = sa1 = (sa0 + sa1) / 2;\n      if (abs2(ta1 - ta0) > ap * 2 + epsilon3)\n        ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);\n      else\n        ta0 = ta1 = (ta0 + ta1) / 2;\n    }\n    context.moveTo(sr * cos(sa0), sr * sin(sa0));\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) {\n      if (headRadius) {\n        var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;\n        context.quadraticCurveTo(0, 0, tr2 * cos(ta0), tr2 * sin(ta0));\n        context.lineTo(tr * cos(ta2), tr * sin(ta2));\n        context.lineTo(tr2 * cos(ta1), tr2 * sin(ta1));\n      } else {\n        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n        context.arc(0, 0, tr, ta0, ta1);\n      }\n    }\n    context.quadraticCurveTo(0, 0, sr * cos(sa0), sr * sin(sa0));\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  if (headRadius)\n    ribbon2.headRadius = function(_) {\n      return arguments.length ? (headRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : headRadius;\n    };\n  ribbon2.radius = function(_) {\n    return arguments.length ? (sourceRadius = targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.sourceRadius = function(_) {\n    return arguments.length ? (sourceRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : sourceRadius;\n  };\n  ribbon2.targetRadius = function(_) {\n    return arguments.length ? (targetRadius = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : targetRadius;\n  };\n  ribbon2.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : startAngle;\n  };\n  ribbon2.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : endAngle;\n  };\n  ribbon2.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default5(+_), ribbon2) : padAngle;\n  };\n  ribbon2.source = function(_) {\n    return arguments.length ? (source = _, ribbon2) : source;\n  };\n  ribbon2.target = function(_) {\n    return arguments.length ? (target = _, ribbon2) : target;\n  };\n  ribbon2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, ribbon2) : context;\n  };\n  return ribbon2;\n}\nfunction ribbon_default() {\n  return ribbon();\n}\nfunction ribbonArrow() {\n  return ribbon(defaultArrowheadRadius);\n}\n\n// node_modules/d3-contour/src/array.js\nvar array3 = Array.prototype;\nvar slice3 = array3.slice;\n\n// node_modules/d3-contour/src/ascending.js\nfunction ascending_default(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/d3-contour/src/area.js\nfunction area_default(ring) {\n  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n)\n    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area2;\n}\n\n// node_modules/d3-contour/src/constant.js\nvar constant_default6 = (x4) => () => x4;\n\n// node_modules/d3-contour/src/contains.js\nfunction contains_default(ring, hole) {\n  var i = -1, n = hole.length, c6;\n  while (++i < n)\n    if (c6 = ringContains(ring, hole[i]))\n      return c6;\n  return 0;\n}\nfunction ringContains(ring, point6) {\n  var x4 = point6[0], y4 = point6[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi7 = ring[i], xi = pi7[0], yi = pi7[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi7, pj, point6))\n      return 0;\n    if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)\n      contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a4, b, c6) {\n  var i;\n  return collinear(a4, b, c6) && within(a4[i = +(a4[0] === b[0])], c6[i], b[i]);\n}\nfunction collinear(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) === (c6[0] - a4[0]) * (b[1] - a4[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\n// node_modules/d3-contour/src/noop.js\nfunction noop_default() {\n}\n\n// node_modules/d3-contour/src/contours.js\nvar cases = [\n  [],\n  [[[1, 1.5], [0.5, 1]]],\n  [[[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [0.5, 1]]],\n  [[[1, 0.5], [1.5, 1]]],\n  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],\n  [[[1, 0.5], [1, 1.5]]],\n  [[[1, 0.5], [0.5, 1]]],\n  [[[0.5, 1], [1, 0.5]]],\n  [[[1, 1.5], [1, 0.5]]],\n  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],\n  [[[1.5, 1], [1, 0.5]]],\n  [[[0.5, 1], [1.5, 1]]],\n  [[[1, 1.5], [1.5, 1]]],\n  [[[0.5, 1], [1, 1.5]]],\n  []\n];\nfunction contours_default() {\n  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;\n  function contours(values2) {\n    var tz = threshold2(values2);\n    if (!Array.isArray(tz)) {\n      const e = extent(values2, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1])\n        tz.pop();\n      while (tz[1] < e[0])\n        tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending_default);\n    }\n    return tz.map((value) => contour2(values2, value));\n  }\n  function contour2(values2, value) {\n    const v2 = value == null ? NaN : +value;\n    if (isNaN(v2))\n      throw new Error(`invalid value: ${value}`);\n    var polygons = [], holes = [];\n    isorings(values2, v2, function(ring) {\n      smooth(ring, values2, v2);\n      if (area_default(ring) > 0)\n        polygons.push([ring]);\n      else\n        holes.push(ring);\n    });\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: \"MultiPolygon\",\n      value,\n      coordinates: polygons\n    };\n  }\n  function isorings(values2, value, callback) {\n    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x4, y4, t03, t13, t22, t32;\n    x4 = y4 = -1;\n    t13 = above(values2[0], value);\n    cases[t13 << 1].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t03 = t13, t13 = above(values2[x4 + 1], value);\n      cases[t03 | t13 << 1].forEach(stitch);\n    }\n    cases[t13 << 0].forEach(stitch);\n    while (++y4 < dy - 1) {\n      x4 = -1;\n      t13 = above(values2[y4 * dx + dx], value);\n      t22 = above(values2[y4 * dx], value);\n      cases[t13 << 1 | t22 << 2].forEach(stitch);\n      while (++x4 < dx - 1) {\n        t03 = t13, t13 = above(values2[y4 * dx + dx + x4 + 1], value);\n        t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);\n      }\n      cases[t13 | t22 << 3].forEach(stitch);\n    }\n    x4 = -1;\n    t22 = values2[y4 * dx] >= value;\n    cases[t22 << 2].forEach(stitch);\n    while (++x4 < dx - 1) {\n      t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);\n      cases[t22 << 2 | t32 << 3].forEach(stitch);\n    }\n    cases[t22 << 3].forEach(stitch);\n    function stitch(line2) {\n      var start2 = [line2[0][0] + x4, line2[0][1] + y4], end = [line2[1][0] + x4, line2[1][1] + y4], startIndex = index3(start2), endIndex = index3(end), f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start2);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };\n      }\n    }\n  }\n  function index3(point6) {\n    return point6[0] * 2 + point6[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values2, value) {\n    ring.forEach(function(point6) {\n      var x4 = point6[0], y4 = point6[1], xt = x4 | 0, yt = y4 | 0, v1 = valid(values2[yt * dx + xt]);\n      if (x4 > 0 && x4 < dx && xt === x4) {\n        point6[0] = smooth1(x4, valid(values2[yt * dx + xt - 1]), v1, value);\n      }\n      if (y4 > 0 && y4 < dy && yt === y4) {\n        point6[1] = smooth1(y4, valid(values2[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n  contours.contour = contour2;\n  contours.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), contours) : threshold2;\n  };\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction finite(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction above(x4, value) {\n  return x4 == null ? false : +x4 >= value;\n}\nfunction valid(v2) {\n  return v2 == null || isNaN(v2 = +v2) ? -Infinity : v2;\n}\nfunction smooth1(x4, v0, v1, value) {\n  const a4 = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a4) || isFinite(b) ? a4 / b : Math.sign(a4) / Math.sign(b);\n  return isNaN(d) ? x4 : x4 + d - 0.5;\n}\n\n// node_modules/d3-contour/src/density.js\nfunction defaultX(d) {\n  return d[0];\n}\nfunction defaultY(d) {\n  return d[1];\n}\nfunction defaultWeight() {\n  return 1;\n}\nfunction density_default() {\n  var x4 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m3 = dy + o * 2 >> k2, threshold2 = constant_default6(20);\n  function grid(data) {\n    var values2 = new Float32Array(n * m3), pow2k = Math.pow(2, -k2), i = -1;\n    for (const d of data) {\n      var xi = (x4(d, ++i, data) + o) * pow2k, yi = (y4(d, i, data) + o) * pow2k, wi = +weight(d, i, data);\n      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m3) {\n        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;\n        values2[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;\n        values2[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;\n        values2[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;\n        values2[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;\n      }\n    }\n    blur2({ data: values2, width: n, height: m3 }, r * pow2k);\n    return values2;\n  }\n  function density2(data) {\n    var values2 = grid(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k2);\n    if (!Array.isArray(tz)) {\n      tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);\n    }\n    return contours_default().size([n, m3]).thresholds(tz.map((d) => d * pow4k))(values2).map((c6, i) => (c6.value = +tz[i], transform2(c6)));\n  }\n  density2.contours = function(data) {\n    var values2 = grid(data), contours = contours_default().size([n, m3]), pow4k = Math.pow(2, 2 * k2), contour2 = (value) => {\n      value = +value;\n      var c6 = transform2(contours.contour(values2, value * pow4k));\n      c6.value = value;\n      return c6;\n    };\n    Object.defineProperty(contour2, \"max\", { get: () => max(values2) / pow4k });\n    return contour2;\n  };\n  function transform2(geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  }\n  function transformPolygon(coordinates2) {\n    coordinates2.forEach(transformRing);\n  }\n  function transformRing(coordinates2) {\n    coordinates2.forEach(transformPoint);\n  }\n  function transformPoint(coordinates2) {\n    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;\n    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;\n  }\n  function resize() {\n    o = r * 3;\n    n = dx + o * 2 >> k2;\n    m3 = dy + o * 2 >> k2;\n    return density2;\n  }\n  density2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : x4;\n  };\n  density2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : y4;\n  };\n  density2.weight = function(_) {\n    return arguments.length ? (weight = typeof _ === \"function\" ? _ : constant_default6(+_), density2) : weight;\n  };\n  density2.size = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    var _0 = +_[0], _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0))\n      throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, resize();\n  };\n  density2.cellSize = function(_) {\n    if (!arguments.length)\n      return 1 << k2;\n    if (!((_ = +_) >= 1))\n      throw new Error(\"invalid cell size\");\n    return k2 = Math.floor(Math.log(_) / Math.LN2), resize();\n  };\n  density2.thresholds = function(_) {\n    return arguments.length ? (threshold2 = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant_default6(slice3.call(_)) : constant_default6(_), density2) : threshold2;\n  };\n  density2.bandwidth = function(_) {\n    if (!arguments.length)\n      return Math.sqrt(r * (r + 1));\n    if (!((_ = +_) >= 0))\n      throw new Error(\"invalid bandwidth\");\n    return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();\n  };\n  return density2;\n}\n\n// node_modules/robust-predicates/esm/util.js\nvar epsilon5 = 11102230246251565e-32;\nvar splitter = 134217729;\nvar resulterrbound = (3 + 8 * epsilon5) * epsilon5;\nfunction sum2(elen, e, flen, f, h) {\n  let Q, Qnew, hh, bvirt;\n  let enow = e[0];\n  let fnow = f[0];\n  let eindex = 0;\n  let findex = 0;\n  if (fnow > enow === fnow > -enow) {\n    Q = enow;\n    enow = e[++eindex];\n  } else {\n    Q = fnow;\n    fnow = f[++findex];\n  }\n  let hindex = 0;\n  if (eindex < elen && findex < flen) {\n    if (fnow > enow === fnow > -enow) {\n      Qnew = enow + Q;\n      hh = Q - (Qnew - enow);\n      enow = e[++eindex];\n    } else {\n      Qnew = fnow + Q;\n      hh = Q - (Qnew - fnow);\n      fnow = f[++findex];\n    }\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n    while (eindex < elen && findex < flen) {\n      if (fnow > enow === fnow > -enow) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n      } else {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n      }\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n    }\n  }\n  while (eindex < elen) {\n    Qnew = Q + enow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (enow - bvirt);\n    enow = e[++eindex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  while (findex < flen) {\n    Qnew = Q + fnow;\n    bvirt = Qnew - Q;\n    hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n    fnow = f[++findex];\n    Q = Qnew;\n    if (hh !== 0) {\n      h[hindex++] = hh;\n    }\n  }\n  if (Q !== 0 || hindex === 0) {\n    h[hindex++] = Q;\n  }\n  return hindex;\n}\nfunction estimate(elen, e) {\n  let Q = e[0];\n  for (let i = 1; i < elen; i++)\n    Q += e[i];\n  return Q;\n}\nfunction vec(n) {\n  return new Float64Array(n);\n}\n\n// node_modules/robust-predicates/esm/orient2d.js\nvar ccwerrboundA = (3 + 16 * epsilon5) * epsilon5;\nvar ccwerrboundB = (2 + 12 * epsilon5) * epsilon5;\nvar ccwerrboundC = (9 + 64 * epsilon5) * epsilon5 * epsilon5;\nvar B2 = vec(4);\nvar C1 = vec(8);\nvar C2 = vec(12);\nvar D2 = vec(16);\nvar u = vec(4);\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n  let acxtail, acytail, bcxtail, bcytail;\n  let bvirt, c6, ahi, alo, bhi, blo, _i, _j2, _0, s1, s0, t13, t03, u33;\n  const acx = ax - cx;\n  const bcx = bx - cx;\n  const acy = ay - cy;\n  const bcy = by - cy;\n  s1 = acx * bcy;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcx;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  B2[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  B2[3] = u33;\n  let det = estimate(4, B2);\n  let errbound = ccwerrboundB * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return det;\n  }\n  bvirt = ax - acx;\n  acxtail = ax - (acx + bvirt) + (bvirt - cx);\n  bvirt = bx - bcx;\n  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n  bvirt = ay - acy;\n  acytail = ay - (acy + bvirt) + (bvirt - cy);\n  bvirt = by - bcy;\n  bcytail = by - (bcy + bvirt) + (bvirt - cy);\n  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n    return det;\n  }\n  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n  if (det >= errbound || -det >= errbound)\n    return det;\n  s1 = acxtail * bcy;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcy;\n  bhi = c6 - (c6 - bcy);\n  blo = bcy - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcx;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcx;\n  bhi = c6 - (c6 - bcx);\n  blo = bcx - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C1len = sum2(4, B2, 4, u, C1);\n  s1 = acx * bcytail;\n  c6 = splitter * acx;\n  ahi = c6 - (c6 - acx);\n  alo = acx - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acy * bcxtail;\n  c6 = splitter * acy;\n  ahi = c6 - (c6 - acy);\n  alo = acy - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const C2len = sum2(C1len, C1, 4, u, C2);\n  s1 = acxtail * bcytail;\n  c6 = splitter * acxtail;\n  ahi = c6 - (c6 - acxtail);\n  alo = acxtail - ahi;\n  c6 = splitter * bcytail;\n  bhi = c6 - (c6 - bcytail);\n  blo = bcytail - bhi;\n  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n  t13 = acytail * bcxtail;\n  c6 = splitter * acytail;\n  ahi = c6 - (c6 - acytail);\n  alo = acytail - ahi;\n  c6 = splitter * bcxtail;\n  bhi = c6 - (c6 - bcxtail);\n  blo = bcxtail - bhi;\n  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);\n  _i = s0 - t03;\n  bvirt = s0 - _i;\n  u[0] = s0 - (_i + bvirt) + (bvirt - t03);\n  _j2 = s1 + _i;\n  bvirt = _j2 - s1;\n  _0 = s1 - (_j2 - bvirt) + (_i - bvirt);\n  _i = _0 - t13;\n  bvirt = _0 - _i;\n  u[1] = _0 - (_i + bvirt) + (bvirt - t13);\n  u33 = _j2 + _i;\n  bvirt = u33 - _j2;\n  u[2] = _j2 - (u33 - bvirt) + (_i - bvirt);\n  u[3] = u33;\n  const Dlen = sum2(C2len, C2, 4, u, D2);\n  return D2[Dlen - 1];\n}\nfunction orient2d(ax, ay, bx, by, cx, cy) {\n  const detleft = (ay - cy) * (bx - cx);\n  const detright = (ax - cx) * (by - cy);\n  const det = detleft - detright;\n  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)\n    return det;\n  const detsum = Math.abs(detleft + detright);\n  if (Math.abs(det) >= ccwerrboundA * detsum)\n    return det;\n  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\n// node_modules/robust-predicates/esm/orient3d.js\nvar o3derrboundA = (7 + 56 * epsilon5) * epsilon5;\nvar o3derrboundB = (3 + 28 * epsilon5) * epsilon5;\nvar o3derrboundC = (26 + 288 * epsilon5) * epsilon5 * epsilon5;\nvar bc = vec(4);\nvar ca = vec(4);\nvar ab = vec(4);\nvar at_b = vec(4);\nvar at_c = vec(4);\nvar bt_c = vec(4);\nvar bt_a = vec(4);\nvar ct_a = vec(4);\nvar ct_b = vec(4);\nvar bct = vec(8);\nvar cat = vec(8);\nvar abt = vec(8);\nvar u2 = vec(4);\nvar _8 = vec(8);\nvar _8b = vec(8);\nvar _16 = vec(8);\nvar _12 = vec(12);\nvar fin = vec(192);\nvar fin2 = vec(192);\n\n// node_modules/robust-predicates/esm/incircle.js\nvar iccerrboundA = (10 + 96 * epsilon5) * epsilon5;\nvar iccerrboundB = (4 + 48 * epsilon5) * epsilon5;\nvar iccerrboundC = (44 + 576 * epsilon5) * epsilon5 * epsilon5;\nvar bc2 = vec(4);\nvar ca2 = vec(4);\nvar ab2 = vec(4);\nvar aa = vec(4);\nvar bb = vec(4);\nvar cc = vec(4);\nvar u3 = vec(4);\nvar v = vec(4);\nvar axtbc = vec(8);\nvar aytbc = vec(8);\nvar bxtca = vec(8);\nvar bytca = vec(8);\nvar cxtab = vec(8);\nvar cytab = vec(8);\nvar abt2 = vec(8);\nvar bct2 = vec(8);\nvar cat2 = vec(8);\nvar abtt = vec(4);\nvar bctt = vec(4);\nvar catt = vec(4);\nvar _82 = vec(8);\nvar _162 = vec(16);\nvar _16b = vec(16);\nvar _16c = vec(16);\nvar _32 = vec(32);\nvar _32b = vec(32);\nvar _48 = vec(48);\nvar _64 = vec(64);\nvar fin3 = vec(1152);\nvar fin22 = vec(1152);\n\n// node_modules/robust-predicates/esm/insphere.js\nvar isperrboundA = (16 + 224 * epsilon5) * epsilon5;\nvar isperrboundB = (5 + 72 * epsilon5) * epsilon5;\nvar isperrboundC = (71 + 1408 * epsilon5) * epsilon5 * epsilon5;\nvar ab3 = vec(4);\nvar bc3 = vec(4);\nvar cd = vec(4);\nvar de = vec(4);\nvar ea = vec(4);\nvar ac = vec(4);\nvar bd = vec(4);\nvar ce = vec(4);\nvar da = vec(4);\nvar eb = vec(4);\nvar abc = vec(24);\nvar bcd = vec(24);\nvar cde = vec(24);\nvar dea = vec(24);\nvar eab = vec(24);\nvar abd = vec(24);\nvar bce = vec(24);\nvar cda = vec(24);\nvar deb = vec(24);\nvar eac = vec(24);\nvar adet = vec(1152);\nvar bdet = vec(1152);\nvar cdet = vec(1152);\nvar ddet = vec(1152);\nvar edet = vec(1152);\nvar abdet = vec(2304);\nvar cddet = vec(2304);\nvar cdedet = vec(3456);\nvar deter = vec(5760);\nvar _83 = vec(8);\nvar _8b2 = vec(8);\nvar _8c = vec(8);\nvar _163 = vec(16);\nvar _24 = vec(24);\nvar _482 = vec(48);\nvar _48b = vec(48);\nvar _96 = vec(96);\nvar _192 = vec(192);\nvar _384x = vec(384);\nvar _384y = vec(384);\nvar _384z = vec(384);\nvar _768 = vec(768);\nvar xdet = vec(96);\nvar ydet = vec(96);\nvar zdet = vec(96);\nvar fin4 = vec(1152);\n\n// node_modules/delaunator/index.js\nvar EPSILON = Math.pow(2, -52);\nvar EDGE_STACK = new Uint32Array(512);\nvar Delaunator = class {\n  static from(points, getX = defaultGetX, getY = defaultGetY) {\n    const n = points.length;\n    const coords = new Float64Array(n * 2);\n    for (let i = 0; i < n; i++) {\n      const p = points[i];\n      coords[2 * i] = getX(p);\n      coords[2 * i + 1] = getY(p);\n    }\n    return new Delaunator(coords);\n  }\n  constructor(coords) {\n    const n = coords.length >> 1;\n    if (n > 0 && typeof coords[0] !== \"number\")\n      throw new Error(\"Expected coords to contain numbers.\");\n    this.coords = coords;\n    const maxTriangles = Math.max(2 * n - 5, 0);\n    this._triangles = new Uint32Array(maxTriangles * 3);\n    this._halfedges = new Int32Array(maxTriangles * 3);\n    this._hashSize = Math.ceil(Math.sqrt(n));\n    this._hullPrev = new Uint32Array(n);\n    this._hullNext = new Uint32Array(n);\n    this._hullTri = new Uint32Array(n);\n    this._hullHash = new Int32Array(this._hashSize).fill(-1);\n    this._ids = new Uint32Array(n);\n    this._dists = new Float64Array(n);\n    this.update();\n  }\n  update() {\n    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;\n    const n = coords.length >> 1;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY2 = -Infinity;\n    for (let i = 0; i < n; i++) {\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (x4 < minX)\n        minX = x4;\n      if (y4 < minY)\n        minY = y4;\n      if (x4 > maxX)\n        maxX = x4;\n      if (y4 > maxY2)\n        maxY2 = y4;\n      this._ids[i] = i;\n    }\n    const cx = (minX + maxX) / 2;\n    const cy = (minY + maxY2) / 2;\n    let minDist = Infinity;\n    let i0, i1, i2;\n    for (let i = 0; i < n; i++) {\n      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist) {\n        i0 = i;\n        minDist = d;\n      }\n    }\n    const i0x = coords[2 * i0];\n    const i0y = coords[2 * i0 + 1];\n    minDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0)\n        continue;\n      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n      if (d < minDist && d > 0) {\n        i1 = i;\n        minDist = d;\n      }\n    }\n    let i1x = coords[2 * i1];\n    let i1y = coords[2 * i1 + 1];\n    let minRadius = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (i === i0 || i === i1)\n        continue;\n      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n      if (r < minRadius) {\n        i2 = i;\n        minRadius = r;\n      }\n    }\n    let i2x = coords[2 * i2];\n    let i2y = coords[2 * i2 + 1];\n    if (minRadius === Infinity) {\n      for (let i = 0; i < n; i++) {\n        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];\n      }\n      quicksort(this._ids, this._dists, 0, n - 1);\n      const hull2 = new Uint32Array(n);\n      let j = 0;\n      for (let i = 0, d0 = -Infinity; i < n; i++) {\n        const id2 = this._ids[i];\n        if (this._dists[id2] > d0) {\n          hull2[j++] = id2;\n          d0 = this._dists[id2];\n        }\n      }\n      this.hull = hull2.subarray(0, j);\n      this.triangles = new Uint32Array(0);\n      this.halfedges = new Uint32Array(0);\n      return;\n    }\n    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n      const i = i1;\n      const x4 = i1x;\n      const y4 = i1y;\n      i1 = i2;\n      i1x = i2x;\n      i1y = i2y;\n      i2 = i;\n      i2x = x4;\n      i2y = y4;\n    }\n    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n    this._cx = center2.x;\n    this._cy = center2.y;\n    for (let i = 0; i < n; i++) {\n      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);\n    }\n    quicksort(this._ids, this._dists, 0, n - 1);\n    this._hullStart = i0;\n    let hullSize = 3;\n    hullNext[i0] = hullPrev[i2] = i1;\n    hullNext[i1] = hullPrev[i0] = i2;\n    hullNext[i2] = hullPrev[i1] = i0;\n    hullTri[i0] = 0;\n    hullTri[i1] = 1;\n    hullTri[i2] = 2;\n    hullHash.fill(-1);\n    hullHash[this._hashKey(i0x, i0y)] = i0;\n    hullHash[this._hashKey(i1x, i1y)] = i1;\n    hullHash[this._hashKey(i2x, i2y)] = i2;\n    this.trianglesLen = 0;\n    this._addTriangle(i0, i1, i2, -1, -1, -1);\n    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {\n      const i = this._ids[k2];\n      const x4 = coords[2 * i];\n      const y4 = coords[2 * i + 1];\n      if (k2 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)\n        continue;\n      xp = x4;\n      yp = y4;\n      if (i === i0 || i === i1 || i === i2)\n        continue;\n      let start2 = 0;\n      for (let j = 0, key = this._hashKey(x4, y4); j < this._hashSize; j++) {\n        start2 = hullHash[(key + j) % this._hashSize];\n        if (start2 !== -1 && start2 !== hullNext[start2])\n          break;\n      }\n      start2 = hullPrev[start2];\n      let e = start2, q;\n      while (q = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n        e = q;\n        if (e === start2) {\n          e = -1;\n          break;\n        }\n      }\n      if (e === -1)\n        continue;\n      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n      hullTri[i] = this._legalize(t + 2);\n      hullTri[e] = t;\n      hullSize++;\n      let n2 = hullNext[e];\n      while (q = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);\n        hullTri[i] = this._legalize(t + 2);\n        hullNext[n2] = n2;\n        hullSize--;\n        n2 = q;\n      }\n      if (e === start2) {\n        while (q = hullPrev[e], orient2d(x4, y4, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n          this._legalize(t + 2);\n          hullTri[q] = t;\n          hullNext[e] = e;\n          hullSize--;\n          e = q;\n        }\n      }\n      this._hullStart = hullPrev[i] = e;\n      hullNext[e] = hullPrev[n2] = i;\n      hullNext[i] = n2;\n      hullHash[this._hashKey(x4, y4)] = i;\n      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n    }\n    this.hull = new Uint32Array(hullSize);\n    for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n      this.hull[i] = e;\n      e = hullNext[e];\n    }\n    this.triangles = this._triangles.subarray(0, this.trianglesLen);\n    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n  }\n  _hashKey(x4, y4) {\n    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;\n  }\n  _legalize(a4) {\n    const { _triangles: triangles, _halfedges: halfedges, coords } = this;\n    let i = 0;\n    let ar = 0;\n    while (true) {\n      const b = halfedges[a4];\n      const a0 = a4 - a4 % 3;\n      ar = a0 + (a4 + 2) % 3;\n      if (b === -1) {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n        continue;\n      }\n      const b02 = b - b % 3;\n      const al = a0 + (a4 + 1) % 3;\n      const bl = b02 + (b + 2) % 3;\n      const p02 = triangles[ar];\n      const pr = triangles[a4];\n      const pl = triangles[al];\n      const p1 = triangles[bl];\n      const illegal = inCircle(\n        coords[2 * p02],\n        coords[2 * p02 + 1],\n        coords[2 * pr],\n        coords[2 * pr + 1],\n        coords[2 * pl],\n        coords[2 * pl + 1],\n        coords[2 * p1],\n        coords[2 * p1 + 1]\n      );\n      if (illegal) {\n        triangles[a4] = p1;\n        triangles[b] = p02;\n        const hbl = halfedges[bl];\n        if (hbl === -1) {\n          let e = this._hullStart;\n          do {\n            if (this._hullTri[e] === bl) {\n              this._hullTri[e] = a4;\n              break;\n            }\n            e = this._hullPrev[e];\n          } while (e !== this._hullStart);\n        }\n        this._link(a4, hbl);\n        this._link(b, halfedges[ar]);\n        this._link(ar, bl);\n        const br = b02 + (b + 1) % 3;\n        if (i < EDGE_STACK.length) {\n          EDGE_STACK[i++] = br;\n        }\n      } else {\n        if (i === 0)\n          break;\n        a4 = EDGE_STACK[--i];\n      }\n    }\n    return ar;\n  }\n  _link(a4, b) {\n    this._halfedges[a4] = b;\n    if (b !== -1)\n      this._halfedges[b] = a4;\n  }\n  // add a new triangle given vertex indices and adjacent half-edge ids\n  _addTriangle(i0, i1, i2, a4, b, c6) {\n    const t = this.trianglesLen;\n    this._triangles[t] = i0;\n    this._triangles[t + 1] = i1;\n    this._triangles[t + 2] = i2;\n    this._link(t, a4);\n    this._link(t + 1, b);\n    this._link(t + 2, c6);\n    this.trianglesLen += 3;\n    return t;\n  }\n};\nfunction pseudoAngle(dx, dy) {\n  const p = dx / (Math.abs(dx) + Math.abs(dy));\n  return (dy > 0 ? 3 - p : 1 + p) / 4;\n}\nfunction dist(ax, ay, bx, by) {\n  const dx = ax - bx;\n  const dy = ay - by;\n  return dx * dx + dy * dy;\n}\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n  const dx = ax - px;\n  const dy = ay - py;\n  const ex = bx - px;\n  const ey = by - py;\n  const fx = cx - px;\n  const fy = cy - py;\n  const ap = dx * dx + dy * dy;\n  const bp = ex * ex + ey * ey;\n  const cp = fx * fx + fy * fy;\n  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n}\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = (ey * bl - dy * cl) * d;\n  const y4 = (dx * cl - ex * bl) * d;\n  return x4 * x4 + y4 * y4;\n}\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const ex = cx - ax;\n  const ey = cy - ay;\n  const bl = dx * dx + dy * dy;\n  const cl = ex * ex + ey * ey;\n  const d = 0.5 / (dx * ey - dy * ex);\n  const x4 = ax + (ey * bl - dy * cl) * d;\n  const y4 = ay + (dx * cl - ex * bl) * d;\n  return { x: x4, y: y4 };\n}\nfunction quicksort(ids, dists, left2, right2) {\n  if (right2 - left2 <= 20) {\n    for (let i = left2 + 1; i <= right2; i++) {\n      const temp = ids[i];\n      const tempDist = dists[temp];\n      let j = i - 1;\n      while (j >= left2 && dists[ids[j]] > tempDist)\n        ids[j + 1] = ids[j--];\n      ids[j + 1] = temp;\n    }\n  } else {\n    const median2 = left2 + right2 >> 1;\n    let i = left2 + 1;\n    let j = right2;\n    swap2(ids, median2, i);\n    if (dists[ids[left2]] > dists[ids[right2]])\n      swap2(ids, left2, right2);\n    if (dists[ids[i]] > dists[ids[right2]])\n      swap2(ids, i, right2);\n    if (dists[ids[left2]] > dists[ids[i]])\n      swap2(ids, left2, i);\n    const temp = ids[i];\n    const tempDist = dists[temp];\n    while (true) {\n      do\n        i++;\n      while (dists[ids[i]] < tempDist);\n      do\n        j--;\n      while (dists[ids[j]] > tempDist);\n      if (j < i)\n        break;\n      swap2(ids, i, j);\n    }\n    ids[left2 + 1] = ids[j];\n    ids[j] = temp;\n    if (right2 - i + 1 >= j - left2) {\n      quicksort(ids, dists, i, right2);\n      quicksort(ids, dists, left2, j - 1);\n    } else {\n      quicksort(ids, dists, left2, j - 1);\n      quicksort(ids, dists, i, right2);\n    }\n  }\n}\nfunction swap2(arr, i, j) {\n  const tmp2 = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp2;\n}\nfunction defaultGetX(p) {\n  return p[0];\n}\nfunction defaultGetY(p) {\n  return p[1];\n}\n\n// node_modules/d3-delaunay/src/path.js\nvar epsilon6 = 1e-6;\nvar Path2 = class {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null;\n    this._ = \"\";\n  }\n  moveTo(x4, y4) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x4, y4) {\n    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;\n  }\n  arc(x4, y4, r) {\n    x4 = +x4, y4 = +y4, r = +r;\n    const x06 = x4 + r;\n    const y06 = y4;\n    if (r < 0)\n      throw new Error(\"negative radius\");\n    if (this._x1 === null)\n      this._ += `M${x06},${y06}`;\n    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)\n      this._ += \"L\" + x06 + \",\" + y06;\n    if (!r)\n      return;\n    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;\n  }\n  rect(x4, y4, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n};\n\n// node_modules/d3-delaunay/src/polygon.js\nvar Polygon = class {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x4, y4) {\n    this._.push([x4, y4]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n};\n\n// node_modules/d3-delaunay/src/voronoi.js\nvar Voronoi = class {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))\n      throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const { delaunay: { points, hull: hull2, triangles }, vectors } = this;\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x4, y4; i < n; i += 3, j += 2) {\n      const t13 = triangles[i] * 2;\n      const t22 = triangles[i + 1] * 2;\n      const t32 = triangles[i + 2] * 2;\n      const x13 = points[t13];\n      const y13 = points[t13 + 1];\n      const x22 = points[t22];\n      const y22 = points[t22 + 1];\n      const x32 = points[t32];\n      const y32 = points[t32 + 1];\n      const dx = x22 - x13;\n      const dy = y22 - y13;\n      const ex = x32 - x13;\n      const ey = y32 - y13;\n      const ab4 = (dx * ey - dy * ex) * 2;\n      if (Math.abs(ab4) < 1e-9) {\n        let a4 = 1e9;\n        const r = triangles[0] * 2;\n        a4 *= Math.sign((points[r] - x13) * ey - (points[r + 1] - y13) * ex);\n        x4 = (x13 + x32) / 2 - a4 * ey;\n        y4 = (y13 + y32) / 2 + a4 * ex;\n      } else {\n        const d = 1 / ab4;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x4 = x13 + (ey * bl - dy * cl) * d;\n        y4 = y13 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x4;\n      circumcenters[j + 1] = y4;\n    }\n    let h = hull2[hull2.length - 1];\n    let p02, p1 = h * 4;\n    let x06, x12 = points[2 * h];\n    let y06, y12 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull2.length; ++i) {\n      h = hull2[i];\n      p02 = p1, x06 = x12, y06 = y12;\n      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];\n      vectors[p02 + 2] = vectors[p1] = y06 - y12;\n      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { delaunay: { halfedges, inedges, hull: hull2 }, circumcenters, vectors } = this;\n    if (hull2.length <= 1)\n      return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull2[hull2.length - 1];\n    for (let i = 0; i < hull2.length; ++i) {\n      h0 = h1, h1 = hull2[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x4 = circumcenters[t];\n      const y4 = circumcenters[t + 1];\n      const v2 = h0 * 4;\n      const p = this._project(x4, y4, vectors[v2 + 2], vectors[v2 + 3]);\n      if (p)\n        this._renderSegment(x4, y4, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const points = this._clip(i);\n    if (points === null || !points.length)\n      return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)\n      n -= 2;\n    for (let i2 = 2; i2 < n; i2 += 2) {\n      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])\n        context.lineTo(points[i2], points[i2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const { delaunay: { points } } = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell2 = this.cellPolygon(i);\n      if (cell2)\n        cell2.index = i, yield cell2;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon();\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x06, y06, x12, y12, context) {\n    let S;\n    const c0 = this._regioncode(x06, y06);\n    const c1 = this._regioncode(x12, y12);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x06, y06);\n      context.lineTo(x12, y12);\n    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x4, y4) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return false;\n    return this.delaunay._step(i, x4, y4) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci)\n      for (const j of this.delaunay.neighbors(i)) {\n        const cj = this._clip(j);\n        if (cj)\n          loop:\n            for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {\n                  yield j;\n                  break loop;\n                }\n              }\n            }\n      }\n  }\n  _cell(i) {\n    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return null;\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null)\n      return null;\n    const { vectors: V } = this;\n    const v2 = i * 4;\n    return V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points);\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x06, y06, x12 = points[n - 2], y12 = points[n - 1];\n    let c0, c1 = this._regioncode(x12, y12);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x06 = x12, y06 = y12, x12 = points[j], y12 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x12, y12);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P)\n          P.push(x12, y12);\n        else\n          P = [x12, y12];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)\n            continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)\n            continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1)\n            this._edge(i, e0, e1, P, P.length);\n          if (P)\n            P.push(sx0, sy0);\n          else\n            P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1)\n          this._edge(i, e0, e1, P, P.length);\n        if (P)\n          P.push(sx1, sy1);\n        else\n          P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1)\n        this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x06, y06, x12, y12, c0, c1) {\n    while (true) {\n      if (c0 === 0 && c1 === 0)\n        return [x06, y06, x12, y12];\n      if (c0 & c1)\n        return null;\n      let x4, y4, c6 = c0 || c1;\n      if (c6 & 8)\n        x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;\n      else if (c6 & 4)\n        x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;\n      else if (c6 & 2)\n        y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;\n      else\n        y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;\n      if (c0)\n        x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);\n      else\n        x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0))\n      P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))\n      P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1)\n          j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x4, y4;\n      switch (e0) {\n        case 5:\n          e0 = 4;\n          continue;\n        case 4:\n          e0 = 6, x4 = this.xmax, y4 = this.ymin;\n          break;\n        case 6:\n          e0 = 2;\n          continue;\n        case 2:\n          e0 = 10, x4 = this.xmax, y4 = this.ymax;\n          break;\n        case 10:\n          e0 = 8;\n          continue;\n        case 8:\n          e0 = 9, x4 = this.xmin, y4 = this.ymax;\n          break;\n        case 9:\n          e0 = 1;\n          continue;\n        case 1:\n          e0 = 5, x4 = this.xmin, y4 = this.ymin;\n          break;\n      }\n      if ((P[j] !== x4 || P[j + 1] !== y4) && this.contains(i, x4, y4)) {\n        P.splice(j, 0, x4, y4), j += 2;\n      }\n    }\n    if (P.length > 4) {\n      for (let i2 = 0; i2 < P.length; i2 += 2) {\n        const j2 = (i2 + 2) % P.length, k2 = (i2 + 4) % P.length;\n        if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])\n          P.splice(j2, 2), i2 -= 2;\n      }\n    }\n    return j;\n  }\n  _project(x06, y06, vx, vy) {\n    let t = Infinity, c6, x4, y4;\n    if (vy < 0) {\n      if (y06 <= this.ymin)\n        return null;\n      if ((c6 = (this.ymin - y06) / vy) < t)\n        y4 = this.ymin, x4 = x06 + (t = c6) * vx;\n    } else if (vy > 0) {\n      if (y06 >= this.ymax)\n        return null;\n      if ((c6 = (this.ymax - y06) / vy) < t)\n        y4 = this.ymax, x4 = x06 + (t = c6) * vx;\n    }\n    if (vx > 0) {\n      if (x06 >= this.xmax)\n        return null;\n      if ((c6 = (this.xmax - x06) / vx) < t)\n        x4 = this.xmax, y4 = y06 + (t = c6) * vy;\n    } else if (vx < 0) {\n      if (x06 <= this.xmin)\n        return null;\n      if ((c6 = (this.xmin - x06) / vx) < t)\n        x4 = this.xmin, y4 = y06 + (t = c6) * vy;\n    }\n    return [x4, y4];\n  }\n  _edgecode(x4, y4) {\n    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);\n  }\n  _regioncode(x4, y4) {\n    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);\n  }\n};\n\n// node_modules/d3-delaunay/src/delaunay.js\nvar tau4 = 2 * Math.PI;\nvar pow = Math.pow;\nfunction pointX(p) {\n  return p[0];\n}\nfunction pointY(p) {\n  return p[1];\n}\nfunction collinear2(d) {\n  const { triangles, coords } = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a4 = 2 * triangles[i], b = 2 * triangles[i + 1], c6 = 2 * triangles[i + 2], cross2 = (coords[c6] - coords[a4]) * (coords[b + 1] - coords[a4 + 1]) - (coords[b] - coords[a4]) * (coords[c6 + 1] - coords[a4 + 1]);\n    if (cross2 > 1e-10)\n      return false;\n  }\n  return true;\n}\nfunction jitter(x4, y4, r) {\n  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];\n}\nvar Delaunay = class {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n    if (d.hull && d.hull.length > 2 && collinear2(d)) {\n      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull2 = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1)\n        inedges[p] = e;\n    }\n    for (let i = 0, n = hull2.length; i < n; ++i) {\n      hullIndex[hull2[i]] = i;\n    }\n    if (hull2.length <= 2 && hull2.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull2[0];\n      inedges[hull2[0]] = 1;\n      if (hull2.length === 2) {\n        inedges[hull2[1]] = 0;\n        this.triangles[1] = hull2[1];\n        this.triangles[2] = hull2[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;\n    if (collinear3) {\n      const l = collinear3.indexOf(i);\n      if (l > 0)\n        yield collinear3[l - 1];\n      if (l < collinear3.length - 1)\n        yield collinear3[l + 1];\n      return;\n    }\n    const e0 = inedges[i];\n    if (e0 === -1)\n      return;\n    let e = e0, p02 = -1;\n    do {\n      yield p02 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        return;\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (p !== p02)\n          yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x4, y4, i = 0) {\n    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))\n      return -1;\n    const i0 = i;\n    let c6;\n    while ((c6 = this._step(i, x4, y4)) >= 0 && c6 !== i && c6 !== i0)\n      i = c6;\n    return c6;\n  }\n  _step(i, x4, y4) {\n    const { inedges, hull: hull2, _hullIndex, halfedges, triangles, points } = this;\n    if (inedges[i] === -1 || !points.length)\n      return (i + 1) % (points.length >> 1);\n    let c6 = i;\n    let dc = pow(x4 - points[i * 2], 2) + pow(y4 - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x4 - points[t * 2], 2) + pow(y4 - points[t * 2 + 1], 2);\n      if (dt < dc)\n        dc = dt, c6 = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i)\n        break;\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull2[(_hullIndex[i] + 1) % hull2.length];\n        if (e !== t) {\n          if (pow(x4 - points[e * 2], 2) + pow(y4 - points[e * 2 + 1], 2) < dc)\n            return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c6;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, halfedges, triangles } = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i)\n        continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === void 0 && (!context || typeof context.moveTo !== \"function\"))\n      r = context, context = null;\n    r = r == void 0 ? 2 : +r;\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points } = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x4 = points[i], y4 = points[i + 1];\n      context.moveTo(x4 + r, y4);\n      context.arc(x4, y4, r, 0, tau4);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { hull: hull2, points } = this;\n    const h = hull2[0] * 2, n = hull2.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h2 = 2 * hull2[i];\n      context.lineTo(points[h2], points[h2 + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon();\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path2() : void 0;\n    const { points, triangles } = this;\n    const t03 = triangles[i *= 3] * 2;\n    const t13 = triangles[i + 1] * 2;\n    const t22 = triangles[i + 2] * 2;\n    context.moveTo(points[t03], points[t03 + 1]);\n    context.lineTo(points[t13], points[t13 + 1]);\n    context.lineTo(points[t22], points[t22 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const { triangles } = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon();\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n};\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array4 = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array4[i * 2] = fx.call(that, p, i, points);\n    array4[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array4;\n}\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n\n// node_modules/d3-dsv/src/dsv.js\nvar EOL = {};\nvar EOF = {};\nvar QUOTE = 34;\nvar NEWLINE = 10;\nvar RETURN = 13;\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + '] || \"\"';\n  }).join(\",\") + \"}\");\n}\nfunction customConverter(columns, f) {\n  var object2 = objectConverter(columns);\n  return function(row, i) {\n    return f(object2(row), i, columns);\n  };\n}\nfunction inferColumns(rows) {\n  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];\n  rows.forEach(function(row) {\n    for (var column2 in row) {\n      if (!(column2 in columnSet)) {\n        columns.push(columnSet[column2] = column2);\n      }\n    }\n  });\n  return columns;\n}\nfunction pad(value, width) {\n  var s2 = value + \"\", length4 = s2.length;\n  return length4 < width ? new Array(width - length4 + 1).join(0) + s2 : s2;\n}\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6) : year > 9999 ? \"+\" + pad(year, 6) : pad(year, 4);\n}\nfunction formatDate(date2) {\n  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();\n  return isNaN(date2) ? \"Invalid Date\" : formatYear(date2.getUTCFullYear(), 4) + \"-\" + pad(date2.getUTCMonth() + 1, 2) + \"-\" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \".\" + pad(milliseconds2, 3) + \"Z\" : seconds2 ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds2, 2) + \"Z\" : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\" : \"\");\n}\nfunction dsv_default(delimiter) {\n  var reFormat = new RegExp('[\"' + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0);\n  function parse2(text2, f) {\n    var convert, columns, rows = parseRows(text2, function(row, i) {\n      if (convert)\n        return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n  function parseRows(text2, f) {\n    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;\n    if (text2.charCodeAt(N - 1) === NEWLINE)\n      --N;\n    if (text2.charCodeAt(N - 1) === RETURN)\n      --N;\n    function token() {\n      if (eof)\n        return EOF;\n      if (eol)\n        return eol = false, EOL;\n      var i, j = I, c6;\n      if (text2.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)\n          ;\n        if ((i = I) >= N)\n          eof = true;\n        else if ((c6 = text2.charCodeAt(I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        }\n        return text2.slice(j + 1, i - 1).replace(/\"\"/g, '\"');\n      }\n      while (I < N) {\n        if ((c6 = text2.charCodeAt(i = I++)) === NEWLINE)\n          eol = true;\n        else if (c6 === RETURN) {\n          eol = true;\n          if (text2.charCodeAt(I) === NEWLINE)\n            ++I;\n        } else if (c6 !== DELIMITER)\n          continue;\n        return text2.slice(j, i);\n      }\n      return eof = true, text2.slice(j, N);\n    }\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF)\n        row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null)\n        continue;\n      rows.push(row);\n    }\n    return rows;\n  }\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column2) {\n        return formatValue(row[column2]);\n      }).join(delimiter);\n    });\n  }\n  function format3(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n  function formatBody(rows, columns) {\n    if (columns == null)\n      columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n  function formatValue(value) {\n    return value == null ? \"\" : value instanceof Date ? formatDate(value) : reFormat.test(value += \"\") ? '\"' + value.replace(/\"/g, '\"\"') + '\"' : value;\n  }\n  return {\n    parse: parse2,\n    parseRows,\n    format: format3,\n    formatBody,\n    formatRows,\n    formatRow,\n    formatValue\n  };\n}\n\n// node_modules/d3-dsv/src/csv.js\nvar csv = dsv_default(\",\");\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatBody = csv.formatBody;\nvar csvFormatRows = csv.formatRows;\nvar csvFormatRow = csv.formatRow;\nvar csvFormatValue = csv.formatValue;\n\n// node_modules/d3-dsv/src/tsv.js\nvar tsv = dsv_default(\"\t\");\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatBody = tsv.formatBody;\nvar tsvFormatRows = tsv.formatRows;\nvar tsvFormatRow = tsv.formatRow;\nvar tsvFormatValue = tsv.formatValue;\n\n// node_modules/d3-dsv/src/autoType.js\nfunction autoType(object2) {\n  for (var key in object2) {\n    var value = object2[key].trim(), number7, m3;\n    if (!value)\n      value = null;\n    else if (value === \"true\")\n      value = true;\n    else if (value === \"false\")\n      value = false;\n    else if (value === \"NaN\")\n      value = NaN;\n    else if (!isNaN(number7 = +value))\n      value = number7;\n    else if (m3 = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n      if (fixtz && !!m3[4] && !m3[7])\n        value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n      value = new Date(value);\n    } else\n      continue;\n    object2[key] = value;\n  }\n  return object2;\n}\nvar fixtz = (/* @__PURE__ */ new Date(\"2019-01-01T00:00\")).getHours() || (/* @__PURE__ */ new Date(\"2019-07-01T00:00\")).getHours();\n\n// node_modules/d3-fetch/src/blob.js\nfunction responseBlob(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.blob();\n}\nfunction blob_default(input, init2) {\n  return fetch(input, init2).then(responseBlob);\n}\n\n// node_modules/d3-fetch/src/buffer.js\nfunction responseArrayBuffer(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.arrayBuffer();\n}\nfunction buffer_default(input, init2) {\n  return fetch(input, init2).then(responseArrayBuffer);\n}\n\n// node_modules/d3-fetch/src/text.js\nfunction responseText(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  return response.text();\n}\nfunction text_default3(input, init2) {\n  return fetch(input, init2).then(responseText);\n}\n\n// node_modules/d3-fetch/src/dsv.js\nfunction dsvParse(parse2) {\n  return function(input, init2, row) {\n    if (arguments.length === 2 && typeof init2 === \"function\")\n      row = init2, init2 = void 0;\n    return text_default3(input, init2).then(function(response) {\n      return parse2(response, row);\n    });\n  };\n}\nfunction dsv(delimiter, input, init2, row) {\n  if (arguments.length === 3 && typeof init2 === \"function\")\n    row = init2, init2 = void 0;\n  var format3 = dsv_default(delimiter);\n  return text_default3(input, init2).then(function(response) {\n    return format3.parse(response, row);\n  });\n}\nvar csv2 = dsvParse(csvParse);\nvar tsv2 = dsvParse(tsvParse);\n\n// node_modules/d3-fetch/src/image.js\nfunction image_default(input, init2) {\n  return new Promise(function(resolve, reject) {\n    var image2 = new Image();\n    for (var key in init2)\n      image2[key] = init2[key];\n    image2.onerror = reject;\n    image2.onload = function() {\n      resolve(image2);\n    };\n    image2.src = input;\n  });\n}\n\n// node_modules/d3-fetch/src/json.js\nfunction responseJson(response) {\n  if (!response.ok)\n    throw new Error(response.status + \" \" + response.statusText);\n  if (response.status === 204 || response.status === 205)\n    return;\n  return response.json();\n}\nfunction json_default(input, init2) {\n  return fetch(input, init2).then(responseJson);\n}\n\n// node_modules/d3-fetch/src/xml.js\nfunction parser(type2) {\n  return (input, init2) => text_default3(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));\n}\nvar xml_default = parser(\"application/xml\");\nvar html = parser(\"text/html\");\nvar svg = parser(\"image/svg+xml\");\n\n// node_modules/d3-force/src/center.js\nfunction center_default(x4, y4) {\n  var nodes, strength = 1;\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force() {\n    var i, n = nodes.length, node, sx = 0, sy = 0;\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n    for (sx = (sx / n - x4) * strength, sy = (sy / n - y4) * strength, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  return force;\n}\n\n// node_modules/d3-quadtree/src/add.js\nfunction add_default(d) {\n  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);\n  return add(this.cover(x4, y4), x4, y4, d);\n}\nfunction add(tree2, x4, y4, d) {\n  if (isNaN(x4) || isNaN(y4))\n    return tree2;\n  var parent, node = tree2._root, leaf = { data: d }, x06 = tree2._x0, y06 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;\n  if (!node)\n    return tree2._root = leaf, tree2;\n  while (node.length) {\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n    if (parent = node, !(node = node[i = bottom2 << 1 | right2]))\n      return parent[i] = leaf, tree2;\n  }\n  xp = +tree2._x.call(null, node.data);\n  yp = +tree2._y.call(null, node.data);\n  if (x4 === xp && y4 === yp)\n    return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);\n    if (right2 = x4 >= (xm = (x06 + x12) / 2))\n      x06 = xm;\n    else\n      x12 = xm;\n    if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n      y06 = ym;\n    else\n      y12 = ym;\n  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));\n  return parent[j] = node, parent[i] = leaf, tree2;\n}\nfunction addAll(data) {\n  var d, i, n = data.length, x4, y4, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))\n      continue;\n    xz[i] = x4;\n    yz[i] = y4;\n    if (x4 < x06)\n      x06 = x4;\n    if (x4 > x12)\n      x12 = x4;\n    if (y4 < y06)\n      y06 = y4;\n    if (y4 > y12)\n      y12 = y4;\n  }\n  if (x06 > x12 || y06 > y12)\n    return this;\n  this.cover(x06, y06).cover(x12, y12);\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/cover.js\nfunction cover_default(x4, y4) {\n  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))\n    return this;\n  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;\n  if (isNaN(x06)) {\n    x12 = (x06 = Math.floor(x4)) + 1;\n    y12 = (y06 = Math.floor(y4)) + 1;\n  } else {\n    var z = x12 - x06 || 1, node = this._root, parent, i;\n    while (x06 > x4 || x4 >= x12 || y06 > y4 || y4 >= y12) {\n      i = (y4 < y06) << 1 | x4 < x06;\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0:\n          x12 = x06 + z, y12 = y06 + z;\n          break;\n        case 1:\n          x06 = x12 - z, y12 = y06 + z;\n          break;\n        case 2:\n          x12 = x06 + z, y06 = y12 - z;\n          break;\n        case 3:\n          x06 = x12 - z, y06 = y12 - z;\n          break;\n      }\n    }\n    if (this._root && this._root.length)\n      this._root = node;\n  }\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  return this;\n}\n\n// node_modules/d3-quadtree/src/data.js\nfunction data_default2() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        data.push(node.data);\n      while (node = node.next);\n  });\n  return data;\n}\n\n// node_modules/d3-quadtree/src/extent.js\nfunction extent_default(_) {\n  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n\n// node_modules/d3-quadtree/src/quad.js\nfunction quad_default(node, x06, y06, x12, y12) {\n  this.node = node;\n  this.x0 = x06;\n  this.y0 = y06;\n  this.x1 = x12;\n  this.y1 = y12;\n}\n\n// node_modules/d3-quadtree/src/find.js\nfunction find_default(x4, y4, radius2) {\n  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;\n  if (node)\n    quads.push(new quad_default(node, x06, y06, x32, y32));\n  if (radius2 == null)\n    radius2 = Infinity;\n  else {\n    x06 = x4 - radius2, y06 = y4 - radius2;\n    x32 = x4 + radius2, y32 = y4 + radius2;\n    radius2 *= radius2;\n  }\n  while (q = quads.pop()) {\n    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)\n      continue;\n    if (node.length) {\n      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;\n      quads.push(\n        new quad_default(node[3], xm, ym, x22, y22),\n        new quad_default(node[2], x12, ym, xm, y22),\n        new quad_default(node[1], xm, y12, x22, ym),\n        new quad_default(node[0], x12, y12, xm, ym)\n      );\n      if (i = (y4 >= ym) << 1 | x4 >= xm) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    } else {\n      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;\n      if (d2 < radius2) {\n        var d = Math.sqrt(radius2 = d2);\n        x06 = x4 - d, y06 = y4 - d;\n        x32 = x4 + d, y32 = y4 + d;\n        data = node.data;\n      }\n    }\n  }\n  return data;\n}\n\n// node_modules/d3-quadtree/src/remove.js\nfunction remove_default3(d) {\n  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))\n    return this;\n  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x4, y4, xm, ym, right2, bottom2, i, j;\n  if (!node)\n    return this;\n  if (node.length)\n    while (true) {\n      if (right2 = x4 >= (xm = (x06 + x12) / 2))\n        x06 = xm;\n      else\n        x12 = xm;\n      if (bottom2 = y4 >= (ym = (y06 + y12) / 2))\n        y06 = ym;\n      else\n        y12 = ym;\n      if (!(parent = node, node = node[i = bottom2 << 1 | right2]))\n        return this;\n      if (!node.length)\n        break;\n      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])\n        retainer = parent, j = i;\n    }\n  while (node.data !== d)\n    if (!(previous = node, node = node.next))\n      return this;\n  if (next = node.next)\n    delete node.next;\n  if (previous)\n    return next ? previous.next = next : delete previous.next, this;\n  if (!parent)\n    return this._root = next, this;\n  next ? parent[i] = next : delete parent[i];\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {\n    if (retainer)\n      retainer[j] = node;\n    else\n      this._root = node;\n  }\n  return this;\n}\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i)\n    this.remove(data[i]);\n  return this;\n}\n\n// node_modules/d3-quadtree/src/root.js\nfunction root_default() {\n  return this._root;\n}\n\n// node_modules/d3-quadtree/src/size.js\nfunction size_default2() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length)\n      do\n        ++size;\n      while (node = node.next);\n  });\n  return size;\n}\n\n// node_modules/d3-quadtree/src/visit.js\nfunction visit_default(callback) {\n  var quads = [], q, node = this._root, child, x06, y06, x12, y12;\n  if (node)\n    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {\n      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/visitAfter.js\nfunction visitAfter_default(callback) {\n  var quads = [], next = [], q;\n  if (this._root)\n    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;\n      if (child = node[0])\n        quads.push(new quad_default(child, x06, y06, xm, ym));\n      if (child = node[1])\n        quads.push(new quad_default(child, xm, y06, x12, ym));\n      if (child = node[2])\n        quads.push(new quad_default(child, x06, ym, xm, y12));\n      if (child = node[3])\n        quads.push(new quad_default(child, xm, ym, x12, y12));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n\n// node_modules/d3-quadtree/src/x.js\nfunction defaultX2(d) {\n  return d[0];\n}\nfunction x_default(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n\n// node_modules/d3-quadtree/src/y.js\nfunction defaultY2(d) {\n  return d[1];\n}\nfunction y_default(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n\n// node_modules/d3-quadtree/src/quadtree.js\nfunction quadtree(nodes, x4, y4) {\n  var tree2 = new Quadtree(x4 == null ? defaultX2 : x4, y4 == null ? defaultY2 : y4, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree2 : tree2.addAll(nodes);\n}\nfunction Quadtree(x4, y4, x06, y06, x12, y12) {\n  this._x = x4;\n  this._y = y4;\n  this._x0 = x06;\n  this._y0 = y06;\n  this._x1 = x12;\n  this._y1 = y12;\n  this._root = void 0;\n}\nfunction leaf_copy(leaf) {\n  var copy3 = { data: leaf.data }, next = copy3;\n  while (leaf = leaf.next)\n    next = next.next = { data: leaf.data };\n  return copy3;\n}\nvar treeProto = quadtree.prototype = Quadtree.prototype;\ntreeProto.copy = function() {\n  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;\n  if (!node)\n    return copy3;\n  if (!node.length)\n    return copy3._root = leaf_copy(node), copy3;\n  nodes = [{ source: node, target: copy3._root = new Array(4) }];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length)\n          nodes.push({ source: child, target: node.target[i] = new Array(4) });\n        else\n          node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n  return copy3;\n};\ntreeProto.add = add_default;\ntreeProto.addAll = addAll;\ntreeProto.cover = cover_default;\ntreeProto.data = data_default2;\ntreeProto.extent = extent_default;\ntreeProto.find = find_default;\ntreeProto.remove = remove_default3;\ntreeProto.removeAll = removeAll;\ntreeProto.root = root_default;\ntreeProto.size = size_default2;\ntreeProto.visit = visit_default;\ntreeProto.visitAfter = visitAfter_default;\ntreeProto.x = x_default;\ntreeProto.y = y_default;\n\n// node_modules/d3-force/src/constant.js\nfunction constant_default7(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-force/src/jiggle.js\nfunction jiggle_default(random) {\n  return (random() - 0.5) * 1e-6;\n}\n\n// node_modules/d3-force/src/collide.js\nfunction x(d) {\n  return d.x + d.vx;\n}\nfunction y(d) {\n  return d.y + d.vy;\n}\nfunction collide_default(radius2) {\n  var nodes, radii, random, strength = 1, iterations2 = 1;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(radius2 == null ? 1 : +radius2);\n  function force() {\n    var i, n = nodes.length, tree2, node, xi, yi, ri, ri2;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      tree2 = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree2.visit(apply2);\n      }\n    }\n    function apply2(quad, x06, y06, x12, y12) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x4 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l = x4 * x4 + y4 * y4;\n          if (l < r * r) {\n            if (x4 === 0)\n              x4 = jiggle_default(random), l += x4 * x4;\n            if (y4 === 0)\n              y4 = jiggle_default(random), l += y4 * y4;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x4 *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y4 *= l) * r;\n            data.vx -= x4 * (r = 1 - r);\n            data.vy -= y4 * r;\n          }\n        }\n        return;\n      }\n      return x06 > xi + r || x12 < xi - r || y06 > yi + r || y12 < yi - r;\n    }\n  }\n  function prepare(quad) {\n    if (quad.data)\n      return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i)\n      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/link.js\nfunction index2(d) {\n  return d.index;\n}\nfunction find2(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node)\n    throw new Error(\"node not found: \" + nodeId);\n  return node;\n}\nfunction link_default(links) {\n  var id2 = index2, strength = defaultStrength, strengths, distance = constant_default7(30), distances, nodes, count3, bias, random, iterations2 = 1;\n  if (links == null)\n    links = [];\n  function defaultStrength(link4) {\n    return 1 / Math.min(count3[link4.source.index], count3[link4.target.index]);\n  }\n  function force(alpha) {\n    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {\n      for (var i = 0, link4, source, target, x4, y4, l, b; i < n; ++i) {\n        link4 = links[i], source = link4.source, target = link4.target;\n        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);\n        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);\n        l = Math.sqrt(x4 * x4 + y4 * y4);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x4 *= l, y4 *= l;\n        target.vx -= x4 * (b = bias[i]);\n        target.vy -= y4 * b;\n        source.vx += x4 * (b = 1 - b);\n        source.vy += y4 * b;\n      }\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link4;\n    for (i = 0, count3 = new Array(n); i < m3; ++i) {\n      link4 = links[i], link4.index = i;\n      if (typeof link4.source !== \"object\")\n        link4.source = find2(nodeById, link4.source);\n      if (typeof link4.target !== \"object\")\n        link4.target = find2(nodeById, link4.target);\n      count3[link4.source.index] = (count3[link4.source.index] || 0) + 1;\n      count3[link4.target.index] = (count3[link4.target.index] || 0) + 1;\n    }\n    for (i = 0, bias = new Array(m3); i < m3; ++i) {\n      link4 = links[i], bias[i] = count3[link4.source.index] / (count3[link4.source.index] + count3[link4.target.index]);\n    }\n    strengths = new Array(m3), initializeStrength();\n    distances = new Array(m3), initializeDistance();\n  }\n  function initializeStrength() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n  function initializeDistance() {\n    if (!nodes)\n      return;\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n  force.id = function(_) {\n    return arguments.length ? (id2 = _, force) : id2;\n  };\n  force.iterations = function(_) {\n    return arguments.length ? (iterations2 = +_, force) : iterations2;\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initializeStrength(), force) : strength;\n  };\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant_default7(+_), initializeDistance(), force) : distance;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/lcg.js\nvar a = 1664525;\nvar c = 1013904223;\nvar m = 4294967296;\nfunction lcg_default() {\n  let s2 = 1;\n  return () => (s2 = (a * s2 + c) % m) / m;\n}\n\n// node_modules/d3-force/src/simulation.js\nfunction x2(d) {\n  return d.x;\n}\nfunction y2(d) {\n  return d.y;\n}\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\nfunction simulation_default(nodes) {\n  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default(\"tick\", \"end\"), random = lcg_default();\n  if (nodes == null)\n    nodes = [];\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n  function tick(iterations2) {\n    var i, n = nodes.length, node;\n    if (iterations2 === void 0)\n      iterations2 = 1;\n    for (var k2 = 0; k2 < iterations2; ++k2) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n      forces.forEach(function(force) {\n        force(alpha);\n      });\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null)\n          node.x += node.vx *= velocityDecay;\n        else\n          node.x = node.fx, node.vx = 0;\n        if (node.fy == null)\n          node.y += node.vy *= velocityDecay;\n        else\n          node.y = node.fy, node.vy = 0;\n      }\n    }\n    return simulation;\n  }\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null)\n        node.x = node.fx;\n      if (node.fy != null)\n        node.y = node.fy;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;\n        node.x = radius2 * Math.cos(angle2);\n        node.y = radius2 * Math.sin(angle2);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n  function initializeForce(force) {\n    if (force.initialize)\n      force.initialize(nodes, random);\n    return force;\n  }\n  initializeNodes();\n  return simulation = {\n    tick,\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n    force: function(name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function(x4, y4, radius2) {\n      var i = 0, n = nodes.length, dx, dy, d2, node, closest;\n      if (radius2 == null)\n        radius2 = Infinity;\n      else\n        radius2 *= radius2;\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x4 - node.x;\n        dy = y4 - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius2)\n          closest = node, radius2 = d2;\n      }\n      return closest;\n    },\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n\n// node_modules/d3-force/src/manyBody.js\nfunction manyBody_default() {\n  var nodes, node, random, alpha, strength = constant_default7(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;\n  function force(_) {\n    var i, n = nodes.length, tree2 = quadtree(nodes, x2, y2).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i)\n      node = nodes[i], tree2.visit(apply2);\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length, node2;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i)\n      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);\n  }\n  function accumulate(quad) {\n    var strength2 = 0, q, c6, weight = 0, x4, y4, i;\n    if (quad.length) {\n      for (x4 = y4 = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c6 = Math.abs(q.value))) {\n          strength2 += q.value, weight += c6, x4 += c6 * q.x, y4 += c6 * q.y;\n        }\n      }\n      quad.x = x4 / weight;\n      quad.y = y4 / weight;\n    } else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do\n        strength2 += strengths[q.data.index];\n      while (q = q.next);\n    }\n    quad.value = strength2;\n  }\n  function apply2(quad, x12, _, x22) {\n    if (!quad.value)\n      return true;\n    var x4 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x12, l = x4 * x4 + y4 * y4;\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x4 === 0)\n          x4 = jiggle_default(random), l += x4 * x4;\n        if (y4 === 0)\n          y4 = jiggle_default(random), l += y4 * y4;\n        if (l < distanceMin2)\n          l = Math.sqrt(distanceMin2 * l);\n        node.vx += x4 * quad.value * alpha / l;\n        node.vy += y4 * quad.value * alpha / l;\n      }\n      return true;\n    } else if (quad.length || l >= distanceMax2)\n      return;\n    if (quad.data !== node || quad.next) {\n      if (x4 === 0)\n        x4 = jiggle_default(random), l += x4 * x4;\n      if (y4 === 0)\n        y4 = jiggle_default(random), l += y4 * y4;\n      if (l < distanceMin2)\n        l = Math.sqrt(distanceMin2 * l);\n    }\n    do\n      if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x4 * w;\n        node.vy += y4 * w;\n      }\n    while (quad = quad.next);\n  }\n  force.initialize = function(_nodes, _random) {\n    nodes = _nodes;\n    random = _random;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/radial.js\nfunction radial_default(radius2, x4, y4) {\n  var nodes, strength = constant_default7(0.1), strengths, radiuses;\n  if (typeof radius2 !== \"function\")\n    radius2 = constant_default7(+radius2);\n  if (x4 == null)\n    x4 = 0;\n  if (y4 == null)\n    y4 = 0;\n  function force(alpha) {\n    for (var i = 0, n = nodes.length; i < n; ++i) {\n      var node = nodes[i], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;\n      node.vx += dx * k2;\n      node.vy += dy * k2;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    radiuses = new Array(n);\n    for (i = 0; i < n; ++i) {\n      radiuses[i] = +radius2(nodes[i], i, nodes);\n      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _, initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : radius2;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = +_, force) : x4;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = +_, force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/x.js\nfunction x_default2(x4) {\n  var strength = constant_default7(0.1), nodes, strengths, xz;\n  if (typeof x4 !== \"function\")\n    x4 = constant_default7(x4 == null ? 0 : +x4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : x4;\n  };\n  return force;\n}\n\n// node_modules/d3-force/src/y.js\nfunction y_default2(y4) {\n  var strength = constant_default7(0.1), nodes, strengths, yz;\n  if (typeof y4 !== \"function\")\n    y4 = constant_default7(y4 == null ? 0 : +y4);\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n  function initialize() {\n    if (!nodes)\n      return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y4(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : strength;\n  };\n  force.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default7(+_), initialize(), force) : y4;\n  };\n  return force;\n}\n\n// node_modules/d3-format/src/formatDecimal.js\nfunction formatDecimal_default(x4) {\n  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString(\"en\").replace(/,/g, \"\") : x4.toString(10);\n}\nfunction formatDecimalParts(x4, p) {\n  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf(\"e\")) < 0)\n    return null;\n  var i, coefficient = x4.slice(0, i);\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x4.slice(i + 1)\n  ];\n}\n\n// node_modules/d3-format/src/exponent.js\nfunction exponent_default(x4) {\n  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;\n}\n\n// node_modules/d3-format/src/formatGroup.js\nfunction formatGroup_default(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length, t = [], j = 0, g = grouping[0], length4 = 0;\n    while (i > 0 && g > 0) {\n      if (length4 + g + 1 > width)\n        g = Math.max(1, width - length4);\n      t.push(value.substring(i -= g, i + g));\n      if ((length4 += g + 1) > width)\n        break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n    return t.reverse().join(thousands);\n  };\n}\n\n// node_modules/d3-format/src/formatNumerals.js\nfunction formatNumerals_default(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n\n// node_modules/d3-format/src/formatSpecifier.js\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nfunction formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier)))\n    throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\nformatSpecifier.prototype = FormatSpecifier.prototype;\nfunction FormatSpecifier(specifier) {\n  this.fill = specifier.fill === void 0 ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === void 0 ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === void 0 ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === void 0 ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === void 0 ? void 0 : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === void 0 ? \"\" : specifier.type + \"\";\n}\nFormatSpecifier.prototype.toString = function() {\n  return this.fill + this.align + this.sign + this.symbol + (this.zero ? \"0\" : \"\") + (this.width === void 0 ? \"\" : Math.max(1, this.width | 0)) + (this.comma ? \",\" : \"\") + (this.precision === void 0 ? \"\" : \".\" + Math.max(0, this.precision | 0)) + (this.trim ? \"~\" : \"\") + this.type;\n};\n\n// node_modules/d3-format/src/formatTrim.js\nfunction formatTrim_default(s2) {\n  out:\n    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (s2[i]) {\n        case \".\":\n          i0 = i1 = i;\n          break;\n        case \"0\":\n          if (i0 === 0)\n            i0 = i;\n          i1 = i;\n          break;\n        default:\n          if (!+s2[i])\n            break out;\n          if (i0 > 0)\n            i0 = 0;\n          break;\n      }\n    }\n  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;\n}\n\n// node_modules/d3-format/src/formatPrefixAuto.js\nvar prefixExponent;\nfunction formatPrefixAuto_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;\n  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join(\"0\") : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i) : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];\n}\n\n// node_modules/d3-format/src/formatRounded.js\nfunction formatRounded_default(x4, p) {\n  var d = formatDecimalParts(x4, p);\n  if (!d)\n    return x4 + \"\";\n  var coefficient = d[0], exponent2 = d[1];\n  return exponent2 < 0 ? \"0.\" + new Array(-exponent2).join(\"0\") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + \".\" + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join(\"0\");\n}\n\n// node_modules/d3-format/src/formatTypes.js\nvar formatTypes_default = {\n  \"%\": (x4, p) => (x4 * 100).toFixed(p),\n  \"b\": (x4) => Math.round(x4).toString(2),\n  \"c\": (x4) => x4 + \"\",\n  \"d\": formatDecimal_default,\n  \"e\": (x4, p) => x4.toExponential(p),\n  \"f\": (x4, p) => x4.toFixed(p),\n  \"g\": (x4, p) => x4.toPrecision(p),\n  \"o\": (x4) => Math.round(x4).toString(8),\n  \"p\": (x4, p) => formatRounded_default(x4 * 100, p),\n  \"r\": formatRounded_default,\n  \"s\": formatPrefixAuto_default,\n  \"X\": (x4) => Math.round(x4).toString(16).toUpperCase(),\n  \"x\": (x4) => Math.round(x4).toString(16)\n};\n\n// node_modules/d3-format/src/identity.js\nfunction identity_default2(x4) {\n  return x4;\n}\n\n// node_modules/d3-format/src/locale.js\nvar map3 = Array.prototype.map;\nvar prefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\\xB5\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\nfunction locale_default(locale3) {\n  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + \"\"), currencyPrefix = locale3.currency === void 0 ? \"\" : locale3.currency[0] + \"\", currencySuffix = locale3.currency === void 0 ? \"\" : locale3.currency[1] + \"\", decimal = locale3.decimal === void 0 ? \".\" : locale3.decimal + \"\", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? \"%\" : locale3.percent + \"\", minus = locale3.minus === void 0 ? \"\\u2212\" : locale3.minus + \"\", nan = locale3.nan === void 0 ? \"NaN\" : locale3.nan + \"\";\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;\n    if (type2 === \"n\")\n      comma = true, type2 = \"g\";\n    else if (!formatTypes_default[type2])\n      precision === void 0 && (precision = 12), trim = true, type2 = \"g\";\n    if (zero3 || fill === \"0\" && align === \"=\")\n      zero3 = true, fill = \"0\", align = \"=\";\n    var prefix = symbol2 === \"$\" ? currencyPrefix : symbol2 === \"#\" && /[boxX]/.test(type2) ? \"0\" + type2.toLowerCase() : \"\", suffix = symbol2 === \"$\" ? currencySuffix : /[%p]/.test(type2) ? percent : \"\";\n    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);\n    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));\n    function format3(value) {\n      var valuePrefix = prefix, valueSuffix = suffix, i, n, c6;\n      if (type2 === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n        var valueNegative = value < 0 || 1 / value < 0;\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n        if (trim)\n          value = formatTrim_default(value);\n        if (valueNegative && +value === 0 && sign3 !== \"+\")\n          valueNegative = false;\n        valuePrefix = (valueNegative ? sign3 === \"(\" ? sign3 : minus : sign3 === \"-\" || sign3 === \"(\" ? \"\" : sign3) + valuePrefix;\n        valueSuffix = (type2 === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign3 === \"(\" ? \")\" : \"\");\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {\n              valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n      if (comma && !zero3)\n        value = group3(value, Infinity);\n      var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : \"\";\n      if (comma && zero3)\n        value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n      switch (align) {\n        case \"<\":\n          value = valuePrefix + value + valueSuffix + padding;\n          break;\n        case \"=\":\n          value = valuePrefix + padding + value + valueSuffix;\n          break;\n        case \"^\":\n          value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);\n          break;\n        default:\n          value = padding + valuePrefix + value + valueSuffix;\n          break;\n      }\n      return numerals(value);\n    }\n    format3.toString = function() {\n      return specifier + \"\";\n    };\n    return format3;\n  }\n  function formatPrefix2(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];\n    return function(value2) {\n      return f(k2 * value2) + prefix;\n    };\n  }\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix2\n  };\n}\n\n// node_modules/d3-format/src/defaultLocale.js\nvar locale;\nvar format;\nvar formatPrefix;\ndefaultLocale({\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\nfunction defaultLocale(definition) {\n  locale = locale_default(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n\n// node_modules/d3-format/src/precisionFixed.js\nfunction precisionFixed_default(step) {\n  return Math.max(0, -exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionPrefix.js\nfunction precisionPrefix_default(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));\n}\n\n// node_modules/d3-format/src/precisionRound.js\nfunction precisionRound_default(step, max5) {\n  step = Math.abs(step), max5 = Math.abs(max5) - step;\n  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;\n}\n\n// node_modules/d3-geo/src/math.js\nvar epsilon7 = 1e-6;\nvar epsilon22 = 1e-12;\nvar pi4 = Math.PI;\nvar halfPi3 = pi4 / 2;\nvar quarterPi = pi4 / 4;\nvar tau5 = pi4 * 2;\nvar degrees3 = 180 / pi4;\nvar radians2 = pi4 / 180;\nvar abs3 = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos2 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\nvar hypot = Math.hypot;\nvar log = Math.log;\nvar pow2 = Math.pow;\nvar sin2 = Math.sin;\nvar sign = Math.sign || function(x4) {\n  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;\n};\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\nfunction acos(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);\n}\nfunction asin(x4) {\n  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);\n}\nfunction haversin(x4) {\n  return (x4 = sin2(x4 / 2)) * x4;\n}\n\n// node_modules/d3-geo/src/noop.js\nfunction noop2() {\n}\n\n// node_modules/d3-geo/src/stream.js\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\nvar streamObjectType = {\n  Feature: function(object2, stream) {\n    streamGeometry(object2.geometry, stream);\n  },\n  FeatureCollection: function(object2, stream) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      streamGeometry(features[i].geometry, stream);\n  }\n};\nvar streamGeometryType = {\n  Sphere: function(object2, stream) {\n    stream.sphere();\n  },\n  Point: function(object2, stream) {\n    object2 = object2.coordinates;\n    stream.point(object2[0], object2[1], object2[2]);\n  },\n  MultiPoint: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);\n  },\n  LineString: function(object2, stream) {\n    streamLine(object2.coordinates, stream, 0);\n  },\n  MultiLineString: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamLine(coordinates2[i], stream, 0);\n  },\n  Polygon: function(object2, stream) {\n    streamPolygon(object2.coordinates, stream);\n  },\n  MultiPolygon: function(object2, stream) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      streamPolygon(coordinates2[i], stream);\n  },\n  GeometryCollection: function(object2, stream) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      streamGeometry(geometries[i], stream);\n  }\n};\nfunction streamLine(coordinates2, stream, closed) {\n  var i = -1, n = coordinates2.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n)\n    coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\nfunction streamPolygon(coordinates2, stream) {\n  var i = -1, n = coordinates2.length;\n  stream.polygonStart();\n  while (++i < n)\n    streamLine(coordinates2[i], stream, 1);\n  stream.polygonEnd();\n}\nfunction stream_default(object2, stream) {\n  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {\n    streamObjectType[object2.type](object2, stream);\n  } else {\n    streamGeometry(object2, stream);\n  }\n}\n\n// node_modules/d3-geo/src/area.js\nvar areaRingSum = new Adder();\nvar areaSum = new Adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\nvar areaStream = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaRingSum = new Adder();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau5 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop2;\n  },\n  sphere: function() {\n    areaSum.add(tau5);\n  }\n};\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\nfunction areaPointFirst(lambda, phi2) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);\n}\nfunction areaPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  phi2 = phi2 / 2 + quarterPi;\n  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k2 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k2 * cos2(adLambda), v2 = k2 * sdLambda * sin2(adLambda);\n  areaRingSum.add(atan2(v2, u4));\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\nfunction area_default2(object2) {\n  areaSum = new Adder();\n  stream_default(object2, areaStream);\n  return areaSum * 2;\n}\n\n// node_modules/d3-geo/src/cartesian.js\nfunction spherical(cartesian2) {\n  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];\n}\nfunction cartesian(spherical2) {\n  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);\n  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];\n}\nfunction cartesianDot(a4, b) {\n  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];\n}\nfunction cartesianCross(a4, b) {\n  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];\n}\nfunction cartesianAddInPlace(a4, b) {\n  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];\n}\nfunction cartesianScale(vector2, k2) {\n  return [vector2[0] * k2, vector2[1] * k2, vector2[2] * k2];\n}\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\n// node_modules/d3-geo/src/bounds.js\nvar lambda02;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda002;\nvar phi002;\nvar p0;\nvar deltaSum;\nvar ranges;\nvar range3;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0)\n      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon7)\n      phi1 = 90;\n    else if (deltaSum < -epsilon7)\n      phi0 = -90;\n    range3[0] = lambda02, range3[1] = lambda1;\n  },\n  sphere: function() {\n    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\nfunction boundsPoint(lambda, phi2) {\n  ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n}\nfunction linePoint(lambda, phi2) {\n  var p = cartesian([lambda * radians2, phi2 * radians2]);\n  if (p0) {\n    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs3(delta) > 180;\n    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = inflection[1] * degrees3;\n      if (phii > phi1)\n        phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {\n      phii = -inflection[1] * degrees3;\n      if (phii < phi0)\n        phi0 = phii;\n    } else {\n      if (phi2 < phi0)\n        phi0 = phi2;\n      if (phi2 > phi1)\n        phi1 = phi2;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n          lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n          lambda02 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda02) {\n        if (lambda < lambda02)\n          lambda02 = lambda;\n        if (lambda > lambda1)\n          lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda02, lambda) > angle(lambda02, lambda1))\n            lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda02, lambda1))\n            lambda02 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range3 = [lambda02 = lambda, lambda1 = lambda]);\n  }\n  if (phi2 < phi0)\n    phi0 = phi2;\n  if (phi2 > phi1)\n    phi1 = phi2;\n  p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n  range3[0] = lambda02, range3[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\nfunction boundsRingPoint(lambda, phi2) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs3(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda002 = lambda, phi002 = phi2;\n  }\n  areaStream.point(lambda, phi2);\n  linePoint(lambda, phi2);\n}\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda002, phi002);\n  areaStream.lineEnd();\n  if (abs3(deltaSum) > epsilon7)\n    lambda02 = -(lambda1 = 180);\n  range3[0] = lambda02, range3[1] = lambda1;\n  p0 = null;\n}\nfunction angle(lambda04, lambda12) {\n  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;\n}\nfunction rangeCompare(a4, b) {\n  return a4[0] - b[0];\n}\nfunction rangeContains(range5, x4) {\n  return range5[0] <= range5[1] ? range5[0] <= x4 && x4 <= range5[1] : x4 < range5[0] || range5[1] < x4;\n}\nfunction bounds_default(feature) {\n  var i, n, a4, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);\n  ranges = [];\n  stream_default(feature, boundsStream);\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a4, b[0]) || rangeContains(a4, b[1])) {\n        if (angle(a4[0], b[1]) > angle(a4[0], a4[1]))\n          a4[1] = b[1];\n        if (angle(b[0], a4[1]) > angle(a4[0], a4[1]))\n          a4[0] = b[0];\n      } else {\n        merged.push(a4 = b);\n      }\n    }\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a4[1], b[0])) > deltaMax)\n        deltaMax = delta, lambda02 = b[0], lambda1 = a4[1];\n    }\n  }\n  ranges = range3 = null;\n  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];\n}\n\n// node_modules/d3-geo/src/centroid.js\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda003;\nvar phi003;\nvar x0;\nvar y0;\nvar z0;\nvar centroidStream = {\n  sphere: noop2,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\nfunction centroidPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));\n}\nfunction centroidPointCartesian(x4, y4, z) {\n  ++W0;\n  X0 += (x4 - X0) / W0;\n  Y0 += (y4 - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\nfunction centroidLinePointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLinePoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), w = atan2(sqrt((w = y0 * z - z0 * y4) * w + (w = z0 * x4 - x0 * z) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda003, phi003);\n  centroidStream.point = centroidPoint;\n}\nfunction centroidRingPointFirst(lambda, phi2) {\n  lambda003 = lambda, phi003 = phi2;\n  lambda *= radians2, phi2 *= radians2;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos2(phi2);\n  x0 = cosPhi * cos2(lambda);\n  y0 = cosPhi * sin2(lambda);\n  z0 = sin2(phi2);\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroidRingPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y4, cy = z0 * x4 - x0 * z, cz = x0 * y4 - y0 * x4, m3 = hypot(cx, cy, cz), w = asin(m3), v2 = m3 && -w / m3;\n  X2.add(v2 * cx);\n  Y2.add(v2 * cy);\n  Z2.add(v2 * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x4));\n  Y1 += w * (y0 + (y0 = y4));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\nfunction centroid_default(object2) {\n  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream_default(object2, centroidStream);\n  var x4 = +X2, y4 = +Y2, z = +Z2, m3 = hypot(x4, y4, z);\n  if (m3 < epsilon22) {\n    x4 = X1, y4 = Y1, z = Z1;\n    if (W1 < epsilon7)\n      x4 = X0, y4 = Y0, z = Z0;\n    m3 = hypot(x4, y4, z);\n    if (m3 < epsilon22)\n      return [NaN, NaN];\n  }\n  return [atan2(y4, x4) * degrees3, asin(z / m3) * degrees3];\n}\n\n// node_modules/d3-geo/src/constant.js\nfunction constant_default8(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-geo/src/compose.js\nfunction compose_default(a4, b) {\n  function compose(x4, y4) {\n    return x4 = a4(x4, y4), b(x4[0], x4[1]);\n  }\n  if (a4.invert && b.invert)\n    compose.invert = function(x4, y4) {\n      return x4 = b.invert(x4, y4), x4 && a4.invert(x4[0], x4[1]);\n    };\n  return compose;\n}\n\n// node_modules/d3-geo/src/rotation.js\nfunction rotationIdentity(lambda, phi2) {\n  if (abs3(lambda) > pi4)\n    lambda -= Math.round(lambda / tau5) * tau5;\n  return [lambda, phi2];\n}\nrotationIdentity.invert = rotationIdentity;\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau5) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n}\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi2) {\n    lambda += deltaLambda;\n    if (abs3(lambda) > pi4)\n      lambda -= Math.round(lambda / tau5) * tau5;\n    return [lambda, phi2];\n  };\n}\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);\n  function rotation(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x4 * sinDeltaPhi;\n    return [\n      atan2(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x4 * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k2 * cosDeltaGamma + y4 * sinDeltaGamma)\n    ];\n  }\n  rotation.invert = function(lambda, phi2) {\n    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;\n    return [\n      atan2(y4 * cosDeltaGamma + z * sinDeltaGamma, x4 * cosDeltaPhi + k2 * sinDeltaPhi),\n      asin(k2 * cosDeltaPhi - x4 * sinDeltaPhi)\n    ];\n  };\n  return rotation;\n}\nfunction rotation_default(rotate) {\n  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);\n  function forward(coordinates2) {\n    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  }\n  forward.invert = function(coordinates2) {\n    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);\n    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/circle.js\nfunction circleStream(stream, radius2, delta, direction, t03, t13) {\n  if (!delta)\n    return;\n  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;\n  if (t03 == null) {\n    t03 = radius2 + direction * tau5;\n    t13 = radius2 - step / 2;\n  } else {\n    t03 = circleRadius(cosRadius, t03);\n    t13 = circleRadius(cosRadius, t13);\n    if (direction > 0 ? t03 < t13 : t03 > t13)\n      t03 += direction * tau5;\n  }\n  for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {\n    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);\n    stream.point(point6[0], point6[1]);\n  }\n}\nfunction circleRadius(cosRadius, point6) {\n  point6 = cartesian(point6), point6[0] -= cosRadius;\n  cartesianNormalizeInPlace(point6);\n  var radius2 = acos(-point6[1]);\n  return ((-point6[2] < 0 ? -radius2 : radius2) + tau5 - epsilon7) % tau5;\n}\nfunction circle_default() {\n  var center2 = constant_default8([0, 0]), radius2 = constant_default8(90), precision = constant_default8(6), ring, rotate, stream = { point: point6 };\n  function point6(x4, y4) {\n    ring.push(x4 = rotate(x4, y4));\n    x4[0] *= degrees3, x4[1] *= degrees3;\n  }\n  function circle2() {\n    var c6 = center2.apply(this, arguments), r = radius2.apply(this, arguments) * radians2, p = precision.apply(this, arguments) * radians2;\n    ring = [];\n    rotate = rotateRadians(-c6[0] * radians2, -c6[1] * radians2, 0).invert;\n    circleStream(stream, r, p, 1);\n    c6 = { type: \"Polygon\", coordinates: [ring] };\n    ring = rotate = null;\n    return c6;\n  }\n  circle2.center = function(_) {\n    return arguments.length ? (center2 = typeof _ === \"function\" ? _ : constant_default8([+_[0], +_[1]]), circle2) : center2;\n  };\n  circle2.radius = function(_) {\n    return arguments.length ? (radius2 = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : radius2;\n  };\n  circle2.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant_default8(+_), circle2) : precision;\n  };\n  return circle2;\n}\n\n// node_modules/d3-geo/src/clip/buffer.js\nfunction buffer_default2() {\n  var lines = [], line2;\n  return {\n    point: function(x4, y4, m3) {\n      line2.push([x4, y4, m3]);\n    },\n    lineStart: function() {\n      lines.push(line2 = []);\n    },\n    lineEnd: noop2,\n    rejoin: function() {\n      if (lines.length > 1)\n        lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line2 = null;\n      return result;\n    }\n  };\n}\n\n// node_modules/d3-geo/src/pointEqual.js\nfunction pointEqual_default(a4, b) {\n  return abs3(a4[0] - b[0]) < epsilon7 && abs3(a4[1] - b[1]) < epsilon7;\n}\n\n// node_modules/d3-geo/src/clip/rejoin.js\nfunction Intersection(point6, points, other, entry) {\n  this.x = point6;\n  this.z = points;\n  this.o = other;\n  this.e = entry;\n  this.v = false;\n  this.n = this.p = null;\n}\nfunction rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {\n  var subject = [], clip = [], i, n;\n  segments.forEach(function(segment) {\n    if ((n2 = segment.length - 1) <= 0)\n      return;\n    var n2, p02 = segment[0], p1 = segment[n2], x4;\n    if (pointEqual_default(p02, p1)) {\n      if (!p02[2] && !p1[2]) {\n        stream.lineStart();\n        for (i = 0; i < n2; ++i)\n          stream.point((p02 = segment[i])[0], p02[1]);\n        stream.lineEnd();\n        return;\n      }\n      p1[0] += 2 * epsilon7;\n    }\n    subject.push(x4 = new Intersection(p02, segment, null, true));\n    clip.push(x4.o = new Intersection(p02, null, x4, false));\n    subject.push(x4 = new Intersection(p1, segment, null, false));\n    clip.push(x4.o = new Intersection(p1, null, x4, true));\n  });\n  if (!subject.length)\n    return;\n  clip.sort(compareIntersection2);\n  link(subject);\n  link(clip);\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n  var start2 = subject[0], points, point6;\n  while (1) {\n    var current = start2, isSubject = true;\n    while (current.v)\n      if ((current = current.n) === start2)\n        return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i)\n            stream.point((point6 = points[i])[0], point6[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\nfunction link(array4) {\n  if (!(n = array4.length))\n    return;\n  var n, i = 0, a4 = array4[0], b;\n  while (++i < n) {\n    a4.n = b = array4[i];\n    b.p = a4;\n    a4 = b;\n  }\n  a4.n = b = array4[0];\n  b.p = a4;\n}\n\n// node_modules/d3-geo/src/polygonContains.js\nfunction longitude(point6) {\n  return abs3(point6[0]) <= pi4 ? point6[0] : sign(point6[0]) * ((abs3(point6[0]) + pi4) % tau5 - pi4);\n}\nfunction polygonContains_default(polygon, point6) {\n  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;\n  var sum5 = new Adder();\n  if (sinPhi === 1)\n    phi2 = halfPi3 + epsilon7;\n  else if (sinPhi === -1)\n    phi2 = -halfPi3 - epsilon7;\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m3 = (ring = polygon[i]).length))\n      continue;\n    var ring, m3, point0 = ring[m3 - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin2(phi02), cosPhi03 = cos2(phi02);\n    for (var j = 0; j < m3; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {\n      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda04, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi4, k2 = sinPhi03 * sinPhi1;\n      sum5.add(atan2(k2 * sign3 * sin2(absDelta), cosPhi03 * cosPhi1 + k2 * cos2(absDelta)));\n      angle2 += antimeridian ? delta + sign3 * tau5 : delta;\n      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection2 = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection2);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);\n        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n  return (angle2 < -epsilon7 || angle2 < epsilon7 && sum5 < -epsilon22) ^ winding & 1;\n}\n\n// node_modules/d3-geo/src/clip/index.js\nfunction clip_default(pointVisible, clipLine, interpolate, start2) {\n  return function(sink) {\n    var line2 = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n    var clip = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point6;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains_default(polygon, start2);\n        if (segments.length) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted)\n          sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n    function point6(lambda, phi2) {\n      if (pointVisible(lambda, phi2))\n        sink.point(lambda, phi2);\n    }\n    function pointLine(lambda, phi2) {\n      line2.point(lambda, phi2);\n    }\n    function lineStart() {\n      clip.point = pointLine;\n      line2.lineStart();\n    }\n    function lineEnd() {\n      clip.point = point6;\n      line2.lineEnd();\n    }\n    function pointRing(lambda, phi2) {\n      ring.push([lambda, phi2]);\n      ringSink.point(lambda, phi2);\n    }\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point7;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n)\n        return;\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m3 = segment.length - 1) > 0) {\n          if (!polygonStarted)\n            sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m3; ++i)\n            sink.point((point7 = segment[i])[0], point7[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n      if (n > 1 && clean & 2)\n        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n    return clip;\n  };\n}\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\nfunction compareIntersection(a4, b) {\n  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi3 - epsilon7 : halfPi3 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi3 - epsilon7 : halfPi3 - b[1]);\n}\n\n// node_modules/d3-geo/src/clip/antimeridian.js\nvar antimeridian_default = clip_default(\n  function() {\n    return true;\n  },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi4, -halfPi3]\n);\nfunction clipAntimeridianLine(stream) {\n  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda12, phi12) {\n      var sign1 = lambda12 > 0 ? pi4 : -pi4, delta = abs3(lambda12 - lambda04);\n      if (abs3(delta - pi4) < epsilon7) {\n        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi3 : -halfPi3);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        stream.point(lambda12, phi02);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi4) {\n        if (abs3(lambda04 - sign0) < epsilon7)\n          lambda04 -= sign0 * epsilon7;\n        if (abs3(lambda12 - sign1) < epsilon7)\n          lambda12 -= sign1 * epsilon7;\n        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);\n        stream.point(sign0, phi02);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi02);\n        clean = 0;\n      }\n      stream.point(lambda04 = lambda12, phi02 = phi12);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda04 = phi02 = NaN;\n    },\n    clean: function() {\n      return 2 - clean;\n    }\n  };\n}\nfunction clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {\n  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin2(lambda04 - lambda12);\n  return abs3(sinLambda0Lambda1) > epsilon7 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi03 = cos2(phi02)) * sin2(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;\n}\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi2;\n  if (from == null) {\n    phi2 = direction * halfPi3;\n    stream.point(-pi4, phi2);\n    stream.point(0, phi2);\n    stream.point(pi4, phi2);\n    stream.point(pi4, 0);\n    stream.point(pi4, -phi2);\n    stream.point(0, -phi2);\n    stream.point(-pi4, -phi2);\n    stream.point(-pi4, 0);\n    stream.point(-pi4, phi2);\n  } else if (abs3(from[0] - to[0]) > epsilon7) {\n    var lambda = from[0] < to[0] ? pi4 : -pi4;\n    phi2 = direction * lambda / 2;\n    stream.point(-lambda, phi2);\n    stream.point(0, phi2);\n    stream.point(lambda, phi2);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\n// node_modules/d3-geo/src/clip/circle.js\nfunction circle_default2(radius2) {\n  var cr = cos2(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon7;\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius2, delta, direction, from, to);\n  }\n  function visible(lambda, phi2) {\n    return cos2(lambda) * cos2(phi2) > cr;\n  }\n  function clipLine(stream) {\n    var point0, c0, v0, v00, clean;\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi2) {\n        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c6 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;\n        if (!point0 && (v00 = v0 = v2))\n          stream.lineStart();\n        if (v2 !== v0) {\n          point22 = intersect2(point0, point1);\n          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))\n            point1[2] = 1;\n        }\n        if (v2 !== v0) {\n          clean = 0;\n          if (v2) {\n            stream.lineStart();\n            point22 = intersect2(point1, point0);\n            stream.point(point22[0], point22[1]);\n          } else {\n            point22 = intersect2(point0, point1);\n            stream.point(point22[0], point22[1], 2);\n            stream.lineEnd();\n          }\n          point0 = point22;\n        } else if (notHemisphere && point0 && smallRadius ^ v2) {\n          var t;\n          if (!(c6 & c0) && (t = intersect2(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1], 3);\n            }\n          }\n        }\n        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v2, c0 = c6;\n      },\n      lineEnd: function() {\n        if (v0)\n          stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  }\n  function intersect2(a4, b, two) {\n    var pa = cartesian(a4), pb = cartesian(b);\n    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n    if (!determinant)\n      return !two && a4;\n    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);\n    cartesianAddInPlace(A5, B3);\n    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);\n    if (t22 < 0)\n      return;\n    var t = sqrt(t22), q = cartesianScale(u4, (-w - t) / uu);\n    cartesianAddInPlace(q, A5);\n    q = spherical(q);\n    if (!two)\n      return q;\n    var lambda04 = a4[0], lambda12 = b[0], phi02 = a4[1], phi12 = b[1], z;\n    if (lambda12 < lambda04)\n      z = lambda04, lambda04 = lambda12, lambda12 = z;\n    var delta2 = lambda12 - lambda04, polar = abs3(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;\n    if (!polar && phi12 < phi02)\n      z = phi02, phi02 = phi12, phi12 = z;\n    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs3(q[0] - lambda04) < epsilon7 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi4 ^ (lambda04 <= q[0] && q[0] <= lambda12)) {\n      var q1 = cartesianScale(u4, (-w + t) / uu);\n      cartesianAddInPlace(q1, A5);\n      return [q, spherical(q1)];\n    }\n  }\n  function code(lambda, phi2) {\n    var r = smallRadius ? radius2 : pi4 - radius2, code2 = 0;\n    if (lambda < -r)\n      code2 |= 1;\n    else if (lambda > r)\n      code2 |= 2;\n    if (phi2 < -r)\n      code2 |= 4;\n    else if (phi2 > r)\n      code2 |= 8;\n    return code2;\n  }\n  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi4, radius2 - pi4]);\n}\n\n// node_modules/d3-geo/src/clip/line.js\nfunction line_default(a4, b, x06, y06, x12, y12) {\n  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;\n  r = x06 - ax;\n  if (!dx && r > 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dx > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = x12 - ax;\n  if (!dx && r < 0)\n    return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dx > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  r = y06 - ay;\n  if (!dy && r > 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  } else if (dy > 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  }\n  r = y12 - ay;\n  if (!dy && r < 0)\n    return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t13)\n      return;\n    if (r > t03)\n      t03 = r;\n  } else if (dy > 0) {\n    if (r < t03)\n      return;\n    if (r < t13)\n      t13 = r;\n  }\n  if (t03 > 0)\n    a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;\n  if (t13 < 1)\n    b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;\n  return true;\n}\n\n// node_modules/d3-geo/src/clip/rectangle.js\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\nfunction clipRectangle(x06, y06, x12, y12) {\n  function visible(x4, y4) {\n    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;\n  }\n  function interpolate(from, to, direction, stream) {\n    var a4 = 0, a1 = 0;\n    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do\n        stream.point(a4 === 0 || a4 === 3 ? x06 : x12, a4 > 1 ? y12 : y06);\n      while ((a4 = (a4 + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n  function corner(p, direction) {\n    return abs3(p[0] - x06) < epsilon7 ? direction > 0 ? 0 : 3 : abs3(p[0] - x12) < epsilon7 ? direction > 0 ? 2 : 1 : abs3(p[1] - y06) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n  }\n  function compareIntersection2(a4, b) {\n    return comparePoint(a4.x, b.x);\n  }\n  function comparePoint(a4, b) {\n    var ca3 = corner(a4, 1), cb = corner(b, 1);\n    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a4[1] : ca3 === 1 ? a4[0] - b[0] : ca3 === 2 ? a4[1] - b[1] : b[0] - a4[0];\n  }\n  return function(stream) {\n    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;\n    var clipStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart,\n      polygonEnd\n    };\n    function point6(x4, y4) {\n      if (visible(x4, y4))\n        activeStream.point(x4, y4);\n    }\n    function polygonInside() {\n      var winding = 0;\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b02 = point7[0], b12 = point7[1]; j < m3; ++j) {\n          a0 = b02, a1 = b12, point7 = ring2[j], b02 = point7[0], b12 = point7[1];\n          if (a1 <= y12) {\n            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x06 - a0))\n              ++winding;\n          } else {\n            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x06 - a0))\n              --winding;\n          }\n        }\n      }\n      return winding;\n    }\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n    function polygonEnd() {\n      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;\n      if (cleanInside || visible2) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible2) {\n          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n    function lineStart() {\n      clipStream.point = linePoint2;\n      if (polygon)\n        polygon.push(ring = []);\n      first2 = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n    function lineEnd() {\n      if (segments) {\n        linePoint2(x__, y__);\n        if (v__ && v_)\n          bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point6;\n      if (v_)\n        activeStream.lineEnd();\n    }\n    function linePoint2(x4, y4) {\n      var v2 = visible(x4, y4);\n      if (polygon)\n        ring.push([x4, y4]);\n      if (first2) {\n        x__ = x4, y__ = y4, v__ = v2;\n        first2 = false;\n        if (v2) {\n          activeStream.lineStart();\n          activeStream.point(x4, y4);\n        }\n      } else {\n        if (v2 && v_)\n          activeStream.point(x4, y4);\n        else {\n          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];\n          if (line_default(a4, b, x06, y06, x12, y12)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a4[0], a4[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v2)\n              activeStream.lineEnd();\n            clean = false;\n          } else if (v2) {\n            activeStream.lineStart();\n            activeStream.point(x4, y4);\n            clean = false;\n          }\n        }\n      }\n      x_ = x4, y_ = y4, v_ = v2;\n    }\n    return clipStream;\n  };\n}\n\n// node_modules/d3-geo/src/clip/extent.js\nfunction extent_default2() {\n  var x06 = 0, y06 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip;\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x06, y06, x12, y12)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip) : [[x06, y06], [x12, y12]];\n    }\n  };\n}\n\n// node_modules/d3-geo/src/length.js\nvar lengthSum;\nvar lambda03;\nvar sinPhi02;\nvar cosPhi02;\nvar lengthStream = {\n  sphere: noop2,\n  point: noop2,\n  lineStart: lengthLineStart,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2\n};\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop2;\n}\nfunction lengthPointFirst(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  lambda03 = lambda, sinPhi02 = sin2(phi2), cosPhi02 = cos2(phi2);\n  lengthStream.point = lengthPoint;\n}\nfunction lengthPoint(lambda, phi2) {\n  lambda *= radians2, phi2 *= radians2;\n  var sinPhi = sin2(phi2), cosPhi = cos2(phi2), delta = abs3(lambda - lambda03), cosDelta = cos2(delta), sinDelta = sin2(delta), x4 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z));\n  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;\n}\nfunction length_default(object2) {\n  lengthSum = new Adder();\n  stream_default(object2, lengthStream);\n  return +lengthSum;\n}\n\n// node_modules/d3-geo/src/distance.js\nvar coordinates = [null, null];\nvar object = { type: \"LineString\", coordinates };\nfunction distance_default(a4, b) {\n  coordinates[0] = a4;\n  coordinates[1] = b;\n  return length_default(object);\n}\n\n// node_modules/d3-geo/src/contains.js\nvar containsObjectType = {\n  Feature: function(object2, point6) {\n    return containsGeometry(object2.geometry, point6);\n  },\n  FeatureCollection: function(object2, point6) {\n    var features = object2.features, i = -1, n = features.length;\n    while (++i < n)\n      if (containsGeometry(features[i].geometry, point6))\n        return true;\n    return false;\n  }\n};\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object2, point6) {\n    return containsPoint(object2.coordinates, point6);\n  },\n  MultiPoint: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPoint(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  LineString: function(object2, point6) {\n    return containsLine(object2.coordinates, point6);\n  },\n  MultiLineString: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsLine(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  Polygon: function(object2, point6) {\n    return containsPolygon(object2.coordinates, point6);\n  },\n  MultiPolygon: function(object2, point6) {\n    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;\n    while (++i < n)\n      if (containsPolygon(coordinates2[i], point6))\n        return true;\n    return false;\n  },\n  GeometryCollection: function(object2, point6) {\n    var geometries = object2.geometries, i = -1, n = geometries.length;\n    while (++i < n)\n      if (containsGeometry(geometries[i], point6))\n        return true;\n    return false;\n  }\n};\nfunction containsGeometry(geometry, point6) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point6) : false;\n}\nfunction containsPoint(coordinates2, point6) {\n  return distance_default(coordinates2, point6) === 0;\n}\nfunction containsLine(coordinates2, point6) {\n  var ao, bo, ab4;\n  for (var i = 0, n = coordinates2.length; i < n; i++) {\n    bo = distance_default(coordinates2[i], point6);\n    if (bo === 0)\n      return true;\n    if (i > 0) {\n      ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);\n      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)\n        return true;\n    }\n    ao = bo;\n  }\n  return false;\n}\nfunction containsPolygon(coordinates2, point6) {\n  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point6));\n}\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\nfunction pointRadians(point6) {\n  return [point6[0] * radians2, point6[1] * radians2];\n}\nfunction contains_default2(object2, point6) {\n  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point6);\n}\n\n// node_modules/d3-geo/src/graticule.js\nfunction graticuleX(y06, y12, dy) {\n  var y4 = range(y06, y12 - epsilon7, dy).concat(y12);\n  return function(x4) {\n    return y4.map(function(y5) {\n      return [x4, y5];\n    });\n  };\n}\nfunction graticuleY(x06, x12, dx) {\n  var x4 = range(x06, x12 - epsilon7, dx).concat(x12);\n  return function(y4) {\n    return x4.map(function(x5) {\n      return [x5, y4];\n    });\n  };\n}\nfunction graticule() {\n  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;\n  function graticule3() {\n    return { type: \"MultiLineString\", coordinates: lines() };\n  }\n  function lines() {\n    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {\n      return abs3(x5 % DX) > epsilon7;\n    }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {\n      return abs3(y5 % DY) > epsilon7;\n    }).map(y4));\n  }\n  graticule3.lines = function() {\n    return lines().map(function(coordinates2) {\n      return { type: \"LineString\", coordinates: coordinates2 };\n    });\n  };\n  graticule3.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X3(X03).concat(\n          Y3(Y13).slice(1),\n          X3(X13).reverse().slice(1),\n          Y3(Y03).reverse().slice(1)\n        )\n      ]\n    };\n  };\n  graticule3.extent = function(_) {\n    if (!arguments.length)\n      return graticule3.extentMinor();\n    return graticule3.extentMajor(_).extentMinor(_);\n  };\n  graticule3.extentMajor = function(_) {\n    if (!arguments.length)\n      return [[X03, Y03], [X13, Y13]];\n    X03 = +_[0][0], X13 = +_[1][0];\n    Y03 = +_[0][1], Y13 = +_[1][1];\n    if (X03 > X13)\n      _ = X03, X03 = X13, X13 = _;\n    if (Y03 > Y13)\n      _ = Y03, Y03 = Y13, Y13 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.extentMinor = function(_) {\n    if (!arguments.length)\n      return [[x06, y06], [x12, y12]];\n    x06 = +_[0][0], x12 = +_[1][0];\n    y06 = +_[0][1], y12 = +_[1][1];\n    if (x06 > x12)\n      _ = x06, x06 = x12, x12 = _;\n    if (y06 > y12)\n      _ = y06, y06 = y12, y12 = _;\n    return graticule3.precision(precision);\n  };\n  graticule3.step = function(_) {\n    if (!arguments.length)\n      return graticule3.stepMinor();\n    return graticule3.stepMajor(_).stepMinor(_);\n  };\n  graticule3.stepMajor = function(_) {\n    if (!arguments.length)\n      return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule3;\n  };\n  graticule3.stepMinor = function(_) {\n    if (!arguments.length)\n      return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule3;\n  };\n  graticule3.precision = function(_) {\n    if (!arguments.length)\n      return precision;\n    precision = +_;\n    x4 = graticuleX(y06, y12, 90);\n    y4 = graticuleY(x06, x12, precision);\n    X3 = graticuleX(Y03, Y13, 90);\n    Y3 = graticuleY(X03, X13, precision);\n    return graticule3;\n  };\n  return graticule3.extentMajor([[-180, -90 + epsilon7], [180, 90 - epsilon7]]).extentMinor([[-180, -80 - epsilon7], [180, 80 + epsilon7]]);\n}\nfunction graticule10() {\n  return graticule()();\n}\n\n// node_modules/d3-geo/src/interpolate.js\nfunction interpolate_default2(a4, b) {\n  var x06 = a4[0] * radians2, y06 = a4[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos2(y06), sy0 = sin2(y06), cy1 = cos2(y12), sy1 = sin2(y12), kx0 = cy0 * cos2(x06), ky0 = cy0 * sin2(x06), kx1 = cy1 * cos2(x12), ky1 = cy1 * sin2(x12), d = 2 * asin(sqrt(haversin(y12 - y06) + cy0 * cy1 * haversin(x12 - x06))), k2 = sin2(d);\n  var interpolate = d ? function(t) {\n    var B3 = sin2(t *= d) / k2, A5 = sin2(d - t) / k2, x4 = A5 * kx0 + B3 * kx1, y4 = A5 * ky0 + B3 * ky1, z = A5 * sy0 + B3 * sy1;\n    return [\n      atan2(y4, x4) * degrees3,\n      atan2(z, sqrt(x4 * x4 + y4 * y4)) * degrees3\n    ];\n  } : function() {\n    return [x06 * degrees3, y06 * degrees3];\n  };\n  interpolate.distance = d;\n  return interpolate;\n}\n\n// node_modules/d3-geo/src/identity.js\nvar identity_default3 = (x4) => x4;\n\n// node_modules/d3-geo/src/path/area.js\nvar areaSum2 = new Adder();\nvar areaRingSum2 = new Adder();\nvar x00;\nvar y00;\nvar x02;\nvar y02;\nvar areaStream2 = {\n  point: noop2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: function() {\n    areaStream2.lineStart = areaRingStart2;\n    areaStream2.lineEnd = areaRingEnd2;\n  },\n  polygonEnd: function() {\n    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;\n    areaSum2.add(abs3(areaRingSum2));\n    areaRingSum2 = new Adder();\n  },\n  result: function() {\n    var area2 = areaSum2 / 2;\n    areaSum2 = new Adder();\n    return area2;\n  }\n};\nfunction areaRingStart2() {\n  areaStream2.point = areaPointFirst2;\n}\nfunction areaPointFirst2(x4, y4) {\n  areaStream2.point = areaPoint2;\n  x00 = x02 = x4, y00 = y02 = y4;\n}\nfunction areaPoint2(x4, y4) {\n  areaRingSum2.add(y02 * x4 - x02 * y4);\n  x02 = x4, y02 = y4;\n}\nfunction areaRingEnd2() {\n  areaPoint2(x00, y00);\n}\nvar area_default3 = areaStream2;\n\n// node_modules/d3-geo/src/path/bounds.js\nvar x03 = Infinity;\nvar y03 = x03;\nvar x1 = -x03;\nvar y1 = x1;\nvar boundsStream2 = {\n  point: boundsPoint2,\n  lineStart: noop2,\n  lineEnd: noop2,\n  polygonStart: noop2,\n  polygonEnd: noop2,\n  result: function() {\n    var bounds = [[x03, y03], [x1, y1]];\n    x1 = y1 = -(y03 = x03 = Infinity);\n    return bounds;\n  }\n};\nfunction boundsPoint2(x4, y4) {\n  if (x4 < x03)\n    x03 = x4;\n  if (x4 > x1)\n    x1 = x4;\n  if (y4 < y03)\n    y03 = y4;\n  if (y4 > y1)\n    y1 = y4;\n}\nvar bounds_default2 = boundsStream2;\n\n// node_modules/d3-geo/src/path/centroid.js\nvar X02 = 0;\nvar Y02 = 0;\nvar Z02 = 0;\nvar X12 = 0;\nvar Y12 = 0;\nvar Z12 = 0;\nvar X22 = 0;\nvar Y22 = 0;\nvar Z22 = 0;\nvar x002;\nvar y002;\nvar x04;\nvar y04;\nvar centroidStream2 = {\n  point: centroidPoint2,\n  lineStart: centroidLineStart2,\n  lineEnd: centroidLineEnd2,\n  polygonStart: function() {\n    centroidStream2.lineStart = centroidRingStart2;\n    centroidStream2.lineEnd = centroidRingEnd2;\n  },\n  polygonEnd: function() {\n    centroidStream2.point = centroidPoint2;\n    centroidStream2.lineStart = centroidLineStart2;\n    centroidStream2.lineEnd = centroidLineEnd2;\n  },\n  result: function() {\n    var centroid2 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];\n    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;\n    return centroid2;\n  }\n};\nfunction centroidPoint2(x4, y4) {\n  X02 += x4;\n  Y02 += y4;\n  ++Z02;\n}\nfunction centroidLineStart2() {\n  centroidStream2.point = centroidPointFirstLine;\n}\nfunction centroidPointFirstLine(x4, y4) {\n  centroidStream2.point = centroidPointLine;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidPointLine(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nfunction centroidLineEnd2() {\n  centroidStream2.point = centroidPoint2;\n}\nfunction centroidRingStart2() {\n  centroidStream2.point = centroidPointFirstRing;\n}\nfunction centroidRingEnd2() {\n  centroidPointRing(x002, y002);\n}\nfunction centroidPointFirstRing(x4, y4) {\n  centroidStream2.point = centroidPointRing;\n  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);\n}\nfunction centroidPointRing(x4, y4) {\n  var dx = x4 - x04, dy = y4 - y04, z = sqrt(dx * dx + dy * dy);\n  X12 += z * (x04 + x4) / 2;\n  Y12 += z * (y04 + y4) / 2;\n  Z12 += z;\n  z = y04 * x4 - x04 * y4;\n  X22 += z * (x04 + x4);\n  Y22 += z * (y04 + y4);\n  Z22 += z * 3;\n  centroidPoint2(x04 = x4, y04 = y4);\n}\nvar centroid_default2 = centroidStream2;\n\n// node_modules/d3-geo/src/path/context.js\nfunction PathContext(context) {\n  this._context = context;\n}\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0)\n      this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x4, y4);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x4, y4);\n        break;\n      }\n      default: {\n        this._context.moveTo(x4 + this._radius, y4);\n        this._context.arc(x4, y4, this._radius, 0, tau5);\n        break;\n      }\n    }\n  },\n  result: noop2\n};\n\n// node_modules/d3-geo/src/path/measure.js\nvar lengthSum2 = new Adder();\nvar lengthRing;\nvar x003;\nvar y003;\nvar x05;\nvar y05;\nvar lengthStream2 = {\n  point: noop2,\n  lineStart: function() {\n    lengthStream2.point = lengthPointFirst2;\n  },\n  lineEnd: function() {\n    if (lengthRing)\n      lengthPoint2(x003, y003);\n    lengthStream2.point = noop2;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length4 = +lengthSum2;\n    lengthSum2 = new Adder();\n    return length4;\n  }\n};\nfunction lengthPointFirst2(x4, y4) {\n  lengthStream2.point = lengthPoint2;\n  x003 = x05 = x4, y003 = y05 = y4;\n}\nfunction lengthPoint2(x4, y4) {\n  x05 -= x4, y05 -= y4;\n  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));\n  x05 = x4, y05 = y4;\n}\nvar measure_default = lengthStream2;\n\n// node_modules/d3-geo/src/path/string.js\nvar cacheDigits;\nvar cacheAppend;\nvar cacheRadius;\nvar cacheCircle;\nvar PathString = class {\n  constructor(digits) {\n    this._append = digits == null ? append2 : appendRound2(digits);\n    this._radius = 4.5;\n    this._ = \"\";\n  }\n  pointRadius(_) {\n    this._radius = +_;\n    return this;\n  }\n  polygonStart() {\n    this._line = 0;\n  }\n  polygonEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line === 0)\n      this._ += \"Z\";\n    this._point = NaN;\n  }\n  point(x4, y4) {\n    switch (this._point) {\n      case 0: {\n        this._append`M${x4},${y4}`;\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._append`L${x4},${y4}`;\n        break;\n      }\n      default: {\n        this._append`M${x4},${y4}`;\n        if (this._radius !== cacheRadius || this._append !== cacheAppend) {\n          const r = this._radius;\n          const s2 = this._;\n          this._ = \"\";\n          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;\n          cacheRadius = r;\n          cacheAppend = this._append;\n          cacheCircle = this._;\n          this._ = s2;\n        }\n        this._ += cacheCircle;\n        break;\n      }\n    }\n  }\n  result() {\n    const result = this._;\n    this._ = \"\";\n    return result.length ? result : null;\n  }\n};\nfunction append2(strings) {\n  let i = 1;\n  this._ += strings[0];\n  for (const j = strings.length; i < j; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound2(digits) {\n  const d = Math.floor(digits);\n  if (!(d >= 0))\n    throw new RangeError(`invalid digits: ${digits}`);\n  if (d > 15)\n    return append2;\n  if (d !== cacheDigits) {\n    const k2 = 10 ** d;\n    cacheDigits = d;\n    cacheAppend = function append3(strings) {\n      let i = 1;\n      this._ += strings[0];\n      for (const j = strings.length; i < j; ++i) {\n        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];\n      }\n    };\n  }\n  return cacheAppend;\n}\n\n// node_modules/d3-geo/src/path/index.js\nfunction path_default(projection2, context) {\n  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;\n  function path2(object2) {\n    if (object2) {\n      if (typeof pointRadius === \"function\")\n        contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream_default(object2, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n  path2.area = function(object2) {\n    stream_default(object2, projectionStream(area_default3));\n    return area_default3.result();\n  };\n  path2.measure = function(object2) {\n    stream_default(object2, projectionStream(measure_default));\n    return measure_default.result();\n  };\n  path2.bounds = function(object2) {\n    stream_default(object2, projectionStream(bounds_default2));\n    return bounds_default2.result();\n  };\n  path2.centroid = function(object2) {\n    stream_default(object2, projectionStream(centroid_default2));\n    return centroid_default2.result();\n  };\n  path2.projection = function(_) {\n    if (!arguments.length)\n      return projection2;\n    projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream;\n    return path2;\n  };\n  path2.context = function(_) {\n    if (!arguments.length)\n      return context;\n    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\")\n      contextStream.pointRadius(pointRadius);\n    return path2;\n  };\n  path2.pointRadius = function(_) {\n    if (!arguments.length)\n      return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path2;\n  };\n  path2.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null)\n      digits = null;\n    else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    if (context === null)\n      contextStream = new PathString(digits);\n    return path2;\n  };\n  return path2.projection(projection2).digits(digits).context(context);\n}\n\n// node_modules/d3-geo/src/transform.js\nfunction transform_default(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\nfunction transformer(methods) {\n  return function(stream) {\n    var s2 = new TransformStream();\n    for (var key in methods)\n      s2[key] = methods[key];\n    s2.stream = stream;\n    return s2;\n  };\n}\nfunction TransformStream() {\n}\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x4, y4) {\n    this.stream.point(x4, y4);\n  },\n  sphere: function() {\n    this.stream.sphere();\n  },\n  lineStart: function() {\n    this.stream.lineStart();\n  },\n  lineEnd: function() {\n    this.stream.lineEnd();\n  },\n  polygonStart: function() {\n    this.stream.polygonStart();\n  },\n  polygonEnd: function() {\n    this.stream.polygonEnd();\n  }\n};\n\n// node_modules/d3-geo/src/projection/fit.js\nfunction fit(projection2, fitBounds, object2) {\n  var clip = projection2.clipExtent && projection2.clipExtent();\n  projection2.scale(150).translate([0, 0]);\n  if (clip != null)\n    projection2.clipExtent(null);\n  stream_default(object2, projection2.stream(bounds_default2));\n  fitBounds(bounds_default2.result());\n  if (clip != null)\n    projection2.clipExtent(clip);\n  return projection2;\n}\nfunction fitExtent(projection2, extent3, object2) {\n  return fit(projection2, function(b) {\n    var w = extent3[1][0] - extent3[0][0], h = extent3[1][1] - extent3[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x4 = +extent3[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent3[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitSize(projection2, size, object2) {\n  return fitExtent(projection2, [[0, 0], size], object2);\n}\nfunction fitWidth(projection2, width, object2) {\n  return fit(projection2, function(b) {\n    var w = +width, k2 = w / (b[1][0] - b[0][0]), x4 = (w - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\nfunction fitHeight(projection2, height, object2) {\n  return fit(projection2, function(b) {\n    var h = +height, k2 = h / (b[1][1] - b[0][1]), x4 = -k2 * b[0][0], y4 = (h - k2 * (b[1][1] + b[0][1])) / 2;\n    projection2.scale(150 * k2).translate([x4, y4]);\n  }, object2);\n}\n\n// node_modules/d3-geo/src/projection/resample.js\nvar maxDepth = 16;\nvar cosMinDistance = cos2(30 * radians2);\nfunction resample_default(project2, delta2) {\n  return +delta2 ? resample(project2, delta2) : resampleNone(project2);\n}\nfunction resampleNone(project2) {\n  return transformer({\n    point: function(x4, y4) {\n      x4 = project2(x4, y4);\n      this.stream.point(x4[0], x4[1]);\n    }\n  });\n}\nfunction resample(project2, delta2) {\n  function resampleLineTo(x06, y06, lambda04, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {\n    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a4 = a0 + a1, b = b02 + b12, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b * b + c6 * c6), phi2 = asin(c6 /= m3), lambda22 = abs3(abs3(c6) - 1) < epsilon7 || abs3(lambda04 - lambda12) < epsilon7 ? (lambda04 + lambda12) / 2 : atan2(b, a4), p = project2(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 || abs3((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {\n        resampleLineTo(x06, y06, lambda04, a0, b02, c0, x22, y22, lambda22, a4 /= m3, b /= m3, c6, depth, stream);\n        stream.point(x22, y22);\n        resampleLineTo(x22, y22, lambda22, a4, b, c6, x12, y12, lambda12, a1, b12, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda004, x004, y004, a00, b00, c00, lambda04, x06, y06, a0, b02, c0;\n    var resampleStream = {\n      point: point6,\n      lineStart,\n      lineEnd,\n      polygonStart: function() {\n        stream.polygonStart();\n        resampleStream.lineStart = ringStart;\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n        resampleStream.lineStart = lineStart;\n      }\n    };\n    function point6(x4, y4) {\n      x4 = project2(x4, y4);\n      stream.point(x4[0], x4[1]);\n    }\n    function lineStart() {\n      x06 = NaN;\n      resampleStream.point = linePoint2;\n      stream.lineStart();\n    }\n    function linePoint2(lambda, phi2) {\n      var c6 = cartesian([lambda, phi2]), p = project2(lambda, phi2);\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x06 = p[0], y06 = p[1], lambda04 = lambda, a0 = c6[0], b02 = c6[1], c0 = c6[2], maxDepth, stream);\n      stream.point(x06, y06);\n    }\n    function lineEnd() {\n      resampleStream.point = point6;\n      stream.lineEnd();\n    }\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n    function ringPoint(lambda, phi2) {\n      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b02, c00 = c0;\n      resampleStream.point = linePoint2;\n    }\n    function ringEnd() {\n      resampleLineTo(x06, y06, lambda04, a0, b02, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n    return resampleStream;\n  };\n}\n\n// node_modules/d3-geo/src/projection/index.js\nvar transformRadians = transformer({\n  point: function(x4, y4) {\n    this.stream.point(x4 * radians2, y4 * radians2);\n  }\n});\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x4, y4) {\n      var r = rotate(x4, y4);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\nfunction scaleTranslate(k2, dx, dy, sx, sy) {\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [dx + k2 * x4, dy - k2 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [(x4 - dx) / k2 * sx, (dy - y4) / k2 * sy];\n  };\n  return transform2;\n}\nfunction scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {\n  if (!alpha)\n    return scaleTranslate(k2, dx, dy, sx, sy);\n  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;\n  function transform2(x4, y4) {\n    x4 *= sx;\n    y4 *= sy;\n    return [a4 * x4 - b * y4 + dx, dy - b * x4 - a4 * y4];\n  }\n  transform2.invert = function(x4, y4) {\n    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];\n  };\n  return transform2;\n}\nfunction projection(project2) {\n  return projectionMutator(function() {\n    return project2;\n  })();\n}\nfunction projectionMutator(projectAt) {\n  var project2, k2 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;\n  function projection2(point6) {\n    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);\n  }\n  function invert(point6) {\n    point6 = projectRotateTransform.invert(point6[0], point6[1]);\n    return point6 && [point6[0] * degrees3, point6[1] * degrees3];\n  }\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n  projection2.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, recenter()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (x4 = +_[0], y4 = +_[1], recenter()) : [x4, y4];\n  };\n  projection2.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];\n  };\n  projection2.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;\n  };\n  projection2.precision = function(_) {\n    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  function recenter() {\n    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x4 - center2[0], y4 - center2[1], sx, sy, alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose_default(project2, transform2);\n    projectRotateTransform = compose_default(rotate, projectTransform);\n    projectResample = resample_default(projectTransform, delta2);\n    return reset();\n  }\n  function reset() {\n    cache = cacheStream = null;\n    return projection2;\n  }\n  return function() {\n    project2 = projectAt.apply(this, arguments);\n    projection2.invert = project2.invert && invert;\n    return recenter();\n  };\n}\n\n// node_modules/d3-geo/src/projection/conic.js\nfunction conicProjection(projectAt) {\n  var phi02 = 0, phi12 = pi4 / 3, m3 = projectionMutator(projectAt), p = m3(phi02, phi12);\n  p.parallels = function(_) {\n    return arguments.length ? m3(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];\n  };\n  return p;\n}\n\n// node_modules/d3-geo/src/projection/cylindricalEqualArea.js\nfunction cylindricalEqualAreaRaw(phi02) {\n  var cosPhi03 = cos2(phi02);\n  function forward(lambda, phi2) {\n    return [lambda * cosPhi03, sin2(phi2) / cosPhi03];\n  }\n  forward.invert = function(x4, y4) {\n    return [x4 / cosPhi03, asin(y4 * cosPhi03)];\n  };\n  return forward;\n}\n\n// node_modules/d3-geo/src/projection/conicEqualArea.js\nfunction conicEqualAreaRaw(y06, y12) {\n  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;\n  if (abs3(n) < epsilon7)\n    return cylindricalEqualAreaRaw(y06);\n  var c6 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c6) / n;\n  function project2(x4, y4) {\n    var r = sqrt(c6 - 2 * n * sin2(y4)) / n;\n    return [r * sin2(x4 *= n), r0 - r * cos2(x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var r0y = r0 - y4, l = atan2(x4, abs3(r0y)) * sign(r0y);\n    if (r0y * n < 0)\n      l -= pi4 * sign(x4) * sign(r0y);\n    return [l / n, asin((c6 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];\n  };\n  return project2;\n}\nfunction conicEqualArea_default() {\n  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);\n}\n\n// node_modules/d3-geo/src/projection/albers.js\nfunction albers_default() {\n  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);\n}\n\n// node_modules/d3-geo/src/projection/albersUsa.js\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x4, y4) {\n      var i = -1;\n      while (++i < n)\n        streams[i].point(x4, y4);\n    },\n    sphere: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].sphere();\n    },\n    lineStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineStart();\n    },\n    lineEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].lineEnd();\n    },\n    polygonStart: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonStart();\n    },\n    polygonEnd: function() {\n      var i = -1;\n      while (++i < n)\n        streams[i].polygonEnd();\n    }\n  };\n}\nfunction albersUsa_default() {\n  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x4, y4) {\n    point6 = [x4, y4];\n  } };\n  function albersUsa(coordinates2) {\n    var x4 = coordinates2[0], y4 = coordinates2[1];\n    return point6 = null, (lower48Point.point(x4, y4), point6) || (alaskaPoint.point(x4, y4), point6) || (hawaiiPoint.point(x4, y4), point6);\n  }\n  albersUsa.invert = function(coordinates2) {\n    var k2 = lower48.scale(), t = lower48.translate(), x4 = (coordinates2[0] - t[0]) / k2, y4 = (coordinates2[1] - t[1]) / k2;\n    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);\n  };\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n  albersUsa.precision = function(_) {\n    if (!arguments.length)\n      return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n  albersUsa.scale = function(_) {\n    if (!arguments.length)\n      return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n  albersUsa.translate = function(_) {\n    if (!arguments.length)\n      return lower48.translate();\n    var k2 = lower48.scale(), x4 = +_[0], y4 = +_[1];\n    lower48Point = lower48.translate(_).clipExtent([[x4 - 0.455 * k2, y4 - 0.238 * k2], [x4 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);\n    alaskaPoint = alaska.translate([x4 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x4 - 0.425 * k2 + epsilon7, y4 + 0.12 * k2 + epsilon7], [x4 - 0.214 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    hawaiiPoint = hawaii.translate([x4 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x4 - 0.214 * k2 + epsilon7, y4 + 0.166 * k2 + epsilon7], [x4 - 0.115 * k2 - epsilon7, y4 + 0.234 * k2 - epsilon7]]).stream(pointStream);\n    return reset();\n  };\n  albersUsa.fitExtent = function(extent3, object2) {\n    return fitExtent(albersUsa, extent3, object2);\n  };\n  albersUsa.fitSize = function(size, object2) {\n    return fitSize(albersUsa, size, object2);\n  };\n  albersUsa.fitWidth = function(width, object2) {\n    return fitWidth(albersUsa, width, object2);\n  };\n  albersUsa.fitHeight = function(height, object2) {\n    return fitHeight(albersUsa, height, object2);\n  };\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n  return albersUsa.scale(1070);\n}\n\n// node_modules/d3-geo/src/projection/azimuthal.js\nfunction azimuthalRaw(scale3) {\n  return function(x4, y4) {\n    var cx = cos2(x4), cy = cos2(y4), k2 = scale3(cx * cy);\n    if (k2 === Infinity)\n      return [2, 0];\n    return [\n      k2 * cy * sin2(x4),\n      k2 * sin2(y4)\n    ];\n  };\n}\nfunction azimuthalInvert(angle2) {\n  return function(x4, y4) {\n    var z = sqrt(x4 * x4 + y4 * y4), c6 = angle2(z), sc = sin2(c6), cc2 = cos2(c6);\n    return [\n      atan2(x4 * sc, z * cc2),\n      asin(z && y4 * sc / z)\n    ];\n  };\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEqualArea.js\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\nfunction azimuthalEqualArea_default() {\n  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/azimuthalEquidistant.js\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c6) {\n  return (c6 = acos(c6)) && c6 / sin2(c6);\n});\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\nfunction azimuthalEquidistant_default() {\n  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);\n}\n\n// node_modules/d3-geo/src/projection/mercator.js\nfunction mercatorRaw(lambda, phi2) {\n  return [lambda, log(tan((halfPi3 + phi2) / 2))];\n}\nmercatorRaw.invert = function(x4, y4) {\n  return [x4, 2 * atan(exp(y4)) - halfPi3];\n};\nfunction mercator_default() {\n  return mercatorProjection(mercatorRaw).scale(961 / tau5);\n}\nfunction mercatorProjection(project2) {\n  var m3 = projection(project2), center2 = m3.center, scale3 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;\n  m3.scale = function(_) {\n    return arguments.length ? (scale3(_), reclip()) : scale3();\n  };\n  m3.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n  m3.center = function(_) {\n    return arguments.length ? (center2(_), reclip()) : center2();\n  };\n  m3.clipExtent = function(_) {\n    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  function reclip() {\n    var k2 = pi4 * scale3(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));\n    return clipExtent(x06 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project2 === mercatorRaw ? [[Math.max(t[0] - k2, x06), y06], [Math.min(t[0] + k2, x12), y12]] : [[x06, Math.max(t[1] - k2, y06)], [x12, Math.min(t[1] + k2, y12)]]);\n  }\n  return reclip();\n}\n\n// node_modules/d3-geo/src/projection/conicConformal.js\nfunction tany(y4) {\n  return tan((halfPi3 + y4) / 2);\n}\nfunction conicConformalRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;\n  if (!n)\n    return mercatorRaw;\n  function project2(x4, y4) {\n    if (f > 0) {\n      if (y4 < -halfPi3 + epsilon7)\n        y4 = -halfPi3 + epsilon7;\n    } else {\n      if (y4 > halfPi3 - epsilon7)\n        y4 = halfPi3 - epsilon7;\n    }\n    var r = f / pow2(tany(y4), n);\n    return [r * sin2(n * x4), f - r * cos2(n * x4)];\n  }\n  project2.invert = function(x4, y4) {\n    var fy = f - y4, r = sign(n) * sqrt(x4 * x4 + fy * fy), l = atan2(x4, abs3(fy)) * sign(fy);\n    if (fy * n < 0)\n      l -= pi4 * sign(x4) * sign(fy);\n    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi3];\n  };\n  return project2;\n}\nfunction conicConformal_default() {\n  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);\n}\n\n// node_modules/d3-geo/src/projection/equirectangular.js\nfunction equirectangularRaw(lambda, phi2) {\n  return [lambda, phi2];\n}\nequirectangularRaw.invert = equirectangularRaw;\nfunction equirectangular_default() {\n  return projection(equirectangularRaw).scale(152.63);\n}\n\n// node_modules/d3-geo/src/projection/conicEquidistant.js\nfunction conicEquidistantRaw(y06, y12) {\n  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;\n  if (abs3(n) < epsilon7)\n    return equirectangularRaw;\n  function project2(x4, y4) {\n    var gy = g - y4, nx = n * x4;\n    return [gy * sin2(nx), g - gy * cos2(nx)];\n  }\n  project2.invert = function(x4, y4) {\n    var gy = g - y4, l = atan2(x4, abs3(gy)) * sign(gy);\n    if (gy * n < 0)\n      l -= pi4 * sign(x4) * sign(gy);\n    return [l / n, g - sign(n) * sqrt(x4 * x4 + gy * gy)];\n  };\n  return project2;\n}\nfunction conicEquidistant_default() {\n  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);\n}\n\n// node_modules/d3-geo/src/projection/equalEarth.js\nvar A1 = 1.340264;\nvar A2 = -0.081106;\nvar A3 = 893e-6;\nvar A4 = 3796e-6;\nvar M = sqrt(3) / 2;\nvar iterations = 12;\nfunction equalEarthRaw(lambda, phi2) {\n  var l = asin(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\nequalEarthRaw.invert = function(x4, y4) {\n  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y4;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs3(delta) < epsilon22)\n      break;\n  }\n  return [\n    M * x4 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),\n    asin(sin2(l) / M)\n  ];\n};\nfunction equalEarth_default() {\n  return projection(equalEarthRaw).scale(177.158);\n}\n\n// node_modules/d3-geo/src/projection/gnomonic.js\nfunction gnomonicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\ngnomonicRaw.invert = azimuthalInvert(atan);\nfunction gnomonic_default() {\n  return projection(gnomonicRaw).scale(144.049).clipAngle(60);\n}\n\n// node_modules/d3-geo/src/projection/identity.js\nfunction identity_default4() {\n  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa, x06 = null, y06, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({\n    point: function(x4, y4) {\n      var p = projection2([x4, y4]);\n      this.stream.point(p[0], p[1]);\n    }\n  }), postclip = identity_default3, cache, cacheStream;\n  function reset() {\n    kx2 = k2 * sx;\n    ky2 = k2 * sy;\n    cache = cacheStream = null;\n    return projection2;\n  }\n  function projection2(p) {\n    var x4 = p[0] * kx2, y4 = p[1] * ky2;\n    if (alpha) {\n      var t = y4 * ca3 - x4 * sa;\n      x4 = x4 * ca3 + y4 * sa;\n      y4 = t;\n    }\n    return [x4 + tx, y4 + ty];\n  }\n  projection2.invert = function(p) {\n    var x4 = p[0] - tx, y4 = p[1] - ty;\n    if (alpha) {\n      var t = y4 * ca3 + x4 * sa;\n      x4 = x4 * ca3 - y4 * sa;\n      y4 = t;\n    }\n    return [x4 / kx2, y4 / ky2];\n  };\n  projection2.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));\n  };\n  projection2.postclip = function(_) {\n    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset()) : postclip;\n  };\n  projection2.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];\n  };\n  projection2.scale = function(_) {\n    return arguments.length ? (k2 = +_, reset()) : k2;\n  };\n  projection2.translate = function(_) {\n    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];\n  };\n  projection2.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians2, sa = sin2(alpha), ca3 = cos2(alpha), reset()) : alpha * degrees3;\n  };\n  projection2.reflectX = function(_) {\n    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;\n  };\n  projection2.reflectY = function(_) {\n    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;\n  };\n  projection2.fitExtent = function(extent3, object2) {\n    return fitExtent(projection2, extent3, object2);\n  };\n  projection2.fitSize = function(size, object2) {\n    return fitSize(projection2, size, object2);\n  };\n  projection2.fitWidth = function(width, object2) {\n    return fitWidth(projection2, width, object2);\n  };\n  projection2.fitHeight = function(height, object2) {\n    return fitHeight(projection2, height, object2);\n  };\n  return projection2;\n}\n\n// node_modules/d3-geo/src/projection/naturalEarth1.js\nfunction naturalEarth1Raw(lambda, phi2) {\n  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n  return [\n    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),\n    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))\n  ];\n}\nnaturalEarth1Raw.invert = function(x4, y4) {\n  var phi2 = y4, i = 25, delta;\n  do {\n    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;\n    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));\n  } while (abs3(delta) > epsilon7 && --i > 0);\n  return [\n    x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),\n    phi2\n  ];\n};\nfunction naturalEarth1_default() {\n  return projection(naturalEarth1Raw).scale(175.295);\n}\n\n// node_modules/d3-geo/src/projection/orthographic.js\nfunction orthographicRaw(x4, y4) {\n  return [cos2(y4) * sin2(x4), sin2(y4)];\n}\northographicRaw.invert = azimuthalInvert(asin);\nfunction orthographic_default() {\n  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon7);\n}\n\n// node_modules/d3-geo/src/projection/stereographic.js\nfunction stereographicRaw(x4, y4) {\n  var cy = cos2(y4), k2 = 1 + cos2(x4) * cy;\n  return [cy * sin2(x4) / k2, sin2(y4) / k2];\n}\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\nfunction stereographic_default() {\n  return projection(stereographicRaw).scale(250).clipAngle(142);\n}\n\n// node_modules/d3-geo/src/projection/transverseMercator.js\nfunction transverseMercatorRaw(lambda, phi2) {\n  return [log(tan((halfPi3 + phi2) / 2)), -lambda];\n}\ntransverseMercatorRaw.invert = function(x4, y4) {\n  return [-y4, 2 * atan(exp(x4)) - halfPi3];\n};\nfunction transverseMercator_default() {\n  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;\n  m3.center = function(_) {\n    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);\n  };\n  m3.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n  return rotate([0, 0, 90]).scale(159.155);\n}\n\n// node_modules/d3-hierarchy/src/cluster.js\nfunction defaultSeparation(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction meanX(children2) {\n  return children2.reduce(meanXReduce, 0) / children2.length;\n}\nfunction meanXReduce(x4, c6) {\n  return x4 + c6.x;\n}\nfunction maxY(children2) {\n  return 1 + children2.reduce(maxYReduce, 0);\n}\nfunction maxYReduce(y4, c6) {\n  return Math.max(y4, c6.y);\n}\nfunction leafLeft(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[0];\n  return node;\n}\nfunction leafRight(node) {\n  var children2;\n  while (children2 = node.children)\n    node = children2[children2.length - 1];\n  return node;\n}\nfunction cluster_default() {\n  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;\n  function cluster2(root3) {\n    var previousNode, x4 = 0;\n    root3.eachAfter(function(node) {\n      var children2 = node.children;\n      if (children2) {\n        node.x = meanX(children2);\n        node.y = maxY(children2);\n      } else {\n        node.x = previousNode ? x4 += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n    var left2 = leafLeft(root3), right2 = leafRight(root3), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;\n    return root3.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root3.x) * dx;\n      node.y = (root3.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x06) / (x12 - x06) * dx;\n      node.y = (1 - (root3.y ? node.y / root3.y : 1)) * dy;\n    });\n  }\n  cluster2.separation = function(x4) {\n    return arguments.length ? (separation = x4, cluster2) : separation;\n  };\n  cluster2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? null : [dx, dy];\n  };\n  cluster2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? [dx, dy] : null;\n  };\n  return cluster2;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/count.js\nfunction count2(node) {\n  var sum5 = 0, children2 = node.children, i = children2 && children2.length;\n  if (!i)\n    sum5 = 1;\n  else\n    while (--i >= 0)\n      sum5 += children2[i].value;\n  node.value = sum5;\n}\nfunction count_default() {\n  return this.eachAfter(count2);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/each.js\nfunction each_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js\nfunction eachBefore_default(callback, that) {\n  var node = this, nodes = [node], children2, i, index3 = -1;\n  while (node = nodes.pop()) {\n    callback.call(that, node, ++index3, this);\n    if (children2 = node.children) {\n      for (i = children2.length - 1; i >= 0; --i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js\nfunction eachAfter_default(callback, that) {\n  var node = this, nodes = [node], next = [], children2, i, n, index3 = -1;\n  while (node = nodes.pop()) {\n    next.push(node);\n    if (children2 = node.children) {\n      for (i = 0, n = children2.length; i < n; ++i) {\n        nodes.push(children2[i]);\n      }\n    }\n  }\n  while (node = next.pop()) {\n    callback.call(that, node, ++index3, this);\n  }\n  return this;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/find.js\nfunction find_default2(callback, that) {\n  let index3 = -1;\n  for (const node of this) {\n    if (callback.call(that, node, ++index3, this)) {\n      return node;\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sum.js\nfunction sum_default(value) {\n  return this.eachAfter(function(node) {\n    var sum5 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;\n    while (--i >= 0)\n      sum5 += children2[i].value;\n    node.value = sum5;\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/sort.js\nfunction sort_default2(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/path.js\nfunction path_default2(end) {\n  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];\n  while (start2 !== ancestor) {\n    start2 = start2.parent;\n    nodes.push(start2);\n  }\n  var k2 = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k2, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\nfunction leastCommonAncestor(a4, b) {\n  if (a4 === b)\n    return a4;\n  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c6 = null;\n  a4 = aNodes.pop();\n  b = bNodes.pop();\n  while (a4 === b) {\n    c6 = a4;\n    a4 = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c6;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/ancestors.js\nfunction ancestors_default() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/descendants.js\nfunction descendants_default() {\n  return Array.from(this);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/leaves.js\nfunction leaves_default() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/links.js\nfunction links_default() {\n  var root3 = this, links = [];\n  root3.each(function(node) {\n    if (node !== root3) {\n      links.push({ source: node.parent, target: node });\n    }\n  });\n  return links;\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/iterator.js\nfunction* iterator_default2() {\n  var node = this, current, next = [node], children2, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      yield node;\n      if (children2 = node.children) {\n        for (i = 0, n = children2.length; i < n; ++i) {\n          next.push(children2[i]);\n        }\n      }\n    }\n  } while (next.length);\n}\n\n// node_modules/d3-hierarchy/src/hierarchy/index.js\nfunction hierarchy(data, children2) {\n  if (data instanceof Map) {\n    data = [void 0, data];\n    if (children2 === void 0)\n      children2 = mapChildren;\n  } else if (children2 === void 0) {\n    children2 = objectChildren;\n  }\n  var root3 = new Node2(data), node, nodes = [root3], child, childs, i, n;\n  while (node = nodes.pop()) {\n    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {\n      node.children = childs;\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = childs[i] = new Node2(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n  return root3.eachBefore(computeHeight);\n}\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\nfunction objectChildren(d) {\n  return d.children;\n}\nfunction mapChildren(d) {\n  return Array.isArray(d) ? d[1] : null;\n}\nfunction copyData(node) {\n  if (node.data.value !== void 0)\n    node.value = node.data.value;\n  node.data = node.data.data;\n}\nfunction computeHeight(node) {\n  var height = 0;\n  do\n    node.height = height;\n  while ((node = node.parent) && node.height < ++height);\n}\nfunction Node2(data) {\n  this.data = data;\n  this.depth = this.height = 0;\n  this.parent = null;\n}\nNode2.prototype = hierarchy.prototype = {\n  constructor: Node2,\n  count: count_default,\n  each: each_default2,\n  eachAfter: eachAfter_default,\n  eachBefore: eachBefore_default,\n  find: find_default2,\n  sum: sum_default,\n  sort: sort_default2,\n  path: path_default2,\n  ancestors: ancestors_default,\n  descendants: descendants_default,\n  leaves: leaves_default,\n  links: links_default,\n  copy: node_copy,\n  [Symbol.iterator]: iterator_default2\n};\n\n// node_modules/d3-hierarchy/src/accessors.js\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\nfunction required(f) {\n  if (typeof f !== \"function\")\n    throw new Error();\n  return f;\n}\n\n// node_modules/d3-hierarchy/src/constant.js\nfunction constantZero() {\n  return 0;\n}\nfunction constant_default9(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-hierarchy/src/lcg.js\nvar a2 = 1664525;\nvar c2 = 1013904223;\nvar m2 = 4294967296;\nfunction lcg_default2() {\n  let s2 = 1;\n  return () => (s2 = (a2 * s2 + c2) % m2) / m2;\n}\n\n// node_modules/d3-hierarchy/src/array.js\nfunction array_default2(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\nfunction shuffle(array4, random) {\n  let m3 = array4.length, t, i;\n  while (m3) {\n    i = random() * m3-- | 0;\n    t = array4[m3];\n    array4[m3] = array4[i];\n    array4[i] = t;\n  }\n  return array4;\n}\n\n// node_modules/d3-hierarchy/src/pack/enclose.js\nfunction enclose_default(circles) {\n  return packEncloseRandom(circles, lcg_default2());\n}\nfunction packEncloseRandom(circles, random) {\n  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B3 = [], p, e;\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p))\n      ++i;\n    else\n      e = encloseBasis(B3 = extendBasis(B3, p)), i = 0;\n  }\n  return e;\n}\nfunction extendBasis(B3, p) {\n  var i, j;\n  if (enclosesWeakAll(p, B3))\n    return [p];\n  for (i = 0; i < B3.length; ++i) {\n    if (enclosesNot(p, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p), B3)) {\n      return [B3[i], p];\n    }\n  }\n  for (i = 0; i < B3.length - 1; ++i) {\n    for (j = i + 1; j < B3.length; ++j) {\n      if (enclosesNot(encloseBasis2(B3[i], B3[j]), p) && enclosesNot(encloseBasis2(B3[i], p), B3[j]) && enclosesNot(encloseBasis2(B3[j], p), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p), B3)) {\n        return [B3[i], B3[j], p];\n      }\n    }\n  }\n  throw new Error();\n}\nfunction enclosesNot(a4, b) {\n  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\nfunction enclosesWeak(a4, b) {\n  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction enclosesWeakAll(a4, B3) {\n  for (var i = 0; i < B3.length; ++i) {\n    if (!enclosesWeak(a4, B3[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction encloseBasis(B3) {\n  switch (B3.length) {\n    case 1:\n      return encloseBasis1(B3[0]);\n    case 2:\n      return encloseBasis2(B3[0], B3[1]);\n    case 3:\n      return encloseBasis3(B3[0], B3[1], B3[2]);\n  }\n}\nfunction encloseBasis1(a4) {\n  return {\n    x: a4.x,\n    y: a4.y,\n    r: a4.r\n  };\n}\nfunction encloseBasis2(a4, b) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x12 + x22 + x21 / l * r21) / 2,\n    y: (y12 + y22 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\nfunction encloseBasis3(a4, b, c6) {\n  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x32 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x32, b22 = y12 - y22, b32 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x12, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab4, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);\n  return {\n    x: x12 + xa + xb * r,\n    y: y12 + ya + yb * r,\n    r\n  };\n}\n\n// node_modules/d3-hierarchy/src/pack/siblings.js\nfunction place(b, a4, c6) {\n  var dx = b.x - a4.x, x4, a22, dy = b.y - a4.y, y4, b22, d2 = dx * dx + dy * dy;\n  if (d2) {\n    a22 = a4.r + c6.r, a22 *= a22;\n    b22 = b.r + c6.r, b22 *= b22;\n    if (a22 > b22) {\n      x4 = (d2 + b22 - a22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));\n      c6.x = b.x - x4 * dx - y4 * dy;\n      c6.y = b.y - x4 * dy + y4 * dx;\n    } else {\n      x4 = (d2 + a22 - b22) / (2 * d2);\n      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));\n      c6.x = a4.x + x4 * dx - y4 * dy;\n      c6.y = a4.y + x4 * dy + y4 * dx;\n    }\n  } else {\n    c6.x = a4.x + c6.r;\n    c6.y = a4.y;\n  }\n}\nfunction intersects(a4, b) {\n  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\nfunction score(node) {\n  var a4 = node._, b = node.next._, ab4 = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab4, dy = (a4.y * b.r + b.y * a4.r) / ab4;\n  return dx * dx + dy * dy;\n}\nfunction Node3(circle2) {\n  this._ = circle2;\n  this.next = null;\n  this.previous = null;\n}\nfunction packSiblingsRandom(circles, random) {\n  if (!(n = (circles = array_default2(circles)).length))\n    return 0;\n  var a4, b, c6, n, aa2, ca3, i, j, k2, sj, sk;\n  a4 = circles[0], a4.x = 0, a4.y = 0;\n  if (!(n > 1))\n    return a4.r;\n  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;\n  if (!(n > 2))\n    return a4.r + b.r;\n  place(b, a4, c6 = circles[2]);\n  a4 = new Node3(a4), b = new Node3(b), c6 = new Node3(c6);\n  a4.next = c6.previous = b;\n  b.next = a4.previous = c6;\n  c6.next = b.previous = a4;\n  pack:\n    for (i = 3; i < n; ++i) {\n      place(a4._, b._, c6 = circles[i]), c6 = new Node3(c6);\n      j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;\n      do {\n        if (sj <= sk) {\n          if (intersects(j._, c6._)) {\n            b = j, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sj += j._.r, j = j.next;\n        } else {\n          if (intersects(k2._, c6._)) {\n            a4 = k2, a4.next = b, b.previous = a4, --i;\n            continue pack;\n          }\n          sk += k2._.r, k2 = k2.previous;\n        }\n      } while (j !== k2.next);\n      c6.previous = a4, c6.next = b, a4.next = b.previous = b = c6;\n      aa2 = score(a4);\n      while ((c6 = c6.next) !== b) {\n        if ((ca3 = score(c6)) < aa2) {\n          a4 = c6, aa2 = ca3;\n        }\n      }\n      b = a4.next;\n    }\n  a4 = [b._], c6 = b;\n  while ((c6 = c6.next) !== b)\n    a4.push(c6._);\n  c6 = packEncloseRandom(a4, random);\n  for (i = 0; i < n; ++i)\n    a4 = circles[i], a4.x -= c6.x, a4.y -= c6.y;\n  return c6.r;\n}\nfunction siblings_default(circles) {\n  packSiblingsRandom(circles, lcg_default2());\n  return circles;\n}\n\n// node_modules/d3-hierarchy/src/pack/index.js\nfunction defaultRadius2(d) {\n  return Math.sqrt(d.value);\n}\nfunction pack_default() {\n  var radius2 = null, dx = 1, dy = 1, padding = constantZero;\n  function pack(root3) {\n    const random = lcg_default2();\n    root3.x = dx / 2, root3.y = dy / 2;\n    if (radius2) {\n      root3.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));\n    } else {\n      root3.eachBefore(radiusLeaf(defaultRadius2)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root3.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root3.r)));\n    }\n    return root3;\n  }\n  pack.radius = function(x4) {\n    return arguments.length ? (radius2 = optional(x4), pack) : radius2;\n  };\n  pack.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];\n  };\n  pack.padding = function(x4) {\n    return arguments.length ? (padding = typeof x4 === \"function\" ? x4 : constant_default9(+x4), pack) : padding;\n  };\n  return pack;\n}\nfunction radiusLeaf(radius2) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius2(node) || 0);\n    }\n  };\n}\nfunction packChildrenRandom(padding, k2, random) {\n  return function(node) {\n    if (children2 = node.children) {\n      var children2, i, n = children2.length, r = padding(node) * k2 || 0, e;\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r += r;\n      e = packSiblingsRandom(children2, random);\n      if (r)\n        for (i = 0; i < n; ++i)\n          children2[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\nfunction translateChild(k2) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k2;\n    if (parent) {\n      node.x = parent.x + k2 * node.x;\n      node.y = parent.y + k2 * node.y;\n    }\n  };\n}\n\n// node_modules/d3-hierarchy/src/treemap/round.js\nfunction round_default2(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n\n// node_modules/d3-hierarchy/src/treemap/dice.js\nfunction dice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.y0 = y06, node.y1 = y12;\n    node.x0 = x06, node.x1 = x06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/partition.js\nfunction partition_default() {\n  var dx = 1, dy = 1, padding = 0, round2 = false;\n  function partition(root3) {\n    var n = root3.height + 1;\n    root3.x0 = root3.y0 = padding;\n    root3.x1 = dx;\n    root3.y1 = dy / n;\n    root3.eachBefore(positionNode(dy, n));\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(dy2, n) {\n    return function(node) {\n      if (node.children) {\n        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);\n      }\n      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      node.x0 = x06;\n      node.y0 = y06;\n      node.x1 = x12;\n      node.y1 = y12;\n    };\n  }\n  partition.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, partition) : round2;\n  };\n  partition.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];\n  };\n  partition.padding = function(x4) {\n    return arguments.length ? (padding = +x4, partition) : padding;\n  };\n  return partition;\n}\n\n// node_modules/d3-hierarchy/src/stratify.js\nvar preroot = { depth: -1 };\nvar ambiguous = {};\nvar imputed = {};\nfunction defaultId(d) {\n  return d.id;\n}\nfunction defaultParentId(d) {\n  return d.parentId;\n}\nfunction stratify_default() {\n  var id2 = defaultId, parentId = defaultParentId, path2;\n  function stratify(data) {\n    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();\n    if (path2 != null) {\n      const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i2 of P) {\n        if (!S.has(i2)) {\n          S.add(i2);\n          I.push(i2);\n          P.push(parentof(i2));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i2) => I[i2];\n      currentParentId = (_, i2) => P[i2];\n    }\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node2(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent)\n          throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous)\n          throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children)\n          parent.children.push(node);\n        else\n          parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root3)\n          throw new Error(\"multiple roots\");\n        root3 = node;\n      }\n    }\n    if (!root3)\n      throw new Error(\"no root\");\n    if (path2 != null) {\n      while (root3.data === imputed && root3.children.length === 1) {\n        root3 = root3.children[0], --n;\n      }\n      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {\n        node = nodes[i2];\n        if (node.data !== imputed)\n          break;\n        node.data = null;\n      }\n    }\n    root3.parent = preroot;\n    root3.eachBefore(function(node2) {\n      node2.depth = node2.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root3.parent = null;\n    if (n > 0)\n      throw new Error(\"cycle\");\n    return root3;\n  }\n  stratify.id = function(x4) {\n    return arguments.length ? (id2 = optional(x4), stratify) : id2;\n  };\n  stratify.parentId = function(x4) {\n    return arguments.length ? (parentId = optional(x4), stratify) : parentId;\n  };\n  stratify.path = function(x4) {\n    return arguments.length ? (path2 = optional(x4), stratify) : path2;\n  };\n  return stratify;\n}\nfunction normalize(path2) {\n  path2 = `${path2}`;\n  let i = path2.length;\n  if (slash(path2, i - 1) && !slash(path2, i - 2))\n    path2 = path2.slice(0, -1);\n  return path2[0] === \"/\" ? path2 : `/${path2}`;\n}\nfunction parentof(path2) {\n  let i = path2.length;\n  if (i < 2)\n    return \"\";\n  while (--i > 1)\n    if (slash(path2, i))\n      break;\n  return path2.slice(0, i);\n}\nfunction slash(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\n\n// node_modules/d3-hierarchy/src/tree.js\nfunction defaultSeparation2(a4, b) {\n  return a4.parent === b.parent ? 1 : 2;\n}\nfunction nextLeft(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[0] : v2.t;\n}\nfunction nextRight(v2) {\n  var children2 = v2.children;\n  return children2 ? children2[children2.length - 1] : v2.t;\n}\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\nfunction executeShifts(v2) {\n  var shift = 0, change = 0, children2 = v2.children, i = children2.length, w;\n  while (--i >= 0) {\n    w = children2[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\nfunction nextAncestor(vim, v2, ancestor) {\n  return vim.a.parent === v2.parent ? vim.a : ancestor;\n}\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null;\n  this.a = this;\n  this.z = 0;\n  this.m = 0;\n  this.c = 0;\n  this.s = 0;\n  this.t = null;\n  this.i = i;\n}\nTreeNode.prototype = Object.create(Node2.prototype);\nfunction treeRoot(root3) {\n  var tree2 = new TreeNode(root3, 0), node, nodes = [tree2], child, children2, i, n;\n  while (node = nodes.pop()) {\n    if (children2 = node._.children) {\n      node.children = new Array(n = children2.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));\n        child.parent = node;\n      }\n    }\n  }\n  (tree2.parent = new TreeNode(null, 0)).children = [tree2];\n  return tree2;\n}\nfunction tree_default() {\n  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;\n  function tree2(root3) {\n    var t = treeRoot(root3);\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n    if (nodeSize)\n      root3.eachBefore(sizeNode);\n    else {\n      var left2 = root3, right2 = root3, bottom2 = root3;\n      root3.eachBefore(function(node) {\n        if (node.x < left2.x)\n          left2 = node;\n        if (node.x > right2.x)\n          right2 = node;\n        if (node.depth > bottom2.depth)\n          bottom2 = node;\n      });\n      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);\n      root3.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx2;\n        node.y = node.depth * ky2;\n      });\n    }\n    return root3;\n  }\n  function firstWalk(v2) {\n    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;\n    if (children2) {\n      executeShifts(v2);\n      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;\n      if (w) {\n        v2.z = w.z + separation(v2._, w._);\n        v2.m = v2.z - midpoint;\n      } else {\n        v2.z = midpoint;\n      }\n    } else if (w) {\n      v2.z = w.z + separation(v2._, w._);\n    }\n    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);\n  }\n  function secondWalk(v2) {\n    v2._.x = v2.z + v2.parent.m;\n    v2.m += v2.parent.m;\n  }\n  function apportion(v2, w, ancestor) {\n    if (w) {\n      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v2;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v2;\n      }\n    }\n    return ancestor;\n  }\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n  tree2.separation = function(x4) {\n    return arguments.length ? (separation = x4, tree2) : separation;\n  };\n  tree2.size = function(x4) {\n    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? null : [dx, dy];\n  };\n  tree2.nodeSize = function(x4) {\n    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? [dx, dy] : null;\n  };\n  return tree2;\n}\n\n// node_modules/d3-hierarchy/src/treemap/slice.js\nfunction slice_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y06) / parent.value;\n  while (++i < n) {\n    node = nodes[i], node.x0 = x06, node.x1 = x12;\n    node.y0 = y06, node.y1 = y06 += node.value * k2;\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/squarify.js\nvar phi = (1 + Math.sqrt(5)) / 2;\nfunction squarifyRatio(ratio, parent, x06, y06, x12, y12) {\n  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n  while (i0 < n) {\n    dx = x12 - x06, dy = y12 - y06;\n    do\n      sumValue = nodes[i1++].value;\n    while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue)\n        minValue = nodeValue;\n      if (nodeValue > maxValue)\n        maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) {\n        sumValue -= nodeValue;\n        break;\n      }\n      minRatio = newRatio;\n    }\n    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n    if (row.dice)\n      dice_default(row, x06, y06, x12, value ? y06 += dy * sumValue / value : y12);\n    else\n      slice_default(row, x06, y06, value ? x06 += dx * sumValue / value : x12, y12);\n    value -= sumValue, i0 = i1;\n  }\n  return rows;\n}\nvar squarify_default = function custom10(ratio) {\n  function squarify(parent, x06, y06, x12, y12) {\n    squarifyRatio(ratio, parent, x06, y06, x12, y12);\n  }\n  squarify.ratio = function(x4) {\n    return custom10((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return squarify;\n}(phi);\n\n// node_modules/d3-hierarchy/src/treemap/index.js\nfunction treemap_default() {\n  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;\n  function treemap(root3) {\n    root3.x0 = root3.y0 = 0;\n    root3.x1 = dx;\n    root3.y1 = dy;\n    root3.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round2)\n      root3.eachBefore(round_default2);\n    return root3;\n  }\n  function positionNode(node) {\n    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;\n    if (x12 < x06)\n      x06 = x12 = (x06 + x12) / 2;\n    if (y12 < y06)\n      y06 = y12 = (y06 + y12) / 2;\n    node.x0 = x06;\n    node.y0 = y06;\n    node.x1 = x12;\n    node.y1 = y12;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x06 += paddingLeft(node) - p;\n      y06 += paddingTop(node) - p;\n      x12 -= paddingRight(node) - p;\n      y12 -= paddingBottom(node) - p;\n      if (x12 < x06)\n        x06 = x12 = (x06 + x12) / 2;\n      if (y12 < y06)\n        y06 = y12 = (y06 + y12) / 2;\n      tile(node, x06, y06, x12, y12);\n    }\n  }\n  treemap.round = function(x4) {\n    return arguments.length ? (round2 = !!x4, treemap) : round2;\n  };\n  treemap.size = function(x4) {\n    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];\n  };\n  treemap.tile = function(x4) {\n    return arguments.length ? (tile = required(x4), treemap) : tile;\n  };\n  treemap.padding = function(x4) {\n    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();\n  };\n  treemap.paddingInner = function(x4) {\n    return arguments.length ? (paddingInner = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingInner;\n  };\n  treemap.paddingOuter = function(x4) {\n    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();\n  };\n  treemap.paddingTop = function(x4) {\n    return arguments.length ? (paddingTop = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingTop;\n  };\n  treemap.paddingRight = function(x4) {\n    return arguments.length ? (paddingRight = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingRight;\n  };\n  treemap.paddingBottom = function(x4) {\n    return arguments.length ? (paddingBottom = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingBottom;\n  };\n  treemap.paddingLeft = function(x4) {\n    return arguments.length ? (paddingLeft = typeof x4 === \"function\" ? x4 : constant_default9(+x4), treemap) : paddingLeft;\n  };\n  return treemap;\n}\n\n// node_modules/d3-hierarchy/src/treemap/binary.js\nfunction binary_default(parent, x06, y06, x12, y12) {\n  var nodes = parent.children, i, n = nodes.length, sum5, sums = new Array(n + 1);\n  for (sums[0] = sum5 = i = 0; i < n; ++i) {\n    sums[i + 1] = sum5 += nodes[i].value;\n  }\n  partition(0, n, parent.value, x06, y06, x12, y12);\n  function partition(i2, j, value, x07, y07, x13, y13) {\n    if (i2 >= j - 1) {\n      var node = nodes[i2];\n      node.x0 = x07, node.y0 = y07;\n      node.x1 = x13, node.y1 = y13;\n      return;\n    }\n    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;\n    while (k2 < hi) {\n      var mid3 = k2 + hi >>> 1;\n      if (sums[mid3] < valueTarget)\n        k2 = mid3 + 1;\n      else\n        hi = mid3;\n    }\n    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)\n      --k2;\n    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;\n    if (x13 - x07 > y13 - y07) {\n      var xk = value ? (x07 * valueRight + x13 * valueLeft) / value : x13;\n      partition(i2, k2, valueLeft, x07, y07, xk, y13);\n      partition(k2, j, valueRight, xk, y07, x13, y13);\n    } else {\n      var yk = value ? (y07 * valueRight + y13 * valueLeft) / value : y13;\n      partition(i2, k2, valueLeft, x07, y07, x13, yk);\n      partition(k2, j, valueRight, x07, yk, x13, y13);\n    }\n  }\n}\n\n// node_modules/d3-hierarchy/src/treemap/sliceDice.js\nfunction sliceDice_default(parent, x06, y06, x12, y12) {\n  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);\n}\n\n// node_modules/d3-hierarchy/src/treemap/resquarify.js\nvar resquarify_default = function custom11(ratio) {\n  function resquarify(parent, x06, y06, x12, y12) {\n    if ((rows = parent._squarify) && rows.ratio === ratio) {\n      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value = parent.value;\n      while (++j < m3) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i)\n          row.value += nodes[i].value;\n        if (row.dice)\n          dice_default(row, x06, y06, x12, value ? y06 += (y12 - y06) * row.value / value : y12);\n        else\n          slice_default(row, x06, y06, value ? x06 += (x12 - x06) * row.value / value : x12, y12);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);\n      rows.ratio = ratio;\n    }\n  }\n  resquarify.ratio = function(x4) {\n    return custom11((x4 = +x4) > 1 ? x4 : 1);\n  };\n  return resquarify;\n}(phi);\n\n// node_modules/d3-polygon/src/area.js\nfunction area_default4(polygon) {\n  var i = -1, n = polygon.length, a4, b = polygon[n - 1], area2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    area2 += a4[1] * b[0] - a4[0] * b[1];\n  }\n  return area2 / 2;\n}\n\n// node_modules/d3-polygon/src/centroid.js\nfunction centroid_default3(polygon) {\n  var i = -1, n = polygon.length, x4 = 0, y4 = 0, a4, b = polygon[n - 1], c6, k2 = 0;\n  while (++i < n) {\n    a4 = b;\n    b = polygon[i];\n    k2 += c6 = a4[0] * b[1] - b[0] * a4[1];\n    x4 += (a4[0] + b[0]) * c6;\n    y4 += (a4[1] + b[1]) * c6;\n  }\n  return k2 *= 3, [x4 / k2, y4 / k2];\n}\n\n// node_modules/d3-polygon/src/cross.js\nfunction cross_default(a4, b, c6) {\n  return (b[0] - a4[0]) * (c6[1] - a4[1]) - (b[1] - a4[1]) * (c6[0] - a4[0]);\n}\n\n// node_modules/d3-polygon/src/hull.js\nfunction lexicographicOrder(a4, b) {\n  return a4[0] - b[0] || a4[1] - b[1];\n}\nfunction computeUpperHullIndexes(points) {\n  const n = points.length, indexes2 = [0, 1];\n  let size = 2, i;\n  for (i = 2; i < n; ++i) {\n    while (size > 1 && cross_default(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)\n      --size;\n    indexes2[size++] = i;\n  }\n  return indexes2.slice(0, size);\n}\nfunction hull_default(points) {\n  if ((n = points.length) < 3)\n    return null;\n  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);\n  for (i = 0; i < n; ++i)\n    sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i)\n    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);\n  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];\n  for (i = upperIndexes.length - 1; i >= 0; --i)\n    hull2.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)\n    hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);\n  return hull2;\n}\n\n// node_modules/d3-polygon/src/contains.js\nfunction contains_default3(polygon, point6) {\n  var n = polygon.length, p = polygon[n - 1], x4 = point6[0], y4 = point6[1], x06 = p[0], y06 = p[1], x12, y12, inside = false;\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x12 = p[0], y12 = p[1];\n    if (y12 > y4 !== y06 > y4 && x4 < (x06 - x12) * (y4 - y12) / (y06 - y12) + x12)\n      inside = !inside;\n    x06 = x12, y06 = y12;\n  }\n  return inside;\n}\n\n// node_modules/d3-polygon/src/length.js\nfunction length_default2(polygon) {\n  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.hypot(xa, ya);\n  }\n  return perimeter;\n}\n\n// node_modules/d3-random/src/defaultSource.js\nvar defaultSource_default = Math.random;\n\n// node_modules/d3-random/src/uniform.js\nvar uniform_default = function sourceRandomUniform(source) {\n  function randomUniform(min4, max5) {\n    min4 = min4 == null ? 0 : +min4;\n    max5 = max5 == null ? 1 : +max5;\n    if (arguments.length === 1)\n      max5 = min4, min4 = 0;\n    else\n      max5 -= min4;\n    return function() {\n      return source() * max5 + min4;\n    };\n  }\n  randomUniform.source = sourceRandomUniform;\n  return randomUniform;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/int.js\nvar int_default = function sourceRandomInt(source) {\n  function randomInt(min4, max5) {\n    if (arguments.length < 2)\n      max5 = min4, min4 = 0;\n    min4 = Math.floor(min4);\n    max5 = Math.floor(max5) - min4;\n    return function() {\n      return Math.floor(source() * max5 + min4);\n    };\n  }\n  randomInt.source = sourceRandomInt;\n  return randomInt;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/normal.js\nvar normal_default = function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x4, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y4;\n      if (x4 != null)\n        y4 = x4, x4 = null;\n      else\n        do {\n          x4 = source() * 2 - 1;\n          y4 = source() * 2 - 1;\n          r = x4 * x4 + y4 * y4;\n        } while (!r || r > 1);\n      return mu + sigma * y4 * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n  randomNormal.source = sourceRandomNormal;\n  return randomNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logNormal.js\nvar logNormal_default = function sourceRandomLogNormal(source) {\n  var N = normal_default.source(source);\n  function randomLogNormal() {\n    var randomNormal = N.apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n  randomLogNormal.source = sourceRandomLogNormal;\n  return randomLogNormal;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/irwinHall.js\nvar irwinHall_default = function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    if ((n = +n) <= 0)\n      return () => 0;\n    return function() {\n      for (var sum5 = 0, i = n; i > 1; --i)\n        sum5 += source();\n      return sum5 + i * source();\n    };\n  }\n  randomIrwinHall.source = sourceRandomIrwinHall;\n  return randomIrwinHall;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bates.js\nvar bates_default = function sourceRandomBates(source) {\n  var I = irwinHall_default.source(source);\n  function randomBates(n) {\n    if ((n = +n) === 0)\n      return source;\n    var randomIrwinHall = I(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n  randomBates.source = sourceRandomBates;\n  return randomBates;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/exponential.js\nvar exponential_default = function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log1p(-source()) / lambda;\n    };\n  }\n  randomExponential.source = sourceRandomExponential;\n  return randomExponential;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/pareto.js\nvar pareto_default = function sourceRandomPareto(source) {\n  function randomPareto(alpha) {\n    if ((alpha = +alpha) < 0)\n      throw new RangeError(\"invalid alpha\");\n    alpha = 1 / -alpha;\n    return function() {\n      return Math.pow(1 - source(), alpha);\n    };\n  }\n  randomPareto.source = sourceRandomPareto;\n  return randomPareto;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/bernoulli.js\nvar bernoulli_default = function sourceRandomBernoulli(source) {\n  function randomBernoulli(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    return function() {\n      return Math.floor(source() + p);\n    };\n  }\n  randomBernoulli.source = sourceRandomBernoulli;\n  return randomBernoulli;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/geometric.js\nvar geometric_default = function sourceRandomGeometric(source) {\n  function randomGeometric(p) {\n    if ((p = +p) < 0 || p > 1)\n      throw new RangeError(\"invalid p\");\n    if (p === 0)\n      return () => Infinity;\n    if (p === 1)\n      return () => 1;\n    p = Math.log1p(-p);\n    return function() {\n      return 1 + Math.floor(Math.log1p(-source()) / p);\n    };\n  }\n  randomGeometric.source = sourceRandomGeometric;\n  return randomGeometric;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/gamma.js\nvar gamma_default = function sourceRandomGamma(source) {\n  var randomNormal = normal_default.source(source)();\n  function randomGamma(k2, theta) {\n    if ((k2 = +k2) < 0)\n      throw new RangeError(\"invalid k\");\n    if (k2 === 0)\n      return () => 0;\n    theta = theta == null ? 1 : +theta;\n    if (k2 === 1)\n      return () => -Math.log1p(-source()) * theta;\n    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c6 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;\n    return function() {\n      do {\n        do {\n          var x4 = randomNormal(), v2 = 1 + c6 * x4;\n        } while (v2 <= 0);\n        v2 *= v2 * v2;\n        var u4 = 1 - source();\n      } while (u4 >= 1 - 0.0331 * x4 * x4 * x4 * x4 && Math.log(u4) >= 0.5 * x4 * x4 + d * (1 - v2 + Math.log(v2)));\n      return d * v2 * multiplier() * theta;\n    };\n  }\n  randomGamma.source = sourceRandomGamma;\n  return randomGamma;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/beta.js\nvar beta_default = function sourceRandomBeta(source) {\n  var G = gamma_default.source(source);\n  function randomBeta(alpha, beta) {\n    var X3 = G(alpha), Y3 = G(beta);\n    return function() {\n      var x4 = X3();\n      return x4 === 0 ? 0 : x4 / (x4 + Y3());\n    };\n  }\n  randomBeta.source = sourceRandomBeta;\n  return randomBeta;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/binomial.js\nvar binomial_default = function sourceRandomBinomial(source) {\n  var G = geometric_default.source(source), B3 = beta_default.source(source);\n  function randomBinomial(n, p) {\n    n = +n;\n    if ((p = +p) >= 1)\n      return () => n;\n    if (p <= 0)\n      return () => 0;\n    return function() {\n      var acc = 0, nn = n, pp = p;\n      while (nn * pp > 16 && nn * (1 - pp) > 16) {\n        var i = Math.floor((nn + 1) * pp), y4 = B3(i, nn - i + 1)();\n        if (y4 <= pp) {\n          acc += i;\n          nn -= i;\n          pp = (pp - y4) / (1 - y4);\n        } else {\n          nn = i - 1;\n          pp /= y4;\n        }\n      }\n      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);\n      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)\n        s2 += g();\n      return acc + (sign3 ? k2 : nn - k2);\n    };\n  }\n  randomBinomial.source = sourceRandomBinomial;\n  return randomBinomial;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/weibull.js\nvar weibull_default = function sourceRandomWeibull(source) {\n  function randomWeibull(k2, a4, b) {\n    var outerFunc;\n    if ((k2 = +k2) === 0) {\n      outerFunc = (x4) => -Math.log(x4);\n    } else {\n      k2 = 1 / k2;\n      outerFunc = (x4) => Math.pow(x4, k2);\n    }\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * outerFunc(-Math.log1p(-source()));\n    };\n  }\n  randomWeibull.source = sourceRandomWeibull;\n  return randomWeibull;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/cauchy.js\nvar cauchy_default = function sourceRandomCauchy(source) {\n  function randomCauchy(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      return a4 + b * Math.tan(Math.PI * source());\n    };\n  }\n  randomCauchy.source = sourceRandomCauchy;\n  return randomCauchy;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/logistic.js\nvar logistic_default = function sourceRandomLogistic(source) {\n  function randomLogistic(a4, b) {\n    a4 = a4 == null ? 0 : +a4;\n    b = b == null ? 1 : +b;\n    return function() {\n      var u4 = source();\n      return a4 + b * Math.log(u4 / (1 - u4));\n    };\n  }\n  randomLogistic.source = sourceRandomLogistic;\n  return randomLogistic;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/poisson.js\nvar poisson_default = function sourceRandomPoisson(source) {\n  var G = gamma_default.source(source), B3 = binomial_default.source(source);\n  function randomPoisson(lambda) {\n    return function() {\n      var acc = 0, l = lambda;\n      while (l > 16) {\n        var n = Math.floor(0.875 * l), t = G(n)();\n        if (t > l)\n          return acc + B3(n - 1, l / t)();\n        acc += n;\n        l -= t;\n      }\n      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)\n        s2 -= Math.log1p(-source());\n      return acc + k2;\n    };\n  }\n  randomPoisson.source = sourceRandomPoisson;\n  return randomPoisson;\n}(defaultSource_default);\n\n// node_modules/d3-random/src/lcg.js\nvar mul = 1664525;\nvar inc = 1013904223;\nvar eps = 1 / 4294967296;\nfunction lcg(seed = Math.random()) {\n  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;\n  return () => (state = mul * state + inc | 0, eps * (state >>> 0));\n}\n\n// node_modules/d3-scale/src/init.js\nfunction initRange(domain, range5) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1:\n      this.range(domain);\n      break;\n    default:\n      this.range(range5).domain(domain);\n      break;\n  }\n  return this;\n}\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0:\n      break;\n    case 1: {\n      if (typeof domain === \"function\")\n        this.interpolator(domain);\n      else\n        this.range(domain);\n      break;\n    }\n    default: {\n      this.domain(domain);\n      if (typeof interpolator === \"function\")\n        this.interpolator(interpolator);\n      else\n        this.range(interpolator);\n      break;\n    }\n  }\n  return this;\n}\n\n// node_modules/d3-scale/src/ordinal.js\nvar implicit = Symbol(\"implicit\");\nfunction ordinal() {\n  var index3 = new InternMap(), domain = [], range5 = [], unknown = implicit;\n  function scale3(d) {\n    let i = index3.get(d);\n    if (i === void 0) {\n      if (unknown !== implicit)\n        return unknown;\n      index3.set(d, i = domain.push(d) - 1);\n    }\n    return range5[i % range5.length];\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [], index3 = new InternMap();\n    for (const value of _) {\n      if (index3.has(value))\n        continue;\n      index3.set(value, domain.push(value) - 1);\n    }\n    return scale3;\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), scale3) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return ordinal(domain, range5).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/band.js\nfunction band() {\n  var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange2 = scale3.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;\n  delete scale3.unknown;\n  function rescale() {\n    var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;\n    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round2)\n      step = Math.floor(step);\n    start2 += (stop - start2 - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round2)\n      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);\n    var values2 = range(n).map(function(i) {\n      return start2 + step * i;\n    });\n    return ordinalRange2(reverse3 ? values2.reverse() : values2);\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];\n  };\n  scale3.rangeRound = function(_) {\n    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();\n  };\n  scale3.bandwidth = function() {\n    return bandwidth;\n  };\n  scale3.step = function() {\n    return step;\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, rescale()) : round2;\n  };\n  scale3.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n  scale3.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n  scale3.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n  scale3.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n  scale3.copy = function() {\n    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n  return initRange.apply(rescale(), arguments);\n}\nfunction pointish(scale3) {\n  var copy3 = scale3.copy;\n  scale3.padding = scale3.paddingOuter;\n  delete scale3.paddingInner;\n  delete scale3.paddingOuter;\n  scale3.copy = function() {\n    return pointish(copy3());\n  };\n  return scale3;\n}\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// node_modules/d3-scale/src/constant.js\nfunction constants(x4) {\n  return function() {\n    return x4;\n  };\n}\n\n// node_modules/d3-scale/src/number.js\nfunction number3(x4) {\n  return +x4;\n}\n\n// node_modules/d3-scale/src/continuous.js\nvar unit = [0, 1];\nfunction identity3(x4) {\n  return x4;\n}\nfunction normalize2(a4, b) {\n  return (b -= a4 = +a4) ? function(x4) {\n    return (x4 - a4) / b;\n  } : constants(isNaN(b) ? NaN : 0.5);\n}\nfunction clamper(a4, b) {\n  var t;\n  if (a4 > b)\n    t = a4, a4 = b, b = t;\n  return function(x4) {\n    return Math.max(a4, Math.min(b, x4));\n  };\n}\nfunction bimap(domain, range5, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];\n  if (d1 < d0)\n    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);\n  else\n    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);\n  return function(x4) {\n    return r0(d0(x4));\n  };\n}\nfunction polymap(domain, range5, interpolate) {\n  var j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j), i = -1;\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range5 = range5.slice().reverse();\n  }\n  while (++i < j) {\n    d[i] = normalize2(domain[i], domain[i + 1]);\n    r[i] = interpolate(range5[i], range5[i + 1]);\n  }\n  return function(x4) {\n    var i2 = bisect_default(domain, x4, 1, j) - 1;\n    return r[i2](d[i2](x4));\n  };\n}\nfunction copy(source, target) {\n  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction transformer2() {\n  var domain = unit, range5 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;\n  function rescale() {\n    var n = Math.min(domain.length, range5.length);\n    if (clamp !== identity3)\n      clamp = clamper(domain[0], domain[n - 1]);\n    piecewise2 = n > 2 ? polymap : bimap;\n    output = input = null;\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform2), range5, interpolate)))(transform2(clamp(x4)));\n  }\n  scale3.invert = function(y4) {\n    return clamp(untransform((input || (input = piecewise2(range5, domain.map(transform2), number_default)))(y4)));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return range5 = Array.from(_), interpolate = round_default, rescale();\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;\n  };\n  scale3.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t, u4) {\n    transform2 = t, untransform = u4;\n    return rescale();\n  };\n}\nfunction continuous() {\n  return transformer2()(identity3, identity3);\n}\n\n// node_modules/d3-scale/src/tickFormat.js\nfunction tickFormat(start2, stop, count3, specifier) {\n  var step = tickStep(start2, stop, count3), precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start2), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))\n        specifier.precision = precision;\n      return formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))\n        specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))\n        specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format(specifier);\n}\n\n// node_modules/d3-scale/src/linear.js\nfunction linearish(scale3) {\n  var domain = scale3.domain;\n  scale3.ticks = function(count3) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);\n  };\n  scale3.nice = function(count3) {\n    if (count3 == null)\n      count3 = 10;\n    var d = domain();\n    var i0 = 0;\n    var i1 = d.length - 1;\n    var start2 = d[i0];\n    var stop = d[i1];\n    var prestep;\n    var step;\n    var maxIter = 10;\n    if (stop < start2) {\n      step = start2, start2 = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n    while (maxIter-- > 0) {\n      step = tickIncrement(start2, stop, count3);\n      if (step === prestep) {\n        d[i0] = start2;\n        d[i1] = stop;\n        return domain(d);\n      } else if (step > 0) {\n        start2 = Math.floor(start2 / step) * step;\n        stop = Math.ceil(stop / step) * step;\n      } else if (step < 0) {\n        start2 = Math.ceil(start2 * step) / step;\n        stop = Math.floor(stop * step) / step;\n      } else {\n        break;\n      }\n      prestep = step;\n    }\n    return scale3;\n  };\n  return scale3;\n}\nfunction linear3() {\n  var scale3 = continuous();\n  scale3.copy = function() {\n    return copy(scale3, linear3());\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/identity.js\nfunction identity4(domain) {\n  var unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : x4;\n  }\n  scale3.invert = scale3;\n  scale3.domain = scale3.range = function(_) {\n    return arguments.length ? (domain = Array.from(_, number3), scale3) : domain.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return identity4(domain).unknown(unknown);\n  };\n  domain = arguments.length ? Array.from(domain, number3) : [0, 1];\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/nice.js\nfunction nice2(domain, interval2) {\n  domain = domain.slice();\n  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;\n  if (x12 < x06) {\n    t = i0, i0 = i1, i1 = t;\n    t = x06, x06 = x12, x12 = t;\n  }\n  domain[i0] = interval2.floor(x06);\n  domain[i1] = interval2.ceil(x12);\n  return domain;\n}\n\n// node_modules/d3-scale/src/log.js\nfunction transformLog(x4) {\n  return Math.log(x4);\n}\nfunction transformExp(x4) {\n  return Math.exp(x4);\n}\nfunction transformLogn(x4) {\n  return -Math.log(-x4);\n}\nfunction transformExpn(x4) {\n  return -Math.exp(-x4);\n}\nfunction pow10(x4) {\n  return isFinite(x4) ? +(\"1e\" + x4) : x4 < 0 ? 0 : x4;\n}\nfunction powp(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);\n}\nfunction logp(base) {\n  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);\n}\nfunction reflect(f) {\n  return (x4, k2) => -f(-x4, k2);\n}\nfunction loggish(transform2) {\n  const scale3 = transform2(transformLog, transformExp);\n  const domain = scale3.domain;\n  let base = 10;\n  let logs;\n  let pows;\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform2(transformLogn, transformExpn);\n    } else {\n      transform2(transformLog, transformExp);\n    }\n    return scale3;\n  }\n  scale3.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n  scale3.ticks = (count3) => {\n    const d = domain();\n    let u4 = d[0];\n    let v2 = d[d.length - 1];\n    const r = v2 < u4;\n    if (r)\n      [u4, v2] = [v2, u4];\n    let i = logs(u4);\n    let j = logs(v2);\n    let k2;\n    let t;\n    const n = count3 == null ? 10 : +count3;\n    let z = [];\n    if (!(base % 1) && j - i < n) {\n      i = Math.floor(i), j = Math.ceil(j);\n      if (u4 > 0)\n        for (; i <= j; ++i) {\n          for (k2 = 1; k2 < base; ++k2) {\n            t = i < 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      else\n        for (; i <= j; ++i) {\n          for (k2 = base - 1; k2 >= 1; --k2) {\n            t = i > 0 ? k2 / pows(-i) : k2 * pows(i);\n            if (t < u4)\n              continue;\n            if (t > v2)\n              break;\n            z.push(t);\n          }\n        }\n      if (z.length * 2 < n)\n        z = ticks(u4, v2, n);\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n    return r ? z.reverse() : z;\n  };\n  scale3.tickFormat = (count3, specifier) => {\n    if (count3 == null)\n      count3 = 10;\n    if (specifier == null)\n      specifier = base === 10 ? \"s\" : \",\";\n    if (typeof specifier !== \"function\") {\n      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)\n        specifier.trim = true;\n      specifier = format(specifier);\n    }\n    if (count3 === Infinity)\n      return specifier;\n    const k2 = Math.max(1, base * count3 / scale3.ticks().length);\n    return (d) => {\n      let i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5)\n        i *= base;\n      return i <= k2 ? specifier(d) : \"\";\n    };\n  };\n  scale3.nice = () => {\n    return domain(nice2(domain(), {\n      floor: (x4) => pows(Math.floor(logs(x4))),\n      ceil: (x4) => pows(Math.ceil(logs(x4)))\n    }));\n  };\n  return scale3;\n}\nfunction log2() {\n  const scale3 = loggish(transformer2()).domain([1, 10]);\n  scale3.copy = () => copy(scale3, log2()).base(scale3.base());\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\n\n// node_modules/d3-scale/src/symlog.js\nfunction transformSymlog(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.log1p(Math.abs(x4 / c6));\n  };\n}\nfunction transformSymexp(c6) {\n  return function(x4) {\n    return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c6;\n  };\n}\nfunction symlogish(transform2) {\n  var c6 = 1, scale3 = transform2(transformSymlog(c6), transformSymexp(c6));\n  scale3.constant = function(_) {\n    return arguments.length ? transform2(transformSymlog(c6 = +_), transformSymexp(c6)) : c6;\n  };\n  return linearish(scale3);\n}\nfunction symlog() {\n  var scale3 = symlogish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, symlog()).constant(scale3.constant());\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/pow.js\nfunction transformPow(exponent2) {\n  return function(x4) {\n    return x4 < 0 ? -Math.pow(-x4, exponent2) : Math.pow(x4, exponent2);\n  };\n}\nfunction transformSqrt(x4) {\n  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);\n}\nfunction transformSquare(x4) {\n  return x4 < 0 ? -x4 * x4 : x4 * x4;\n}\nfunction powish(transform2) {\n  var scale3 = transform2(identity3, identity3), exponent2 = 1;\n  function rescale() {\n    return exponent2 === 1 ? transform2(identity3, identity3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));\n  }\n  scale3.exponent = function(_) {\n    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;\n  };\n  return linearish(scale3);\n}\nfunction pow3() {\n  var scale3 = powish(transformer2());\n  scale3.copy = function() {\n    return copy(scale3, pow3()).exponent(scale3.exponent());\n  };\n  initRange.apply(scale3, arguments);\n  return scale3;\n}\nfunction sqrt2() {\n  return pow3.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/radial.js\nfunction square(x4) {\n  return Math.sign(x4) * x4 * x4;\n}\nfunction unsquare(x4) {\n  return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n}\nfunction radial() {\n  var squared = continuous(), range5 = [0, 1], round2 = false, unknown;\n  function scale3(x4) {\n    var y4 = unsquare(squared(x4));\n    return isNaN(y4) ? unknown : round2 ? Math.round(y4) : y4;\n  }\n  scale3.invert = function(y4) {\n    return squared.invert(square(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? (squared.domain(_), scale3) : squared.domain();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (squared.range((range5 = Array.from(_, number3)).map(square)), scale3) : range5.slice();\n  };\n  scale3.rangeRound = function(_) {\n    return scale3.range(_).round(true);\n  };\n  scale3.round = function(_) {\n    return arguments.length ? (round2 = !!_, scale3) : round2;\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (squared.clamp(_), scale3) : squared.clamp();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return radial(squared.domain(), range5).round(round2).clamp(squared.clamp()).unknown(unknown);\n  };\n  initRange.apply(scale3, arguments);\n  return linearish(scale3);\n}\n\n// node_modules/d3-scale/src/quantile.js\nfunction quantile2() {\n  var domain = [], range5 = [], thresholds = [], unknown;\n  function rescale() {\n    var i = 0, n = Math.max(1, range5.length);\n    thresholds = new Array(n - 1);\n    while (++i < n)\n      thresholds[i - 1] = quantileSorted(domain, i / n);\n    return scale3;\n  }\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : range5[bisect_default(thresholds, x4)];\n  }\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.quantiles = function() {\n    return thresholds.slice();\n  };\n  scale3.copy = function() {\n    return quantile2().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/quantize.js\nfunction quantize() {\n  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range5 = [0, 1], unknown;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n)\n      domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);\n    return scale3;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : scale3;\n  };\n  scale3.thresholds = function() {\n    return domain.slice();\n  };\n  scale3.copy = function() {\n    return quantize().domain([x06, x12]).range(range5).unknown(unknown);\n  };\n  return initRange.apply(linearish(scale3), arguments);\n}\n\n// node_modules/d3-scale/src/threshold.js\nfunction threshold() {\n  var domain = [0.5], range5 = [0, 1], unknown, n = 1;\n  function scale3(x4) {\n    return x4 != null && x4 <= x4 ? range5[bisect_default(domain, x4, 0, n)] : unknown;\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : domain.slice();\n  };\n  scale3.range = function(_) {\n    return arguments.length ? (range5 = Array.from(_), n = Math.min(domain.length, range5.length - 1), scale3) : range5.slice();\n  };\n  scale3.invertExtent = function(y4) {\n    var i = range5.indexOf(y4);\n    return [domain[i - 1], domain[i]];\n  };\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  scale3.copy = function() {\n    return threshold().domain(domain).range(range5).unknown(unknown);\n  };\n  return initRange.apply(scale3, arguments);\n}\n\n// node_modules/d3-time/src/interval.js\nvar t02 = /* @__PURE__ */ new Date();\nvar t12 = /* @__PURE__ */ new Date();\nfunction timeInterval(floori, offseti, count3, field2) {\n  function interval2(date2) {\n    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;\n  }\n  interval2.floor = (date2) => {\n    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;\n  };\n  interval2.ceil = (date2) => {\n    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;\n  };\n  interval2.round = (date2) => {\n    const d0 = interval2(date2), d1 = interval2.ceil(date2);\n    return date2 - d0 < d1 - date2 ? d0 : d1;\n  };\n  interval2.offset = (date2, step) => {\n    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;\n  };\n  interval2.range = (start2, stop, step) => {\n    const range5 = [];\n    start2 = interval2.ceil(start2);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start2 < stop) || !(step > 0))\n      return range5;\n    let previous;\n    do\n      range5.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);\n    while (previous < start2 && start2 < stop);\n    return range5;\n  };\n  interval2.filter = (test) => {\n    return timeInterval((date2) => {\n      if (date2 >= date2)\n        while (floori(date2), !test(date2))\n          date2.setTime(date2 - 1);\n    }, (date2, step) => {\n      if (date2 >= date2) {\n        if (step < 0)\n          while (++step <= 0) {\n            while (offseti(date2, -1), !test(date2)) {\n            }\n          }\n        else\n          while (--step >= 0) {\n            while (offseti(date2, 1), !test(date2)) {\n            }\n          }\n      }\n    });\n  };\n  if (count3) {\n    interval2.count = (start2, end) => {\n      t02.setTime(+start2), t12.setTime(+end);\n      floori(t02), floori(t12);\n      return Math.floor(count3(t02, t12));\n    };\n    interval2.every = (step) => {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);\n    };\n  }\n  return interval2;\n}\n\n// node_modules/d3-time/src/millisecond.js\nvar millisecond = timeInterval(() => {\n}, (date2, step) => {\n  date2.setTime(+date2 + step);\n}, (start2, end) => {\n  return end - start2;\n});\nmillisecond.every = (k2) => {\n  k2 = Math.floor(k2);\n  if (!isFinite(k2) || !(k2 > 0))\n    return null;\n  if (!(k2 > 1))\n    return millisecond;\n  return timeInterval((date2) => {\n    date2.setTime(Math.floor(date2 / k2) * k2);\n  }, (date2, step) => {\n    date2.setTime(+date2 + step * k2);\n  }, (start2, end) => {\n    return (end - start2) / k2;\n  });\n};\nvar milliseconds = millisecond.range;\n\n// node_modules/d3-time/src/duration.js\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// node_modules/d3-time/src/second.js\nvar second = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds());\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationSecond);\n}, (start2, end) => {\n  return (end - start2) / durationSecond;\n}, (date2) => {\n  return date2.getUTCSeconds();\n});\nvar seconds = second.range;\n\n// node_modules/d3-time/src/minute.js\nvar timeMinute = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getMinutes();\n});\nvar timeMinutes = timeMinute.range;\nvar utcMinute = timeInterval((date2) => {\n  date2.setUTCSeconds(0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationMinute);\n}, (start2, end) => {\n  return (end - start2) / durationMinute;\n}, (date2) => {\n  return date2.getUTCMinutes();\n});\nvar utcMinutes = utcMinute.range;\n\n// node_modules/d3-time/src/hour.js\nvar timeHour = timeInterval((date2) => {\n  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getHours();\n});\nvar timeHours = timeHour.range;\nvar utcHour = timeInterval((date2) => {\n  date2.setUTCMinutes(0, 0, 0);\n}, (date2, step) => {\n  date2.setTime(+date2 + step * durationHour);\n}, (start2, end) => {\n  return (end - start2) / durationHour;\n}, (date2) => {\n  return date2.getUTCHours();\n});\nvar utcHours = utcHour.range;\n\n// node_modules/d3-time/src/day.js\nvar timeDay = timeInterval(\n  (date2) => date2.setHours(0, 0, 0, 0),\n  (date2, step) => date2.setDate(date2.getDate() + step),\n  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,\n  (date2) => date2.getDate() - 1\n);\nvar timeDays = timeDay.range;\nvar utcDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return date2.getUTCDate() - 1;\n});\nvar utcDays = utcDay.range;\nvar unixDay = timeInterval((date2) => {\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCDate(date2.getUTCDate() + step);\n}, (start2, end) => {\n  return (end - start2) / durationDay;\n}, (date2) => {\n  return Math.floor(date2 / durationDay);\n});\nvar unixDays = unixDay.range;\n\n// node_modules/d3-time/src/week.js\nfunction timeWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setDate(date2.getDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\nvar timeSunday = timeWeekday(0);\nvar timeMonday = timeWeekday(1);\nvar timeTuesday = timeWeekday(2);\nvar timeWednesday = timeWeekday(3);\nvar timeThursday = timeWeekday(4);\nvar timeFriday = timeWeekday(5);\nvar timeSaturday = timeWeekday(6);\nvar timeSundays = timeSunday.range;\nvar timeMondays = timeMonday.range;\nvar timeTuesdays = timeTuesday.range;\nvar timeWednesdays = timeWednesday.range;\nvar timeThursdays = timeThursday.range;\nvar timeFridays = timeFriday.range;\nvar timeSaturdays = timeSaturday.range;\nfunction utcWeekday(i) {\n  return timeInterval((date2) => {\n    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCDate(date2.getUTCDate() + step * 7);\n  }, (start2, end) => {\n    return (end - start2) / durationWeek;\n  });\n}\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\n// node_modules/d3-time/src/month.js\nvar timeMonth = timeInterval((date2) => {\n  date2.setDate(1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setMonth(date2.getMonth() + step);\n}, (start2, end) => {\n  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;\n}, (date2) => {\n  return date2.getMonth();\n});\nvar timeMonths = timeMonth.range;\nvar utcMonth = timeInterval((date2) => {\n  date2.setUTCDate(1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCMonth(date2.getUTCMonth() + step);\n}, (start2, end) => {\n  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;\n}, (date2) => {\n  return date2.getUTCMonth();\n});\nvar utcMonths = utcMonth.range;\n\n// node_modules/d3-time/src/year.js\nvar timeYear = timeInterval((date2) => {\n  date2.setMonth(0, 1);\n  date2.setHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setFullYear(date2.getFullYear() + step);\n}, (start2, end) => {\n  return end.getFullYear() - start2.getFullYear();\n}, (date2) => {\n  return date2.getFullYear();\n});\ntimeYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);\n    date2.setMonth(0, 1);\n    date2.setHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setFullYear(date2.getFullYear() + step * k2);\n  });\n};\nvar timeYears = timeYear.range;\nvar utcYear = timeInterval((date2) => {\n  date2.setUTCMonth(0, 1);\n  date2.setUTCHours(0, 0, 0, 0);\n}, (date2, step) => {\n  date2.setUTCFullYear(date2.getUTCFullYear() + step);\n}, (start2, end) => {\n  return end.getUTCFullYear() - start2.getUTCFullYear();\n}, (date2) => {\n  return date2.getUTCFullYear();\n});\nutcYear.every = (k2) => {\n  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {\n    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);\n    date2.setUTCMonth(0, 1);\n    date2.setUTCHours(0, 0, 0, 0);\n  }, (date2, step) => {\n    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);\n  });\n};\nvar utcYears = utcYear.range;\n\n// node_modules/d3-time/src/ticks.js\nfunction ticker(year, month, week, day, hour, minute) {\n  const tickIntervals = [\n    [second, 1, durationSecond],\n    [second, 5, 5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute, 1, durationMinute],\n    [minute, 5, 5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [hour, 1, durationHour],\n    [hour, 3, 3 * durationHour],\n    [hour, 6, 6 * durationHour],\n    [hour, 12, 12 * durationHour],\n    [day, 1, durationDay],\n    [day, 2, 2 * durationDay],\n    [week, 1, durationWeek],\n    [month, 1, durationMonth],\n    [month, 3, 3 * durationMonth],\n    [year, 1, durationYear]\n  ];\n  function ticks2(start2, stop, count3) {\n    const reverse3 = stop < start2;\n    if (reverse3)\n      [start2, stop] = [stop, start2];\n    const interval2 = count3 && typeof count3.range === \"function\" ? count3 : tickInterval(start2, stop, count3);\n    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];\n    return reverse3 ? ticks3.reverse() : ticks3;\n  }\n  function tickInterval(start2, stop, count3) {\n    const target = Math.abs(stop - start2) / count3;\n    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);\n    if (i === tickIntervals.length)\n      return year.every(tickStep(start2 / durationYear, stop / durationYear, count3));\n    if (i === 0)\n      return millisecond.every(Math.max(tickStep(start2, stop, count3), 1));\n    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n    return t.every(step);\n  }\n  return [ticks2, tickInterval];\n}\nvar [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);\nvar [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);\n\n// node_modules/d3-time-format/src/locale.js\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date2.setFullYear(d.y);\n    return date2;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date2.setUTCFullYear(d.y);\n    return date2;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\nfunction newDate(y4, m3, d) {\n  return { y: y4, m: m3, d, H: 0, M: 0, S: 0, L: 0 };\n}\nfunction formatLocale(locale3) {\n  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;\n  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday2,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth2,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"g\": formatYearISO,\n    \"G\": formatFullYearISO,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"q\": formatQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear2,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"g\": formatUTCYearISO,\n    \"G\": formatUTCFullYearISO,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"q\": formatUTCQuarter,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"g\": parseYear,\n    \"G\": parseFullYear,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"q\": parseQuarter,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n  function newFormat(specifier, formats2) {\n    return function(date2) {\n      var string2 = [], i = -1, j = 0, n = specifier.length, c6, pad4, format3;\n      if (!(date2 instanceof Date))\n        date2 = /* @__PURE__ */ new Date(+date2);\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string2.push(specifier.slice(j, i));\n          if ((pad4 = pads[c6 = specifier.charAt(++i)]) != null)\n            c6 = specifier.charAt(++i);\n          else\n            pad4 = c6 === \"e\" ? \" \" : \"0\";\n          if (format3 = formats2[c6])\n            c6 = format3(date2, pad4);\n          string2.push(c6);\n          j = i + 1;\n        }\n      }\n      string2.push(specifier.slice(j, i));\n      return string2.join(\"\");\n    };\n  }\n  function newParse(specifier, Z) {\n    return function(string2) {\n      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += \"\", 0), week, day;\n      if (i != string2.length)\n        return null;\n      if (\"Q\" in d)\n        return new Date(d.Q);\n      if (\"s\" in d)\n        return new Date(d.s * 1e3 + (\"L\" in d ? d.L : 0));\n      if (Z && !(\"Z\" in d))\n        d.Z = 0;\n      if (\"p\" in d)\n        d.H = d.H % 12 + d.p * 12;\n      if (d.m === void 0)\n        d.m = \"q\" in d ? d.q : 0;\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53)\n          return null;\n        if (!(\"w\" in d))\n          d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();\n          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();\n          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);\n          week = timeDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d))\n          d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day = \"Z\" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n      }\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n      return localDate(d);\n    };\n  }\n  function parseSpecifier(d, specifier, string2, j) {\n    var i = 0, n = specifier.length, m3 = string2.length, c6, parse2;\n    while (i < n) {\n      if (j >= m3)\n        return -1;\n      c6 = specifier.charCodeAt(i++);\n      if (c6 === 37) {\n        c6 = specifier.charAt(i++);\n        parse2 = parses[c6 in pads ? specifier.charAt(i++) : c6];\n        if (!parse2 || (j = parse2(d, string2, j)) < 0)\n          return -1;\n      } else if (c6 != string2.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n    return j;\n  }\n  function parsePeriod(d, string2, i) {\n    var n = periodRe.exec(string2.slice(i));\n    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortWeekday(d, string2, i) {\n    var n = shortWeekdayRe.exec(string2.slice(i));\n    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseWeekday(d, string2, i) {\n    var n = weekdayRe.exec(string2.slice(i));\n    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseShortMonth(d, string2, i) {\n    var n = shortMonthRe.exec(string2.slice(i));\n    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseMonth(d, string2, i) {\n    var n = monthRe.exec(string2.slice(i));\n    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n  }\n  function parseLocaleDateTime(d, string2, i) {\n    return parseSpecifier(d, locale_dateTime, string2, i);\n  }\n  function parseLocaleDate(d, string2, i) {\n    return parseSpecifier(d, locale_date, string2, i);\n  }\n  function parseLocaleTime(d, string2, i) {\n    return parseSpecifier(d, locale_time, string2, i);\n  }\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n  function formatWeekday2(d) {\n    return locale_weekdays[d.getDay()];\n  }\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n  function formatMonth2(d) {\n    return locale_months[d.getMonth()];\n  }\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n  function formatQuarter(d) {\n    return 1 + ~~(d.getMonth() / 3);\n  }\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n  function formatUTCQuarter(d) {\n    return 1 + ~~(d.getUTCMonth() / 3);\n  }\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", false);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() {\n        return specifier;\n      };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier += \"\", true);\n      p.toString = function() {\n        return specifier;\n      };\n      return p;\n    }\n  };\n}\nvar pads = { \"-\": \"\", \"_\": \" \", \"0\": \"0\" };\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\nfunction pad2(value, fill, width) {\n  var sign3 = value < 0 ? \"-\" : \"\", string2 = (sign3 ? -value : value) + \"\", length4 = string2.length;\n  return sign3 + (length4 < width ? new Array(width - length4 + 1).join(fill) + string2 : string2);\n}\nfunction requote(s2) {\n  return s2.replace(requoteRe, \"\\\\$&\");\n}\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\nfunction formatLookup(names) {\n  return new Map(names.map((name, i) => [name.toLowerCase(), i]));\n}\nfunction parseWeekdayNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekdayNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberSunday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberISO(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\nfunction parseWeekNumberMonday(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\nfunction parseFullYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\nfunction parseYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;\n}\nfunction parseZone(d, string2, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string2.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\nfunction parseQuarter(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 1));\n  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;\n}\nfunction parseMonthNumber(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\nfunction parseDayOfMonth(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseDayOfYear(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\nfunction parseHour24(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\nfunction parseMinutes(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\nfunction parseSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\nfunction parseMilliseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\nfunction parseMicroseconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;\n}\nfunction parseLiteralPercent(d, string2, i) {\n  var n = percentRe.exec(string2.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\nfunction parseUnixTimestamp(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\nfunction parseUnixTimestampSeconds(d, string2, i) {\n  var n = numberRe.exec(string2.slice(i));\n  return n ? (d.s = +n[0], i + n[0].length) : -1;\n}\nfunction formatDayOfMonth(d, p) {\n  return pad2(d.getDate(), p, 2);\n}\nfunction formatHour24(d, p) {\n  return pad2(d.getHours(), p, 2);\n}\nfunction formatHour12(d, p) {\n  return pad2(d.getHours() % 12 || 12, p, 2);\n}\nfunction formatDayOfYear(d, p) {\n  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);\n}\nfunction formatMilliseconds(d, p) {\n  return pad2(d.getMilliseconds(), p, 3);\n}\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\nfunction formatMonthNumber(d, p) {\n  return pad2(d.getMonth() + 1, p, 2);\n}\nfunction formatMinutes(d, p) {\n  return pad2(d.getMinutes(), p, 2);\n}\nfunction formatSeconds(d, p) {\n  return pad2(d.getSeconds(), p, 2);\n}\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\nfunction formatWeekNumberSunday(d, p) {\n  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction dISO(d) {\n  var day = d.getDay();\n  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n}\nfunction formatWeekNumberISO(d, p) {\n  d = dISO(d);\n  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);\n}\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\nfunction formatWeekNumberMonday(d, p) {\n  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);\n}\nfunction formatYear2(d, p) {\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatYearISO(d, p) {\n  d = dISO(d);\n  return pad2(d.getFullYear() % 100, p, 2);\n}\nfunction formatFullYear(d, p) {\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatFullYearISO(d, p) {\n  var day = d.getDay();\n  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);\n  return pad2(d.getFullYear() % 1e4, p, 4);\n}\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\")) + pad2(z / 60 | 0, \"0\", 2) + pad2(z % 60, \"0\", 2);\n}\nfunction formatUTCDayOfMonth(d, p) {\n  return pad2(d.getUTCDate(), p, 2);\n}\nfunction formatUTCHour24(d, p) {\n  return pad2(d.getUTCHours(), p, 2);\n}\nfunction formatUTCHour12(d, p) {\n  return pad2(d.getUTCHours() % 12 || 12, p, 2);\n}\nfunction formatUTCDayOfYear(d, p) {\n  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);\n}\nfunction formatUTCMilliseconds(d, p) {\n  return pad2(d.getUTCMilliseconds(), p, 3);\n}\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\nfunction formatUTCMonthNumber(d, p) {\n  return pad2(d.getUTCMonth() + 1, p, 2);\n}\nfunction formatUTCMinutes(d, p) {\n  return pad2(d.getUTCMinutes(), p, 2);\n}\nfunction formatUTCSeconds(d, p) {\n  return pad2(d.getUTCSeconds(), p, 2);\n}\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction UTCdISO(d) {\n  var day = d.getUTCDay();\n  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n}\nfunction formatUTCWeekNumberISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);\n}\nfunction formatUTCYear(d, p) {\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCYearISO(d, p) {\n  d = UTCdISO(d);\n  return pad2(d.getUTCFullYear() % 100, p, 2);\n}\nfunction formatUTCFullYear(d, p) {\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCFullYearISO(d, p) {\n  var day = d.getUTCDay();\n  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);\n  return pad2(d.getUTCFullYear() % 1e4, p, 4);\n}\nfunction formatUTCZone() {\n  return \"+0000\";\n}\nfunction formatLiteralPercent() {\n  return \"%\";\n}\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1e3);\n}\n\n// node_modules/d3-time-format/src/defaultLocale.js\nvar locale2;\nvar timeFormat;\nvar timeParse;\nvar utcFormat;\nvar utcParse;\ndefaultLocale2({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\nfunction defaultLocale2(definition) {\n  locale2 = formatLocale(definition);\n  timeFormat = locale2.format;\n  timeParse = locale2.parse;\n  utcFormat = locale2.utcFormat;\n  utcParse = locale2.utcParse;\n  return locale2;\n}\n\n// node_modules/d3-time-format/src/isoFormat.js\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nfunction formatIsoNative(date2) {\n  return date2.toISOString();\n}\nvar formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);\nvar isoFormat_default = formatIso;\n\n// node_modules/d3-time-format/src/isoParse.js\nfunction parseIsoNative(string2) {\n  var date2 = new Date(string2);\n  return isNaN(date2) ? null : date2;\n}\nvar parseIso = +/* @__PURE__ */ new Date(\"2000-01-01T00:00:00.000Z\") ? parseIsoNative : utcParse(isoSpecifier);\nvar isoParse_default = parseIso;\n\n// node_modules/d3-scale/src/time.js\nfunction date(t) {\n  return new Date(t);\n}\nfunction number4(t) {\n  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);\n}\nfunction calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {\n  var scale3 = continuous(), invert = scale3.invert, domain = scale3.domain;\n  var formatMillisecond = format3(\".%L\"), formatSecond = format3(\":%S\"), formatMinute = format3(\"%I:%M\"), formatHour = format3(\"%I %p\"), formatDay = format3(\"%a %d\"), formatWeek = format3(\"%b %d\"), formatMonth2 = format3(\"%B\"), formatYear4 = format3(\"%Y\");\n  function tickFormat2(date2) {\n    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear4)(date2);\n  }\n  scale3.invert = function(y4) {\n    return new Date(invert(y4));\n  };\n  scale3.domain = function(_) {\n    return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);\n  };\n  scale3.ticks = function(interval2) {\n    var d = domain();\n    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n  };\n  scale3.tickFormat = function(count3, specifier) {\n    return specifier == null ? tickFormat2 : format3(specifier);\n  };\n  scale3.nice = function(interval2) {\n    var d = domain();\n    if (!interval2 || typeof interval2.range !== \"function\")\n      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);\n    return interval2 ? domain(nice2(d, interval2)) : scale3;\n  };\n  scale3.copy = function() {\n    return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));\n  };\n  return scale3;\n}\nfunction time() {\n  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/utcTime.js\nfunction utcTime() {\n  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);\n}\n\n// node_modules/d3-scale/src/sequential.js\nfunction transformer3() {\n  var x06 = 0, x12 = 1, t03, t13, k10, transform2, interpolator = identity3, clamp = false, unknown;\n  function scale3(x4) {\n    return x4 == null || isNaN(x4 = +x4) ? unknown : interpolator(k10 === 0 ? 0.5 : (x4 = (transform2(x4) - t03) * k10, clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale3) : [x06, x12];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1;\n      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale3) : [interpolator(0), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);\n    return scale3;\n  };\n}\nfunction copy2(source, target) {\n  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction sequential() {\n  var scale3 = linearish(transformer3()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, sequential());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialLog() {\n  var scale3 = loggish(transformer3()).domain([1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, sequentialLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSymlog() {\n  var scale3 = symlogish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialPow() {\n  var scale3 = powish(transformer3());\n  scale3.copy = function() {\n    return copy2(scale3, sequentialPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale/src/sequentialQuantile.js\nfunction sequentialQuantile() {\n  var domain = [], interpolator = identity3;\n  function scale3(x4) {\n    if (x4 != null && !isNaN(x4 = +x4))\n      return interpolator((bisect_default(domain, x4, 1) - 1) / (domain.length - 1));\n  }\n  scale3.domain = function(_) {\n    if (!arguments.length)\n      return domain.slice();\n    domain = [];\n    for (let d of _)\n      if (d != null && !isNaN(d = +d))\n        domain.push(d);\n    domain.sort(ascending);\n    return scale3;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  scale3.range = function() {\n    return domain.map((d, i) => interpolator(i / (domain.length - 1)));\n  };\n  scale3.quantiles = function(n) {\n    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));\n  };\n  scale3.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\n\n// node_modules/d3-scale/src/diverging.js\nfunction transformer4() {\n  var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;\n  function scale3(x4) {\n    return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform2(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));\n  }\n  scale3.domain = function(_) {\n    return arguments.length ? ([x06, x12, x22] = _, t03 = transform2(x06 = +x06), t13 = transform2(x12 = +x12), t22 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];\n  };\n  scale3.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale3) : clamp;\n  };\n  scale3.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale3) : interpolator;\n  };\n  function range5(interpolate) {\n    return function(_) {\n      var r0, r1, r2;\n      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];\n    };\n  }\n  scale3.range = range5(value_default);\n  scale3.rangeRound = range5(round_default);\n  scale3.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale3) : unknown;\n  };\n  return function(t) {\n    transform2 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;\n    return scale3;\n  };\n}\nfunction diverging() {\n  var scale3 = linearish(transformer4()(identity3));\n  scale3.copy = function() {\n    return copy2(scale3, diverging());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingLog() {\n  var scale3 = loggish(transformer4()).domain([0.1, 1, 10]);\n  scale3.copy = function() {\n    return copy2(scale3, divergingLog()).base(scale3.base());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSymlog() {\n  var scale3 = symlogish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingSymlog()).constant(scale3.constant());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingPow() {\n  var scale3 = powish(transformer4());\n  scale3.copy = function() {\n    return copy2(scale3, divergingPow()).exponent(scale3.exponent());\n  };\n  return initInterpolator.apply(scale3, arguments);\n}\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// node_modules/d3-scale-chromatic/src/colors.js\nfunction colors_default(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n)\n    colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n\n// node_modules/d3-scale-chromatic/src/categorical/category10.js\nvar category10_default = colors_default(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Accent.js\nvar Accent_default = colors_default(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Dark2.js\nvar Dark2_default = colors_default(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Paired.js\nvar Paired_default = colors_default(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js\nvar Pastel1_default = colors_default(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js\nvar Pastel2_default = colors_default(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set1.js\nvar Set1_default = colors_default(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set2.js\nvar Set2_default = colors_default(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Set3.js\nvar Set3_default = colors_default(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");\n\n// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js\nvar Tableau10_default = colors_default(\"4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab\");\n\n// node_modules/d3-scale-chromatic/src/ramp.js\nvar ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);\n\n// node_modules/d3-scale-chromatic/src/diverging/BrBG.js\nvar scheme = new Array(3).concat(\n  \"d8b365f5f5f55ab4ac\",\n  \"a6611adfc27d80cdc1018571\",\n  \"a6611adfc27df5f5f580cdc1018571\",\n  \"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\n  \"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\n  \"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\n  \"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\n  \"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\n  \"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"\n).map(colors_default);\nvar BrBG_default = ramp_default(scheme);\n\n// node_modules/d3-scale-chromatic/src/diverging/PRGn.js\nvar scheme2 = new Array(3).concat(\n  \"af8dc3f7f7f77fbf7b\",\n  \"7b3294c2a5cfa6dba0008837\",\n  \"7b3294c2a5cff7f7f7a6dba0008837\",\n  \"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\n  \"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\n  \"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\n  \"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\n  \"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\n  \"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"\n).map(colors_default);\nvar PRGn_default = ramp_default(scheme2);\n\n// node_modules/d3-scale-chromatic/src/diverging/PiYG.js\nvar scheme3 = new Array(3).concat(\n  \"e9a3c9f7f7f7a1d76a\",\n  \"d01c8bf1b6dab8e1864dac26\",\n  \"d01c8bf1b6daf7f7f7b8e1864dac26\",\n  \"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\n  \"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\n  \"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\n  \"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\n  \"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\n  \"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"\n).map(colors_default);\nvar PiYG_default = ramp_default(scheme3);\n\n// node_modules/d3-scale-chromatic/src/diverging/PuOr.js\nvar scheme4 = new Array(3).concat(\n  \"998ec3f7f7f7f1a340\",\n  \"5e3c99b2abd2fdb863e66101\",\n  \"5e3c99b2abd2f7f7f7fdb863e66101\",\n  \"542788998ec3d8daebfee0b6f1a340b35806\",\n  \"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\n  \"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\n  \"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\n  \"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\n  \"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors_default);\nvar PuOr_default = ramp_default(scheme4);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdBu.js\nvar scheme5 = new Array(3).concat(\n  \"ef8a62f7f7f767a9cf\",\n  \"ca0020f4a58292c5de0571b0\",\n  \"ca0020f4a582f7f7f792c5de0571b0\",\n  \"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\n  \"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\n  \"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\n  \"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\n  \"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\n  \"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"\n).map(colors_default);\nvar RdBu_default = ramp_default(scheme5);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdGy.js\nvar scheme6 = new Array(3).concat(\n  \"ef8a62ffffff999999\",\n  \"ca0020f4a582bababa404040\",\n  \"ca0020f4a582ffffffbababa404040\",\n  \"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\n  \"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\n  \"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\n  \"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\n  \"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\n  \"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"\n).map(colors_default);\nvar RdGy_default = ramp_default(scheme6);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js\nvar scheme7 = new Array(3).concat(\n  \"fc8d59ffffbf91bfdb\",\n  \"d7191cfdae61abd9e92c7bb6\",\n  \"d7191cfdae61ffffbfabd9e92c7bb6\",\n  \"d73027fc8d59fee090e0f3f891bfdb4575b4\",\n  \"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\n  \"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\n  \"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\n  \"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\n  \"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"\n).map(colors_default);\nvar RdYlBu_default = ramp_default(scheme7);\n\n// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js\nvar scheme8 = new Array(3).concat(\n  \"fc8d59ffffbf91cf60\",\n  \"d7191cfdae61a6d96a1a9641\",\n  \"d7191cfdae61ffffbfa6d96a1a9641\",\n  \"d73027fc8d59fee08bd9ef8b91cf601a9850\",\n  \"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\n  \"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\n  \"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\n  \"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\n  \"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"\n).map(colors_default);\nvar RdYlGn_default = ramp_default(scheme8);\n\n// node_modules/d3-scale-chromatic/src/diverging/Spectral.js\nvar scheme9 = new Array(3).concat(\n  \"fc8d59ffffbf99d594\",\n  \"d7191cfdae61abdda42b83ba\",\n  \"d7191cfdae61ffffbfabdda42b83ba\",\n  \"d53e4ffc8d59fee08be6f59899d5943288bd\",\n  \"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\n  \"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\n  \"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\n  \"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\n  \"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\"\n).map(colors_default);\nvar Spectral_default = ramp_default(scheme9);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js\nvar scheme10 = new Array(3).concat(\n  \"e5f5f999d8c92ca25f\",\n  \"edf8fbb2e2e266c2a4238b45\",\n  \"edf8fbb2e2e266c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"\n).map(colors_default);\nvar BuGn_default = ramp_default(scheme10);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js\nvar scheme11 = new Array(3).concat(\n  \"e0ecf49ebcda8856a7\",\n  \"edf8fbb3cde38c96c688419d\",\n  \"edf8fbb3cde38c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"\n).map(colors_default);\nvar BuPu_default = ramp_default(scheme11);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js\nvar scheme12 = new Array(3).concat(\n  \"e0f3dba8ddb543a2ca\",\n  \"f0f9e8bae4bc7bccc42b8cbe\",\n  \"f0f9e8bae4bc7bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"\n).map(colors_default);\nvar GnBu_default = ramp_default(scheme12);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js\nvar scheme13 = new Array(3).concat(\n  \"fee8c8fdbb84e34a33\",\n  \"fef0d9fdcc8afc8d59d7301f\",\n  \"fef0d9fdcc8afc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"\n).map(colors_default);\nvar OrRd_default = ramp_default(scheme13);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js\nvar scheme14 = new Array(3).concat(\n  \"ece2f0a6bddb1c9099\",\n  \"f6eff7bdc9e167a9cf02818a\",\n  \"f6eff7bdc9e167a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"\n).map(colors_default);\nvar PuBuGn_default = ramp_default(scheme14);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js\nvar scheme15 = new Array(3).concat(\n  \"ece7f2a6bddb2b8cbe\",\n  \"f1eef6bdc9e174a9cf0570b0\",\n  \"f1eef6bdc9e174a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"\n).map(colors_default);\nvar PuBu_default = ramp_default(scheme15);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js\nvar scheme16 = new Array(3).concat(\n  \"e7e1efc994c7dd1c77\",\n  \"f1eef6d7b5d8df65b0ce1256\",\n  \"f1eef6d7b5d8df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"\n).map(colors_default);\nvar PuRd_default = ramp_default(scheme16);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js\nvar scheme17 = new Array(3).concat(\n  \"fde0ddfa9fb5c51b8a\",\n  \"feebe2fbb4b9f768a1ae017e\",\n  \"feebe2fbb4b9f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"\n).map(colors_default);\nvar RdPu_default = ramp_default(scheme17);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js\nvar scheme18 = new Array(3).concat(\n  \"edf8b17fcdbb2c7fb8\",\n  \"ffffcca1dab441b6c4225ea8\",\n  \"ffffcca1dab441b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"\n).map(colors_default);\nvar YlGnBu_default = ramp_default(scheme18);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js\nvar scheme19 = new Array(3).concat(\n  \"f7fcb9addd8e31a354\",\n  \"ffffccc2e69978c679238443\",\n  \"ffffccc2e69978c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"\n).map(colors_default);\nvar YlGn_default = ramp_default(scheme19);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js\nvar scheme20 = new Array(3).concat(\n  \"fff7bcfec44fd95f0e\",\n  \"ffffd4fed98efe9929cc4c02\",\n  \"ffffd4fed98efe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"\n).map(colors_default);\nvar YlOrBr_default = ramp_default(scheme20);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js\nvar scheme21 = new Array(3).concat(\n  \"ffeda0feb24cf03b20\",\n  \"ffffb2fecc5cfd8d3ce31a1c\",\n  \"ffffb2fecc5cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"\n).map(colors_default);\nvar YlOrRd_default = ramp_default(scheme21);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js\nvar scheme22 = new Array(3).concat(\n  \"deebf79ecae13182bd\",\n  \"eff3ffbdd7e76baed62171b5\",\n  \"eff3ffbdd7e76baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"\n).map(colors_default);\nvar Blues_default = ramp_default(scheme22);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js\nvar scheme23 = new Array(3).concat(\n  \"e5f5e0a1d99b31a354\",\n  \"edf8e9bae4b374c476238b45\",\n  \"edf8e9bae4b374c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"\n).map(colors_default);\nvar Greens_default = ramp_default(scheme23);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js\nvar scheme24 = new Array(3).concat(\n  \"f0f0f0bdbdbd636363\",\n  \"f7f7f7cccccc969696525252\",\n  \"f7f7f7cccccc969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"\n).map(colors_default);\nvar Greys_default = ramp_default(scheme24);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js\nvar scheme25 = new Array(3).concat(\n  \"efedf5bcbddc756bb1\",\n  \"f2f0f7cbc9e29e9ac86a51a3\",\n  \"f2f0f7cbc9e29e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"\n).map(colors_default);\nvar Purples_default = ramp_default(scheme25);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js\nvar scheme26 = new Array(3).concat(\n  \"fee0d2fc9272de2d26\",\n  \"fee5d9fcae91fb6a4acb181d\",\n  \"fee5d9fcae91fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"\n).map(colors_default);\nvar Reds_default = ramp_default(scheme26);\n\n// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js\nvar scheme27 = new Array(3).concat(\n  \"fee6cefdae6be6550d\",\n  \"feeddefdbe85fd8d3cd94701\",\n  \"feeddefdbe85fd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"\n).map(colors_default);\nvar Oranges_default = ramp_default(scheme27);\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js\nfunction cividis_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + \", \" + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + \", \" + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js\nvar cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));\nvar c3 = cubehelix();\nfunction rainbow_default(t) {\n  if (t < 0 || t > 1)\n    t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c3.h = 360 * t - 100;\n  c3.s = 1.5 - 1.5 * ts;\n  c3.l = 0.8 - 0.9 * ts;\n  return c3 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js\nvar c4 = rgb();\nvar pi_1_3 = Math.PI / 3;\nvar pi_2_3 = Math.PI * 2 / 3;\nfunction sinebow_default(t) {\n  var x4;\n  t = (0.5 - t) * Math.PI;\n  c4.r = 255 * (x4 = Math.sin(t)) * x4;\n  c4.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;\n  c4.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;\n  return c4 + \"\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js\nfunction turbo_default(t) {\n  t = Math.max(0, Math.min(1, t));\n  return \"rgb(\" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + \", \" + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + \", \" + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + \")\";\n}\n\n// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js\nfunction ramp(range5) {\n  var n = range5.length;\n  return function(t) {\n    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\nvar viridis_default = ramp(colors_default(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\nvar magma = ramp(colors_default(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\nvar inferno = ramp(colors_default(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\nvar plasma = ramp(colors_default(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\n// node_modules/d3-shape/src/constant.js\nfunction constant_default10(x4) {\n  return function constant3() {\n    return x4;\n  };\n}\n\n// node_modules/d3-shape/src/math.js\nvar abs4 = Math.abs;\nvar atan22 = Math.atan2;\nvar cos3 = Math.cos;\nvar max4 = Math.max;\nvar min3 = Math.min;\nvar sin3 = Math.sin;\nvar sqrt3 = Math.sqrt;\nvar epsilon8 = 1e-12;\nvar pi5 = Math.PI;\nvar halfPi4 = pi5 / 2;\nvar tau6 = 2 * pi5;\nfunction acos2(x4) {\n  return x4 > 1 ? 0 : x4 < -1 ? pi5 : Math.acos(x4);\n}\nfunction asin2(x4) {\n  return x4 >= 1 ? halfPi4 : x4 <= -1 ? -halfPi4 : Math.asin(x4);\n}\n\n// node_modules/d3-shape/src/path.js\nfunction withPath(shape) {\n  let digits = 3;\n  shape.digits = function(_) {\n    if (!arguments.length)\n      return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0))\n        throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n  return () => new Path(digits);\n}\n\n// node_modules/d3-shape/src/arc.js\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction arcPadAngle(d) {\n  return d && d.padAngle;\n}\nfunction intersect(x06, y06, x12, y12, x22, y22, x32, y32) {\n  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;\n  if (t * t < epsilon8)\n    return;\n  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;\n  return [x06 + t * x10, y06 + t * y10];\n}\nfunction cornerTangents(x06, y06, x12, y12, r1, rc, cw) {\n  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw ? rc : -rc) / sqrt3(x01 * x01 + y01 * y01), ox2 = lo * y01, oy2 = -lo * x01, x11 = x06 + ox2, y11 = y06 + oy2, x10 = x12 + ox2, y10 = y12 + oy2, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt3(max4(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)\n    cx0 = cx1, cy0 = cy1;\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox2,\n    y01: -oy2,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\nfunction arc_default() {\n  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default10(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);\n  function arc() {\n    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da2 = abs4(a1 - a0), cw = a1 > a0;\n    if (!context)\n      context = buffer = path2();\n    if (r1 < r0)\n      r = r1, r1 = r0, r0 = r;\n    if (!(r1 > epsilon8))\n      context.moveTo(0, 0);\n    else if (da2 > tau6 - epsilon8) {\n      context.moveTo(r1 * cos3(a0), r1 * sin3(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon8) {\n        context.moveTo(r0 * cos3(a1), r0 * sin3(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    } else {\n      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt3(r0 * r0 + r1 * r1)), rc = min3(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;\n      if (rp > epsilon8) {\n        var p02 = asin2(rp / r0 * sin3(ap)), p1 = asin2(rp / r1 * sin3(ap));\n        if ((da0 -= p02 * 2) > epsilon8)\n          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;\n        else\n          da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon8)\n          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;\n        else\n          da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n      var x01 = r1 * cos3(a01), y01 = r1 * sin3(a01), x10 = r0 * cos3(a10), y10 = r0 * sin3(a10);\n      if (rc > epsilon8) {\n        var x11 = r1 * cos3(a11), y11 = r1 * sin3(a11), x004 = r0 * cos3(a00), y004 = r0 * sin3(a00), oc;\n        if (da2 < pi5) {\n          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {\n            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin3(acos2((ax * bx + ay * by) / (sqrt3(ax * ax + ay * ay) * sqrt3(bx * bx + by * by))) / 2), lc = sqrt3(oc[0] * oc[0] + oc[1] * oc[1]);\n            rc0 = min3(rc, (r0 - lc) / (kc - 1));\n            rc1 = min3(rc, (r1 - lc) / (kc + 1));\n          } else {\n            rc0 = rc1 = 0;\n          }\n        }\n      }\n      if (!(da1 > epsilon8))\n        context.moveTo(x01, y01);\n      else if (rc1 > epsilon8) {\n        t03 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw);\n        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc1 < rc)\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc1, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r1, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), !cw);\n          context.arc(t13.cx, t13.cy, rc1, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n      if (!(r0 > epsilon8) || !(da0 > epsilon8))\n        context.lineTo(x10, y10);\n      else if (rc0 > epsilon8) {\n        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw);\n        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);\n        if (rc0 < rc)\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t13.y01, t13.x01), !cw);\n        else {\n          context.arc(t03.cx, t03.cy, rc0, atan22(t03.y01, t03.x01), atan22(t03.y11, t03.x11), !cw);\n          context.arc(0, 0, r0, atan22(t03.cy + t03.y11, t03.cx + t03.x11), atan22(t13.cy + t13.y11, t13.cx + t13.x11), cw);\n          context.arc(t13.cx, t13.cy, rc0, atan22(t13.y11, t13.x11), atan22(t13.y01, t13.x01), !cw);\n        }\n      } else\n        context.arc(0, 0, r0, a10, a00, cw);\n    }\n    context.closePath();\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi5 / 2;\n    return [cos3(a4) * r, sin3(a4) * r];\n  };\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : innerRadius;\n  };\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : outerRadius;\n  };\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : cornerRadius;\n  };\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padRadius;\n  };\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : startAngle;\n  };\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : endAngle;\n  };\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), arc) : padAngle;\n  };\n  arc.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n  return arc;\n}\n\n// node_modules/d3-shape/src/array.js\nvar slice4 = Array.prototype.slice;\nfunction array_default3(x4) {\n  return typeof x4 === \"object\" && \"length\" in x4 ? x4 : Array.from(x4);\n}\n\n// node_modules/d3-shape/src/curve/linear.js\nfunction Linear(context) {\n  this._context = context;\n}\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default:\n        this._context.lineTo(x4, y4);\n        break;\n    }\n  }\n};\nfunction linear_default(context) {\n  return new Linear(context);\n}\n\n// node_modules/d3-shape/src/point.js\nfunction x3(p) {\n  return p[0];\n}\nfunction y3(p) {\n  return p[1];\n}\n\n// node_modules/d3-shape/src/line.js\nfunction line_default2(x4, y4) {\n  var defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);\n  x4 = typeof x4 === \"function\" ? x4 : x4 === void 0 ? x3 : constant_default10(x4);\n  y4 = typeof y4 === \"function\" ? y4 : y4 === void 0 ? y3 : constant_default10(y4);\n  function line2(data) {\n    var i, n = (data = array_default3(data)).length, d, defined0 = false, buffer;\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0)\n          output.lineStart();\n        else\n          output.lineEnd();\n      }\n      if (defined0)\n        output.point(+x4(d, i, data), +y4(d, i, data));\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  line2.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : x4;\n  };\n  line2.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), line2) : y4;\n  };\n  line2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), line2) : defined2;\n  };\n  line2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;\n  };\n  line2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;\n  };\n  return line2;\n}\n\n// node_modules/d3-shape/src/area.js\nfunction area_default5(x06, y06, y12) {\n  var x12 = null, defined2 = constant_default10(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);\n  x06 = typeof x06 === \"function\" ? x06 : x06 === void 0 ? x3 : constant_default10(+x06);\n  y06 = typeof y06 === \"function\" ? y06 : y06 === void 0 ? constant_default10(0) : constant_default10(+y06);\n  y12 = typeof y12 === \"function\" ? y12 : y12 === void 0 ? y3 : constant_default10(+y12);\n  function area2(data) {\n    var i, j, k2, n = (data = array_default3(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);\n    if (context == null)\n      output = curve(buffer = path2());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k2 = i - 1; k2 >= j; --k2) {\n            output.point(x0z[k2], y0z[k2]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);\n        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);\n      }\n    }\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  function arealine() {\n    return line_default2().defined(defined2).curve(curve).context(context);\n  }\n  area2.x = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), x12 = null, area2) : x06;\n  };\n  area2.x0 = function(_) {\n    return arguments.length ? (x06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x06;\n  };\n  area2.x1 = function(_) {\n    return arguments.length ? (x12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : x12;\n  };\n  area2.y = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), y12 = null, area2) : y06;\n  };\n  area2.y0 = function(_) {\n    return arguments.length ? (y06 = typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y06;\n  };\n  area2.y1 = function(_) {\n    return arguments.length ? (y12 = _ == null ? null : typeof _ === \"function\" ? _ : constant_default10(+_), area2) : y12;\n  };\n  area2.lineX0 = area2.lineY0 = function() {\n    return arealine().x(x06).y(y06);\n  };\n  area2.lineY1 = function() {\n    return arealine().x(x06).y(y12);\n  };\n  area2.lineX1 = function() {\n    return arealine().x(x12).y(y06);\n  };\n  area2.defined = function(_) {\n    return arguments.length ? (defined2 = typeof _ === \"function\" ? _ : constant_default10(!!_), area2) : defined2;\n  };\n  area2.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;\n  };\n  area2.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;\n  };\n  return area2;\n}\n\n// node_modules/d3-shape/src/descending.js\nfunction descending_default(a4, b) {\n  return b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;\n}\n\n// node_modules/d3-shape/src/identity.js\nfunction identity_default5(d) {\n  return d;\n}\n\n// node_modules/d3-shape/src/pie.js\nfunction pie_default() {\n  var value = identity_default5, sortValues = descending_default, sort3 = null, startAngle = constant_default10(0), endAngle = constant_default10(tau6), padAngle = constant_default10(0);\n  function pie(data) {\n    var i, n = (data = array_default3(data)).length, j, k2, sum5 = 0, index3 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau6, Math.max(-tau6, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p * (da2 < 0 ? -1 : 1), v2;\n    for (i = 0; i < n; ++i) {\n      if ((v2 = arcs[index3[i] = i] = +value(data[i], i, data)) > 0) {\n        sum5 += v2;\n      }\n    }\n    if (sortValues != null)\n      index3.sort(function(i2, j2) {\n        return sortValues(arcs[i2], arcs[j2]);\n      });\n    else if (sort3 != null)\n      index3.sort(function(i2, j2) {\n        return sort3(data[i2], data[j2]);\n      });\n    for (i = 0, k2 = sum5 ? (da2 - n * pa) / sum5 : 0; i < n; ++i, a0 = a1) {\n      j = index3[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v2,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n    return arcs;\n  }\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : value;\n  };\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort3 = null, pie) : sortValues;\n  };\n  pie.sort = function(_) {\n    return arguments.length ? (sort3 = _, sortValues = null, pie) : sort3;\n  };\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : startAngle;\n  };\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : endAngle;\n  };\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant_default10(+_), pie) : padAngle;\n  };\n  return pie;\n}\n\n// node_modules/d3-shape/src/curve/radial.js\nvar curveRadialLinear = curveRadial(linear_default);\nfunction Radial(curve) {\n  this._curve = curve;\n}\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a4, r) {\n    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));\n  }\n};\nfunction curveRadial(curve) {\n  function radial2(context) {\n    return new Radial(curve(context));\n  }\n  radial2._curve = curve;\n  return radial2;\n}\n\n// node_modules/d3-shape/src/lineRadial.js\nfunction lineRadial(l) {\n  var c6 = l.curve;\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  l.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return l;\n}\nfunction lineRadial_default() {\n  return lineRadial(line_default2().curve(curveRadialLinear));\n}\n\n// node_modules/d3-shape/src/areaRadial.js\nfunction areaRadial_default() {\n  var a4 = area_default5().curve(curveRadialLinear), c6 = a4.curve, x06 = a4.lineX0, x12 = a4.lineX1, y06 = a4.lineY0, y12 = a4.lineY1;\n  a4.angle = a4.x, delete a4.x;\n  a4.startAngle = a4.x0, delete a4.x0;\n  a4.endAngle = a4.x1, delete a4.x1;\n  a4.radius = a4.y, delete a4.y;\n  a4.innerRadius = a4.y0, delete a4.y0;\n  a4.outerRadius = a4.y1, delete a4.y1;\n  a4.lineStartAngle = function() {\n    return lineRadial(x06());\n  }, delete a4.lineX0;\n  a4.lineEndAngle = function() {\n    return lineRadial(x12());\n  }, delete a4.lineX1;\n  a4.lineInnerRadius = function() {\n    return lineRadial(y06());\n  }, delete a4.lineY0;\n  a4.lineOuterRadius = function() {\n    return lineRadial(y12());\n  }, delete a4.lineY1;\n  a4.curve = function(_) {\n    return arguments.length ? c6(curveRadial(_)) : c6()._curve;\n  };\n  return a4;\n}\n\n// node_modules/d3-shape/src/pointRadial.js\nfunction pointRadial_default(x4, y4) {\n  return [(y4 = +y4) * Math.cos(x4 -= Math.PI / 2), y4 * Math.sin(x4)];\n}\n\n// node_modules/d3-shape/src/curve/bump.js\nvar Bump = class {\n  constructor(context, x4) {\n    this._context = context;\n    this._x = x4;\n  }\n  areaStart() {\n    this._line = 0;\n  }\n  areaEnd() {\n    this._line = NaN;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0: {\n        this._point = 1;\n        if (this._line)\n          this._context.lineTo(x4, y4);\n        else\n          this._context.moveTo(x4, y4);\n        break;\n      }\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._x)\n          this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);\n        else\n          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);\n        break;\n      }\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nvar BumpRadial = class {\n  constructor(context) {\n    this._context = context;\n  }\n  lineStart() {\n    this._point = 0;\n  }\n  lineEnd() {\n  }\n  point(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point === 0) {\n      this._point = 1;\n    } else {\n      const p02 = pointRadial_default(this._x0, this._y0);\n      const p1 = pointRadial_default(this._x0, this._y0 = (this._y0 + y4) / 2);\n      const p2 = pointRadial_default(x4, this._y0);\n      const p3 = pointRadial_default(x4, y4);\n      this._context.moveTo(...p02);\n      this._context.bezierCurveTo(...p1, ...p2, ...p3);\n    }\n    this._x0 = x4, this._y0 = y4;\n  }\n};\nfunction bumpX(context) {\n  return new Bump(context, true);\n}\nfunction bumpY(context) {\n  return new Bump(context, false);\n}\nfunction bumpRadial(context) {\n  return new BumpRadial(context);\n}\n\n// node_modules/d3-shape/src/link.js\nfunction linkSource(d) {\n  return d.source;\n}\nfunction linkTarget(d) {\n  return d.target;\n}\nfunction link2(curve) {\n  let source = linkSource, target = linkTarget, x4 = x3, y4 = y3, context = null, output = null, path2 = withPath(link4);\n  function link4() {\n    let buffer;\n    const argv = slice4.call(arguments);\n    const s2 = source.apply(this, argv);\n    const t = target.apply(this, argv);\n    if (context == null)\n      output = curve(buffer = path2());\n    output.lineStart();\n    argv[0] = s2, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    argv[0] = t, output.point(+x4.apply(this, argv), +y4.apply(this, argv));\n    output.lineEnd();\n    if (buffer)\n      return output = null, buffer + \"\" || null;\n  }\n  link4.source = function(_) {\n    return arguments.length ? (source = _, link4) : source;\n  };\n  link4.target = function(_) {\n    return arguments.length ? (target = _, link4) : target;\n  };\n  link4.x = function(_) {\n    return arguments.length ? (x4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : x4;\n  };\n  link4.y = function(_) {\n    return arguments.length ? (y4 = typeof _ === \"function\" ? _ : constant_default10(+_), link4) : y4;\n  };\n  link4.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link4) : context;\n  };\n  return link4;\n}\nfunction linkHorizontal() {\n  return link2(bumpX);\n}\nfunction linkVertical() {\n  return link2(bumpY);\n}\nfunction linkRadial() {\n  const l = link2(bumpRadial);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\n// node_modules/d3-shape/src/symbol/asterisk.js\nvar sqrt32 = sqrt3(3);\nvar asterisk_default = {\n  draw(context, size) {\n    const r = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;\n    const t = r / 2;\n    const u4 = t * sqrt32;\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n    context.moveTo(-u4, -t);\n    context.lineTo(u4, t);\n    context.moveTo(-u4, t);\n    context.lineTo(u4, -t);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/circle.js\nvar circle_default3 = {\n  draw(context, size) {\n    const r = sqrt3(size / pi5);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau6);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/cross.js\nvar cross_default2 = {\n  draw(context, size) {\n    const r = sqrt3(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond.js\nvar tan30 = sqrt3(1 / 3);\nvar tan30_2 = tan30 * 2;\nvar diamond_default = {\n  draw(context, size) {\n    const y4 = sqrt3(size / tan30_2);\n    const x4 = y4 * tan30;\n    context.moveTo(0, -y4);\n    context.lineTo(x4, 0);\n    context.lineTo(0, y4);\n    context.lineTo(-x4, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/diamond2.js\nvar diamond2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.62625;\n    context.moveTo(0, -r);\n    context.lineTo(r, 0);\n    context.lineTo(0, r);\n    context.lineTo(-r, 0);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/plus.js\nvar plus_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 7, 2)) * 0.87559;\n    context.moveTo(-r, 0);\n    context.lineTo(r, 0);\n    context.moveTo(0, r);\n    context.lineTo(0, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square.js\nvar square_default = {\n  draw(context, size) {\n    const w = sqrt3(size);\n    const x4 = -w / 2;\n    context.rect(x4, x4, w, w);\n  }\n};\n\n// node_modules/d3-shape/src/symbol/square2.js\nvar square2_default = {\n  draw(context, size) {\n    const r = sqrt3(size) * 0.4431;\n    context.moveTo(r, r);\n    context.lineTo(r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, r);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/star.js\nvar ka = 0.8908130915292852;\nvar kr = sin3(pi5 / 10) / sin3(7 * pi5 / 10);\nvar kx = sin3(tau6 / 10) * kr;\nvar ky = -cos3(tau6 / 10) * kr;\nvar star_default = {\n  draw(context, size) {\n    const r = sqrt3(size * ka);\n    const x4 = kx * r;\n    const y4 = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x4, y4);\n    for (let i = 1; i < 5; ++i) {\n      const a4 = tau6 * i / 5;\n      const c6 = cos3(a4);\n      const s2 = sin3(a4);\n      context.lineTo(s2 * r, -c6 * r);\n      context.lineTo(c6 * x4 - s2 * y4, s2 * x4 + c6 * y4);\n    }\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle.js\nvar sqrt33 = sqrt3(3);\nvar triangle_default = {\n  draw(context, size) {\n    const y4 = -sqrt3(size / (sqrt33 * 3));\n    context.moveTo(0, y4 * 2);\n    context.lineTo(-sqrt33 * y4, -y4);\n    context.lineTo(sqrt33 * y4, -y4);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/triangle2.js\nvar sqrt34 = sqrt3(3);\nvar triangle2_default = {\n  draw(context, size) {\n    const s2 = sqrt3(size) * 0.6824;\n    const t = s2 / 2;\n    const u4 = s2 * sqrt34 / 2;\n    context.moveTo(0, -s2);\n    context.lineTo(u4, t);\n    context.lineTo(-u4, t);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/wye.js\nvar c5 = -0.5;\nvar s = sqrt3(3) / 2;\nvar k = 1 / sqrt3(12);\nvar a3 = (k / 2 + 1) * 3;\nvar wye_default = {\n  draw(context, size) {\n    const r = sqrt3(size / a3);\n    const x06 = r / 2, y06 = r * k;\n    const x12 = x06, y12 = r * k + r;\n    const x22 = -x12, y22 = y12;\n    context.moveTo(x06, y06);\n    context.lineTo(x12, y12);\n    context.lineTo(x22, y22);\n    context.lineTo(c5 * x06 - s * y06, s * x06 + c5 * y06);\n    context.lineTo(c5 * x12 - s * y12, s * x12 + c5 * y12);\n    context.lineTo(c5 * x22 - s * y22, s * x22 + c5 * y22);\n    context.lineTo(c5 * x06 + s * y06, c5 * y06 - s * x06);\n    context.lineTo(c5 * x12 + s * y12, c5 * y12 - s * x12);\n    context.lineTo(c5 * x22 + s * y22, c5 * y22 - s * x22);\n    context.closePath();\n  }\n};\n\n// node_modules/d3-shape/src/symbol/times.js\nvar times_default = {\n  draw(context, size) {\n    const r = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;\n    context.moveTo(-r, -r);\n    context.lineTo(r, r);\n    context.moveTo(-r, r);\n    context.lineTo(r, -r);\n  }\n};\n\n// node_modules/d3-shape/src/symbol.js\nvar symbolsFill = [\n  circle_default3,\n  cross_default2,\n  diamond_default,\n  square_default,\n  star_default,\n  triangle_default,\n  wye_default\n];\nvar symbolsStroke = [\n  circle_default3,\n  plus_default,\n  times_default,\n  triangle2_default,\n  asterisk_default,\n  square2_default,\n  diamond2_default\n];\nfunction Symbol2(type2, size) {\n  let context = null, path2 = withPath(symbol2);\n  type2 = typeof type2 === \"function\" ? type2 : constant_default10(type2 || circle_default3);\n  size = typeof size === \"function\" ? size : constant_default10(size === void 0 ? 64 : +size);\n  function symbol2() {\n    let buffer;\n    if (!context)\n      context = buffer = path2();\n    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer)\n      return context = null, buffer + \"\" || null;\n  }\n  symbol2.type = function(_) {\n    return arguments.length ? (type2 = typeof _ === \"function\" ? _ : constant_default10(_), symbol2) : type2;\n  };\n  symbol2.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant_default10(+_), symbol2) : size;\n  };\n  symbol2.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol2) : context;\n  };\n  return symbol2;\n}\n\n// node_modules/d3-shape/src/noop.js\nfunction noop_default2() {\n}\n\n// node_modules/d3-shape/src/curve/basis.js\nfunction point2(that, x4, y4) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x4) / 6,\n    (that._y0 + 4 * that._y1 + y4) / 6\n  );\n}\nfunction Basis(context) {\n  this._context = context;\n}\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3:\n        point2(this, this._x1, this._y1);\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basis_default2(context) {\n  return new Basis(context);\n}\n\n// node_modules/d3-shape/src/curve/basisClosed.js\nfunction BasisClosed(context) {\n  this._context = context;\n}\nBasisClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x2 = x4, this._y2 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 2:\n        this._point = 3;\n        this._x4 = x4, this._y4 = y4;\n        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);\n        break;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisClosed_default2(context) {\n  return new BasisClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/basisOpen.js\nfunction BasisOpen(context) {\n  this._context = context;\n}\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;\n        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point2(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n  }\n};\nfunction basisOpen_default(context) {\n  return new BasisOpen(context);\n}\n\n// node_modules/d3-shape/src/curve/bundle.js\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, j = x4.length - 1;\n    if (j > 0) {\n      var x06 = x4[0], y06 = y4[0], dx = x4[j] - x06, dy = y4[j] - y06, i = -1, t;\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),\n          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)\n        );\n      }\n    }\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nvar bundle_default = function custom12(beta) {\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n  bundle.beta = function(beta2) {\n    return custom12(+beta2);\n  };\n  return bundle;\n}(0.85);\n\n// node_modules/d3-shape/src/curve/cardinal.js\nfunction point3(that, x4, y4) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x4),\n    that._y2 + that._k * (that._y1 - y4),\n    that._x2,\n    that._y2\n  );\n}\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        point3(this, this._x1, this._y1);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        this._x1 = x4, this._y1 = y4;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinal_default = function custom13(tension) {\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom13(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalClosed.js\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalClosed_default = function custom14(tension) {\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom14(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/cardinalOpen.js\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point3(this, x4, y4);\n        break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar cardinalOpen_default = function custom15(tension) {\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n  cardinal.tension = function(tension2) {\n    return custom15(+tension2);\n  };\n  return cardinal;\n}(0);\n\n// node_modules/d3-shape/src/curve/catmullRom.js\nfunction point4(that, x4, y4) {\n  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;\n  if (that._l01_a > epsilon8) {\n    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n  if (that._l23_a > epsilon8) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x22 = (x22 * b + that._x1 * that._l23_2a - x4 * that._l12_2a) / m3;\n    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;\n  }\n  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);\n}\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x2, this._y2);\n        break;\n      case 3:\n        this.point(this._x2, this._y2);\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRom_default = function custom16(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom16(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomClosed.js\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._x3 = x4, this._y3 = y4;\n        break;\n      case 1:\n        this._point = 2;\n        this._context.moveTo(this._x4 = x4, this._y4 = y4);\n        break;\n      case 2:\n        this._point = 3;\n        this._x5 = x4, this._y5 = y4;\n        break;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomClosed_default = function custom17(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom17(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/catmullRomOpen.js\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || this._line !== 0 && this._point === 3)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point) {\n      var x23 = this._x2 - x4, y23 = this._y2 - y4;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n        break;\n      case 3:\n        this._point = 4;\n      default:\n        point4(this, x4, y4);\n        break;\n    }\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;\n  }\n};\nvar catmullRomOpen_default = function custom18(alpha) {\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n  catmullRom.alpha = function(alpha2) {\n    return custom18(+alpha2);\n  };\n  return catmullRom;\n}(0.5);\n\n// node_modules/d3-shape/src/curve/linearClosed.js\nfunction LinearClosed(context) {\n  this._context = context;\n}\nLinearClosed.prototype = {\n  areaStart: noop_default2,\n  areaEnd: noop_default2,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point)\n      this._context.closePath();\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    if (this._point)\n      this._context.lineTo(x4, y4);\n    else\n      this._point = 1, this._context.moveTo(x4, y4);\n  }\n};\nfunction linearClosed_default(context) {\n  return new LinearClosed(context);\n}\n\n// node_modules/d3-shape/src/curve/monotone.js\nfunction sign2(x4) {\n  return x4 < 0 ? -1 : 1;\n}\nfunction slope3(that, x22, y22) {\n  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\nfunction point5(that, t03, t13) {\n  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;\n  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);\n}\nfunction MonotoneX(context) {\n  this._context = context;\n}\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2:\n        this._context.lineTo(this._x1, this._y1);\n        break;\n      case 3:\n        point5(this, this._t0, slope2(this, this._t0));\n        break;\n    }\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    var t13 = NaN;\n    x4 = +x4, y4 = +y4;\n    if (x4 === this._x1 && y4 === this._y1)\n      return;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n        break;\n      case 2:\n        this._point = 3;\n        point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);\n        break;\n      default:\n        point5(this, this._t0, t13 = slope3(this, x4, y4));\n        break;\n    }\n    this._x0 = this._x1, this._x1 = x4;\n    this._y0 = this._y1, this._y1 = y4;\n    this._t0 = t13;\n  }\n};\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {\n  MonotoneX.prototype.point.call(this, y4, x4);\n};\nfunction ReflectContext(context) {\n  this._context = context;\n}\nReflectContext.prototype = {\n  moveTo: function(x4, y4) {\n    this._context.moveTo(y4, x4);\n  },\n  closePath: function() {\n    this._context.closePath();\n  },\n  lineTo: function(x4, y4) {\n    this._context.lineTo(y4, x4);\n  },\n  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {\n    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);\n  }\n};\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\n// node_modules/d3-shape/src/curve/natural.js\nfunction Natural(context) {\n  this._context = context;\n}\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x4 = this._x, y4 = this._y, n = x4.length;\n    if (n) {\n      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);\n      if (n === 2) {\n        this._context.lineTo(x4[1], y4[1]);\n      } else {\n        var px = controlPoints(x4), py = controlPoints(y4);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);\n        }\n      }\n    }\n    if (this._line || this._line !== 0 && n === 1)\n      this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x4, y4) {\n    this._x.push(+x4);\n    this._y.push(+y4);\n  }\n};\nfunction controlPoints(x4) {\n  var i, n = x4.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);\n  a4[0] = 0, b[0] = 2, r[0] = x4[0] + 2 * x4[1];\n  for (i = 1; i < n - 1; ++i)\n    a4[i] = 1, b[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];\n  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];\n  for (i = 1; i < n; ++i)\n    m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];\n  a4[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i)\n    a4[i] = (r[i] - a4[i + 1]) / b[i];\n  b[n - 1] = (x4[n] + a4[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i)\n    b[i] = 2 * x4[i + 1] - a4[i + 1];\n  return [a4, b];\n}\nfunction natural_default(context) {\n  return new Natural(context);\n}\n\n// node_modules/d3-shape/src/curve/step.js\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2)\n      this._context.lineTo(this._x, this._y);\n    if (this._line || this._line !== 0 && this._point === 1)\n      this._context.closePath();\n    if (this._line >= 0)\n      this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x4, y4) {\n    x4 = +x4, y4 = +y4;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);\n        break;\n      case 1:\n        this._point = 2;\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y4);\n          this._context.lineTo(x4, y4);\n        } else {\n          var x12 = this._x * (1 - this._t) + x4 * this._t;\n          this._context.lineTo(x12, this._y);\n          this._context.lineTo(x12, y4);\n        }\n        break;\n      }\n    }\n    this._x = x4, this._y = y4;\n  }\n};\nfunction step_default(context) {\n  return new Step(context, 0.5);\n}\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\n// node_modules/d3-shape/src/offset/none.js\nfunction none_default(series, order) {\n  if (!((n = series.length) > 1))\n    return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m3 = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m3; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n\n// node_modules/d3-shape/src/order/none.js\nfunction none_default2(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0)\n    o[n] = n;\n  return o;\n}\n\n// node_modules/d3-shape/src/stack.js\nfunction stackValue(d, key) {\n  return d[key];\n}\nfunction stackSeries(key) {\n  const series = [];\n  series.key = key;\n  return series;\n}\nfunction stack_default() {\n  var keys = constant_default10([]), order = none_default2, offset2 = none_default, value = stackValue;\n  function stack2(data) {\n    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;\n    for (const d of data) {\n      for (i = 0, ++j; i < n; ++i) {\n        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;\n      }\n    }\n    for (i = 0, oz = array_default3(order(sz)); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n    offset2(sz, oz);\n    return sz;\n  }\n  stack2.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : keys;\n  };\n  stack2.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant_default10(+_), stack2) : value;\n  };\n  stack2.order = function(_) {\n    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === \"function\" ? _ : constant_default10(Array.from(_)), stack2) : order;\n  };\n  stack2.offset = function(_) {\n    return arguments.length ? (offset2 = _ == null ? none_default : _, stack2) : offset2;\n  };\n  return stack2;\n}\n\n// node_modules/d3-shape/src/offset/expand.js\nfunction expand_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, n, j = 0, m3 = series[0].length, y4; j < m3; ++j) {\n    for (y4 = i = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    if (y4)\n      for (i = 0; i < n; ++i)\n        series[i][j][1] /= y4;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/diverging.js\nfunction diverging_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var i, j = 0, d, dy, yp, yn, n, m3 = series[order[0]].length; j < m3; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = 0, d[1] = dy;\n      }\n    }\n  }\n}\n\n// node_modules/d3-shape/src/offset/silhouette.js\nfunction silhouette_default(series, order) {\n  if (!((n = series.length) > 0))\n    return;\n  for (var j = 0, s0 = series[order[0]], n, m3 = s0.length; j < m3; ++j) {\n    for (var i = 0, y4 = 0; i < n; ++i)\n      y4 += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y4 / 2;\n  }\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/offset/wiggle.js\nfunction wiggle_default(series, order) {\n  if (!((n = series.length) > 0) || !((m3 = (s0 = series[order[0]]).length) > 0))\n    return;\n  for (var y4 = 0, j = 1, s0, m3, n; j < m3; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;\n      for (var k2 = 0; k2 < i; ++k2) {\n        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y4;\n    if (s1)\n      y4 -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y4;\n  none_default(series, order);\n}\n\n// node_modules/d3-shape/src/order/appearance.js\nfunction appearance_default(series) {\n  var peaks = series.map(peak);\n  return none_default2(series).sort(function(a4, b) {\n    return peaks[a4] - peaks[b];\n  });\n}\nfunction peak(series) {\n  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n  while (++i < n)\n    if ((vi = +series[i][1]) > vj)\n      vj = vi, j = i;\n  return j;\n}\n\n// node_modules/d3-shape/src/order/ascending.js\nfunction ascending_default2(series) {\n  var sums = series.map(sum3);\n  return none_default2(series).sort(function(a4, b) {\n    return sums[a4] - sums[b];\n  });\n}\nfunction sum3(series) {\n  var s2 = 0, i = -1, n = series.length, v2;\n  while (++i < n)\n    if (v2 = +series[i][1])\n      s2 += v2;\n  return s2;\n}\n\n// node_modules/d3-shape/src/order/descending.js\nfunction descending_default2(series) {\n  return ascending_default2(series).reverse();\n}\n\n// node_modules/d3-shape/src/order/insideOut.js\nfunction insideOut_default(series) {\n  var n = series.length, i, j, sums = series.map(sum3), order = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top2 < bottom2) {\n      top2 += sums[j];\n      tops.push(j);\n    } else {\n      bottom2 += sums[j];\n      bottoms.push(j);\n    }\n  }\n  return bottoms.reverse().concat(tops);\n}\n\n// node_modules/d3-shape/src/order/reverse.js\nfunction reverse_default(series) {\n  return none_default2(series).reverse();\n}\n\n// node_modules/d3-zoom/src/constant.js\nvar constant_default11 = (x4) => () => x4;\n\n// node_modules/d3-zoom/src/event.js\nfunction ZoomEvent(type2, {\n  sourceEvent,\n  target,\n  transform: transform2,\n  dispatch: dispatch2\n}) {\n  Object.defineProperties(this, {\n    type: { value: type2, enumerable: true, configurable: true },\n    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },\n    target: { value: target, enumerable: true, configurable: true },\n    transform: { value: transform2, enumerable: true, configurable: true },\n    _: { value: dispatch2 }\n  });\n}\n\n// node_modules/d3-zoom/src/transform.js\nfunction Transform(k2, x4, y4) {\n  this.k = k2;\n  this.x = x4;\n  this.y = y4;\n}\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k2) {\n    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);\n  },\n  translate: function(x4, y4) {\n    return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);\n  },\n  apply: function(point6) {\n    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];\n  },\n  applyX: function(x4) {\n    return x4 * this.k + this.x;\n  },\n  applyY: function(y4) {\n    return y4 * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x4) {\n    return (x4 - this.x) / this.k;\n  },\n  invertY: function(y4) {\n    return (y4 - this.y) / this.k;\n  },\n  rescaleX: function(x4) {\n    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));\n  },\n  rescaleY: function(y4) {\n    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\nvar identity5 = new Transform(1, 0, 0);\ntransform.prototype = Transform.prototype;\nfunction transform(node) {\n  while (!node.__zoom)\n    if (!(node = node.parentNode))\n      return identity5;\n  return node.__zoom;\n}\n\n// node_modules/d3-zoom/src/noevent.js\nfunction nopropagation3(event) {\n  event.stopImmediatePropagation();\n}\nfunction noevent_default3(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\n// node_modules/d3-zoom/src/zoom.js\nfunction defaultFilter3(event) {\n  return (!event.ctrlKey || event.type === \"wheel\") && !event.button;\n}\nfunction defaultExtent2() {\n  var e = this;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    if (e.hasAttribute(\"viewBox\")) {\n      e = e.viewBox.baseVal;\n      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];\n    }\n    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];\n  }\n  return [[0, 0], [e.clientWidth, e.clientHeight]];\n}\nfunction defaultTransform() {\n  return this.__zoom || identity5;\n}\nfunction defaultWheelDelta(event) {\n  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);\n}\nfunction defaultTouchable3() {\n  return navigator.maxTouchPoints || \"ontouchstart\" in this;\n}\nfunction defaultConstrain(transform2, extent3, translateExtent) {\n  var dx0 = transform2.invertX(extent3[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent3[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent3[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent3[1][1]) - translateExtent[1][1];\n  return transform2.translate(\n    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n  );\n}\nfunction zoom_default2() {\n  var filter4 = defaultFilter3, extent3 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable3, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default(\"start\", \"zoom\", \"end\"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;\n  function zoom(selection2) {\n    selection2.property(\"__zoom\", defaultTransform).on(\"wheel.zoom\", wheeled, { passive: false }).on(\"mousedown.zoom\", mousedowned).on(\"dblclick.zoom\", dblclicked).filter(touchable).on(\"touchstart.zoom\", touchstarted).on(\"touchmove.zoom\", touchmoved).on(\"touchend.zoom touchcancel.zoom\", touchended).style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n  zoom.transform = function(collection, transform2, point6, event) {\n    var selection2 = collection.selection ? collection.selection() : collection;\n    selection2.property(\"__zoom\", defaultTransform);\n    if (collection !== selection2) {\n      schedule(collection, transform2, point6, event);\n    } else {\n      selection2.interrupt().each(function() {\n        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === \"function\" ? transform2.apply(this, arguments) : transform2).end();\n      });\n    }\n  };\n  zoom.scaleBy = function(selection2, k2, p, event) {\n    zoom.scaleTo(selection2, function() {\n      var k0 = this.__zoom.k, k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return k0 * k1;\n    }, p, event);\n  };\n  zoom.scaleTo = function(selection2, k2, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t03 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p, p1 = t03.invert(p02), k1 = typeof k2 === \"function\" ? k2.apply(this, arguments) : k2;\n      return constrain(translate(scale3(t03, k1), p02, p1), e, translateExtent);\n    }, p, event);\n  };\n  zoom.translateBy = function(selection2, x4, y4, event) {\n    zoom.transform(selection2, function() {\n      return constrain(this.__zoom.translate(\n        typeof x4 === \"function\" ? x4.apply(this, arguments) : x4,\n        typeof y4 === \"function\" ? y4.apply(this, arguments) : y4\n      ), extent3.apply(this, arguments), translateExtent);\n    }, null, event);\n  };\n  zoom.translateTo = function(selection2, x4, y4, p, event) {\n    zoom.transform(selection2, function() {\n      var e = extent3.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === \"function\" ? p.apply(this, arguments) : p;\n      return constrain(identity5.translate(p02[0], p02[1]).scale(t.k).translate(\n        typeof x4 === \"function\" ? -x4.apply(this, arguments) : -x4,\n        typeof y4 === \"function\" ? -y4.apply(this, arguments) : -y4\n      ), e, translateExtent);\n    }, p, event);\n  };\n  function scale3(transform2, k2) {\n    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));\n    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);\n  }\n  function translate(transform2, p02, p1) {\n    var x4 = p02[0] - p1[0] * transform2.k, y4 = p02[1] - p1[1] * transform2.k;\n    return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);\n  }\n  function centroid2(extent4) {\n    return [(+extent4[0][0] + +extent4[1][0]) / 2, (+extent4[0][1] + +extent4[1][1]) / 2];\n  }\n  function schedule(transition2, transform2, point6, event) {\n    transition2.on(\"start.zoom\", function() {\n      gesture(this, arguments).event(event).start();\n    }).on(\"interrupt.zoom end.zoom\", function() {\n      gesture(this, arguments).event(event).end();\n    }).tween(\"zoom\", function() {\n      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent3.apply(that, args), p = point6 == null ? centroid2(e) : typeof point6 === \"function\" ? point6.apply(that, args) : point6, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a4 = that.__zoom, b = typeof transform2 === \"function\" ? transform2.apply(that, args) : transform2, i = interpolate(a4.invert(p).concat(w / a4.k), b.invert(p).concat(w / b.k));\n      return function(t) {\n        if (t === 1)\n          t = b;\n        else {\n          var l = i(t), k2 = w / l[2];\n          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);\n        }\n        g.zoom(null, t);\n      };\n    });\n  }\n  function gesture(that, args, clean) {\n    return !clean && that.__zooming || new Gesture(that, args);\n  }\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.active = 0;\n    this.sourceEvent = null;\n    this.extent = extent3.apply(that, args);\n    this.taps = 0;\n  }\n  Gesture.prototype = {\n    event: function(event) {\n      if (event)\n        this.sourceEvent = event;\n      return this;\n    },\n    start: function() {\n      if (++this.active === 1) {\n        this.that.__zooming = this;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform2) {\n      if (this.mouse && key !== \"mouse\")\n        this.mouse[1] = transform2.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\")\n        this.touch0[1] = transform2.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\")\n        this.touch1[1] = transform2.invert(this.touch1[0]);\n      this.that.__zoom = transform2;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        delete this.that.__zooming;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type2) {\n      var d = select_default2(this.that).datum();\n      listeners.call(\n        type2,\n        this.that,\n        new ZoomEvent(type2, {\n          sourceEvent: this.sourceEvent,\n          target: zoom,\n          type: type2,\n          transform: this.that.__zoom,\n          dispatch: listeners\n        }),\n        d\n      );\n    }\n  };\n  function wheeled(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    } else if (t.k === k2)\n      return;\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt_default(this);\n      g.start();\n    }\n    noevent_default3(event);\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale3(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n  function mousedowned(event, ...args) {\n    if (touchending || !filter4.apply(this, arguments))\n      return;\n    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true), p = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;\n    nodrag_default(event.view);\n    nopropagation3(event);\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt_default(this);\n    g.start();\n    function mousemoved(event2) {\n      noevent_default3(event2);\n      if (!g.moved) {\n        var dx = event2.clientX - x06, dy = event2.clientY - y06;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.event(event2).zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));\n    }\n    function mouseupped(event2) {\n      v2.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(event2.view, g.moved);\n      noevent_default3(event2);\n      g.event(event2).end();\n    }\n  }\n  function dblclicked(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var t03 = this.__zoom, p02 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p02), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale3(t03, k1), p02, p1), extent3.apply(this, args), translateExtent);\n    noevent_default3(event);\n    if (duration > 0)\n      select_default2(this).transition().duration(duration).call(schedule, t13, p02, event);\n    else\n      select_default2(this).call(zoom.transform, t13, p02, event);\n  }\n  function touchstarted(event, ...args) {\n    if (!filter4.apply(this, arguments))\n      return;\n    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;\n    nopropagation3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0)\n        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;\n      else if (!g.touch1 && g.touch0[2] !== p[2])\n        g.touch1 = p, g.taps = 0;\n    }\n    if (touchstarting)\n      touchstarting = clearTimeout(touchstarting);\n    if (started) {\n      if (g.taps < 2)\n        touchfirst = p[0], touchstarting = setTimeout(function() {\n          touchstarting = null;\n        }, touchDelay);\n      interrupt_default(this);\n      g.start();\n    }\n  }\n  function touchmoved(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;\n    noevent_default3(event);\n    for (i = 0; i < n; ++i) {\n      t = touches[i], p = pointer_default(t, this);\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale3(t, Math.sqrt(dp / dl));\n      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    } else if (g.touch0)\n      p = g.touch0[0], l = g.touch0[1];\n    else\n      return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\n  }\n  function touchended(event, ...args) {\n    if (!this.__zooming)\n      return;\n    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;\n    nopropagation3(event);\n    if (touchending)\n      clearTimeout(touchending);\n    touchending = setTimeout(function() {\n      touchending = null;\n    }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches[i];\n      if (g.touch0 && g.touch0[2] === t.identifier)\n        delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier)\n        delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0)\n      g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0)\n      g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else {\n      g.end();\n      if (g.taps === 2) {\n        t = pointer_default(t, this);\n        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {\n          var p = select_default2(this).on(\"dblclick.zoom\");\n          if (p)\n            p.apply(this, arguments);\n        }\n      }\n    }\n  }\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant_default11(+_), zoom) : wheelDelta;\n  };\n  zoom.filter = function(_) {\n    return arguments.length ? (filter4 = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : filter4;\n  };\n  zoom.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant_default11(!!_), zoom) : touchable;\n  };\n  zoom.extent = function(_) {\n    return arguments.length ? (extent3 = typeof _ === \"function\" ? _ : constant_default11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent3;\n  };\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\n  };\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\n  };\n  zoom.constrain = function(_) {\n    return arguments.length ? (constrain = _, zoom) : constrain;\n  };\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n  zoom.tapDistance = function(_) {\n    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;\n  };\n  return zoom;\n}\n\n// node_modules/isoformat/src/format.js\nfunction format2(date2, fallback) {\n  if (!(date2 instanceof Date))\n    date2 = /* @__PURE__ */ new Date(+date2);\n  if (isNaN(date2))\n    return typeof fallback === \"function\" ? fallback(date2) : fallback;\n  const hours = date2.getUTCHours();\n  const minutes = date2.getUTCMinutes();\n  const seconds2 = date2.getUTCSeconds();\n  const milliseconds2 = date2.getUTCMilliseconds();\n  return `${formatYear3(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;\n}\nfunction formatYear3(year) {\n  return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);\n}\nfunction pad3(value, width) {\n  return `${value}`.padStart(width, \"0\");\n}\n\n// node_modules/isoformat/src/parse.js\nvar re2 = /^(?:[-+]\\d{2})?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{3})?)?(?:Z|[-+]\\d{2}:?\\d{2})?)?$/;\nfunction parse(string2, fallback) {\n  if (!re2.test(string2 += \"\"))\n    return typeof fallback === \"function\" ? fallback(string2) : fallback;\n  return new Date(string2);\n}\n\n// node_modules/@observablehq/plot/dist/time.js\nvar timeIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", timeMinute],\n  [\"hour\", timeHour],\n  [\"day\", timeDay],\n  [\"week\", timeSunday],\n  [\"month\", timeMonth],\n  [\"year\", timeYear],\n  [\"monday\", timeMonday],\n  [\"tuesday\", timeTuesday],\n  [\"wednesday\", timeWednesday],\n  [\"thursday\", timeThursday],\n  [\"friday\", timeFriday],\n  [\"saturday\", timeSaturday],\n  [\"sunday\", timeSunday]\n]);\nvar utcIntervals = /* @__PURE__ */ new Map([\n  [\"second\", second],\n  [\"minute\", utcMinute],\n  [\"hour\", utcHour],\n  [\"day\", utcDay],\n  [\"week\", utcSunday],\n  [\"month\", utcMonth],\n  [\"year\", utcYear],\n  [\"monday\", utcMonday],\n  [\"tuesday\", utcTuesday],\n  [\"wednesday\", utcWednesday],\n  [\"thursday\", utcThursday],\n  [\"friday\", utcFriday],\n  [\"saturday\", utcSaturday],\n  [\"sunday\", utcSunday]\n]);\nfunction maybeTimeInterval(interval2) {\n  const i = timeIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\nfunction maybeUtcInterval(interval2) {\n  const i = utcIntervals.get(`${interval2}`.toLowerCase());\n  if (!i)\n    throw new Error(`unknown interval: ${interval2}`);\n  return i;\n}\n\n// node_modules/@observablehq/plot/dist/options.js\nvar TypedArray = Object.getPrototypeOf(Uint8Array);\nvar objectToString = Object.prototype.toString;\nfunction valueof(data, value, type2) {\n  const valueType = typeof value;\n  return valueType === \"string\" ? map4(data, field(value), type2) : valueType === \"function\" ? map4(data, value, type2) : valueType === \"number\" || value instanceof Date || valueType === \"boolean\" ? map4(data, constant2(value), type2) : value && typeof value.transform === \"function\" ? arrayify2(value.transform(data), type2) : arrayify2(value, type2);\n}\nvar field = (name) => (d) => d[name];\nvar indexOf = (d, i) => i;\nvar identity6 = { transform: (d) => d };\nvar one2 = () => 1;\nvar yes = () => true;\nvar string = (x4) => x4 == null ? x4 : `${x4}`;\nvar number5 = (x4) => x4 == null ? x4 : +x4;\nvar first = (x4) => x4 ? x4[0] : void 0;\nvar second2 = (x4) => x4 ? x4[1] : void 0;\nvar third = (x4) => x4 ? x4[2] : void 0;\nvar constant2 = (x4) => () => x4;\nfunction percentile(reduce2) {\n  const p = +`${reduce2}`.slice(1) / 100;\n  return (I, f) => quantile(I, p, f);\n}\nfunction maybeColorChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null ? [void 0, \"none\"] : isColor(value) ? [void 0, value] : [value, void 0];\n}\nfunction maybeNumberChannel(value, defaultValue) {\n  if (value === void 0)\n    value = defaultValue;\n  return value === null || typeof value === \"number\" ? [void 0, value] : [value, void 0];\n}\nfunction maybeKeyword(input, name, allowed) {\n  if (input != null)\n    return keyword(input, name, allowed);\n}\nfunction keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i))\n    throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\nfunction arrayify2(data, type2) {\n  return data == null ? data : type2 === void 0 ? data instanceof Array || data instanceof TypedArray ? data : Array.from(data) : data instanceof type2 ? data : type2.from(data);\n}\nfunction map4(values2, f, type2 = Array) {\n  return values2 instanceof type2 ? values2.map(f) : type2.from(values2, f);\n}\nfunction slice5(values2, type2 = Array) {\n  return values2 instanceof type2 ? values2.slice() : type2.from(values2);\n}\nfunction isTypedArray(values2) {\n  return values2 instanceof TypedArray;\n}\nfunction isObject(option) {\n  return option?.toString === objectToString;\n}\nfunction isScaleOptions(option) {\n  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);\n}\nfunction isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\nfunction isDomainSort(sort3) {\n  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;\n}\nfunction maybeZero(x4, x12, x22, x32 = identity6) {\n  if (x12 === void 0 && x22 === void 0) {\n    x12 = 0, x22 = x4 === void 0 ? x32 : x4;\n  } else if (x12 === void 0) {\n    x12 = x4 === void 0 ? 0 : x4;\n  } else if (x22 === void 0) {\n    x22 = x4 === void 0 ? 0 : x4;\n  }\n  return [x12, x22];\n}\nfunction maybeTuple(x4, y4) {\n  return x4 === void 0 && y4 === void 0 ? [first, second2] : [x4, y4];\n}\nfunction maybeZ({ z, fill, stroke } = {}) {\n  if (z === void 0)\n    [z] = maybeColorChannel(fill);\n  if (z === void 0)\n    [z] = maybeColorChannel(stroke);\n  return z;\n}\nfunction range4(data) {\n  const n = data.length;\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i)\n    r[i] = i;\n  return r;\n}\nfunction take(values2, index3) {\n  return map4(index3, (i) => values2[i]);\n}\nfunction keyof2(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\nfunction maybeInput(key, options) {\n  if (options[key] !== void 0)\n    return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\nfunction column(source) {\n  let value;\n  return [\n    {\n      transform: () => value,\n      label: labelof(source)\n    },\n    (v2) => value = v2\n  ];\n}\nfunction maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\nfunction labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== void 0 ? value.label : defaultValue;\n}\nfunction mid(x12, x22) {\n  return {\n    transform(data) {\n      const X13 = x12.transform(data);\n      const X23 = x22.transform(data);\n      return isTemporal(X13) || isTemporal(X23) ? map4(X13, (_, i) => new Date((+X13[i] + +X23[i]) / 2)) : map4(X13, (_, i) => (+X13[i] + +X23[i]) / 2, Float64Array);\n    },\n    label: x12.label\n  };\n}\nfunction maybeInterval(interval2, type2) {\n  if (interval2 == null)\n    return;\n  if (typeof interval2 === \"number\") {\n    const n = interval2;\n    return {\n      floor: (d) => n * Math.floor(d / n),\n      offset: (d) => d + n,\n      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x4) => n * x4)\n    };\n  }\n  if (typeof interval2 === \"string\")\n    return (type2 === \"time\" ? maybeTimeInterval : maybeUtcInterval)(interval2);\n  if (typeof interval2.floor !== \"function\")\n    throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval2.offset !== \"function\")\n    throw new Error(\"invalid interval; missing offset method\");\n  return interval2;\n}\nfunction maybeValue(value) {\n  return value === void 0 || isOptions(value) ? value : { value };\n}\nfunction numberChannel(source) {\n  return source == null ? null : {\n    transform: (data) => valueof(data, source, Float64Array),\n    label: labelof(source)\n  };\n}\nfunction isTuples(data) {\n  if (!isIterable(data))\n    return false;\n  for (const d of data) {\n    if (d == null)\n      continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\nfunction isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\nfunction isTextual(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\nfunction isOrdinal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    const type2 = typeof value;\n    return type2 === \"string\" || type2 === \"boolean\";\n  }\n}\nfunction isTemporal(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return value instanceof Date;\n  }\n}\nfunction isTemporalString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"string\" && isNaN(value) && parse(value);\n  }\n}\nfunction isNumericString(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (typeof value !== \"string\")\n      return false;\n    if (!value.trim())\n      continue;\n    return !isNaN(value);\n  }\n}\nfunction isNumeric(values2) {\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    return typeof value === \"number\";\n  }\n}\nfunction isEvery(values2, is) {\n  let every2;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (!is(value))\n      return false;\n    every2 = true;\n  }\n  return every2;\n}\nfunction isColor(value) {\n  if (typeof value !== \"string\")\n    return false;\n  value = value.toLowerCase().trim();\n  return value === \"none\" || value === \"currentcolor\" || value.startsWith(\"url(\") && value.endsWith(\")\") || // <funciri>, e.g. pattern or gradient\n  value.startsWith(\"var(\") && value.endsWith(\")\") || // CSS variable\n  color(value) !== null;\n}\nfunction isNoneish(value) {\n  return value == null || isNone(value);\n}\nfunction isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\nfunction isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\nfunction maybeFrameAnchor(value = \"middle\") {\n  return keyword(value, \"frameAnchor\", [\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\"\n  ]);\n}\nfunction orderof(values2) {\n  if (values2 == null)\n    return;\n  const first2 = values2[0];\n  const last = values2[values2.length - 1];\n  return descending(first2, last);\n}\nfunction inherit2(options = {}, ...rest) {\n  let o = options;\n  for (const defaults21 of rest) {\n    for (const key in defaults21) {\n      if (o[key] === void 0) {\n        const value = defaults21[key];\n        if (o === options)\n          o = { ...o, [key]: value };\n        else\n          o[key] = value;\n      }\n    }\n  }\n  return o;\n}\nfunction Named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = /* @__PURE__ */ new Set();\n  return Object.fromEntries(Array.from(things, (thing) => {\n    const { name } = thing;\n    if (name == null)\n      throw new Error(\"missing name\");\n    const key = `${name}`;\n    if (key === \"__proto__\")\n      throw new Error(`illegal name: ${key}`);\n    if (names.has(key))\n      throw new Error(`duplicate name: ${key}`);\n    names.add(key);\n    return [name, thing];\n  }));\n}\nfunction maybeNamed(things) {\n  return isIterable(things) ? Named(things) : things;\n}\n\n// node_modules/@observablehq/plot/dist/scales/index.js\nvar position = Symbol(\"position\");\nvar color2 = Symbol(\"color\");\nvar radius = Symbol(\"radius\");\nvar length3 = Symbol(\"length\");\nvar opacity = Symbol(\"opacity\");\nvar symbol = Symbol(\"symbol\");\nvar registry = /* @__PURE__ */ new Map([\n  [\"x\", position],\n  [\"y\", position],\n  [\"fx\", position],\n  [\"fy\", position],\n  [\"r\", radius],\n  [\"color\", color2],\n  [\"opacity\", opacity],\n  [\"symbol\", symbol],\n  [\"length\", length3]\n]);\n\n// node_modules/@observablehq/plot/dist/symbols.js\nvar sqrt35 = Math.sqrt(3);\nvar sqrt4_3 = 2 / sqrt35;\nvar symbolHexagon = {\n  draw(context, size) {\n    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;\n    context.moveTo(0, ry);\n    context.lineTo(rx, hy);\n    context.lineTo(rx, -hy);\n    context.lineTo(0, -ry);\n    context.lineTo(-rx, -hy);\n    context.lineTo(-rx, hy);\n    context.closePath();\n  }\n};\nvar symbols = /* @__PURE__ */ new Map([\n  [\"asterisk\", asterisk_default],\n  [\"circle\", circle_default3],\n  [\"cross\", cross_default2],\n  [\"diamond\", diamond_default],\n  [\"diamond2\", diamond2_default],\n  [\"hexagon\", symbolHexagon],\n  [\"plus\", plus_default],\n  [\"square\", square_default],\n  [\"square2\", square2_default],\n  [\"star\", star_default],\n  [\"times\", times_default],\n  [\"triangle\", triangle_default],\n  [\"triangle2\", triangle2_default],\n  [\"wye\", wye_default]\n]);\nfunction isSymbolObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction isSymbol(value) {\n  if (isSymbolObject(value))\n    return true;\n  if (typeof value !== \"string\")\n    return false;\n  return symbols.has(value.toLowerCase());\n}\nfunction maybeSymbol(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return symbol2;\n  const value = symbols.get(`${symbol2}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid symbol: ${symbol2}`);\n}\nfunction maybeSymbolChannel(symbol2) {\n  if (symbol2 == null || isSymbolObject(symbol2))\n    return [void 0, symbol2];\n  if (typeof symbol2 === \"string\") {\n    const value = symbols.get(`${symbol2}`.toLowerCase());\n    if (value)\n      return [void 0, value];\n  }\n  return [symbol2, void 0];\n}\n\n// node_modules/@observablehq/plot/dist/defined.js\nfunction defined(x4) {\n  return x4 != null && !Number.isNaN(x4);\n}\nfunction ascendingDefined2(a4, b) {\n  return +defined(b) - +defined(a4) || ascending(a4, b);\n}\nfunction descendingDefined(a4, b) {\n  return +defined(b) - +defined(a4) || descending(a4, b);\n}\nfunction nonempty(x4) {\n  return x4 != null && `${x4}` !== \"\";\n}\nfunction finite2(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\nfunction positive(x4) {\n  return x4 > 0 && isFinite(x4) ? x4 : NaN;\n}\nfunction negative(x4) {\n  return x4 < 0 && isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/basic.js\nfunction basic(options = {}, transform2) {\n  let { filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...remainingOptions } = options;\n  if (t13 === void 0) {\n    if (f1 != null)\n      t13 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      t13 = composeTransform(t13, sortTransform(s1));\n    if (r1)\n      t13 = composeTransform(t13, reverseTransform);\n  }\n  if (transform2 != null && i1 != null)\n    throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    transform: composeTransform(t13, transform2)\n  };\n}\nfunction initializer(options = {}, initializer2) {\n  let { filter: f1, sort: s1, reverse: r1, initializer: i1, ...remainingOptions } = options;\n  if (i1 === void 0) {\n    if (f1 != null)\n      i1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1))\n      i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1)\n      i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...remainingOptions,\n    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },\n    initializer: composeInitializer(i1, initializer2)\n  };\n}\nfunction composeTransform(t13, t22) {\n  if (t13 == null)\n    return t22 === null ? void 0 : t22;\n  if (t22 == null)\n    return t13 === null ? void 0 : t13;\n  return function(data, facets) {\n    ({ data, facets } = t13.call(this, data, facets));\n    return t22.call(this, arrayify2(data), facets);\n  };\n}\nfunction composeInitializer(i1, i2) {\n  if (i1 == null)\n    return i2 === null ? void 0 : i2;\n  if (i2 == null)\n    return i1 === null ? void 0 : i1;\n  return function(data, facets, channels, ...args) {\n    let c1, d1, f1, c22, d2, f2;\n    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));\n    ({ data: d2 = d1, facets: f2 = f1, channels: c22 } = i2.call(this, d1, f1, { ...channels, ...c1 }, ...args));\n    return { data: d2, facets: f2, channels: { ...c1, ...c22 } };\n  };\n}\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\nfunction filter3(test, options) {\n  return apply(options, filterTransform(test));\n}\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = valueof(data, value);\n    return { data, facets: facets.map((I) => I.filter((i) => V[i])) };\n  };\n}\nfunction reverse2(options) {\n  return { ...apply(options, reverseTransform), sort: null };\n}\nfunction reverseTransform(data, facets) {\n  return { data, facets: facets.map((I) => I.slice().reverse()) };\n}\nfunction shuffle2(options = {}) {\n  const { seed, ...remainingOptions } = options;\n  return { ...apply(remainingOptions, sortValue(seed == null ? Math.random : lcg(seed))), sort: null };\n}\nfunction sort2(order, options) {\n  return {\n    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),\n    sort: null\n  };\n}\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = (i, j) => compare(data[i], data[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareData)) };\n  };\n}\nfunction sortValue(value) {\n  let channel, order;\n  ({ channel, value, order = ascendingDefined2 } = { ...maybeValue(value) });\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = ascendingDefined2;\n        break;\n      case \"descending\":\n        order = descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === void 0) {\n      V = valueof(data, value);\n    } else {\n      if (channels === void 0)\n        throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V)\n        return {};\n      V = V.value;\n    }\n    const compareValue2 = (i, j) => order(V[i], V[j]);\n    return { data, facets: facets.map((I) => I.slice().sort(compareValue2)) };\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/group.js\nfunction groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\nfunction groupX(outputs = { y: \"count\" }, options = {}) {\n  const { x: x4 = identity6 } = options;\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  return groupn(x4, null, outputs, options);\n}\nfunction groupY(outputs = { x: \"count\" }, options = {}) {\n  const { y: y4 = identity6 } = options;\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(null, y4, outputs, options);\n}\nfunction group2(outputs = { fill: \"count\" }, options = {}) {\n  let { x: x4, y: y4 } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  if (x4 == null)\n    throw new Error(\"missing channel: x\");\n  if (y4 == null)\n    throw new Error(\"missing channel: y\");\n  return groupn(x4, y4, outputs, options);\n}\nfunction groupn(x4, y4, {\n  data: reduceData = reduceIdentity,\n  filter: filter4,\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  const [GX, setGX] = maybeColumn(x4);\n  const [GY, setGY] = maybeColumn(y4);\n  const {\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const X3 = valueof(data, x4);\n      const Y3 = valueof(data, y4);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GX2 = X3 && setGX([]);\n      const GY2 = Y3 && setGY([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y5, gg] of maybeGroup(I, Y3)) {\n            for (const [x5, g] of maybeGroup(gg, X3)) {\n              if (filter4 && !filter4.reduce(g))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(g, data));\n              if (X3)\n                GX2.push(x5);\n              if (Y3)\n                GY2.push(y5);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[g[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[g[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[g[0]]);\n              for (const o of outputs)\n                o.reduce(g);\n              if (sort3)\n                sort3.reduce(g);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (GX ? { x: GX } : { x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (GY ? { y: GY } : { y1: y12, y2: y22 }),\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction hasOutput(outputs, ...names) {\n  for (const { name } of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction maybeOutputs(outputs, inputs) {\n  const entries = Object.entries(outputs);\n  if (inputs.title != null && outputs.title === void 0)\n    entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === void 0)\n    entries.push([\"href\", reduceFirst]);\n  return entries.filter(([, reduce2]) => reduce2 !== void 0).map(([name, reduce2]) => {\n    return reduce2 === null ? { name, initialize() {\n    }, scope() {\n    }, reduce() {\n    } } : maybeOutput(name, reduce2, inputs);\n  });\n}\nfunction maybeOutput(name, reduce2, inputs) {\n  const evaluator = maybeEvaluator(name, reduce2, inputs);\n  const [output, setOutput] = column(evaluator.label);\n  let O;\n  return {\n    name,\n    output,\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent3) {\n      O.push(evaluator.reduce(I, extent3));\n    }\n  };\n}\nfunction maybeEvaluator(name, reduce2, inputs) {\n  const input = maybeInput(name, inputs);\n  const reducer2 = maybeReduce(reduce2, input);\n  let V, context;\n  return {\n    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),\n    initialize(data) {\n      V = input === void 0 ? data : valueof(data, input);\n      if (reducer2.scope === \"data\") {\n        context = reducer2.reduce(range4(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer2.scope === scope) {\n        context = reducer2.reduce(I, V);\n      }\n    },\n    reduce(I, extent3) {\n      return reducer2.scope == null ? reducer2.reduce(I, V, extent3) : reducer2.reduce(I, V, context, extent3);\n    }\n  };\n}\nfunction maybeGroup(I, X3) {\n  return X3 ? sort(group(I, (i) => X3[i]), first) : [[, I]];\n}\nfunction maybeReduce(reduce2, value) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return reduce2;\n  if (typeof reduce2 === \"function\")\n    return reduceFunction(reduce2);\n  if (/^p\\d{2}$/i.test(reduce2))\n    return reduceAccessor(percentile(reduce2));\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(deviation);\n    case \"min\":\n      return reduceAccessor(min);\n    case \"min-index\":\n      return reduceAccessor(minIndex);\n    case \"max\":\n      return reduceAccessor(max);\n    case \"max-index\":\n      return reduceAccessor(maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(median);\n    case \"variance\":\n      return reduceAccessor(variance);\n    case \"mode\":\n      return reduceAccessor(mode);\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n  }\n  throw new Error(`invalid reduce: ${reduce2}`);\n}\nfunction maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== void 0 && !outputs.some((o) => o.name === name)) {\n      return value;\n    }\n  }\n}\nfunction maybeSort(facets, sort3, reverse3) {\n  if (sort3) {\n    const S = sort3.output.transform();\n    const compare = (i, j) => ascendingDefined2(S[i], S[j]);\n    facets.forEach((f) => f.sort(compare));\n  }\n  if (reverse3) {\n    facets.forEach((f) => f.reverse());\n  }\n}\nfunction reduceFunction(f) {\n  return {\n    reduce(I, X3, extent3) {\n      return f(take(X3, I), extent3);\n    }\n  };\n}\nfunction reduceAccessor(f) {\n  return {\n    reduce(I, X3) {\n      return f(I, (i) => X3[i]);\n    }\n  };\n}\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduce(I, X3) {\n      const x4 = f(I, (i) => X3[i]);\n      return isTemporal(X3) ? new Date(x4) : x4;\n    }\n  };\n}\nvar reduceIdentity = {\n  reduce(I, X3) {\n    return take(X3, I);\n  }\n};\nvar reduceFirst = {\n  reduce(I, X3) {\n    return X3[I[0]];\n  }\n};\nvar reduceTitle = {\n  reduce(I, X3) {\n    const n = 5;\n    const groups2 = sort(rollup(I, (V) => V.length, (i) => X3[i]), second2);\n    const top2 = groups2.slice(-n).reverse();\n    if (top2.length < groups2.length) {\n      const bottom2 = groups2.slice(0, 1 - n);\n      top2[n - 1] = [`\\u2026 ${bottom2.length.toLocaleString(\"en-US\")} more`, sum(bottom2, second2)];\n    }\n    return top2.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\nvar reduceLast = {\n  reduce(I, X3) {\n    return X3[I[I.length - 1]];\n  }\n};\nvar reduceCount = {\n  label: \"Frequency\",\n  reduce(I) {\n    return I.length;\n  }\n};\nvar reduceDistinct = {\n  label: \"Distinct\",\n  reduce: (I, X3) => {\n    const s2 = new InternSet();\n    for (const i of I)\n      s2.add(X3[i]);\n    return s2.size;\n  }\n};\nvar reduceSum = reduceAccessor(sum);\nfunction reduceProportion(value, scope) {\n  return value == null ? { scope, label: \"Frequency\", reduce: (I, V, basis2 = 1) => I.length / basis2 } : { scope, reduce: (I, V, basis2 = 1) => sum(I, (i) => V[i]) / basis2 };\n}\nfunction mid2(x12, x22) {\n  const m3 = (+x12 + +x22) / 2;\n  return x12 instanceof Date ? new Date(m3) : m3;\n}\nvar reduceX = {\n  reduce(I, X3, { x1: x12, x2: x22 }) {\n    return mid2(x12, x22);\n  }\n};\nvar reduceY = {\n  reduce(I, X3, { y1: y12, y2: y22 }) {\n    return mid2(y12, y22);\n  }\n};\nvar reduceX1 = {\n  reduce(I, X3, { x1: x12 }) {\n    return x12;\n  }\n};\nvar reduceX2 = {\n  reduce(I, X3, { x2: x22 }) {\n    return x22;\n  }\n};\nvar reduceY1 = {\n  reduce(I, X3, { y1: y12 }) {\n    return y12;\n  }\n};\nvar reduceY2 = {\n  reduce(I, X3, { y2: y22 }) {\n    return y22;\n  }\n};\n\n// node_modules/@observablehq/plot/dist/channel.js\nfunction Channel(data, { scale: scale3, type: type2, value, filter: filter4, hint }, name) {\n  return inferChannelScale(name, {\n    scale: scale3,\n    type: type2,\n    value: valueof(data, value),\n    label: labelof(value),\n    filter: filter4,\n    hint\n  });\n}\nfunction Channels(channels, data) {\n  return Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, Channel(data, channel, name)]));\n}\nfunction valueObject(channels, scales) {\n  return Object.fromEntries(Object.entries(channels).map(([name, { scale: scaleName, value }]) => {\n    const scale3 = scaleName == null ? null : scales[scaleName];\n    return [name, scale3 == null ? value : map4(value, scale3)];\n  }));\n}\nfunction inferChannelScale(name, channel) {\n  const { scale: scale3, value } = channel;\n  if (scale3 === true || scale3 === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = isEvery(value, isColor) ? null : \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n        channel.scale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (isEvery(value, isSymbol)) {\n          channel.scale = null;\n          channel.value = map4(value, maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        break;\n      default:\n        channel.scale = registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale3 != null && !registry.has(scale3)) {\n    throw new Error(`unknown scale: ${scale3}`);\n  }\n  return channel;\n}\nfunction channelDomain(channels, facetChannels, data, options) {\n  const { reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;\n  for (const x4 in options) {\n    if (!registry.has(x4))\n      continue;\n    let { value: y4, reverse: reverse3 = defaultReverse, reduce: reduce2 = defaultReduce, limit = defaultLimit } = maybeValue(options[x4]);\n    if (reverse3 === void 0)\n      reverse3 = y4 === \"width\" || y4 === \"height\";\n    if (reduce2 == null || reduce2 === false)\n      continue;\n    const X3 = findScaleChannel(channels, x4) || facetChannels && findScaleChannel(facetChannels, x4);\n    if (!X3)\n      throw new Error(`missing channel for scale: ${x4}`);\n    const XV = X3.value;\n    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y4 == null) {\n      X3.domain = () => {\n        let domain = XV;\n        if (reverse3)\n          domain = domain.slice().reverse();\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV = y4 === \"data\" ? data : y4 === \"height\" ? difference2(channels, \"y1\", \"y2\") : y4 === \"width\" ? difference2(channels, \"x1\", \"x2\") : values(channels, y4, y4 === \"y\" ? \"y2\" : y4 === \"x\" ? \"x2\" : void 0);\n      const reducer2 = maybeReduce(reduce2 === true ? \"max\" : reduce2, YV);\n      X3.domain = () => {\n        let domain = rollup(range4(XV), (I) => reducer2.reduce(I, YV), (i) => XV[i]);\n        domain = sort(domain, reverse3 ? descendingGroup : ascendingGroup);\n        if (lo !== 0 || hi !== Infinity)\n          domain = domain.slice(lo, hi);\n        return domain.map(first);\n      };\n    }\n  }\n}\nfunction findScaleChannel(channels, scale3) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale3)\n      return channel;\n  }\n}\nfunction difference2(channels, k1, k2) {\n  const X13 = values(channels, k1);\n  const X23 = values(channels, k2);\n  return map4(X23, (x22, i) => Math.abs(x22 - X13[i]), Float64Array);\n}\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== void 0)\n    channel = channels[alias];\n  if (channel)\n    return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return ascending(av, bv) || ascending(ak, bk);\n}\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return descending(av, bv) || ascending(ak, bk);\n}\n\n// node_modules/@observablehq/plot/dist/scales/schemes.js\nvar ordinalSchemes = /* @__PURE__ */ new Map([\n  // categorical\n  [\"accent\", Accent_default],\n  [\"category10\", category10_default],\n  [\"dark2\", Dark2_default],\n  [\"paired\", Paired_default],\n  [\"pastel1\", Pastel1_default],\n  [\"pastel2\", Pastel2_default],\n  [\"set1\", Set1_default],\n  [\"set2\", Set2_default],\n  [\"set3\", Set3_default],\n  [\"tableau10\", Tableau10_default],\n  // diverging\n  [\"brbg\", scheme112(scheme, BrBG_default)],\n  [\"prgn\", scheme112(scheme2, PRGn_default)],\n  [\"piyg\", scheme112(scheme3, PiYG_default)],\n  [\"puor\", scheme112(scheme4, PuOr_default)],\n  [\"rdbu\", scheme112(scheme5, RdBu_default)],\n  [\"rdgy\", scheme112(scheme6, RdGy_default)],\n  [\"rdylbu\", scheme112(scheme7, RdYlBu_default)],\n  [\"rdylgn\", scheme112(scheme8, RdYlGn_default)],\n  [\"spectral\", scheme112(scheme9, Spectral_default)],\n  // reversed diverging (for temperature data)\n  [\"burd\", scheme11r(scheme5, RdBu_default)],\n  [\"buylrd\", scheme11r(scheme7, RdYlBu_default)],\n  // sequential (single-hue)\n  [\"blues\", scheme92(scheme22, Blues_default)],\n  [\"greens\", scheme92(scheme23, Greens_default)],\n  [\"greys\", scheme92(scheme24, Greys_default)],\n  [\"oranges\", scheme92(scheme27, Oranges_default)],\n  [\"purples\", scheme92(scheme25, Purples_default)],\n  [\"reds\", scheme92(scheme26, Reds_default)],\n  // sequential (multi-hue)\n  [\"turbo\", schemei(turbo_default)],\n  [\"viridis\", schemei(viridis_default)],\n  [\"magma\", schemei(magma)],\n  [\"inferno\", schemei(inferno)],\n  [\"plasma\", schemei(plasma)],\n  [\"cividis\", schemei(cividis_default)],\n  [\"cubehelix\", schemei(cubehelix_default2)],\n  [\"warm\", schemei(warm)],\n  [\"cool\", schemei(cool)],\n  [\"bugn\", scheme92(scheme10, BuGn_default)],\n  [\"bupu\", scheme92(scheme11, BuPu_default)],\n  [\"gnbu\", scheme92(scheme12, GnBu_default)],\n  [\"orrd\", scheme92(scheme13, OrRd_default)],\n  [\"pubu\", scheme92(scheme15, PuBu_default)],\n  [\"pubugn\", scheme92(scheme14, PuBuGn_default)],\n  [\"purd\", scheme92(scheme16, PuRd_default)],\n  [\"rdpu\", scheme92(scheme17, RdPu_default)],\n  [\"ylgn\", scheme92(scheme19, YlGn_default)],\n  [\"ylgnbu\", scheme92(scheme18, YlGnBu_default)],\n  [\"ylorbr\", scheme92(scheme20, YlOrBr_default)],\n  [\"ylorrd\", scheme92(scheme21, YlOrRd_default)],\n  // cyclical\n  [\"rainbow\", schemeicyclical(rainbow_default)],\n  [\"sinebow\", schemeicyclical(sinebow_default)]\n]);\nfunction scheme92(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 1)\n      return [scheme28[3][1]];\n    if (n === 2)\n      return [scheme28[3][1], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme112(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][0], scheme28[3][2]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];\n  };\n}\nfunction scheme11r(scheme28, interpolate) {\n  return ({ length: n }) => {\n    if (n === 2)\n      return [scheme28[3][2], scheme28[3][0]];\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();\n  };\n}\nfunction schemei(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));\n}\nfunction schemeicyclical(interpolate) {\n  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\nfunction ordinalScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!ordinalSchemes.has(s2))\n    throw new Error(`unknown ordinal scheme: ${s2}`);\n  return ordinalSchemes.get(s2);\n}\nfunction ordinalRange(scheme28, length4) {\n  const s2 = ordinalScheme(scheme28);\n  const r = typeof s2 === \"function\" ? s2({ length: length4 }) : s2;\n  return r.length !== length4 ? r.slice(0, length4) : r;\n}\nfunction maybeBooleanRange(domain, scheme28 = \"greys\") {\n  const range5 = /* @__PURE__ */ new Set();\n  const [f, t] = ordinalRange(scheme28, 2);\n  for (const value of domain) {\n    if (value == null)\n      continue;\n    if (value === true)\n      range5.add(t);\n    else if (value === false)\n      range5.add(f);\n    else\n      return;\n  }\n  return [...range5];\n}\nvar quantitativeSchemes = /* @__PURE__ */ new Map([\n  // diverging\n  [\"brbg\", BrBG_default],\n  [\"prgn\", PRGn_default],\n  [\"piyg\", PiYG_default],\n  [\"puor\", PuOr_default],\n  [\"rdbu\", RdBu_default],\n  [\"rdgy\", RdGy_default],\n  [\"rdylbu\", RdYlBu_default],\n  [\"rdylgn\", RdYlGn_default],\n  [\"spectral\", Spectral_default],\n  // reversed diverging (for temperature data)\n  [\"burd\", (t) => RdBu_default(1 - t)],\n  [\"buylrd\", (t) => RdYlBu_default(1 - t)],\n  // sequential (single-hue)\n  [\"blues\", Blues_default],\n  [\"greens\", Greens_default],\n  [\"greys\", Greys_default],\n  [\"purples\", Purples_default],\n  [\"reds\", Reds_default],\n  [\"oranges\", Oranges_default],\n  // sequential (multi-hue)\n  [\"turbo\", turbo_default],\n  [\"viridis\", viridis_default],\n  [\"magma\", magma],\n  [\"inferno\", inferno],\n  [\"plasma\", plasma],\n  [\"cividis\", cividis_default],\n  [\"cubehelix\", cubehelix_default2],\n  [\"warm\", warm],\n  [\"cool\", cool],\n  [\"bugn\", BuGn_default],\n  [\"bupu\", BuPu_default],\n  [\"gnbu\", GnBu_default],\n  [\"orrd\", OrRd_default],\n  [\"pubugn\", PuBuGn_default],\n  [\"pubu\", PuBu_default],\n  [\"purd\", PuRd_default],\n  [\"rdpu\", RdPu_default],\n  [\"ylgnbu\", YlGnBu_default],\n  [\"ylgn\", YlGn_default],\n  [\"ylorbr\", YlOrBr_default],\n  [\"ylorrd\", YlOrRd_default],\n  // cyclical\n  [\"rainbow\", rainbow_default],\n  [\"sinebow\", sinebow_default]\n]);\nfunction quantitativeScheme(scheme28) {\n  const s2 = `${scheme28}`.toLowerCase();\n  if (!quantitativeSchemes.has(s2))\n    throw new Error(`unknown quantitative scheme: ${s2}`);\n  return quantitativeSchemes.get(s2);\n}\nvar divergingSchemes = /* @__PURE__ */ new Set([\n  \"brbg\",\n  \"prgn\",\n  \"piyg\",\n  \"puor\",\n  \"rdbu\",\n  \"rdgy\",\n  \"rdylbu\",\n  \"rdylgn\",\n  \"spectral\",\n  \"burd\",\n  \"buylrd\"\n]);\nfunction isDivergingScheme(scheme28) {\n  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());\n}\n\n// node_modules/@observablehq/plot/dist/scales/quantitative.js\nvar flip = (i) => (t) => i(1 - t);\nvar unit2 = [0, 1];\nvar interpolators = /* @__PURE__ */ new Map([\n  // numbers\n  [\"number\", number_default],\n  // color spaces\n  [\"rgb\", rgb_default],\n  [\"hsl\", hsl_default],\n  [\"hcl\", hcl_default],\n  [\"lab\", lab2]\n]);\nfunction Interpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i))\n    throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\nfunction ScaleQ(key, scale3, channels, { type: type2, nice: nice3, clamp, zero: zero3, domain = inferAutoDomain(key, channels), unknown, round: round2, scheme: scheme28, interval: interval2, range: range5 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === \"cyclical\" ? \"rainbow\" : \"turbo\") : round2 ? round_default : number_default, reverse: reverse3 }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (type2 === \"cyclical\" || type2 === \"sequential\")\n    type2 = \"linear\";\n  reverse3 = !!reverse3;\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (interpolate.length === 1) {\n    if (reverse3) {\n      interpolate = flip(interpolate);\n      reverse3 = false;\n    }\n    if (range5 === void 0) {\n      range5 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range5.length === 2)\n        range5 = unit2;\n    }\n    scale3.interpolate((range5 === unit2 ? constant2 : interpolatePiecewise)(interpolate));\n  } else {\n    scale3.interpolate(interpolate);\n  }\n  if (zero3) {\n    const [min4, max5] = extent(domain);\n    if (min4 > 0 || max5 < 0) {\n      domain = slice5(domain);\n      if (orderof(domain) !== Math.sign(min4))\n        domain[domain.length - 1] = 0;\n      else\n        domain[0] = 0;\n    }\n  }\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain).unknown(unknown);\n  if (nice3)\n    scale3.nice(nice3 === true ? void 0 : nice3), domain = scale3.domain();\n  if (range5 !== void 0)\n    scale3.range(range5);\n  if (clamp)\n    scale3.clamp(clamp);\n  return { type: type2, domain, range: range5, scale: scale3, interpolate, interval: interval2 };\n}\nfunction ScaleLinear(key, channels, options) {\n  return ScaleQ(key, linear3(), channels, options);\n}\nfunction ScaleSqrt(key, channels, options) {\n  return ScalePow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScalePow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleQ(key, pow3().exponent(exponent2), channels, { ...options, type: \"pow\" });\n}\nfunction ScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {\n  return ScaleQ(key, log2().base(base), channels, { ...options, domain });\n}\nfunction ScaleSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleQ(key, symlog().constant(constant3), channels, options);\n}\nfunction ScaleQuantile(key, channels, {\n  range: range5,\n  quantiles = range5 === void 0 ? 5 : (range5 = [...range5]).length,\n  // deprecated; use n instead\n  n = quantiles,\n  scheme: scheme28 = \"rdylbu\",\n  domain = inferQuantileDomain(channels),\n  interpolate,\n  reverse: reverse3\n}) {\n  if (range5 === void 0) {\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  }\n  if (domain.length > 0) {\n    domain = quantile2(domain, range5 === void 0 ? { length: n } : range5).quantiles();\n  }\n  return ScaleThreshold(key, channels, { domain, range: range5, reverse: reverse3 });\n}\nfunction ScaleQuantize(key, channels, { range: range5, n = range5 === void 0 ? 5 : (range5 = [...range5]).length, scheme: scheme28 = \"rdylbu\", domain = inferAutoDomain(key, channels), unknown, interpolate, reverse: reverse3 }) {\n  const [min4, max5] = extent(domain);\n  let thresholds;\n  if (range5 === void 0) {\n    thresholds = ticks(min4, max5, n);\n    if (thresholds[0] <= min4)\n      thresholds.splice(0, 1);\n    if (thresholds[thresholds.length - 1] >= max5)\n      thresholds.pop();\n    n = thresholds.length + 1;\n    range5 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;\n  } else {\n    thresholds = quantize_default(number_default(min4, max5), n + 1).slice(1, -1);\n    if (min4 instanceof Date)\n      thresholds = thresholds.map((x4) => new Date(x4));\n  }\n  if (orderof(arrayify2(domain)) < 0)\n    thresholds.reverse();\n  return ScaleThreshold(key, channels, { domain: thresholds, range: range5, reverse: reverse3, unknown });\n}\nfunction ScaleThreshold(key, channels, {\n  domain = [0],\n  // explicit thresholds in ascending order\n  unknown,\n  scheme: scheme28 = \"rdylbu\",\n  interpolate,\n  range: range5 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,\n  reverse: reverse3\n}) {\n  domain = arrayify2(domain);\n  const sign3 = orderof(domain);\n  if (!isOrdered(domain, sign3))\n    throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse3)\n    range5 = reverse(range5);\n  return {\n    type: \"threshold\",\n    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range5 === void 0 ? [] : range5).unknown(unknown),\n    domain,\n    range: range5\n  };\n}\nfunction isOrdered(domain, sign3) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s2 = descending(d, d = domain[i]);\n    if (s2 !== 0 && s2 !== sign3)\n      return false;\n  }\n  return true;\n}\nfunction ScaleIdentity() {\n  return { type: \"identity\", scale: identity4() };\n}\nfunction inferDomain(channels, f = finite2) {\n  return channels.length ? [\n    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),\n    max(channels, ({ value }) => value === void 0 ? value : max(value, f))\n  ] : [0, 1];\n}\nfunction inferAutoDomain(key, channels) {\n  const type2 = registry.get(key);\n  return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);\n}\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite2)) : 1];\n}\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);\n  if (hint !== void 0)\n    return [0, hint.radius];\n  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));\n  const range5 = domain.map((d) => 3 * Math.sqrt(d / h25));\n  const k2 = 30 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLengthRange(channels, domain) {\n  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));\n  const range5 = domain.map((d) => 12 * d / h50);\n  const k2 = 60 / max(range5);\n  return k2 < 1 ? range5.map((r) => r * k2) : range5;\n}\nfunction inferLogDomain(channels) {\n  for (const { value } of channels) {\n    if (value !== void 0) {\n      for (let v2 of value) {\n        if (v2 > 0)\n          return inferDomain(channels, positive);\n        if (v2 < 0)\n          return inferDomain(channels, negative);\n      }\n    }\n  }\n  return [1, 10];\n}\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const { value } of channels) {\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      domain.push(v2);\n  }\n  return domain;\n}\nfunction interpolatePiecewise(interpolate) {\n  return (i, j) => (t) => interpolate(i + t * (j - i));\n}\n\n// node_modules/@observablehq/plot/dist/scales/diverging.js\nfunction ScaleD(key, scale3, transform2, channels, { type: type2, nice: nice3, clamp, domain = inferDomain(channels), unknown, pivot = 0, scheme: scheme28, range: range5, symmetric = true, interpolate = registry.get(key) === color2 ? scheme28 == null && range5 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : \"rdbu\") : number_default, reverse: reverse3 }) {\n  pivot = +pivot;\n  let [min4, max5] = domain;\n  if (descending(min4, max5) < 0)\n    [min4, max5] = [max5, min4], reverse3 = !reverse3;\n  min4 = Math.min(min4, pivot);\n  max5 = Math.max(max5, pivot);\n  if (typeof interpolate !== \"function\") {\n    interpolate = Interpolator(interpolate);\n  }\n  if (range5 !== void 0) {\n    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range5) : piecewise(interpolate, range5);\n  }\n  if (reverse3)\n    interpolate = flip(interpolate);\n  if (symmetric) {\n    const mid3 = transform2.apply(pivot);\n    const mindelta = mid3 - transform2.apply(min4);\n    const maxdelta = transform2.apply(max5) - mid3;\n    if (mindelta < maxdelta)\n      min4 = transform2.invert(mid3 - maxdelta);\n    else if (mindelta > maxdelta)\n      max5 = transform2.invert(mid3 + mindelta);\n  }\n  scale3.domain([min4, pivot, max5]).unknown(unknown).interpolator(interpolate);\n  if (clamp)\n    scale3.clamp(clamp);\n  if (nice3)\n    scale3.nice(nice3);\n  return { type: type2, domain: [min4, max5], pivot, interpolate, scale: scale3 };\n}\nfunction ScaleDiverging(key, channels, options) {\n  return ScaleD(key, diverging(), transformIdentity, channels, options);\n}\nfunction ScaleDivergingSqrt(key, channels, options) {\n  return ScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });\n}\nfunction ScaleDivergingPow(key, channels, { exponent: exponent2 = 1, ...options }) {\n  return ScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow2(exponent2), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\nfunction ScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {\n  return ScaleD(key, divergingLog().base(base = +base), transformLog2, channels, { domain, pivot, ...options });\n}\nfunction ScaleDivergingSymlog(key, channels, { constant: constant3 = 1, ...options }) {\n  return ScaleD(key, divergingSymlog().constant(constant3 = +constant3), transformSymlog2(constant3), channels, options);\n}\nvar transformIdentity = {\n  apply(x4) {\n    return x4;\n  },\n  invert(x4) {\n    return x4;\n  }\n};\nvar transformLog2 = {\n  apply: Math.log,\n  invert: Math.exp\n};\nvar transformSqrt2 = {\n  apply(x4) {\n    return Math.sign(x4) * Math.sqrt(Math.abs(x4));\n  },\n  invert(x4) {\n    return Math.sign(x4) * (x4 * x4);\n  }\n};\nfunction transformPow2(exponent2) {\n  return exponent2 === 0.5 ? transformSqrt2 : {\n    apply(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), exponent2);\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.pow(Math.abs(x4), 1 / exponent2);\n    }\n  };\n}\nfunction transformSymlog2(constant3) {\n  return {\n    apply(x4) {\n      return Math.sign(x4) * Math.log1p(Math.abs(x4 / constant3));\n    },\n    invert(x4) {\n      return Math.sign(x4) * Math.expm1(Math.abs(x4)) * constant3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/scales/temporal.js\nfunction ScaleT(key, scale3, channels, options) {\n  return ScaleQ(key, scale3, channels, options);\n}\nfunction ScaleTime(key, channels, options) {\n  return ScaleT(key, time(), channels, options);\n}\nfunction ScaleUtc(key, channels, options) {\n  return ScaleT(key, utcTime(), channels, options);\n}\n\n// node_modules/@observablehq/plot/dist/scales/ordinal.js\nvar ordinalImplicit = Symbol(\"ordinal\");\nfunction ScaleO(key, scale3, channels, { type: type2, interval: interval2, domain, range: range5, reverse: reverse3, hint }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  if (type2 === \"categorical\" || type2 === ordinalImplicit)\n    type2 = \"ordinal\";\n  if (reverse3)\n    domain = reverse(domain);\n  scale3.domain(domain);\n  if (range5 !== void 0) {\n    if (typeof range5 === \"function\")\n      range5 = range5(domain);\n    scale3.range(range5);\n  }\n  return { type: type2, domain, range: range5, scale: scale3, hint, interval: interval2 };\n}\nfunction ScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range5, scheme: scheme28, unknown, ...options }) {\n  interval2 = maybeInterval(interval2, type2);\n  if (domain === void 0)\n    domain = inferDomain2(channels, interval2, key);\n  let hint;\n  if (registry.get(key) === symbol) {\n    hint = inferSymbolHint(channels);\n    range5 = range5 === void 0 ? inferSymbolRange(hint) : map4(range5, maybeSymbol);\n  } else if (registry.get(key) === color2) {\n    if (range5 === void 0 && (type2 === \"ordinal\" || type2 === ordinalImplicit)) {\n      range5 = maybeBooleanRange(domain, scheme28);\n      if (range5 !== void 0)\n        scheme28 = void 0;\n    }\n    if (scheme28 === void 0 && range5 === void 0) {\n      scheme28 = type2 === \"ordinal\" ? \"turbo\" : \"tableau10\";\n    }\n    if (scheme28 !== void 0) {\n      if (range5 !== void 0) {\n        const interpolate = quantitativeScheme(scheme28);\n        const t03 = range5[0], d = range5[1] - range5[0];\n        range5 = ({ length: n }) => quantize_default((t) => interpolate(t03 + d * t), n);\n      } else {\n        range5 = ordinalScheme(scheme28);\n      }\n    }\n  }\n  if (unknown === implicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return ScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range5, hint });\n}\nfunction ScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {\n  return maybeRound(point().align(align).padding(padding), channels, options, key);\n}\nfunction ScaleBand(key, channels, { align = 0.5, padding = 0.1, paddingInner = padding, paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding, ...options }) {\n  return maybeRound(band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter), channels, options, key);\n}\nfunction maybeRound(scale3, channels, options, key) {\n  let { round: round2 } = options;\n  if (round2 !== void 0)\n    scale3.round(round2 = !!round2);\n  scale3 = ScaleO(key, scale3, channels, options);\n  scale3.round = round2;\n  return scale3;\n}\nfunction inferDomain2(channels, interval2, key) {\n  const values2 = new InternSet();\n  for (const { value, domain } of channels) {\n    if (domain !== void 0)\n      return domain();\n    if (value === void 0)\n      continue;\n    for (const v2 of value)\n      values2.add(v2);\n  }\n  if (interval2 !== void 0) {\n    const [min4, max5] = extent(values2).map(interval2.floor, interval2);\n    return interval2.range(min4, interval2.offset(max5));\n  }\n  if (values2.size > 1e4 && registry.get(key) === position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return sort(values2, ascendingDefined2);\n}\nfunction inferHint(channels, key) {\n  let value;\n  for (const { hint } of channels) {\n    const candidate = hint?.[key];\n    if (candidate === void 0)\n      continue;\n    if (value === void 0)\n      value = candidate;\n    else if (value !== candidate)\n      return;\n  }\n  return value;\n}\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\nfunction inferSymbolRange(hint) {\n  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;\n}\n\n// node_modules/@observablehq/plot/dist/warnings.js\nvar warnings = 0;\nfunction consumeWarnings() {\n  const w = warnings;\n  warnings = 0;\n  return w;\n}\nfunction warn(message) {\n  console.warn(message);\n  ++warnings;\n}\n\n// node_modules/@observablehq/plot/dist/scales.js\nfunction Scales(channelsByScale, { label: globalLabel, inset: globalInset = 0, insetTop: globalInsetTop = globalInset, insetRight: globalInsetRight = globalInset, insetBottom: globalInsetBottom = globalInset, insetLeft: globalInsetLeft = globalInset, round: round2, nice: nice3, clamp, zero: zero3, align, padding, projection: projection2, facet: { label: facetLabel = globalLabel } = {}, ...options } = {}) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale3 = Scale(key, channels, {\n      round: registry.get(key) === position ? round2 : void 0,\n      nice: nice3,\n      clamp,\n      zero: zero3,\n      align,\n      padding,\n      projection: projection2,\n      ...scaleOptions\n    });\n    if (scale3) {\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform: transform2,\n        inset,\n        insetTop = inset !== void 0 ? inset : key === \"y\" ? globalInsetTop : 0,\n        // not fy\n        insetRight = inset !== void 0 ? inset : key === \"x\" ? globalInsetRight : 0,\n        // not fx\n        insetBottom = inset !== void 0 ? inset : key === \"y\" ? globalInsetBottom : 0,\n        // not fy\n        insetLeft = inset !== void 0 ? inset : key === \"x\" ? globalInsetLeft : 0\n        // not fx\n      } = scaleOptions || {};\n      if (transform2 == null)\n        transform2 = void 0;\n      else if (typeof transform2 !== \"function\")\n        throw new Error(\"invalid scale transform; not a function\");\n      scale3.percent = !!percent;\n      scale3.label = label === void 0 ? inferScaleLabel(channels, scale3) : label;\n      scale3.transform = transform2;\n      if (key === \"x\" || key === \"fx\") {\n        scale3.insetLeft = +insetLeft;\n        scale3.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale3.insetTop = +insetTop;\n        scale3.insetBottom = +insetBottom;\n      }\n      scales[key] = scale3;\n    }\n  }\n  return scales;\n}\nfunction ScaleFunctions(scales) {\n  return Object.fromEntries(Object.entries(scales).filter(([, { scale: scale3 }]) => scale3).map(([name, { scale: scale3, type: type2, interval: interval2, label }]) => {\n    scale3.type = type2;\n    if (interval2 != null)\n      scale3.interval = interval2;\n    if (label != null)\n      scale3.label = label;\n    return [name, scale3];\n  }));\n}\nfunction autoScaleRange(scales, dimensions) {\n  const { x: x4, y: y4, fx, fy } = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx)\n    autoScaleRangeX(fx, superdimensions);\n  if (fy)\n    autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x4)\n    autoScaleRangeX(x4, subdimensions);\n  if (y4)\n    autoScaleRangeY(y4, subdimensions);\n}\nfunction inferScaleLabel(channels = [], scale3) {\n  let label;\n  for (const { label: l } of channels) {\n    if (l === void 0)\n      continue;\n    if (label === void 0)\n      label = l;\n    else if (label !== l)\n      return;\n  }\n  if (label === void 0)\n    return;\n  if (isTemporalScale(scale3) && /^(date|time|year)$/i.test(label))\n    return;\n  if (!isOrdinalScale(scale3) && scale3.percent)\n    label = `${label} (%)`;\n  return { inferred: true, toString: () => label };\n}\nfunction outerDimensions(dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height, facet: { marginTop: facetMarginTop, marginRight: facetMarginRight, marginBottom: facetMarginBottom, marginLeft: facetMarginLeft } } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\nfunction innerDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height\n  };\n}\nfunction autoScaleRangeX(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetLeft, insetRight } = scale3;\n    const { width, marginLeft = 0, marginRight = 0 } = dimensions;\n    const left2 = marginLeft + insetLeft;\n    const right2 = width - marginRight - insetRight;\n    scale3.range = [left2, Math.max(left2, right2)];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRangeY(scale3, dimensions) {\n  if (scale3.range === void 0) {\n    const { insetTop, insetBottom } = scale3;\n    const { height, marginTop = 0, marginBottom = 0 } = dimensions;\n    const top2 = marginTop + insetTop;\n    const bottom2 = height - marginBottom - insetBottom;\n    scale3.range = [Math.max(top2, bottom2), top2];\n    if (!isOrdinalScale(scale3))\n      scale3.range = piecewiseRange(scale3);\n    else\n      scale3.range.reverse();\n    scale3.scale.range(scale3.range);\n  }\n  autoScaleRound(scale3);\n}\nfunction autoScaleRound(scale3) {\n  if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {\n    scale3.scale.round(true);\n  }\n}\nfunction roundError({ scale: scale3 }) {\n  const n = scale3.domain().length;\n  const [start2, stop] = scale3.range();\n  const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;\n  const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();\n  const m3 = n - paddingInner;\n  const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);\n  return (step - Math.floor(step)) * m3;\n}\nfunction piecewiseRange(scale3) {\n  const length4 = scale3.scale.domain().length + isThresholdScale(scale3);\n  if (!(length4 > 2))\n    return scale3.range;\n  const [start2, end] = scale3.range;\n  return Array.from({ length: length4 }, (_, i) => start2 + i / (length4 - 1) * (end - start2));\n}\nfunction normalizeScale(key, scale3, hint) {\n  return Scale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale3 });\n}\nfunction Scale(key, channels = [], options = {}) {\n  const type2 = inferScaleType(key, channels, options);\n  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== \"fx\" && key !== \"fy\" && isOrdinalScale({ type: type2 })) {\n    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n    if (values2.some(isTemporal))\n      warn(`Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isTemporalString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type2)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n    else if (values2.some(isNumericString))\n      warn(`Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(type2)}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type2)}\".`);\n  }\n  options.type = type2;\n  switch (type2) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, coerceNumbers);\n      break;\n    case \"identity\":\n      switch (registry.get(key)) {\n        case position:\n          options = coerceType(channels, options, coerceNumbers);\n          break;\n        case symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, coerceDates);\n      break;\n  }\n  switch (type2) {\n    case \"diverging\":\n      return ScaleDiverging(key, channels, options);\n    case \"diverging-sqrt\":\n      return ScaleDivergingSqrt(key, channels, options);\n    case \"diverging-pow\":\n      return ScaleDivergingPow(key, channels, options);\n    case \"diverging-log\":\n      return ScaleDivergingLog(key, channels, options);\n    case \"diverging-symlog\":\n      return ScaleDivergingSymlog(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case ordinalImplicit:\n      return ScaleOrdinal(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return ScaleLinear(key, channels, options);\n    case \"sqrt\":\n      return ScaleSqrt(key, channels, options);\n    case \"threshold\":\n      return ScaleThreshold(key, channels, options);\n    case \"quantile\":\n      return ScaleQuantile(key, channels, options);\n    case \"quantize\":\n      return ScaleQuantize(key, channels, options);\n    case \"pow\":\n      return ScalePow(key, channels, options);\n    case \"log\":\n      return ScaleLog(key, channels, options);\n    case \"symlog\":\n      return ScaleSymlog(key, channels, options);\n    case \"utc\":\n      return ScaleUtc(key, channels, options);\n    case \"time\":\n      return ScaleTime(key, channels, options);\n    case \"point\":\n      return ScalePoint(key, channels, options);\n    case \"band\":\n      return ScaleBand(key, channels, options);\n    case \"identity\":\n      return registry.get(key) === position ? ScaleIdentity() : { type: \"identity\" };\n    case void 0:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type2}`);\n  }\n}\nfunction formatScaleType(type2) {\n  return typeof type2 === \"symbol\" ? type2.description : type2;\n}\nvar typeProjection = { toString: () => \"projection\" };\nfunction inferScaleType(key, channels, { type: type2, domain, range: range5, scheme: scheme28, pivot, projection: projection2 }) {\n  if (key === \"fx\" || key === \"fy\")\n    return \"band\";\n  if ((key === \"x\" || key === \"y\") && projection2 != null)\n    type2 = typeProjection;\n  for (const { type: t } of channels) {\n    if (t === void 0)\n      continue;\n    else if (type2 === void 0)\n      type2 = t;\n    else if (type2 !== t)\n      throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);\n  }\n  if (type2 === typeProjection)\n    return;\n  if (type2 !== void 0)\n    return type2;\n  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))\n    return;\n  const kind = registry.get(key);\n  if (kind === radius)\n    return \"sqrt\";\n  if (kind === opacity || kind === length3)\n    return \"linear\";\n  if (kind === symbol)\n    return \"ordinal\";\n  if ((domain || range5 || []).length > 2)\n    return asOrdinalType(kind);\n  if (domain !== void 0) {\n    if (isOrdinal(domain))\n      return asOrdinalType(kind);\n    if (isTemporal(domain))\n      return \"utc\";\n    if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n      return \"diverging\";\n    return \"linear\";\n  }\n  const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);\n  if (values2.some(isOrdinal))\n    return asOrdinalType(kind);\n  if (values2.some(isTemporal))\n    return \"utc\";\n  if (kind === color2 && (pivot != null || isDivergingScheme(scheme28)))\n    return \"diverging\";\n  return \"linear\";\n}\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case position:\n      return \"point\";\n    case color2:\n      return ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\nfunction isTemporalScale({ type: type2 }) {\n  return type2 === \"time\" || type2 === \"utc\";\n}\nfunction isOrdinalScale({ type: type2 }) {\n  return type2 === \"ordinal\" || type2 === \"point\" || type2 === \"band\" || type2 === ordinalImplicit;\n}\nfunction isThresholdScale({ type: type2 }) {\n  return type2 === \"threshold\";\n}\nfunction isBandScale({ type: type2 }) {\n  return type2 === \"point\" || type2 === \"band\";\n}\nfunction isCollapsed(scale3) {\n  if (scale3 === void 0)\n    return true;\n  const domain = scale3.domain();\n  const value = scale3(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale3(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction coerceType(channels, { domain, ...options }, coerceValues) {\n  for (const c6 of channels) {\n    if (c6.value !== void 0) {\n      c6.value = coerceValues(c6.value);\n    }\n  }\n  return {\n    domain: domain === void 0 ? domain : coerceValues(domain),\n    ...options\n  };\n}\nfunction coerceSymbols(values2) {\n  return map4(values2, maybeSymbol);\n}\nfunction coerceDates(values2) {\n  return map4(values2, coerceDate);\n}\nfunction coerceNumbers(values2) {\n  return isTypedArray(values2) ? values2 : map4(values2, coerceNumber, Float64Array);\n}\nfunction coerceNumber(x4) {\n  return x4 == null ? NaN : Number(x4);\n}\nfunction coerceDate(x4) {\n  return x4 instanceof Date && !isNaN(x4) ? x4 : typeof x4 === \"string\" ? parse(x4) : x4 == null || isNaN(x4 = +x4) ? void 0 : new Date(x4);\n}\nfunction scale2(options = {}) {\n  let scale3;\n  for (const key in options) {\n    if (!registry.has(key))\n      continue;\n    if (!isScaleOptions(options[key]))\n      continue;\n    if (scale3 !== void 0)\n      throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale3 = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale3 === void 0)\n    throw new Error(\"invalid scale definition; no scale found\");\n  return scale3;\n}\nfunction exposeScales(scaleDescriptors) {\n  return (key) => {\n    if (!registry.has(key = `${key}`))\n      throw new Error(`unknown scale: ${key}`);\n    return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;\n  };\n}\nfunction exposeScale({ scale: scale3, type: type2, domain, range: range5, interpolate, interval: interval2, transform: transform2, percent, pivot }) {\n  if (type2 === \"identity\")\n    return { type: \"identity\", apply: (d) => d, invert: (d) => d };\n  const unknown = scale3.unknown ? scale3.unknown() : void 0;\n  return {\n    type: type2,\n    domain: slice5(domain),\n    ...range5 !== void 0 && { range: slice5(range5) },\n    ...transform2 !== void 0 && { transform: transform2 },\n    ...percent && { percent },\n    ...unknown !== void 0 && { unknown },\n    ...interval2 !== void 0 && { interval: interval2 },\n    // quantitative\n    ...interpolate !== void 0 && { interpolate },\n    ...scale3.clamp && { clamp: scale3.clamp() },\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...pivot !== void 0 && { pivot, symmetric: false },\n    // log, diverging-log\n    ...scale3.base && { base: scale3.base() },\n    // pow, diverging-pow\n    ...scale3.exponent && { exponent: scale3.exponent() },\n    // symlog, diverging-symlog\n    ...scale3.constant && { constant: scale3.constant() },\n    // band, point\n    ...scale3.align && { align: scale3.align(), round: scale3.round() },\n    ...scale3.padding && (scale3.paddingInner ? { paddingInner: scale3.paddingInner(), paddingOuter: scale3.paddingOuter() } : { padding: scale3.padding() }),\n    ...scale3.bandwidth && { bandwidth: scale3.bandwidth(), step: scale3.step() },\n    // utilities\n    apply: (t) => scale3(t),\n    ...scale3.invert && { invert: (t) => scale3.invert(t) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/projection.js\nvar pi6 = Math.PI;\nvar tau7 = 2 * pi6;\nvar defaultAspectRatio = 0.618;\nfunction Projection({ projection: projection2, inset: globalInset = 0, insetTop = globalInset, insetRight = globalInset, insetBottom = globalInset, insetLeft = globalInset } = {}, dimensions) {\n  if (projection2 == null)\n    return;\n  if (typeof projection2.stream === \"function\")\n    return projection2;\n  let options;\n  let domain;\n  let clip = \"frame\";\n  if (isObject(projection2)) {\n    let inset;\n    ({\n      type: projection2,\n      domain,\n      inset,\n      insetTop = inset !== void 0 ? inset : insetTop,\n      insetRight = inset !== void 0 ? inset : insetRight,\n      insetBottom = inset !== void 0 ? inset : insetBottom,\n      insetLeft = inset !== void 0 ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection2);\n    if (projection2 == null)\n      return;\n  }\n  if (typeof projection2 !== \"function\")\n    ({ type: projection2 } = namedProjection(projection2));\n  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection2 = projection2?.({ width: dx, height: dy, clip, ...options });\n  if (projection2 == null)\n    return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform2;\n  if (domain != null) {\n    const [[x06, y06], [x12, y12]] = path_default(projection2).bounds(domain);\n    const k2 = Math.min(dx / (x12 - x06), dy / (y12 - y06));\n    if (k2 > 0) {\n      tx -= (k2 * (x06 + x12) - dx) / 2;\n      ty -= (k2 * (y06 + y12) - dy) / 2;\n      transform2 = transform_default({\n        point(x4, y4) {\n          this.stream.point(x4 * k2 + tx, y4 * k2 + ty);\n        }\n      });\n    } else {\n      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n  transform2 ??= tx === 0 && ty === 0 ? identity7() : transform_default({\n    point(x4, y4) {\n      this.stream.point(x4 + tx, y4 + ty);\n    }\n  });\n  return { stream: (s2) => projection2.stream(transform2.stream(clip(s2))) };\n}\nfunction namedProjection(projection2) {\n  switch (`${projection2}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(albersUsa_default, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection2(albers_default, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(azimuthalEqualArea_default, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(azimuthalEquidistant_default, tau7, tau7);\n    case \"conic-conformal\":\n      return conicProjection2(conicConformal_default, tau7, tau7);\n    case \"conic-equal-area\":\n      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(equalEarth_default, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(equirectangular_default, tau7, pi6);\n    case \"gnomonic\":\n      return scaleProjection(gnomonic_default, 3.4641, 3.4641);\n    case \"identity\":\n      return { type: identity7 };\n    case \"reflect-y\":\n      return { type: reflectY };\n    case \"mercator\":\n      return scaleProjection(mercator_default, tau7, tau7);\n    case \"orthographic\":\n      return scaleProjection(orthographic_default, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(stereographic_default, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(transverseMercator_default, tau7, tau7);\n    default:\n      throw new Error(`unknown projection type: ${projection2}`);\n  }\n}\nfunction maybePostClip(clip, x12, y12, x22, y22) {\n  if (clip === false || clip == null || typeof clip === \"number\")\n    return (s2) => s2;\n  if (clip === true)\n    clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return clipRectangle(x12, y12, x22, y22);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\nfunction scaleProjection(createProjection, kx2, ky2) {\n  return {\n    type: ({ width, height, rotate, precision = 0.15, clip }) => {\n      const projection2 = createProjection();\n      if (precision != null)\n        projection2.precision?.(precision);\n      if (rotate != null)\n        projection2.rotate?.(rotate);\n      if (typeof clip === \"number\")\n        projection2.clipAngle?.(clip);\n      projection2.scale(Math.min(width / kx2, height / ky2));\n      projection2.translate([width / 2, height / 2]);\n      return projection2;\n    },\n    aspectRatio: ky2 / kx2\n  };\n}\nfunction conicProjection2(createProjection, kx2, ky2) {\n  const { type: type2, aspectRatio } = scaleProjection(createProjection, kx2, ky2);\n  return {\n    type: (options) => {\n      const { parallels, domain, width, height } = options;\n      const projection2 = type2(options);\n      if (parallels != null) {\n        projection2.parallels(parallels);\n        if (domain === void 0) {\n          projection2.fitSize([width, height], { type: \"Sphere\" });\n        }\n      }\n      return projection2;\n    },\n    aspectRatio\n  };\n}\nvar identity7 = constant2({ stream: (stream) => stream });\nvar reflectY = constant2(transform_default({\n  point(x4, y4) {\n    this.stream.point(x4, -y4);\n  }\n}));\nfunction maybeProject(cx, cy, channels, values2, context) {\n  const x4 = channels[cx] && channels[cx].scale === \"x\";\n  const y4 = channels[cy] && channels[cy].scale === \"y\";\n  if (x4 && y4) {\n    project(cx, cy, values2, context.projection);\n  } else if (x4) {\n    throw new Error(`projection requires paired x and y channels; ${cx} is missing ${cy}`);\n  } else if (y4) {\n    throw new Error(`projection requires paired x and y channels; ${cy} is missing ${cx}`);\n  }\n}\nfunction project(cx, cy, values2, projection2) {\n  const x4 = values2[cx];\n  const y4 = values2[cy];\n  const n = x4.length;\n  const X3 = values2[cx] = new Float64Array(n).fill(NaN);\n  const Y3 = values2[cy] = new Float64Array(n).fill(NaN);\n  let i;\n  const stream = projection2.stream({\n    point(x5, y5) {\n      X3[i] = x5;\n      Y3[i] = y5;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x4[i], y4[i]);\n  }\n}\nfunction projectionAspectRatio(projection2, marks2) {\n  if (typeof projection2?.stream === \"function\")\n    return defaultAspectRatio;\n  if (isObject(projection2))\n    projection2 = projection2.type;\n  if (projection2 == null)\n    return hasGeometry(marks2) ? defaultAspectRatio : void 0;\n  if (typeof projection2 !== \"function\") {\n    const { aspectRatio } = namedProjection(projection2);\n    if (aspectRatio)\n      return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\nfunction Position(channels, scales, context) {\n  const { x: x4, y: y4 } = channels;\n  let position2 = {};\n  if (x4)\n    position2.x = x4;\n  if (y4)\n    position2.y = y4;\n  position2 = valueObject(position2, scales);\n  if (context.projection)\n    maybeProject(\"x\", \"y\", channels, position2, context);\n  if (x4)\n    position2.x = coerceNumbers(position2.x);\n  if (y4)\n    position2.y = coerceNumbers(position2.y);\n  return position2;\n}\nfunction hasGeometry(marks2) {\n  for (const mark of marks2)\n    if (mark.channels.geometry)\n      return true;\n  return false;\n}\n\n// node_modules/@observablehq/plot/dist/context.js\nfunction Context(options = {}, dimensions) {\n  const { document: document2 = typeof window !== \"undefined\" ? window.document : void 0 } = options;\n  return { document: document2, projection: Projection(options, dimensions) };\n}\nfunction create2(name, { document: document2 }) {\n  return select_default2(creator_default(name).call(document2.documentElement));\n}\n\n// node_modules/@observablehq/plot/dist/memoize.js\nfunction memoize1(compute) {\n  let cacheValue, cacheKeys;\n  return (...keys) => {\n    if (cacheKeys?.length !== keys.length || cacheKeys.some((k2, i) => k2 !== keys[i])) {\n      cacheKeys = keys;\n      cacheValue = compute(...keys);\n    }\n    return cacheValue;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/format.js\nvar numberFormat = memoize1((locale3) => new Intl.NumberFormat(locale3));\nvar monthFormat = memoize1((locale3, month) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...month && { month } }));\nvar weekdayFormat = memoize1((locale3, weekday) => new Intl.DateTimeFormat(locale3, { timeZone: \"UTC\", ...weekday && { weekday } }));\nfunction formatNumber(locale3 = \"en-US\") {\n  const format3 = numberFormat(locale3);\n  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;\n}\nfunction formatMonth(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = monthFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatWeekday(locale3 = \"en-US\", format3 = \"short\") {\n  const fmt = weekdayFormat(locale3, format3);\n  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;\n}\nfunction formatIsoDate(date2) {\n  return format2(date2, \"Invalid Date\");\n}\nfunction formatAuto(locale3 = \"en-US\") {\n  const number7 = formatNumber(locale3);\n  return (v2) => (v2 instanceof Date ? formatIsoDate : typeof v2 === \"number\" ? number7 : string)(v2);\n}\nvar formatDefault = formatAuto();\n\n// node_modules/@observablehq/plot/dist/style.js\nvar offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5;\nvar nextClipId = 0;\nfunction getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\nfunction styles(mark, { title, href, ariaLabel: variaLabel, ariaDescription, ariaHidden, target, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, opacity: opacity2, mixBlendMode, paintOrder, pointerEvents, shapeRendering }, { ariaLabel: cariaLabel, fill: defaultFill = \"currentColor\", fillOpacity: defaultFillOpacity, stroke: defaultStroke = \"none\", strokeOpacity: defaultStrokeOpacity, strokeWidth: defaultStrokeWidth, strokeLinecap: defaultStrokeLinecap, strokeLinejoin: defaultStrokeLinejoin, strokeMiterlimit: defaultStrokeMiterlimit, paintOrder: defaultPaintOrder }) {\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n  if (isNoneish(defaultFill)) {\n    if (!isNoneish(defaultStroke) && !isNoneish(fill))\n      defaultStroke = \"none\";\n  } else {\n    if (isNoneish(defaultStroke) && !isNoneish(stroke))\n      defaultFill = \"none\";\n  }\n  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = maybeNumberChannel(opacity2);\n  if (!isNone(cstroke)) {\n    if (strokeWidth === void 0)\n      strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === void 0)\n      strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === void 0)\n      strokeLinejoin = defaultStrokeLinejoin;\n    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))\n      strokeMiterlimit = defaultStrokeMiterlimit;\n    if (!isNone(cfill) && paintOrder === void 0)\n      paintOrder = defaultPaintOrder;\n  }\n  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n  mark.target = string(target);\n  mark.ariaLabel = string(cariaLabel);\n  mark.ariaDescription = string(ariaDescription);\n  mark.ariaHidden = string(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n  return {\n    title: { value: title, optional: true },\n    href: { value: href, optional: true },\n    ariaLabel: { value: variaLabel, optional: true },\n    fill: { value: vfill, scale: \"auto\", optional: true },\n    fillOpacity: { value: vfillOpacity, scale: \"opacity\", optional: true },\n    stroke: { value: vstroke, scale: \"auto\", optional: true },\n    strokeOpacity: { value: vstrokeOpacity, scale: \"opacity\", optional: true },\n    strokeWidth: { value: vstrokeWidth, optional: true },\n    opacity: { value: vopacity, scale: \"opacity\", optional: true }\n  };\n}\nfunction applyTitle(selection2, L) {\n  if (L)\n    selection2.filter((i) => nonempty(L[i])).append(\"title\").call(applyText, L);\n}\nfunction applyTitleGroup(selection2, L) {\n  if (L)\n    selection2.filter(([i]) => nonempty(L[i])).append(\"title\").call(applyTextGroup, L);\n}\nfunction applyText(selection2, T) {\n  if (T)\n    selection2.text((i) => formatDefault(T[i]));\n}\nfunction applyTextGroup(selection2, T) {\n  if (T)\n    selection2.text(([i]) => formatDefault(T[i]));\n}\nfunction applyChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", (i) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", (i) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", (i) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", (i) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", (i) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", (i) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", (i) => O[i]);\n  if (H)\n    applyHref(selection2, (i) => H[i], target);\n  applyTitle(selection2, T);\n}\nfunction applyGroupedChannelStyles(selection2, { target }, { ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  if (AL)\n    applyAttr(selection2, \"aria-label\", ([i]) => AL[i]);\n  if (F)\n    applyAttr(selection2, \"fill\", ([i]) => F[i]);\n  if (FO)\n    applyAttr(selection2, \"fill-opacity\", ([i]) => FO[i]);\n  if (S)\n    applyAttr(selection2, \"stroke\", ([i]) => S[i]);\n  if (SO)\n    applyAttr(selection2, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW)\n    applyAttr(selection2, \"stroke-width\", ([i]) => SW[i]);\n  if (O)\n    applyAttr(selection2, \"opacity\", ([i]) => O[i]);\n  if (H)\n    applyHref(selection2, ([i]) => H[i], target);\n  applyTitleGroup(selection2, T);\n}\nfunction groupAesthetics({ ariaLabel: AL, title: T, fill: F, fillOpacity: FO, stroke: S, strokeOpacity: SO, strokeWidth: SW, opacity: O, href: H }) {\n  return [AL, T, F, FO, S, SO, SW, O, H].filter((c6) => c6 !== void 0);\n}\nfunction groupZ2(I, Z, z) {\n  const G = group(I, (i) => Z[i]);\n  if (z === void 0 && G.size > I.length >> 1) {\n    warn(`Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`);\n  }\n  return G.values();\n}\nfunction* groupIndex(I, position2, { z }, channels) {\n  const { z: Z } = channels;\n  const A5 = groupAesthetics(channels);\n  const C3 = [...position2, ...A5];\n  for (const G of Z ? groupZ2(I, Z, z) : [I]) {\n    let Ag;\n    let Gg;\n    out:\n      for (const i of G) {\n        for (const c6 of C3) {\n          if (!defined(c6[i])) {\n            if (Gg)\n              Gg.push(-1);\n            continue out;\n          }\n        }\n        if (Ag === void 0) {\n          if (Gg)\n            yield Gg;\n          Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n          continue;\n        }\n        Gg.push(i);\n        for (let j = 0; j < A5.length; ++j) {\n          const k2 = keyof2(A5[j][i]);\n          if (k2 !== Ag[j]) {\n            yield Gg;\n            Ag = A5.map((c6) => keyof2(c6[i])), Gg = [i];\n            continue out;\n          }\n        }\n      }\n    if (Gg)\n      yield Gg;\n  }\n}\nfunction maybeClip(clip) {\n  if (clip === true)\n    clip = \"frame\";\n  else if (clip === false)\n    clip = null;\n  return maybeKeyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n}\nfunction applyClip(selection2, mark, dimensions, context) {\n  let clipUrl;\n  switch (mark.clip) {\n    case \"frame\": {\n      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2 = create2(\"svg:g\", context).call((g) => g.append(\"svg:clipPath\").attr(\"id\", id2).append(\"rect\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginRight - marginLeft).attr(\"height\", height - marginTop - marginBottom)).each(function() {\n        this.appendChild(selection2.node());\n        selection2.node = () => this;\n      });\n      break;\n    }\n    case \"sphere\": {\n      const { projection: projection2 } = context;\n      if (!projection2)\n        throw new Error(`the \"sphere\" clip option requires a projection`);\n      const id2 = getClipId();\n      clipUrl = `url(#${id2})`;\n      selection2.append(\"clipPath\").attr(\"id\", id2).append(\"path\").attr(\"d\", path_default(projection2)({ type: \"Sphere\" }));\n      break;\n    }\n  }\n  applyAttr(selection2, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection2, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection2, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection2, \"clip-path\", clipUrl);\n}\nfunction applyIndirectStyles(selection2, mark, dimensions, context) {\n  applyClip(selection2, mark, dimensions, context);\n  applyAttr(selection2, \"fill\", mark.fill);\n  applyAttr(selection2, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection2, \"stroke\", mark.stroke);\n  applyAttr(selection2, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection2, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection2, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection2, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection2, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection2, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection2, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection2, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection2, \"paint-order\", mark.paintOrder);\n  applyAttr(selection2, \"pointer-events\", mark.pointerEvents);\n}\nfunction applyDirectStyles(selection2, mark) {\n  applyStyle(selection2, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection2, \"opacity\", mark.opacity);\n}\nfunction applyHref(selection2, href, target) {\n  selection2.each(function(i) {\n    const h = href(i);\n    if (h != null) {\n      const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, \"a\");\n      a4.setAttribute(\"fill\", \"inherit\");\n      a4.setAttributeNS(namespaces_default.xlink, \"href\", h);\n      if (target != null)\n        a4.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a4, this).appendChild(this);\n    }\n  });\n}\nfunction applyAttr(selection2, name, value) {\n  if (value != null)\n    selection2.attr(name, value);\n}\nfunction applyStyle(selection2, name, value) {\n  if (value != null)\n    selection2.style(name, value);\n}\nfunction applyTransform(selection2, mark, { x: x4, y: y4 }, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x4?.bandwidth)\n    tx += x4.bandwidth() / 2;\n  if (y4?.bandwidth)\n    ty += y4.bandwidth() / 2;\n  if (tx || ty)\n    selection2.attr(\"transform\", `translate(${tx},${ty})`);\n}\nfunction impliedString(value, impliedValue) {\n  if ((value = string(value)) !== impliedValue)\n    return value;\n}\nfunction impliedNumber(value, impliedValue) {\n  if ((value = number5(value)) !== impliedValue)\n    return value;\n}\nvar validClassName = /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/;\nfunction maybeClassName(name) {\n  if (name === void 0)\n    return `plot-${Math.random().toString(16).slice(2)}`;\n  name = `${name}`;\n  if (!validClassName.test(name))\n    throw new Error(`invalid class name: ${name}`);\n  return name;\n}\nfunction applyInlineStyles(selection2, style) {\n  if (typeof style === \"string\") {\n    selection2.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection2) {\n      Object.assign(element.style, style);\n    }\n  }\n}\nfunction applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {\n  return [\n    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,\n    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2\n  ];\n}\n\n// node_modules/@observablehq/plot/dist/dimensions.js\nfunction Dimensions(scales, marks2, options = {}) {\n  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;\n  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {\n    if (marginTop2 > marginTopDefault)\n      marginTopDefault = marginTop2;\n    if (marginRight2 > marginRightDefault)\n      marginRightDefault = marginRight2;\n    if (marginBottom2 > marginBottomDefault)\n      marginBottomDefault = marginBottom2;\n    if (marginLeft2 > marginLeftDefault)\n      marginLeftDefault = marginLeft2;\n  }\n  let { margin, marginTop = margin !== void 0 ? margin : marginTopDefault, marginRight = margin !== void 0 ? margin : marginRightDefault, marginBottom = margin !== void 0 ? margin : marginBottomDefault, marginLeft = margin !== void 0 ? margin : marginLeftDefault } = options;\n  marginTop = +marginTop;\n  marginRight = +marginRight;\n  marginBottom = +marginBottom;\n  marginLeft = +marginLeft;\n  let { width = 640, height = autoHeight(scales, marks2, options, {\n    width,\n    marginTopDefault,\n    marginRightDefault,\n    marginBottomDefault,\n    marginLeftDefault\n  }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault) } = options;\n  width = +width;\n  height = +height;\n  const dimensions = {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n  if (scales.fx || scales.fy) {\n    let { margin: facetMargin, marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop, marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight, marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom, marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft } = options.facet ?? {};\n    facetMarginTop = +facetMarginTop;\n    facetMarginRight = +facetMarginRight;\n    facetMarginBottom = +facetMarginBottom;\n    facetMarginLeft = +facetMarginLeft;\n    dimensions.facet = {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    };\n  }\n  return dimensions;\n}\nfunction autoHeight({ x: x4, y: y4, fy, fx }, marks2, { projection: projection2, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {\n  const nfy = fy ? fy.scale.domain().length : 1;\n  const ar = projectionAspectRatio(projection2, marks2);\n  if (ar) {\n    const nfx = fx ? fx.scale.domain().length : 1;\n    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;\n    const lar = Math.max(0.1, Math.min(10, far));\n    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);\n  }\n  const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;\n  if (aspectRatio != null) {\n    aspectRatio = +aspectRatio;\n    if (!(isFinite(aspectRatio) && aspectRatio > 0))\n      throw new Error(`invalid aspectRatio: ${aspectRatio}`);\n    const ratio = aspectRatioLength(\"y\", y4) / (aspectRatioLength(\"x\", x4) * aspectRatio);\n    const fxb = fx ? fx.scale.bandwidth() : 1;\n    const fyb = fy ? fy.scale.bandwidth() : 1;\n    const w = fxb * (width - marginLeftDefault - marginRightDefault) - x4.insetLeft - x4.insetRight;\n    return (ratio * w + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;\n  }\n  return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;\n}\nfunction aspectRatioLength(k2, scale3) {\n  if (!scale3)\n    throw new Error(`aspectRatio requires ${k2} scale`);\n  const { type: type2, domain } = scale3;\n  let transform2;\n  switch (type2) {\n    case \"linear\":\n    case \"utc\":\n    case \"time\":\n      transform2 = Number;\n      break;\n    case \"pow\": {\n      const exponent2 = scale3.scale.exponent();\n      transform2 = (x4) => Math.pow(x4, exponent2);\n      break;\n    }\n    case \"log\":\n      transform2 = Math.log;\n      break;\n    case \"point\":\n    case \"band\":\n      return domain.length;\n    default:\n      throw new Error(`unsupported ${k2} scale for aspectRatio: ${type2}`);\n  }\n  const [min4, max5] = extent(domain);\n  return Math.abs(transform2(max5) - transform2(min4));\n}\n\n// node_modules/@observablehq/plot/dist/facet.js\nfunction Facets(channelsByScale, options) {\n  const { fx, fy } = Scales(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x4, y4], i) => ({ x: x4, y: y4, i })) : fxDomain ? fxDomain.map((x4, i) => ({ x: x4, i })) : fyDomain ? fyDomain.map((y4, i) => ({ y: y4, i })) : void 0;\n}\nfunction facetOrder({ x: X3, y: Y3 }) {\n  const xi = X3 && new Map(X3.map((v2, i) => [v2, i]));\n  const yi = Y3 && new Map(Y3.map((v2, i) => [v2, i]));\n  return X3 && Y3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) || yi.get(a4.y) - yi.get(b.y) : X3 ? (a4, b) => xi.get(a4.x) - xi.get(b.x) : (a4, b) => yi.get(a4.y) - yi.get(b.y);\n}\nfunction facetGroups(data, { fx, fy }) {\n  const I = range4(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy ? rollup(I, (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G), (i) => FX[i], (i) => FY[i]) : fx ? rollup(I, (G) => (G.fx = FX[G[0]], G), (i) => FX[i]) : rollup(I, (G) => (G.fy = FY[G[0]], G), (i) => FY[i]);\n}\nfunction facetTranslate(fx, fy, { marginTop, marginLeft }) {\n  return fx && fy ? ({ x: x4, y: y4 }) => `translate(${fx(x4) - marginLeft},${fy(y4) - marginTop})` : fx ? ({ x: x4 }) => `translate(${fx(x4) - marginLeft},0)` : ({ y: y4 }) => `translate(0,${fy(y4) - marginTop})`;\n}\nfunction facetExclude(index3) {\n  const ex = [];\n  const e = new Uint32Array(sum(index3, (d) => d.length));\n  for (const i of index3) {\n    let n = 0;\n    for (const j of index3) {\n      if (i === j)\n        continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\nvar facetAnchors = /* @__PURE__ */ new Map([\n  [\"top\", facetAnchorTop],\n  [\"right\", facetAnchorRight],\n  [\"bottom\", facetAnchorBottom],\n  [\"left\", facetAnchorLeft],\n  [\"top-left\", and(facetAnchorTop, facetAnchorLeft)],\n  [\"top-right\", and(facetAnchorTop, facetAnchorRight)],\n  [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)],\n  [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)],\n  [\"top-empty\", facetAnchorTopEmpty],\n  [\"right-empty\", facetAnchorRightEmpty],\n  [\"bottom-empty\", facetAnchorBottomEmpty],\n  [\"left-empty\", facetAnchorLeftEmpty],\n  [\"empty\", facetAnchorEmpty]\n]);\nfunction maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null)\n    return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor)\n    return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\nfunction facetAnchorTop(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === 0 : true;\n}\nfunction facetAnchorBottom(facets, { y: Y3 }, { y: y4 }) {\n  return Y3 ? Y3.indexOf(y4) === Y3.length - 1 : true;\n}\nfunction facetAnchorLeft(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === 0 : true;\n}\nfunction facetAnchorRight(facets, { x: X3 }, { x: x4 }) {\n  return X3 ? X3.indexOf(x4) === X3.length - 1 : true;\n}\nfunction facetAnchorTopEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i > 0) {\n    const y5 = Y3[i - 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = Y3?.indexOf(y4);\n  if (i < Y3?.length - 1) {\n    const y5 = Y3[i + 1];\n    return facets.find((f) => f.x === x4 && f.y === y5)?.empty;\n  }\n}\nfunction facetAnchorLeftEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i > 0) {\n    const x5 = X3[i - 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorRightEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {\n  if (empty4)\n    return false;\n  const i = X3?.indexOf(x4);\n  if (i < X3?.length - 1) {\n    const x5 = X3[i + 1];\n    return facets.find((f) => f.x === x5 && f.y === y4)?.empty;\n  }\n}\nfunction facetAnchorEmpty(facets, channels, { empty: empty4 }) {\n  return empty4;\n}\nfunction and(a4, b) {\n  return function() {\n    return a4.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\nfunction facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {\n  return fx && fy ? facets.map(({ x: x4, y: y4 }) => groups2.get(x4)?.get(y4) ?? []) : fx ? facets.map(({ x: x4 }) => groups2.get(x4) ?? []) : facets.map(({ y: y4 }) => groups2.get(y4) ?? []);\n}\n\n// node_modules/@observablehq/plot/dist/axes.js\nfunction inferFontVariant(scale3) {\n  return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction maybeAutoTickFormat(tickFormat2, domain) {\n  return tickFormat2 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat2 === \"function\" ? tickFormat2 : (typeof tickFormat2 === \"string\" ? isTemporal(domain) ? utcFormat : format : constant2)(tickFormat2);\n}\n\n// node_modules/@observablehq/plot/dist/legends/ramp.js\nfunction legendRamp(color3, options) {\n  let { label = color3.label, tickSize = 6, width = 240, height = 44 + tickSize, marginTop = 18, marginRight = 0, marginBottom = 16 + tickSize, marginLeft = 0, style, ticks: ticks2 = (width - marginLeft - marginRight) / 64, tickFormat: tickFormat2, fontVariant = inferFontVariant(color3), round: round2 = true, className } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  if (tickFormat2 === null)\n    tickFormat2 = () => null;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n          overflow: visible;\n        }\n        .${className} text {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style);\n  let tickAdjust = (g) => g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x4;\n  const applyRange = round2 ? (x5, range6) => x5.rangeRound(range6) : (x5, range6) => x5.range(range6);\n  const { type: type2, domain, range: range5, interpolate, scale: scale3, pivot } = color3;\n  if (interpolate) {\n    const interpolator = range5 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range5);\n    x4 = applyRange(scale3.copy(), quantize_default(number_default(marginLeft, width - marginRight), Math.min(domain.length + (pivot !== void 0), range5 === void 0 ? Infinity : range5.length)));\n    const n = 256;\n    const canvas = context.document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context2 = canvas.getContext(\"2d\");\n    for (let i = 0, j = n - 1; i < n; ++i) {\n      context2.fillStyle = interpolator(i / j);\n      context2.fillRect(i, 0, 1, 1);\n    }\n    svg2.append(\"image\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginLeft - marginRight).attr(\"height\", height - marginTop - marginBottom).attr(\"preserveAspectRatio\", \"none\").attr(\"xlink:href\", canvas.toDataURL());\n  } else if (type2 === \"threshold\") {\n    const thresholds = domain;\n    const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === \"string\" ? format(tickFormat2) : tickFormat2;\n    x4 = applyRange(linear3().domain([-1, range5.length - 1]), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(range5).enter().append(\"rect\").attr(\"x\", (d, i) => x4(i - 1)).attr(\"y\", marginTop).attr(\"width\", (d, i) => x4(i) - x4(i - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", (d) => d);\n    ticks2 = map4(thresholds, (_, i) => i);\n    tickFormat2 = (i) => thresholdFormat(thresholds[i], i);\n  } else {\n    x4 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);\n    svg2.append(\"g\").selectAll().data(domain).enter().append(\"rect\").attr(\"x\", x4).attr(\"y\", marginTop).attr(\"width\", Math.max(0, x4.bandwidth() - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", scale3);\n    tickAdjust = () => {\n    };\n  }\n  svg2.append(\"g\").attr(\"transform\", `translate(0,${height - marginBottom})`).call(axisBottom(x4).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === \"string\" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === \"function\" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)).attr(\"font-size\", null).attr(\"font-family\", null).attr(\"font-variant\", impliedString(fontVariant, \"normal\")).call(tickAdjust).call((g) => g.select(\".domain\").remove());\n  if (label !== void 0) {\n    svg2.append(\"text\").attr(\"x\", marginLeft).attr(\"y\", marginTop - 6).attr(\"fill\", \"currentColor\").attr(\"font-weight\", \"bold\").text(label);\n  }\n  return svg2.node();\n}\n\n// node_modules/@observablehq/plot/dist/legends/swatches.js\nfunction maybeScale(scale3, key) {\n  if (key == null)\n    return key;\n  const s2 = scale3(key);\n  if (!s2)\n    throw new Error(`scale not found: ${key}`);\n  return s2;\n}\nfunction legendSwatches(color3, options) {\n  if (!isOrdinalScale(color3) && !isThresholdScale(color3))\n    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);\n  return legendItems(color3, options, (selection2, scale3) => selection2.append(\"svg\").attr(\"fill\", scale3.scale).append(\"rect\").attr(\"width\", \"100%\").attr(\"height\", \"100%\"), (className) => `.${className}-swatch svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n      }`);\n}\nfunction legendSymbols(symbol2, { fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : \"none\", fillOpacity = 1, stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? \"currentColor\" : \"none\", strokeOpacity = 1, strokeWidth = 1.5, r = 4.5, ...options } = {}, scale3) {\n  const [vf, cf] = maybeColorChannel(fill);\n  const [vs, cs] = maybeColorChannel(stroke);\n  const sf = maybeScale(scale3, vf);\n  const ss = maybeScale(scale3, vs);\n  const size = r * r * Math.PI;\n  fillOpacity = maybeNumberChannel(fillOpacity)[1];\n  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];\n  strokeWidth = maybeNumberChannel(strokeWidth)[1];\n  return legendItems(symbol2, options, (selection2) => selection2.append(\"svg\").attr(\"viewBox\", \"-8 -8 16 16\").attr(\"fill\", vf === \"color\" ? (d) => sf.scale(d) : null).attr(\"stroke\", vs === \"color\" ? (d) => ss.scale(d) : null).append(\"path\").attr(\"d\", (d) => {\n    const p = pathRound();\n    symbol2.scale(d).draw(p, size);\n    return p;\n  }), (className) => `.${className}-swatch > svg {\n        width: var(--swatchWidth);\n        height: var(--swatchHeight);\n        margin-right: 0.5em;\n        overflow: visible;\n        fill: ${cf};\n        fill-opacity: ${fillOpacity};\n        stroke: ${cs};\n        stroke-width: ${strokeWidth}px;\n        stroke-opacity: ${strokeOpacity};\n      }`);\n}\nfunction legendItems(scale3, options = {}, swatch, swatchStyle) {\n  let {\n    columns,\n    tickFormat: tickFormat2,\n    fontVariant = inferFontVariant(scale3),\n    // TODO label,\n    swatchSize = 15,\n    swatchWidth = swatchSize,\n    swatchHeight = swatchSize,\n    marginLeft = 0,\n    className,\n    style,\n    width\n  } = options;\n  const context = Context(options);\n  className = maybeClassName(className);\n  tickFormat2 = maybeAutoTickFormat(tickFormat2, scale3.domain);\n  const swatches = create2(\"div\", context).attr(\"class\", className).attr(\"style\", `\n        --swatchWidth: ${+swatchWidth}px;\n        --swatchHeight: ${+swatchHeight}px;\n      `);\n  let extraStyle;\n  if (columns != null) {\n    extraStyle = `\n      .${className}-swatch {\n        display: flex;\n        align-items: center;\n        break-inside: avoid;\n        padding-bottom: 1px;\n      }\n      .${className}-swatch::before {\n        flex-shrink: 0;\n      }\n      .${className}-label {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n    `;\n    swatches.style(\"columns\", columns).selectAll().data(scale3.domain).enter().append(\"div\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).call((item) => item.append(\"div\").attr(\"class\", `${className}-label`).attr(\"title\", tickFormat2).text(tickFormat2));\n  } else {\n    extraStyle = `\n      .${className} {\n        display: flex;\n        align-items: center;\n        min-height: 33px;\n        flex-wrap: wrap;\n      }\n      .${className}-swatch {\n        display: inline-flex;\n        align-items: center;\n        margin-right: 1em;\n      }\n    `;\n    swatches.selectAll().data(scale3.domain).enter().append(\"span\").attr(\"class\", `${className}-swatch`).call(swatch, scale3).append(function() {\n      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));\n    });\n  }\n  return swatches.call((div) => div.insert(\"style\", \"*\").text(`\n        .${className} {\n          font-family: system-ui, sans-serif;\n          font-size: 10px;\n          margin-bottom: 0.5em;${marginLeft === void 0 ? \"\" : `\n          margin-left: ${+marginLeft}px;`}${width === void 0 ? \"\" : `\n          width: ${width}px;`}\n        }\n        ${swatchStyle(className)}\n        ${extraStyle}\n      `)).style(\"font-variant\", impliedString(fontVariant, \"normal\")).call(applyInlineStyles, style).node();\n}\n\n// node_modules/@observablehq/plot/dist/legends.js\nvar legendRegistry = /* @__PURE__ */ new Map([\n  [\"symbol\", legendSymbols],\n  [\"color\", legendColor],\n  [\"opacity\", legendOpacity]\n]);\nfunction legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale3 = options[key];\n    if (isScaleOptions(scale3)) {\n      const context = Context(options);\n      let hint;\n      if (key === \"symbol\") {\n        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? \"color\" : void 0 } = options;\n        hint = { fill, stroke };\n      }\n      return value(normalizeScale(key, scale3, hint), legendOptions(context, scale3, options), (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null);\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\nfunction exposeLegends(scales, context, defaults21 = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key))\n      throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales))\n      return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults21[key], options), (key2) => scales[key2]);\n  };\n}\nfunction legendOptions(context, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {\n  return inherit2(options, context, { label, ticks: ticks2, tickFormat: tickFormat2 });\n}\nfunction legendColor(color3, { legend: legend2 = true, ...options }) {\n  if (legend2 === true)\n    legend2 = color3.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color3.domain === void 0)\n    return;\n  switch (`${legend2}`.toLowerCase()) {\n    case \"swatches\":\n      return legendSwatches(color3, options);\n    case \"ramp\":\n      return legendRamp(color3, options);\n    default:\n      throw new Error(`unknown legend type: ${legend2}`);\n  }\n}\nfunction legendOpacity({ type: type2, interpolate, ...scale3 }, { legend: legend2 = true, color: color3 = rgb(0, 0, 0), ...options }) {\n  if (!interpolate)\n    throw new Error(`${type2} opacity scales are not supported`);\n  if (legend2 === true)\n    legend2 = \"ramp\";\n  if (`${legend2}`.toLowerCase() !== \"ramp\")\n    throw new Error(`${legend2} opacity legends are not supported`);\n  return legendColor({ type: type2, ...scale3, interpolate: interpolateOpacity(color3) }, { legend: legend2, ...options });\n}\nfunction interpolateOpacity(color3) {\n  const { r, g, b } = rgb(color3) || rgb(0, 0, 0);\n  return (t) => `rgba(${r},${g},${b},${t})`;\n}\nfunction Legends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend2 = value(scales[key], legendOptions(context, scales[key], o), (key2) => scales[key2]);\n      if (legend2 != null)\n        legends.push(legend2);\n    }\n  }\n  return legends;\n}\n\n// node_modules/@observablehq/plot/dist/mark.js\nvar Mark = class {\n  constructor(data, channels = {}, options = {}, defaults21) {\n    const { facet = \"auto\", facetAnchor, fx, fy, sort: sort3, dx = 0, dy = 0, margin = 0, marginTop = margin, marginRight = margin, marginBottom = margin, marginLeft = margin, clip, channels: extraChannels } = options;\n    this.data = data;\n    this.sort = isDomainSort(sort3) ? sort3 : null;\n    this.initializer = initializer(options).initializer;\n    this.transform = this.initializer ? options.transform : basic(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = keyword(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = fx;\n      this.fy = fy;\n    }\n    this.facetAnchor = maybeFacetAnchor(facetAnchor);\n    channels = maybeNamed(channels);\n    if (extraChannels !== void 0)\n      channels = { ...maybeNamed(extraChannels), ...channels };\n    if (defaults21 !== void 0)\n      channels = { ...styles(this, options, defaults21), ...channels };\n    this.channels = Object.fromEntries(Object.entries(channels).map(([name, channel]) => {\n      const { value } = channel;\n      if (isOptions(value)) {\n        channel = { ...channel, value: value.value };\n        if (value.scale !== void 0)\n          channel.scale = value.scale;\n      }\n      return [name, channel];\n    }).filter(([name, { value, optional: optional2 }]) => {\n      if (value != null)\n        return true;\n      if (optional2)\n        return false;\n      throw new Error(`missing channel value: ${name}`);\n    }));\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = maybeClip(clip);\n    if (this.facet === \"super\") {\n      if (fx || fy)\n        throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const { scale: scale3 } = channels[name];\n        if (scale3 !== \"x\" && scale3 !== \"y\")\n          continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n  }\n  initialize(facets, facetChannels) {\n    let data = arrayify2(this.data);\n    if (facets === void 0 && data != null)\n      facets = [range4(data)];\n    if (this.transform != null)\n      ({ facets, data } = this.transform(data, facets)), data = arrayify2(data);\n    const channels = Channels(this.channels, data);\n    if (this.sort != null)\n      channelDomain(channels, facetChannels, data, this.sort);\n    return { data, facets, channels };\n  }\n  filter(index3, channels, values2) {\n    for (const name in channels) {\n      const { filter: filter4 = defined } = channels[name];\n      if (filter4 !== null) {\n        const value = values2[name];\n        index3 = index3.filter((i) => filter4(value[i]));\n      }\n    }\n    return index3;\n  }\n  // If there is a projection, and there are both x and y channels (or x1 and\n  // y1, or x2 and y2 channels), and those channels are associated with the x\n  // and y scale respectively (and not already in screen coordinates as with an\n  // initializer), then apply the projection, replacing the x and y values. Note\n  // that the x and y scales themselves dont exist if there is a projection,\n  // but whether the channels are associated with scales still determines\n  // whether the projection should apply; think of the projection as a\n  // combination xy-scale.\n  project(channels, values2, context) {\n    maybeProject(\"x\", \"y\", channels, values2, context);\n    maybeProject(\"x1\", \"y1\", channels, values2, context);\n    maybeProject(\"x2\", \"y2\", channels, values2, context);\n  }\n  scale(channels, scales, context) {\n    const values2 = valueObject(channels, scales);\n    if (context.projection)\n      this.project(channels, values2, context);\n    return values2;\n  }\n};\nfunction marks(...marks2) {\n  marks2.plot = Mark.prototype.plot;\n  return marks2;\n}\n\n// node_modules/@observablehq/plot/dist/math.js\nvar radians3 = Math.PI / 180;\n\n// node_modules/@observablehq/plot/dist/transforms/inset.js\nfunction maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {\n  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);\n  return { inset, insetLeft, insetRight, ...options };\n}\nfunction maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {\n  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);\n  return { inset, insetTop, insetBottom, ...options };\n}\nfunction maybeInset(inset, inset1, inset2) {\n  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];\n}\n\n// node_modules/@observablehq/plot/dist/transforms/interval.js\nfunction maybeIntervalValue(value, { interval: interval2 }) {\n  value = { ...maybeValue(value) };\n  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);\n  return value;\n}\nfunction maybeIntervalK(k2, maybeInsetK, options, trivial) {\n  const { [k2]: v2, [`${k2}1`]: v1, [`${k2}2`]: v22 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null && !trivial)\n    return options;\n  const label = labelof(v2);\n  if (interval2 == null) {\n    let V;\n    const kv = { transform: (data) => V || (V = valueof(data, value)), label };\n    return {\n      ...options,\n      [k2]: void 0,\n      [`${k2}1`]: v1 === void 0 ? kv : v1,\n      [`${k2}2`]: v22 === void 0 ? kv : v22\n    };\n  }\n  let D1, V1;\n  function transform2(data) {\n    if (V1 !== void 0 && data === D1)\n      return V1;\n    return V1 = map4(valueof(D1 = data, value), (v3) => interval2.floor(v3));\n  }\n  return maybeInsetK({\n    ...options,\n    [k2]: void 0,\n    [`${k2}1`]: v1 === void 0 ? { transform: transform2, label } : v1,\n    [`${k2}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v3) => interval2.offset(v3)), label } : v22\n  });\n}\nfunction maybeIntervalMidK(k2, maybeInsetK, options) {\n  const { [k2]: v2 } = options;\n  const { value, interval: interval2 } = maybeIntervalValue(v2, options);\n  if (value == null || interval2 == null)\n    return options;\n  return maybeInsetK({\n    ...options,\n    [k2]: {\n      label: labelof(v2),\n      transform: (data) => {\n        const V1 = map4(valueof(data, value), (v3) => interval2.floor(v3));\n        const V2 = V1.map((v3) => interval2.offset(v3));\n        return V1.map(isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2);\n      }\n    }\n  });\n}\nfunction maybeTrivialIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options, true);\n}\nfunction maybeTrivialIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options, true);\n}\nfunction maybeIntervalX(options = {}) {\n  return maybeIntervalK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalY(options = {}) {\n  return maybeIntervalK(\"y\", maybeInsetY, options);\n}\nfunction maybeIntervalMidX(options = {}) {\n  return maybeIntervalMidK(\"x\", maybeInsetX, options);\n}\nfunction maybeIntervalMidY(options = {}) {\n  return maybeIntervalMidK(\"y\", maybeInsetY, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/rule.js\nvar defaults = {\n  ariaLabel: \"rule\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar RuleX = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y1: Y13, y2: Y23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetTop, insetBottom } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions).call(applyTransform, this, { x: X3 && x4 }, offset, 0).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"x2\", X3 ? (i) => X3[i] : (marginLeft + width - marginRight) / 2).attr(\"y1\", Y13 && !isCollapsed(y4) ? (i) => Y13[i] + insetTop : marginTop + insetTop).attr(\"y2\", Y23 && !isCollapsed(y4) ? y4.bandwidth ? (i) => Y23[i] + y4.bandwidth() - insetBottom : (i) => Y23[i] - insetBottom : height - marginBottom - insetBottom).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar RuleY = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12, scale: \"x\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true }\n    }, options, defaults);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { y: Y3, x1: X13, x2: X23 } = channels;\n    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;\n    const { insetLeft, insetRight } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y4 }, 0, offset).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", X13 && !isCollapsed(x4) ? (i) => X13[i] + insetLeft : marginLeft + insetLeft).attr(\"x2\", X23 && !isCollapsed(x4) ? x4.bandwidth ? (i) => X23[i] + x4.bandwidth() - insetRight : (i) => X23[i] - insetRight : width - marginRight - insetRight).attr(\"y1\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).attr(\"y2\", Y3 ? (i) => Y3[i] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction ruleX(data, options) {\n  let { x: x4 = identity6, y: y4, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);\n  [y12, y22] = maybeOptionalZero(y4, y12, y22);\n  return new RuleX(data, { ...rest, x: x4, y1: y12, y2: y22 });\n}\nfunction ruleY(data, options) {\n  let { y: y4 = identity6, x: x4, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);\n  [x12, x22] = maybeOptionalZero(x4, x12, x22);\n  return new RuleY(data, { ...rest, y: y4, x1: x12, x2: x22 });\n}\nfunction maybeOptionalZero(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [0, x22];\n    } else {\n      if (x22 === void 0)\n        return [0, x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [0, x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/template.js\nfunction template(strings, ...parts) {\n  let n = parts.length;\n  for (let j = 0, copy3 = true; j < n; ++j) {\n    if (typeof parts[j] !== \"function\") {\n      if (copy3) {\n        strings = strings.slice();\n        copy3 = false;\n      }\n      strings.splice(j, 2, strings[j] + parts[j] + strings[j + 1]);\n      parts.splice(j, 1);\n      --j, --n;\n    }\n  }\n  return (i) => {\n    let s2 = strings[0];\n    for (let j = 0; j < n; ++j) {\n      s2 += parts[j](i) + strings[j + 1];\n    }\n    return s2;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/text.js\nvar defaults2 = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\nvar softHyphen = \"\\xAD\";\nvar Text = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf, frameAnchor, textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\", lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\", lineHeight = 1, lineWidth = Infinity, textOverflow, monospace, fontFamily = monospace ? \"ui-monospace, monospace\" : void 0, fontSize, fontStyle, fontVariant, fontWeight, rotate } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      fontSize: { value: vfontSize, optional: true },\n      rotate: { value: numberChannel(vrotate), optional: true },\n      text: { value: text2, filter: nonempty, optional: true }\n    }, options, defaults2);\n    this.rotate = crotate;\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.lineAnchor = keyword(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    if (!(this.lineWidth >= 0))\n      throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter2(this);\n    this.clipLine = clipper(this);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, rotate: R, text: T, title: TL, fontSize: FS } = channels;\n    const { rotate } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"text\").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`).call(applyAttr, \"font-size\", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction maybeTextOverflow(textOverflow) {\n  return textOverflow == null ? null : keyword(textOverflow, \"textOverflow\", [\n    \"clip\",\n    \"ellipsis\",\n    \"clip-start\",\n    \"clip-end\",\n    \"ellipsis-start\",\n    \"ellipsis-middle\",\n    \"ellipsis-end\"\n  ]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\nfunction applyMultilineText(selection2, mark, T, TL) {\n  if (!T)\n    return;\n  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;\n  selection2.each(function(i) {\n    const lines = splitLines(formatDefault(T[i])).map(clipLine);\n    const n = lines.length;\n    const y4 = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      for (let i2 = 0; i2 < n; ++i2) {\n        if (!lines[i2])\n          continue;\n        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        tspan.setAttribute(\"y\", `${(y4 + i2) * lineHeight}em`);\n        tspan.textContent = lines[i2];\n        this.appendChild(tspan);\n      }\n    } else {\n      if (y4)\n        this.setAttribute(\"y\", `${y4 * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(namespaces_default.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\nfunction text(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Text(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction textX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction textY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Text(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction applyIndirectTextStyles(selection2, mark, T) {\n  applyAttr(selection2, \"text-anchor\", mark.textAnchor);\n  applyAttr(selection2, \"font-family\", mark.fontFamily);\n  applyAttr(selection2, \"font-size\", mark.fontSize);\n  applyAttr(selection2, \"font-style\", mark.fontStyle);\n  applyAttr(selection2, \"font-variant\", mark.fontVariant === void 0 ? inferFontVariant2(T) : mark.fontVariant);\n  applyAttr(selection2, \"font-weight\", mark.fontWeight);\n}\nfunction inferFontVariant2(T) {\n  return isNumeric(T) || isTemporal(T) ? \"tabular-nums\" : void 0;\n}\nvar fontSizes = /* @__PURE__ */ new Set([\n  // global keywords\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n  // absolute keywords\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"xxx-large\",\n  // relative keywords\n  \"larger\",\n  \"smaller\"\n]);\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\")\n    return [void 0, fontSize];\n  if (typeof fontSize !== \"string\")\n    return [fontSize, void 0];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];\n}\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart, lineEnd = 0;\n  for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {\n    if (lineStart === void 0)\n      lineStart = wordStart;\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n    if (required2) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = void 0;\n      continue;\n    }\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\nfunction* lineBreaks(input) {\n  let i = 0, j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k2 = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\":\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \")\n          ;\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\")\n          ++k2;\n      case \"\\n\":\n        yield [i, j, true];\n        j += k2;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\nvar defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"\\u2018\": 31,\n  \"\\u2019\": 31,\n  \"\\u201C\": 47,\n  \"\\u201D\": 47,\n  \"\\u2026\": 82\n};\nfunction defaultWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += defaultWidthMap[text2[i]] ?? (isPictographic(text2, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum5;\n}\nfunction monospaceWidth(text2, start2 = 0, end = text2.length) {\n  let sum5 = 0;\n  for (let i = start2; i < end; i = readCharacter(text2, i)) {\n    sum5 += isPictographic(text2, i) ? 200 : 100;\n  }\n  return sum5;\n}\nfunction splitter2({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow != null || lineWidth == Infinity)\n    return (text2) => text2.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return (text2) => lineWrap(text2, maxWidth, widthof);\n}\nfunction clipper({ monospace, lineWidth, textOverflow }) {\n  if (textOverflow == null || lineWidth == Infinity)\n    return (text2) => text2;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return (text2) => clipStart(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-middle\":\n      return (text2) => clipMiddle(text2, maxWidth, widthof, \"\\u2026\");\n    case \"ellipsis-end\":\n      return (text2) => clipEnd(text2, maxWidth, widthof, \"\\u2026\");\n  }\n}\nfunction cut(text2, width, widthof, inset) {\n  const I = [];\n  let w = 0;\n  for (let i = 0, j = 0, n = text2.length; i < n; i = j) {\n    j = readCharacter(text2, i);\n    const l = widthof(text2, i, j);\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0)\n        j = i, i = I.pop(), w -= widthof(text2, i, j);\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\nfunction clipEnd(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const e = widthof(ellipsis);\n  const [i] = cut(text2, width, widthof, e);\n  return i < 0 ? text2 : text2.slice(0, i).trimEnd() + ellipsis;\n}\nfunction clipMiddle(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text2, width / 2, widthof, e);\n  const [j] = cut(text2, w - width / 2 - ei + e, widthof, -e);\n  return j < 0 ? ellipsis : text2.slice(0, i).trimEnd() + ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nfunction clipStart(text2, width, widthof, ellipsis) {\n  text2 = text2.trim();\n  const w = widthof(text2);\n  if (w <= width)\n    return text2;\n  const e = widthof(ellipsis);\n  const [j] = cut(text2, w - width + e, widthof, -e);\n  return j < 0 ? ellipsis : ellipsis + text2.slice(readCharacter(text2, j)).trimStart();\n}\nvar reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nvar rePictographic = /\\p{Extended_Pictographic}/uy;\nfunction readCharacter(text2, i) {\n  i += isSurrogatePair(text2, i) ? 2 : 1;\n  if (isCombiner(text2, i))\n    i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text2, i))\n    return readCharacter(text2, i + 1);\n  return i;\n}\nfunction isAscii(text2, i) {\n  return text2.charCodeAt(i) < 128;\n}\nfunction isSurrogatePair(text2, i) {\n  const hi = text2.charCodeAt(i);\n  if (hi >= 55296 && hi < 56320) {\n    const lo = text2.charCodeAt(i + 1);\n    return lo >= 56320 && lo < 57344;\n  }\n  return false;\n}\nfunction isZeroWidthJoiner(text2, i) {\n  return text2.charCodeAt(i) === 8205;\n}\nfunction isCombiner(text2, i) {\n  return isAscii(text2, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text2));\n}\nfunction isPictographic(text2, i) {\n  return isAscii(text2, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text2));\n}\n\n// node_modules/@observablehq/plot/dist/marks/vector.js\nvar defaults3 = {\n  ariaLabel: \"vector\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\"\n};\nvar defaultRadius3 = 3.5;\nvar wingRatio = defaultRadius3 * 5;\nvar shapeArrow = {\n  draw(context, l, r) {\n    const wing = l * r / wingRatio;\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n    context.moveTo(-wing, wing - l);\n    context.lineTo(0, -l);\n    context.lineTo(wing, wing - l);\n  }\n};\nvar shapeSpike = {\n  draw(context, l, r) {\n    context.moveTo(-r, 0);\n    context.lineTo(0, -l);\n    context.lineTo(r, 0);\n  }\n};\nvar shapes = /* @__PURE__ */ new Map([\n  [\"arrow\", shapeArrow],\n  [\"spike\", shapeSpike]\n]);\nfunction isShapeObject(value) {\n  return value && typeof value.draw === \"function\";\n}\nfunction Shape(shape) {\n  if (isShapeObject(shape))\n    return shape;\n  const value = shapes.get(`${shape}`.toLowerCase());\n  if (value)\n    return value;\n  throw new Error(`invalid shape: ${shape}`);\n}\nvar Vector = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r = defaultRadius3, length: length4, rotate, shape = shapeArrow, anchor = \"middle\", frameAnchor } = options;\n    const [vl, cl] = maybeNumberChannel(length4, 12);\n    const [vr, cr] = maybeNumberChannel(rotate, 0);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      length: { value: vl, scale: \"length\", optional: true },\n      rotate: { value: vr, optional: true }\n    }, options, defaults3);\n    this.r = +r;\n    this.length = cl;\n    this.rotate = cr;\n    this.shape = Shape(shape);\n    this.anchor = keyword(anchor, \"anchor\", [\"start\", \"middle\", \"end\"]);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, length: L, rotate: A5 } = channels;\n    const { length: length4, rotate, anchor, shape, r } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === \"start\" ? `` : anchor === \"end\" ? L ? (i) => ` translate(0,${L[i]})` : ` translate(0,${length4})` : L ? (i) => ` translate(0,${L[i] / 2})` : ` translate(0,${length4 / 2})`}`).attr(\"d\", L ? (i) => {\n      const p = pathRound();\n      shape.draw(p, L[i], r);\n      return p;\n    } : (() => {\n      const p = pathRound();\n      shape.draw(p, length4, r);\n      return p;\n    })()).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction vector(data, options = {}) {\n  let { x: x4, y: y4, ...rest } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Vector(data, { ...rest, x: x4, y: y4 });\n}\nfunction vectorX(data, options = {}) {\n  const { x: x4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, x: x4 });\n}\nfunction vectorY(data, options = {}) {\n  const { y: y4 = identity6, ...rest } = options;\n  return new Vector(data, { ...rest, y: y4 });\n}\nfunction spike(data, options = {}) {\n  const { shape = shapeSpike, stroke = defaults3.stroke, strokeWidth = 1, fill = stroke, fillOpacity = 0.3, anchor = \"start\", ...rest } = options;\n  return vector(data, { ...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor });\n}\n\n// node_modules/@observablehq/plot/dist/marks/axis.js\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !isIterable(data))\n    options = data, data = null;\n  if (options === void 0)\n    options = {};\n  return [data, options];\n}\nfunction maybeAnchor({ anchor } = {}, anchors) {\n  return anchor === void 0 ? anchors[0] : keyword(anchor, \"anchor\", anchors);\n}\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\nfunction axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\nfunction axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\nfunction axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\nfunction axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\nfunction axisKy(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"y\" ? 6 : 0, tickPadding, tickRotate, x: x4, marginTop = 20, marginRight = anchor === \"right\" ? 40 : 0, marginBottom = 20, marginLeft = anchor === \"left\" ? 40 : 0, label, labelOffset, labelAnchor, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKy(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKy(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x: x4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"y\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"top\");\n      const clo = labelOffset ?? (anchor === \"right\" ? marginRight2 : marginLeft2) - 3;\n      if (cla === \"center\") {\n        this.textAnchor = void 0;\n        this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n        this.frameAnchor = anchor;\n        this.rotate = -90;\n      } else {\n        this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n        this.lineAnchor = cla;\n        this.frameAnchor = `${cla}-${anchor}`;\n        this.rotate = 0;\n      }\n      this.dy = cla === \"top\" ? 3 - marginTop2 : cla === \"bottom\" ? marginBottom2 - 3 : 0;\n      this.dx = anchor === \"right\" ? clo : -clo;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisKx(k2, anchor, data, { color: color3 = \"currentColor\", opacity: opacity2 = 1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, fill = color3, fillOpacity = opacity2, textAnchor, textStroke, textStrokeOpacity, textStrokeWidth, tickSize = k2 === \"x\" ? 6 : 0, tickPadding, tickRotate, y: y4, marginTop = anchor === \"top\" ? 30 : 0, marginRight = 20, marginBottom = anchor === \"bottom\" ? 30 : 0, marginLeft = 20, label, labelAnchor, labelOffset, ...options }) {\n  tickSize = number5(tickSize);\n  tickPadding = number5(tickPadding);\n  tickRotate = number5(tickRotate);\n  if (labelAnchor !== void 0)\n    labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKx(k2, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKx(k2, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y: y4,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], {\n    fill,\n    fillOpacity,\n    ...options,\n    lineWidth: void 0,\n    textOverflow: void 0,\n    facet: \"super\",\n    x: null,\n    y: null,\n    initializer: function(data2, facets, channels, scales, dimensions) {\n      const scale3 = scales[k2];\n      const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k2 === \"x\" && dimensions.inset || dimensions;\n      const cla = labelAnchor ?? (scale3.bandwidth ? \"center\" : \"right\");\n      const clo = labelOffset ?? (anchor === \"top\" ? marginTop2 : marginBottom2) - 3;\n      if (cla === \"center\") {\n        this.frameAnchor = anchor;\n        this.textAnchor = void 0;\n      } else {\n        this.frameAnchor = `${anchor}-${cla}`;\n        this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n      }\n      this.lineAnchor = anchor;\n      this.dy = anchor === \"top\" ? -clo : clo;\n      this.dx = cla === \"right\" ? marginRight2 - 3 : cla === \"left\" ? 3 - marginLeft2 : 0;\n      this.ariaLabel = `${k2}-axis label`;\n      return {\n        facets: [[0]],\n        channels: {\n          text: {\n            value: [label === void 0 ? inferAxisLabel(k2, scale3, cla) : label]\n          }\n        }\n      };\n    }\n  }) : null);\n}\nfunction axisTickKy(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(vectorY, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinecap,\n    strokeLinejoin,\n    facetAnchor,\n    frameAnchor,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - offset + +insetLeft : +dx + offset - insetRight,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n  });\n}\nfunction axisTickKx(k2, anchor, data, { strokeWidth = 1, strokeLinecap = null, strokeLinejoin = null, facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(vectorX, k2, `${k2}-axis tick`, data, {\n    strokeWidth,\n    strokeLinejoin,\n    strokeLinecap,\n    facetAnchor,\n    frameAnchor,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy - offset - insetBottom : +dy + offset + +insetTop,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n  });\n}\nfunction axisTextKy(k2, anchor, data, { facetAnchor = anchor + (k2 === \"y\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\", lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\", fontVariant, inset = 0, insetLeft = inset, insetRight = inset, dx = 0, y: y4 = k2 === \"y\" ? void 0 : null, ...options }) {\n  return axisMark(textY, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    y: y4,\n    ...options,\n    dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction axisTextKx(k2, anchor, data, { facetAnchor = anchor + (k2 === \"x\" ? \"-empty\" : \"\"), frameAnchor = anchor, tickSize, tickRotate = 0, tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0), tickFormat: tickFormat2, text: text2 = typeof tickFormat2 === \"function\" ? tickFormat2 : void 0, textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === \"bottom\" ? \"start\" : \"end\" : \"middle\", lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\", fontVariant, inset = 0, insetTop = inset, insetBottom = inset, dy = 0, x: x4 = k2 === \"x\" ? void 0 : null, ...options }) {\n  return axisMark(textX, k2, `${k2}-axis tick label`, data, {\n    facetAnchor,\n    frameAnchor,\n    text: text2 === void 0 ? null : text2,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    x: x4,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n  }, function(scale3, ticks2, channels) {\n    if (fontVariant === void 0)\n      this.fontVariant = inferFontVariant3(scale3);\n    if (text2 === void 0)\n      channels.text = inferTextChannel(scale3, ticks2, tickFormat2);\n  });\n}\nfunction gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\nfunction gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\nfunction gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\nfunction gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\nfunction gridKy(k2, anchor, data, { y: y4 = k2 === \"y\" ? void 0 : null, x: x4 = null, x1: x12 = anchor === \"left\" ? x4 : null, x2: x22 = anchor === \"right\" ? x4 : null, ...options }) {\n  return axisMark(ruleY, k2, `${k2}-grid`, data, { y: y4, x1: x12, x2: x22, ...gridDefaults(options) });\n}\nfunction gridKx(k2, anchor, data, { x: x4 = k2 === \"x\" ? void 0 : null, y: y4 = null, y1: y12 = anchor === \"top\" ? y4 : null, y2: y22 = anchor === \"bottom\" ? y4 : null, ...options }) {\n  return axisMark(ruleX, k2, `${k2}-grid`, data, { x: x4, y1: y12, y2: y22, ...gridDefaults(options) });\n}\nfunction gridDefaults({ color: color3 = \"currentColor\", opacity: opacity2 = 0.1, stroke = color3, strokeOpacity = opacity2, strokeWidth = 1, ...options }) {\n  return { stroke, strokeOpacity, strokeWidth, ...options };\n}\nfunction axisMark(mark, k2, ariaLabel, data, options, initialize) {\n  let channels;\n  const m3 = mark(data, initializer(options, function(data2, facets, _channels, scales) {\n    const { [k2]: scale3 } = scales;\n    if (!scale3)\n      throw new Error(`missing scale: ${k2}`);\n    let { ticks: ticks2, tickSpacing, interval: interval2 } = options;\n    if (isTemporalScale(scale3) && typeof ticks2 === \"string\")\n      interval2 = ticks2, ticks2 = void 0;\n    if (data2 == null) {\n      if (isIterable(ticks2)) {\n        data2 = arrayify2(ticks2);\n      } else if (scale3.ticks) {\n        if (ticks2 !== void 0) {\n          data2 = scale3.ticks(ticks2);\n        } else {\n          interval2 = maybeInterval(interval2 === void 0 ? scale3.interval : interval2, scale3.type);\n          if (interval2 !== void 0) {\n            const [min4, max5] = extent(scale3.domain());\n            data2 = interval2.range(min4, interval2.offset(interval2.floor(max5)));\n          } else {\n            const [min4, max5] = extent(scale3.range());\n            ticks2 = (max5 - min4) / (tickSpacing === void 0 ? k2 === \"x\" ? 80 : 35 : tickSpacing);\n            data2 = scale3.ticks(ticks2);\n          }\n        }\n      } else {\n        data2 = scale3.domain();\n      }\n      if (k2 === \"y\" || k2 === \"x\") {\n        facets = [range4(data2)];\n      } else {\n        channels[k2] = { scale: k2, value: identity6 };\n        facets = void 0;\n      }\n    }\n    initialize?.call(this, scale3, ticks2, channels);\n    return {\n      data: data2,\n      facets,\n      channels: Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, { ...channel, value: valueof(data2, channel.value) }]))\n    };\n  }));\n  if (data == null) {\n    channels = m3.channels;\n    m3.channels = {};\n  } else {\n    channels = {};\n  }\n  m3.ariaLabel = ariaLabel;\n  return m3;\n}\nfunction inferTextChannel(scale3, ticks2, tickFormat2) {\n  return { value: inferTickFormat(scale3, ticks2, tickFormat2) };\n}\nfunction inferTickFormat(scale3, ticks2, tickFormat2) {\n  return scale3.tickFormat ? scale3.tickFormat(isIterable(ticks2) ? null : ticks2, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === \"string\" ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : constant2(tickFormat2);\n}\nvar shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\nvar shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\nvar shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\nvar shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\nfunction inferFontVariant3(scale3) {\n  return scale3.bandwidth && scale3.interval === void 0 ? void 0 : \"tabular-nums\";\n}\nfunction inferScaleOrder(scale3) {\n  return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));\n}\nfunction inferAxisLabel(key, scale3, labelAnchor) {\n  const label = scale3.label;\n  if (scale3.bandwidth || !label?.inferred)\n    return label;\n  const order = inferScaleOrder(scale3);\n  return order ? key === \"x\" || labelAnchor === \"center\" ? key === \"x\" === order < 0 ? `\\u2190 ${label}` : `${label} \\u2192` : `${order < 0 ? \"\\u2191 \" : \"\\u2193 \"}${label}` : label;\n}\n\n// node_modules/@observablehq/plot/dist/marks/frame.js\nvar defaults4 = {\n  ariaLabel: \"frame\",\n  fill: \"none\",\n  stroke: \"currentColor\"\n};\nvar lineDefaults = {\n  ariaLabel: \"frame\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeLinecap: \"square\"\n};\nvar Frame = class extends Mark {\n  constructor(options = {}) {\n    const { anchor = null, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(void 0, void 0, options, anchor == null ? defaults4 : lineDefaults);\n    this.anchor = maybeKeyword(anchor, \"anchor\", [\"top\", \"right\", \"bottom\", \"left\"]);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = number5(rx);\n    this.ry = number5(ry);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    const x12 = marginLeft + insetLeft;\n    const x22 = width - marginRight - insetRight;\n    const y12 = marginTop + insetTop;\n    const y22 = height - marginBottom - insetBottom;\n    return create2(anchor ? \"svg:line\" : \"svg:rect\", context).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyTransform, this, {}).call(anchor === \"left\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x12).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"right\" ? (line2) => line2.attr(\"x1\", x22).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y22) : anchor === \"top\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y12).attr(\"y2\", y12) : anchor === \"bottom\" ? (line2) => line2.attr(\"x1\", x12).attr(\"x2\", x22).attr(\"y1\", y22).attr(\"y2\", y22) : (rect2) => rect2.attr(\"x\", x12).attr(\"y\", y12).attr(\"width\", x22 - x12).attr(\"height\", y22 - y12).attr(\"rx\", rx).attr(\"ry\", ry)).node();\n  }\n};\nfunction frame2(options) {\n  return new Frame(options);\n}\n\n// node_modules/@observablehq/plot/dist/plot.js\nfunction plot(options = {}) {\n  const { facet, style, caption, ariaLabel, ariaDescription } = options;\n  const className = maybeClassName(options.className);\n  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);\n  const topFacetState = maybeTopFacet(facet, options);\n  const facetStateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  const channelsByScale = /* @__PURE__ */ new Map();\n  if (topFacetState)\n    addScaleChannels(channelsByScale, [topFacetState]);\n  addScaleChannels(channelsByScale, facetStateByMark);\n  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));\n  for (const mark of axes) {\n    const facetState = maybeMarkFacet(mark, topFacetState, options);\n    if (facetState)\n      facetStateByMark.set(mark, facetState);\n  }\n  marks2.unshift(...axes);\n  const facets = Facets(channelsByScale, options);\n  if (facets !== void 0) {\n    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;\n    for (const mark of marks2) {\n      if (mark.facet === null || mark.facet === \"super\")\n        continue;\n      const facetState = facetStateByMark.get(mark);\n      if (facetState === void 0)\n        continue;\n      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;\n    }\n    const nonEmpty = /* @__PURE__ */ new Set();\n    for (const { facetsIndex } of facetStateByMark.values()) {\n      facetsIndex?.forEach((index3, i) => {\n        if (index3?.length > 0) {\n          nonEmpty.add(i);\n        }\n      });\n    }\n    facets.forEach(0 < nonEmpty.size && nonEmpty.size < facets.length ? (f, i) => f.empty = !nonEmpty.has(i) : (f) => f.empty = false);\n    for (const mark of marks2) {\n      if (mark.facet === \"exclude\") {\n        const facetState = facetStateByMark.get(mark);\n        if (facetState !== void 0)\n          facetState.facetsIndex = facetExclude(facetState.facetsIndex);\n      }\n    }\n  }\n  for (const key of registry.keys()) {\n    if (isScaleOptions(options[key]) && key !== \"fx\" && key !== \"fy\") {\n      channelsByScale.set(key, []);\n    }\n  }\n  const stateByMark = /* @__PURE__ */ new Map();\n  for (const mark of marks2) {\n    if (stateByMark.has(mark))\n      throw new Error(\"duplicate mark; each mark must be unique\");\n    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};\n    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels);\n    applyScaleTransforms(channels, options);\n    stateByMark.set(mark, { data, facets: facets2, channels });\n  }\n  const scaleDescriptors = Scales(addScaleChannels(channelsByScale, stateByMark), options);\n  const scales = ScaleFunctions(scaleDescriptors);\n  const dimensions = Dimensions(scaleDescriptors, marks2, options);\n  autoScaleRange(scaleDescriptors, dimensions);\n  const { fx, fy } = scales;\n  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;\n  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;\n  const context = Context(options, subdimensions, scaleDescriptors);\n  const newByScale = /* @__PURE__ */ new Set();\n  for (const [mark, state] of stateByMark) {\n    if (mark.initializer != null) {\n      const dimensions2 = mark.facet === \"super\" ? superdimensions : subdimensions;\n      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);\n      if (update.data !== void 0) {\n        state.data = update.data;\n      }\n      if (update.facets !== void 0) {\n        state.facets = update.facets;\n      }\n      if (update.channels !== void 0) {\n        inferChannelScales(update.channels);\n        Object.assign(state.channels, update.channels);\n        for (const channel of Object.values(update.channels)) {\n          const { scale: scale3 } = channel;\n          if (scale3 != null && registry.get(scale3) !== position) {\n            applyScaleTransform(channel, options);\n            newByScale.add(scale3);\n          }\n        }\n        const { fx: fx2, fy: fy2 } = update.channels;\n        if (fx2 != null || fy2 != null) {\n          const facetState = facetStateByMark.get(mark) ?? { channels: {} };\n          if (fx2 != null)\n            facetState.channels.fx = fx2;\n          if (fy2 != null)\n            facetState.channels.fy = fy2;\n          facetState.groups = facetGroups(state.data, facetState.channels);\n          facetState.facetsIndex = state.facets = facetFilter(facets, facetState);\n          facetStateByMark.set(mark, facetState);\n        }\n      }\n    }\n  }\n  if (newByScale.size) {\n    const newChannelsByScale = /* @__PURE__ */ new Map();\n    addScaleChannels(newChannelsByScale, stateByMark, (key) => newByScale.has(key));\n    addScaleChannels(channelsByScale, stateByMark, (key) => newByScale.has(key));\n    const newScaleDescriptors = inheritScaleLabels(Scales(newChannelsByScale, options), scaleDescriptors);\n    const newScales = ScaleFunctions(newScaleDescriptors);\n    Object.assign(scaleDescriptors, newScaleDescriptors);\n    Object.assign(scales, newScales);\n  }\n  for (const [mark, state] of stateByMark) {\n    state.values = mark.scale(state.channels, scales, context);\n  }\n  const { width, height } = dimensions;\n  const svg2 = create2(\"svg\", context).attr(\"class\", className).attr(\"fill\", \"currentColor\").attr(\"font-family\", \"system-ui, sans-serif\").attr(\"font-size\", 10).attr(\"text-anchor\", \"middle\").attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", `0 0 ${width} ${height}`).attr(\"aria-label\", ariaLabel).attr(\"aria-description\", ariaDescription).call((svg3) => svg3.append(\"style\").text(`\n        .${className} {\n          display: block;\n          background: white;\n          height: auto;\n          height: intrinsic;\n          max-width: 100%;\n        }\n        .${className} text,\n        .${className} tspan {\n          white-space: pre;\n        }\n      `)).call(applyInlineStyles, style).node();\n  if (facets !== void 0) {\n    const facetDomains = { x: fx?.domain(), y: fy?.domain() };\n    facets.sort(facetOrder(facetDomains));\n    select_default2(svg2).selectAll().data(facets).enter().append(\"g\").attr(\"aria-label\", \"facet\").attr(\"transform\", facetTranslate(fx, fy, dimensions)).each(function(f) {\n      let empty4 = true;\n      for (const mark of marks2) {\n        if (mark.facet === \"super\")\n          continue;\n        const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n        if (!(mark.facetAnchor?.(facets, facetDomains, f) ?? !f.empty))\n          continue;\n        let index3 = null;\n        if (indexes2) {\n          index3 = indexes2[facetStateByMark.has(mark) ? f.i : 0];\n          index3 = mark.filter(index3, channels, values2);\n          if (index3.length === 0)\n            continue;\n          index3.fi = f.i;\n        }\n        const node = mark.render(index3, scales, values2, subdimensions, context);\n        if (node == null)\n          continue;\n        empty4 = false;\n        this.appendChild(node);\n      }\n      if (empty4)\n        this.remove();\n    });\n  }\n  for (const mark of marks2) {\n    if (facets !== void 0 && mark.facet !== \"super\")\n      continue;\n    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);\n    let index3 = null;\n    if (indexes2) {\n      index3 = indexes2[0];\n      index3 = mark.filter(index3, channels, values2);\n      if (index3.length === 0)\n        continue;\n    }\n    const node = mark.render(index3, scales, values2, superdimensions, context);\n    if (node != null)\n      svg2.appendChild(node);\n  }\n  let figure = svg2;\n  const legends = Legends(scaleDescriptors, context, options);\n  if (caption != null || legends.length > 0) {\n    const { document: document2 } = context;\n    figure = document2.createElement(\"figure\");\n    figure.style.maxWidth = \"initial\";\n    for (const legend2 of legends)\n      figure.appendChild(legend2);\n    figure.appendChild(svg2);\n    if (caption != null) {\n      const figcaption = document2.createElement(\"figcaption\");\n      figcaption.appendChild(caption instanceof Node ? caption : document2.createTextNode(caption));\n      figure.appendChild(figcaption);\n    }\n  }\n  figure.scale = exposeScales(scaleDescriptors);\n  figure.legend = exposeLegends(scaleDescriptors, context, options);\n  const w = consumeWarnings();\n  if (w > 0) {\n    select_default2(svg2).append(\"text\").attr(\"x\", width).attr(\"y\", 20).attr(\"dy\", \"-1em\").attr(\"text-anchor\", \"end\").attr(\"font-family\", \"initial\").text(\"\\u26A0\\uFE0F\").append(\"title\").text(`${w.toLocaleString(\"en-US\")} warning${w === 1 ? \"\" : \"s\"}. Please check the console.`);\n  }\n  return figure;\n}\nfunction plotThis({ marks: marks2 = [], ...options } = {}) {\n  return plot({ ...options, marks: [...marks2, this] });\n}\nMark.prototype.plot = plotThis;\nfunction flatMarks(marks2) {\n  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);\n}\nfunction markify(mark) {\n  return typeof mark.render === \"function\" ? mark : new Render(mark);\n}\nvar Render = class extends Mark {\n  constructor(render2) {\n    if (typeof render2 !== \"function\")\n      throw new TypeError(\"invalid mark; missing render function\");\n    super();\n    this.render = render2;\n  }\n  render() {\n  }\n};\nfunction applyScaleTransforms(channels, options) {\n  for (const name in channels)\n    applyScaleTransform(channels[name], options);\n  return channels;\n}\nfunction applyScaleTransform(channel, options) {\n  const { scale: scale3 } = channel;\n  if (scale3 == null)\n    return;\n  const { type: type2, percent, interval: interval2, transform: transform2 = percent ? (x4) => x4 * 100 : maybeInterval(interval2, type2)?.floor } = options[scale3] ?? {};\n  if (transform2 != null)\n    channel.value = map4(channel.value, transform2);\n}\nfunction inferChannelScales(channels) {\n  for (const name in channels) {\n    inferChannelScale(name, channels[name]);\n  }\n}\nfunction addScaleChannels(channelsByScale, stateByMark, filter4 = yes) {\n  for (const { channels } of stateByMark.values()) {\n    for (const name in channels) {\n      const channel = channels[name];\n      const { scale: scale3 } = channel;\n      if (scale3 != null && filter4(scale3)) {\n        const scaleChannels = channelsByScale.get(scale3);\n        if (scaleChannels !== void 0)\n          scaleChannels.push(channel);\n        else\n          channelsByScale.set(scale3, [channel]);\n      }\n    }\n  }\n  return channelsByScale;\n}\nfunction maybeTopFacet(facet, options) {\n  if (facet == null)\n    return;\n  const { x: x4, y: y4 } = facet;\n  if (x4 == null && y4 == null)\n    return;\n  const data = arrayify2(facet.data ?? x4 ?? y4);\n  if (data === void 0)\n    throw new Error(`missing facet data`);\n  const channels = {};\n  if (x4 != null)\n    channels.fx = Channel(data, { value: x4, scale: \"fx\" });\n  if (y4 != null)\n    channels.fy = Channel(data, { value: y4, scale: \"fy\" });\n  applyScaleTransforms(channels, options);\n  const groups2 = facetGroups(data, channels);\n  return { channels, groups: groups2, data: facet.data };\n}\nfunction maybeMarkFacet(mark, topFacetState, options) {\n  if (mark.facet === null || mark.facet === \"super\")\n    return;\n  const { fx, fy } = mark;\n  if (fx != null || fy != null) {\n    const data2 = arrayify2(mark.data ?? fx ?? fy);\n    if (data2 === void 0)\n      throw new Error(`missing facet data in ${mark.ariaLabel}`);\n    if (data2 === null)\n      return;\n    const channels2 = {};\n    if (fx != null)\n      channels2.fx = Channel(data2, { value: fx, scale: \"fx\" });\n    if (fy != null)\n      channels2.fy = Channel(data2, { value: fy, scale: \"fy\" });\n    applyScaleTransforms(channels2, options);\n    return { channels: channels2, groups: facetGroups(data2, channels2) };\n  }\n  if (topFacetState === void 0)\n    return;\n  const { channels, groups: groups2, data } = topFacetState;\n  if (mark.facet !== \"auto\" || mark.data === data)\n    return { channels, groups: groups2 };\n  if ((groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {\n    warn(`Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is \"auto\", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`);\n  }\n}\nfunction inferAxes(marks2, channelsByScale, options) {\n  let { projection: projection2, x: x4 = {}, y: y4 = {}, fx = {}, fy = {}, axis: axis2, grid, facet = {}, facet: { axis: facetAxis = axis2, grid: facetGrid } = facet, x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x4, y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y4, fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx, fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy } = options;\n  if (projection2 || !isScaleOptions(x4) && !hasScaleChannel(\"x\", marks2))\n    xAxis = xGrid = null;\n  if (projection2 || !isScaleOptions(y4) && !hasScaleChannel(\"y\", marks2))\n    yAxis = yGrid = null;\n  if (!channelsByScale.has(\"fx\"))\n    fxAxis = fxGrid = null;\n  if (!channelsByScale.has(\"fy\"))\n    fyAxis = fyGrid = null;\n  if (xAxis === void 0)\n    xAxis = !hasAxis(marks2, \"x\");\n  if (yAxis === void 0)\n    yAxis = !hasAxis(marks2, \"y\");\n  if (fxAxis === void 0)\n    fxAxis = !hasAxis(marks2, \"fx\");\n  if (fyAxis === void 0)\n    fyAxis = !hasAxis(marks2, \"fy\");\n  if (xAxis === true)\n    xAxis = \"bottom\";\n  if (yAxis === true)\n    yAxis = \"left\";\n  if (fxAxis === true)\n    fxAxis = xAxis === \"top\" || xAxis === null ? \"bottom\" : \"top\";\n  if (fyAxis === true)\n    fyAxis = yAxis === \"right\" || yAxis === null ? \"left\" : \"right\";\n  const axes = [];\n  maybeGrid(axes, fyGrid, gridFy, fy);\n  maybeAxis(axes, fyAxis, axisFy, \"right\", \"left\", facet, fy);\n  maybeGrid(axes, fxGrid, gridFx, fx);\n  maybeAxis(axes, fxAxis, axisFx, \"top\", \"bottom\", facet, fx);\n  maybeGrid(axes, yGrid, gridY, y4);\n  maybeAxis(axes, yAxis, axisY, \"left\", \"right\", options, y4);\n  maybeGrid(axes, xGrid, gridX, x4);\n  maybeAxis(axes, xAxis, axisX, \"bottom\", \"top\", options, x4);\n  return axes;\n}\nfunction maybeAxis(axes, axis2, axisType, primary, secondary, defaults21, options) {\n  if (!axis2)\n    return;\n  const both = isBoth(axis2);\n  options = axisOptions(both ? primary : axis2, defaults21, options);\n  const { line: line2 } = options;\n  if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2))\n    axes.push(frame2(lineOptions(options)));\n  axes.push(axisType(options));\n  if (both)\n    axes.push(axisType({ ...options, anchor: secondary, label: null }));\n}\nfunction maybeGrid(axes, grid, gridType, options) {\n  if (!grid || isNone(grid))\n    return;\n  axes.push(gridType(gridOptions(grid, options)));\n}\nfunction isBoth(value) {\n  return /^\\s*both\\s*$/i.test(value);\n}\nfunction axisOptions(anchor, defaults21, { line: line2 = defaults21.line, ticks: ticks2, tickSize, tickSpacing, tickPadding, tickFormat: tickFormat2, tickRotate, fontVariant, ariaLabel, ariaDescription, label = defaults21.label, labelAnchor, labelOffset }) {\n  return {\n    anchor,\n    line: line2,\n    ticks: ticks2,\n    tickSize,\n    tickSpacing,\n    tickPadding,\n    tickFormat: tickFormat2,\n    tickRotate,\n    fontVariant,\n    ariaLabel,\n    ariaDescription,\n    label,\n    labelAnchor,\n    labelOffset\n  };\n}\nfunction lineOptions(options) {\n  const { anchor, line: line2 } = options;\n  return { anchor, facetAnchor: anchor + \"-empty\", stroke: line2 === true ? void 0 : line2 };\n}\nfunction gridOptions(grid, { stroke = isColor(grid) ? grid : void 0, ticks: ticks2 = isGridTicks(grid) ? grid : void 0, tickSpacing, ariaLabel, ariaDescription }) {\n  return {\n    stroke,\n    ticks: ticks2,\n    tickSpacing,\n    ariaLabel,\n    ariaDescription\n  };\n}\nfunction isGridTicks(grid) {\n  switch (typeof grid) {\n    case \"number\":\n      return true;\n    case \"string\":\n      return !isColor(grid);\n  }\n  return isIterable(grid) || typeof grid?.range === \"function\";\n}\nfunction hasAxis(marks2, k2) {\n  const prefix = `${k2}-axis `;\n  return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));\n}\nfunction hasScaleChannel(k2, marks2) {\n  for (const mark of marks2) {\n    for (const key in mark.channels) {\n      if (mark.channels[key].scale === k2) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction inheritScaleLabels(newScales, scales) {\n  for (const key in newScales) {\n    const newScale = newScales[key];\n    const scale3 = scales[key];\n    if (newScale.label === void 0 && scale3) {\n      newScale.label = scale3.label;\n    }\n  }\n  return newScales;\n}\nfunction actualDimensions({ fx, fy }, dimensions) {\n  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);\n  const fxr = fx && outerRange(fx);\n  const fyr = fy && outerRange(fy);\n  return {\n    marginTop: fy ? fyr[0] : marginTop,\n    marginRight: fx ? width - fxr[1] : marginRight,\n    marginBottom: fy ? height - fyr[1] : marginBottom,\n    marginLeft: fx ? fxr[0] : marginLeft,\n    // Some marks, namely the x- and y-axis labels, want to know what the\n    // desired (rather than actual) margins are for positioning.\n    inset: {\n      marginTop: dimensions.marginTop,\n      marginRight: dimensions.marginRight,\n      marginBottom: dimensions.marginBottom,\n      marginLeft: dimensions.marginLeft\n    },\n    width,\n    height\n  };\n}\nfunction outerRange(scale3) {\n  const domain = scale3.domain();\n  let x12 = scale3(domain[0]);\n  let x22 = scale3(domain[domain.length - 1]);\n  if (x22 < x12)\n    [x12, x22] = [x22, x12];\n  return [x12, x22 + scale3.bandwidth()];\n}\n\n// node_modules/@observablehq/plot/dist/curve.js\nvar curves = /* @__PURE__ */ new Map([\n  [\"basis\", basis_default2],\n  [\"basis-closed\", basisClosed_default2],\n  [\"basis-open\", basisOpen_default],\n  [\"bundle\", bundle_default],\n  [\"bump-x\", bumpX],\n  [\"bump-y\", bumpY],\n  [\"cardinal\", cardinal_default],\n  [\"cardinal-closed\", cardinalClosed_default],\n  [\"cardinal-open\", cardinalOpen_default],\n  [\"catmull-rom\", catmullRom_default],\n  [\"catmull-rom-closed\", catmullRomClosed_default],\n  [\"catmull-rom-open\", catmullRomOpen_default],\n  [\"linear\", linear_default],\n  [\"linear-closed\", linearClosed_default],\n  [\"monotone-x\", monotoneX],\n  [\"monotone-y\", monotoneY],\n  [\"natural\", natural_default],\n  [\"step\", step_default],\n  [\"step-after\", stepAfter],\n  [\"step-before\", stepBefore]\n]);\nfunction Curve(curve = linear_default, tension) {\n  if (typeof curve === \"function\")\n    return curve;\n  const c6 = curves.get(`${curve}`.toLowerCase());\n  if (!c6)\n    throw new Error(`unknown curve: ${curve}`);\n  if (tension !== void 0) {\n    if (\"beta\" in c6) {\n      return c6.beta(tension);\n    } else if (\"tension\" in c6) {\n      return c6.tension(tension);\n    } else if (\"alpha\" in c6) {\n      return c6.alpha(tension);\n    }\n  }\n  return c6;\n}\nfunction PathCurve(curve = curveAuto, tension) {\n  return typeof curve !== \"function\" && `${curve}`.toLowerCase() === \"auto\" ? curveAuto : Curve(curve, tension);\n}\nfunction curveAuto(context) {\n  return linear_default(context);\n}\n\n// node_modules/@observablehq/plot/dist/transforms/bin.js\nfunction binX(outputs = { y: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(maybeBinValue(x4, options, identity6), null, null, y4, outputs, maybeInsetX(options));\n}\nfunction binY(outputs = { x: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = options;\n  return binn(null, maybeBinValue(y4, options, identity6), x4, null, outputs, maybeInsetY(options));\n}\nfunction bin2(outputs = { fill: \"count\" }, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const { x: x4, y: y4 } = maybeBinValueTuple(options);\n  return binn(x4, y4, null, null, outputs, maybeInsetX(maybeInsetY(options)));\n}\nfunction maybeDenseInterval(bin3, k2, options = {}) {\n  return options?.interval == null ? options : bin3({ [k2]: options?.reduce === void 0 ? reduceFirst : options.reduce, filter: null }, options);\n}\nfunction maybeDenseIntervalX(options) {\n  return maybeDenseInterval(binX, \"y\", options);\n}\nfunction maybeDenseIntervalY(options) {\n  return maybeDenseInterval(binY, \"x\", options);\n}\nfunction binn(bx, by, gx, gy, {\n  data: reduceData = reduceIdentity,\n  // TODO avoid materializing when unused?\n  filter: filter4 = reduceCount,\n  // return only non-empty bins by default\n  sort: sort3,\n  reverse: reverse3,\n  ...outputs\n  // output channel definitions\n} = {}, inputs = {}) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n  outputs = maybeOutputs(outputs, inputs);\n  reduceData = maybeReduce(reduceData, identity6);\n  sort3 = sort3 == null ? void 0 : maybeOutput(\"sort\", sort3, inputs);\n  filter4 = filter4 == null ? void 0 : maybeEvaluator(\"filter\", filter4, inputs);\n  if (gx != null && hasOutput(outputs, \"x\", \"x1\", \"x2\"))\n    gx = null;\n  if (gy != null && hasOutput(outputs, \"y\", \"y1\", \"y2\"))\n    gy = null;\n  const [BX1, setBX1] = maybeColumn(bx);\n  const [BX2, setBX2] = maybeColumn(bx);\n  const [BY1, setBY1] = maybeColumn(by);\n  const [BY2, setBY2] = maybeColumn(by);\n  const [k2, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = maybeColumn(k2);\n  const {\n    x: x4,\n    y: y4,\n    z,\n    fill,\n    stroke,\n    x1: x12,\n    x2: x22,\n    // consumed if x is an output\n    y1: y12,\n    y2: y22,\n    // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval: interval2,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...\"z\" in inputs && { z: GZ || z },\n    ...\"fill\" in inputs && { fill: GF || fill },\n    ...\"stroke\" in inputs && { stroke: GS || stroke },\n    ...basic(options, (data, facets) => {\n      const K2 = valueof(data, k2);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S });\n      const groupFacets = [];\n      const groupData = [];\n      const GK2 = K2 && setGK([]);\n      const GZ2 = Z && setGZ([]);\n      const GF2 = F && setGF([]);\n      const GS2 = S && setGS([]);\n      const BX12 = bx && setBX1([]);\n      const BX22 = bx && setBX2([]);\n      const BY12 = by && setBY1([]);\n      const BY22 = by && setBY2([]);\n      const bin3 = Bin(bx?.(data), by?.(data));\n      let i = 0;\n      for (const o of outputs)\n        o.initialize(data);\n      if (sort3)\n        sort3.initialize(data);\n      if (filter4)\n        filter4.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs)\n          o.scope(\"facet\", facet);\n        if (sort3)\n          sort3.scope(\"facet\", facet);\n        if (filter4)\n          filter4.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [k3, g] of maybeGroup(I, K2)) {\n            for (const [b, extent3] of bin3(g)) {\n              if (filter4 && !filter4.reduce(b, extent3))\n                continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduce(b, data, extent3));\n              if (K2)\n                GK2.push(k3);\n              if (Z)\n                GZ2.push(G === Z ? f : Z[b[0]]);\n              if (F)\n                GF2.push(G === F ? f : F[b[0]]);\n              if (S)\n                GS2.push(G === S ? f : S[b[0]]);\n              if (BX12)\n                BX12.push(extent3.x1), BX22.push(extent3.x2);\n              if (BY12)\n                BY12.push(extent3.y1), BY22.push(extent3.y2);\n              for (const o of outputs)\n                o.reduce(b, extent3);\n              if (sort3)\n                sort3.reduce(b);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort3, reverse3);\n      return { data: groupData, facets: groupFacets };\n    }),\n    ...!hasOutput(outputs, \"x\") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x4, x1: x12, x2: x22 }),\n    ...!hasOutput(outputs, \"y\") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y4, y1: y12, y2: y22 }),\n    ...GK && { [gk]: GK },\n    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))\n  };\n}\nfunction mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {\n  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];\n}\nfunction maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {\n  value = { ...maybeValue(value) };\n  if (value.domain === void 0)\n    value.domain = domain;\n  if (value.cumulative === void 0)\n    value.cumulative = cumulative;\n  if (value.thresholds === void 0)\n    value.thresholds = thresholds;\n  if (value.interval === void 0)\n    value.interval = interval2;\n  if (value.value === void 0)\n    value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\nfunction maybeBinValueTuple(options) {\n  let { x: x4, y: y4 } = options;\n  x4 = maybeBinValue(x4, options);\n  y4 = maybeBinValue(y4, options);\n  [x4.value, y4.value] = maybeTuple(x4.value, y4.value);\n  return { x: x4, y: y4 };\n}\nfunction maybeBin(options) {\n  if (options == null)\n    return;\n  const { value, cumulative, domain = extent, thresholds } = options;\n  const bin3 = (data) => {\n    let V = valueof(data, value);\n    let T;\n    if (isTemporal(V) || isTimeThresholds(thresholds)) {\n      V = map4(V, coerceDate, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\")\n        t = utcTickInterval(min4, max5, t);\n      if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    } else {\n      V = map4(V, coerceNumber, Float64Array);\n      let [min4, max5] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min4, max5) : thresholds;\n      if (typeof t === \"number\") {\n        if (domain === extent) {\n          let step = tickIncrement(min4, max5, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min4 / step);\n              let r1 = Math.round(max5 / step);\n              if (!(r0 * step <= min4))\n                --r0;\n              if (!(r1 * step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min4 * step);\n              let r1 = Math.round(max5 * step);\n              if (!(r0 / step <= min4))\n                --r0;\n              if (!(r1 / step > max5))\n                ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i)\n                t[i] = (r0 + i) / step;\n            } else {\n              t = [min4];\n            }\n          } else {\n            t = [min4];\n          }\n        } else {\n          t = ticks(min4, max5, t);\n        }\n      } else if (isInterval(t)) {\n        if (domain === extent) {\n          min4 = t.floor(min4);\n          max5 = t.offset(t.floor(max5));\n        }\n        t = t.range(min4, t.offset(max5));\n      }\n      T = t;\n    }\n    const E2 = [];\n    if (T.length === 1)\n      E2.push([T[0], T[0]]);\n    else\n      for (let i = 1; i < T.length; ++i)\n        E2.push([T[i - 1], T[i]]);\n    E2.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E2, T, V);\n    return E2;\n  };\n  bin3.label = labelof(value);\n  return bin3;\n}\nfunction maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {\n  if (thresholds === void 0) {\n    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return thresholdFreedmanDiaconis;\n      case \"scott\":\n        return thresholdScott;\n      case \"sturges\":\n        return thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    const interval3 = maybeInterval(thresholds);\n    if (interval3 !== void 0)\n      return interval3;\n    throw new Error(`invalid thresholds: ${thresholds}`);\n  }\n  return thresholds;\n}\nfunction maybeRangeInterval(interval2) {\n  interval2 = maybeInterval(interval2);\n  if (!isInterval(interval2))\n    throw new Error(`invalid interval: ${interval2}`);\n  return interval2;\n}\nfunction thresholdAuto(values2, min4, max5) {\n  return Math.min(200, thresholdScott(values2, min4, max5));\n}\nfunction isTimeThresholds(t) {\n  return isTimeInterval(t) || isIterable(t) && isTemporal(t);\n}\nfunction isTimeInterval(t) {\n  return isInterval(t) && typeof t === \"function\" && t() instanceof Date;\n}\nfunction isInterval(t) {\n  return t ? typeof t.range === \"function\" : false;\n}\nfunction Bin(EX, EY) {\n  return EX && EY ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [ix, [x12, x22]] of EX.entries()) {\n      const Y3 = EY.bin(X3[ix]);\n      for (const [iy, [y12, y22]] of EY.entries()) {\n        yield [Y3[iy], { x1: x12, y1: y12, x2: x22, y2: y22 }];\n      }\n    }\n  } : EX ? function* (I) {\n    const X3 = EX.bin(I);\n    for (const [i, [x12, x22]] of EX.entries()) {\n      yield [X3[i], { x1: x12, x2: x22 }];\n    }\n  } : function* (I) {\n    const Y3 = EY.bin(I);\n    for (const [i, [y12, y22]] of EY.entries()) {\n      yield [Y3[i], { y1: y12, y2: y22 }];\n    }\n  };\n}\nfunction bin1(E2, T, V) {\n  T = T.map(coerceNumber);\n  return (I) => {\n    const B3 = E2.map(() => []);\n    for (const i of I)\n      B3[bisect_default(T, V[i]) - 1]?.push(i);\n    return B3;\n  };\n}\nfunction bin1cp(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = 1, n = B3.length; i < n; ++i) {\n      const C3 = B3[i - 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\nfunction bin1cn(E2, T, V) {\n  const bin3 = bin1(E2, T, V);\n  return (I) => {\n    const B3 = bin3(I);\n    for (let i = B3.length - 2; i >= 0; --i) {\n      const C3 = B3[i + 1];\n      const b = B3[i];\n      for (const j of C3)\n        b.push(j);\n    }\n    return B3;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/identity.js\nfunction maybeIdentityX(options = {}) {\n  const { x: x4, x1: x12, x2: x22 } = options;\n  return x12 === void 0 && x22 === void 0 && x4 === void 0 ? { ...options, x: identity6 } : options;\n}\nfunction maybeIdentityY(options = {}) {\n  const { y: y4, y1: y12, y2: y22 } = options;\n  return y12 === void 0 && y22 === void 0 && y4 === void 0 ? { ...options, y: identity6 } : options;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/stack.js\nfunction stackX(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4, ...rest } = options;\n  const [transform2, Y3, x12, x22] = stackAlias(y4, x4, \"x\", stack2, rest);\n  return { ...transform2, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };\n}\nfunction stackX1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackX2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { y1: y12, y: y4 = y12, x: x4 } = options;\n  const [transform2, Y3, , X3] = stackAlias(y4, x4, \"x\", stack2, options);\n  return { ...transform2, y1: y12, y: Y3, x: X3 };\n}\nfunction stackY(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4, ...rest } = options;\n  const [transform2, X3, y12, y22] = stackAlias(x4, y4, \"y\", stack2, rest);\n  return { ...transform2, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };\n}\nfunction stackY1(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction stackY2(stack2 = {}, options = {}) {\n  if (arguments.length === 1)\n    [stack2, options] = mergeOptions2(stack2);\n  const { x1: x12, x: x4 = x12, y: y4 } = options;\n  const [transform2, X3, , Y3] = stackAlias(x4, y4, \"y\", stack2, options);\n  return { ...transform2, x1: x12, x: X3, y: Y3 };\n}\nfunction maybeStackX({ x: x4, x1: x12, x2: x22, ...options } = {}) {\n  if (x12 === void 0 && x22 === void 0)\n    return stackX({ x: x4, ...options });\n  [x12, x22] = maybeZero(x4, x12, x22);\n  return { ...options, x1: x12, x2: x22 };\n}\nfunction maybeStackY({ y: y4, y1: y12, y2: y22, ...options } = {}) {\n  if (y12 === void 0 && y22 === void 0)\n    return stackY({ y: y4, ...options });\n  [y12, y22] = maybeZero(y4, y12, y22);\n  return { ...options, y1: y12, y2: y22 };\n}\nfunction mergeOptions2(options) {\n  const { offset: offset2, order, reverse: reverse3, ...rest } = options;\n  return [{ offset: offset2, order, reverse: reverse3 }, rest];\n}\nfunction stack(x4, y4 = one2, ky2, { offset: offset2, order, reverse: reverse3 }, options) {\n  const z = maybeZ(options);\n  const [X3, setX] = maybeColumn(x4);\n  const [Y13, setY1] = column(y4);\n  const [Y23, setY2] = column(y4);\n  offset2 = maybeOffset(offset2);\n  order = maybeOrder(order, offset2, ky2);\n  return [\n    basic(options, (data, facets) => {\n      const X4 = x4 == null ? void 0 : setX(valueof(data, x4));\n      const Y3 = valueof(data, y4, Float64Array);\n      const Z = valueof(data, z);\n      const O = order && order(data, X4, Y3, Z);\n      const n = data.length;\n      const Y14 = setY1(new Float64Array(n));\n      const Y24 = setY2(new Float64Array(n));\n      const facetstacks = [];\n      for (const facet of facets) {\n        const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];\n        if (O)\n          applyOrder(stacks, O);\n        for (const stack2 of stacks) {\n          let yn = 0, yp = 0;\n          if (reverse3)\n            stack2.reverse();\n          for (const i of stack2) {\n            const y5 = Y3[i];\n            if (y5 < 0)\n              yn = Y24[i] = (Y14[i] = yn) + y5;\n            else if (y5 > 0)\n              yp = Y24[i] = (Y14[i] = yp) + y5;\n            else\n              Y24[i] = Y14[i] = yp;\n          }\n        }\n        facetstacks.push(stacks);\n      }\n      if (offset2)\n        offset2(facetstacks, Y14, Y24, Z);\n      return { data, facets };\n    }),\n    X3,\n    Y13,\n    Y23\n  ];\n}\nvar stackAlias = stack;\nfunction maybeOffset(offset2) {\n  if (offset2 == null)\n    return;\n  if (typeof offset2 === \"function\")\n    return offset2;\n  switch (`${offset2}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset2}`);\n}\nfunction extent2(stack2, Y23) {\n  let min4 = 0, max5 = 0;\n  for (const i of stack2) {\n    const y4 = Y23[i];\n    if (y4 < min4)\n      min4 = y4;\n    if (y4 > max5)\n      max5 = y4;\n  }\n  return [min4, max5];\n}\nfunction offsetExpand(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = 1 / (yp - yn || 1);\n        Y13[i] = m3 * (Y13[i] - yn);\n        Y23[i] = m3 * (Y23[i] - yn);\n      }\n    }\n  }\n}\nfunction offsetCenter(facetstacks, Y13, Y23) {\n  for (const stacks of facetstacks) {\n    for (const stack2 of stacks) {\n      const [yn, yp] = extent2(stack2, Y23);\n      for (const i of stack2) {\n        const m3 = (yp + yn) / 2;\n        Y13[i] -= m3;\n        Y23[i] -= m3;\n      }\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetWiggle(facetstacks, Y13, Y23, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new InternMap();\n    let y4 = 0;\n    for (const stack2 of stacks) {\n      let j = -1;\n      const Fi = stack2.map((i) => Math.abs(Y23[i] - Y13[i]));\n      const Df = stack2.map((i) => {\n        j = Z ? Z[i] : ++j;\n        const value = Y23[i] - Y13[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...cumsum(Df)];\n      for (const i of stack2) {\n        Y13[i] += y4;\n        Y23[i] += y4;\n      }\n      const s1 = sum(Fi);\n      if (s1)\n        y4 -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y13, Y23);\n  }\n  offsetCenterFacets(facetstacks, Y13, Y23);\n}\nfunction offsetZero(stacks, Y13, Y23) {\n  const m3 = min(stacks, (stack2) => min(stack2, (i) => Y13[i]));\n  for (const stack2 of stacks) {\n    for (const i of stack2) {\n      Y13[i] -= m3;\n      Y23[i] -= m3;\n    }\n  }\n}\nfunction offsetCenterFacets(facetstacks, Y13, Y23) {\n  const n = facetstacks.length;\n  if (n === 1)\n    return;\n  const facets = facetstacks.map((stacks) => stacks.flat());\n  const m3 = facets.map((I) => (min(I, (i) => Y13[i]) + max(I, (i) => Y23[i])) / 2);\n  const m0 = min(m3);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m3[j];\n    for (const i of facets[j]) {\n      Y13[i] += p;\n      Y23[i] += p;\n    }\n  }\n}\nfunction maybeOrder(order, offset2, ky2) {\n  if (order === void 0 && offset2 === offsetWiggle)\n    return orderInsideOut;\n  if (order == null)\n    return;\n  if (typeof order === \"string\") {\n    switch (order.toLowerCase()) {\n      case \"value\":\n      case ky2:\n        return orderY;\n      case \"z\":\n        return orderZ;\n      case \"sum\":\n        return orderSum;\n      case \"appearance\":\n        return orderAppearance;\n      case \"inside-out\":\n        return orderInsideOut;\n    }\n    return orderFunction(field(order));\n  }\n  if (typeof order === \"function\")\n    return orderFunction(order);\n  if (Array.isArray(order))\n    return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\nfunction orderY(data, X3, Y3) {\n  return Y3;\n}\nfunction orderZ(order, X3, Y3, Z) {\n  return Z;\n}\nfunction orderSum(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => sum(I, (i) => Y3[i]), (i) => Z[i]));\n}\nfunction orderAppearance(data, X3, Y3, Z) {\n  return orderZDomain(Z, groupSort(range4(data), (I) => X3[greatest(I, (i) => Y3[i])], (i) => Z[i]));\n}\nfunction orderInsideOut(data, X3, Y3, Z) {\n  const I = range4(data);\n  const K2 = groupSort(I, (I2) => X3[greatest(I2, (i) => Y3[i])], (i) => Z[i]);\n  const sums = rollup(I, (I2) => sum(I2, (i) => Y3[i]), (i) => Z[i]);\n  const Kp = [], Kn = [];\n  let s2 = 0;\n  for (const k2 of K2) {\n    if (s2 < 0) {\n      s2 += sums.get(k2);\n      Kp.push(k2);\n    } else {\n      s2 -= sums.get(k2);\n      Kn.push(k2);\n    }\n  }\n  return orderZDomain(Z, Kn.reverse().concat(Kp));\n}\nfunction orderFunction(f) {\n  return (data) => valueof(data, f);\n}\nfunction orderGiven(domain) {\n  return (data, X3, Y3, Z) => orderZDomain(Z, domain);\n}\nfunction orderZDomain(Z, domain) {\n  if (!Z)\n    throw new Error(\"missing channel: z\");\n  domain = new InternMap(domain.map((d, i) => [d, i]));\n  return Z.map((z) => domain.get(z));\n}\nfunction applyOrder(stacks, O) {\n  for (const stack2 of stacks) {\n    stack2.sort((i, j) => ascendingDefined2(O[i], O[j]));\n  }\n}\n\n// node_modules/@observablehq/plot/dist/marks/area.js\nvar defaults5 = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Area = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, z, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults5);\n    this.z = z;\n    this.curve = Curve(curve, tension);\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call((g) => g.selectAll().data(groupIndex(index3, [X13, Y13, X23, Y23], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(\"d\", area_default5().curve(this.curve).defined((i) => i >= 0).x0((i) => X13[i]).y0((i) => Y13[i]).x1((i) => X23[i]).y1((i) => Y23[i]))).node();\n  }\n};\nfunction area(data, options) {\n  if (options === void 0)\n    return areaY(data, { x: first, y: second2 });\n  return new Area(data, options);\n}\nfunction areaX(data, options) {\n  const { y: y4 = indexOf, ...rest } = maybeDenseIntervalY(options);\n  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y4, y2: void 0 })));\n}\nfunction areaY(data, options) {\n  const { x: x4 = indexOf, ...rest } = maybeDenseIntervalX(options);\n  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x4, x2: void 0 })));\n}\n\n// node_modules/@observablehq/plot/dist/marks/marker.js\nfunction markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {\n  mark.markerStart = maybeMarker(markerStart);\n  mark.markerMid = maybeMarker(markerMid);\n  mark.markerEnd = maybeMarker(markerEnd);\n}\nfunction maybeMarker(marker) {\n  if (marker == null || marker === false)\n    return null;\n  if (marker === true)\n    return markerCircleFill;\n  if (typeof marker === \"function\")\n    return marker;\n  switch (`${marker}`.toLowerCase()) {\n    case \"none\":\n      return null;\n    case \"arrow\":\n      return markerArrow;\n    case \"dot\":\n      return markerDot;\n    case \"circle\":\n    case \"circle-fill\":\n      return markerCircleFill;\n    case \"circle-stroke\":\n      return markerCircleStroke;\n  }\n  throw new Error(`invalid marker: ${marker}`);\n}\nfunction markerArrow(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"orient\", \"auto\").attr(\"fill\", \"none\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).attr(\"stroke-linecap\", \"round\").attr(\"stroke-linejoin\", \"round\").call((marker) => marker.append(\"path\").attr(\"d\", \"M-1.5,-3l3,3l-3,3\")).node();\n}\nfunction markerDot(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"none\").call((marker) => marker.append(\"circle\").attr(\"r\", 2.5)).node();\n}\nfunction markerCircleFill(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", color3).attr(\"stroke\", \"white\").attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nfunction markerCircleStroke(color3, context) {\n  return create2(\"svg:marker\", context).attr(\"viewBox\", \"-5 -5 10 10\").attr(\"markerWidth\", 6.67).attr(\"markerHeight\", 6.67).attr(\"fill\", \"white\").attr(\"stroke\", color3).attr(\"stroke-width\", 1.5).call((marker) => marker.append(\"circle\").attr(\"r\", 3)).node();\n}\nvar nextMarkerId = 0;\nfunction applyMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && ((i) => S[i]));\n}\nfunction applyGroupedMarkers(path2, mark, { stroke: S } = {}) {\n  return applyMarkersColor(path2, mark, S && (([i]) => S[i]));\n}\nfunction applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke) {\n  const iriByMarkerColor = /* @__PURE__ */ new Map();\n  function applyMarker(marker) {\n    return function(i) {\n      const color3 = strokeof(i);\n      let iriByColor = iriByMarkerColor.get(marker);\n      if (!iriByColor)\n        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());\n      let iri = iriByColor.get(color3);\n      if (!iri) {\n        const context = { document: this.ownerDocument };\n        const node = this.parentNode.insertBefore(marker(color3, context), this);\n        const id2 = `plot-marker-${++nextMarkerId}`;\n        node.setAttribute(\"id\", id2);\n        iriByColor.set(color3, iri = `url(#${id2})`);\n      }\n      return iri;\n    };\n  }\n  if (markerStart)\n    path2.attr(\"marker-start\", applyMarker(markerStart));\n  if (markerMid)\n    path2.attr(\"marker-mid\", applyMarker(markerMid));\n  if (markerEnd)\n    path2.attr(\"marker-end\", applyMarker(markerEnd));\n}\n\n// node_modules/@observablehq/plot/dist/marks/link.js\nvar defaults6 = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Link = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, curve, tension } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults6);\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", curve === curveAuto && context.projection ? sphereLink(context.projection, X13, Y13, X23, Y23) : (i) => {\n      const p = pathRound();\n      const c6 = curve(p);\n      c6.lineStart();\n      c6.point(X13[i], Y13[i]);\n      c6.point(X23[i], Y23[i]);\n      c6.lineEnd();\n      return p;\n    }).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels)).node();\n  }\n};\nfunction sphereLink(projection2, X13, Y13, X23, Y23) {\n  const path2 = path_default(projection2);\n  X13 = coerceNumbers(X13);\n  Y13 = coerceNumbers(Y13);\n  X23 = coerceNumbers(X23);\n  Y23 = coerceNumbers(Y23);\n  return (i) => path2({\n    type: \"LineString\",\n    coordinates: [\n      [X13[i], Y13[i]],\n      [X23[i], Y23[i]]\n    ]\n  });\n}\nfunction link3(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Link(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\nfunction maybeSameValue(x4, x12, x22) {\n  if (x4 === void 0) {\n    if (x12 === void 0) {\n      if (x22 !== void 0)\n        return [x22];\n    } else {\n      if (x22 === void 0)\n        return [x12];\n    }\n  } else if (x12 === void 0) {\n    return x22 === void 0 ? [x4] : [x4, x22];\n  } else if (x22 === void 0) {\n    return [x4, x12];\n  }\n  return [x12, x22];\n}\n\n// node_modules/@observablehq/plot/dist/marks/arrow.js\nvar defaults7 = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\nvar Arrow = class extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1: x12,\n      y1: y12,\n      x2: x22,\n      y2: y22,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8,\n      // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset\n    } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      y1: { value: y12, scale: \"y\" },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults7);\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13, SW } = channels;\n    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;\n    const sw = SW ? (i) => SW[i] : constant2(strokeWidth === void 0 ? 1 : strokeWidth);\n    const bendAngle = bend * radians3;\n    const wingAngle = headAngle * radians3 / 2;\n    const wingScale = headLength / 1.5;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => {\n      let x12 = X13[i], y12 = Y13[i], x22 = X23[i], y22 = Y23[i];\n      const lineLength = Math.hypot(x22 - x12, y22 - y12);\n      if (lineLength <= insetStart + insetEnd)\n        return null;\n      let lineAngle = Math.atan2(y22 - y12, x22 - x12);\n      const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);\n      const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n      if (insetStart || insetEnd) {\n        if (r < 1e5) {\n          const sign3 = Math.sign(bendAngle);\n          const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r, sign3);\n          if (insetStart) {\n            [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));\n          }\n          if (insetEnd) {\n            const [x5, y5] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign3 * Math.sign(insetEnd));\n            lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);\n            x22 = x5, y22 = y5;\n          }\n        } else {\n          const dx = x22 - x12, dy = y22 - y12, d = Math.hypot(dx, dy);\n          if (insetStart)\n            x12 += dx / d * insetStart, y12 += dy / d * insetStart;\n          if (insetEnd)\n            x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;\n        }\n      }\n      const endAngle = lineAngle + bendAngle;\n      const leftAngle = endAngle + wingAngle;\n      const rightAngle = endAngle - wingAngle;\n      const x32 = x22 - headLength2 * Math.cos(leftAngle);\n      const y32 = y22 - headLength2 * Math.sin(leftAngle);\n      const x4 = x22 - headLength2 * Math.cos(rightAngle);\n      const y4 = y22 - headLength2 * Math.sin(rightAngle);\n      return `M${x12},${y12}${r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`}${x22},${y22}M${x32},${y32}L${x22},${y22}L${x4},${y4}`;\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction pointPointCenter([ax, ay], [bx, by], r, sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const k2 = sign3 * Math.sqrt(r * r - d * d / 4) / d;\n  return [(ax + bx) / 2 - dy * k2, (ay + by) / 2 + dx * k2];\n}\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {\n  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);\n  const x4 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y4 = sign3 * Math.sqrt(ar * ar - x4 * x4);\n  return [ax + (dx * x4 + dy * y4) / d, ay + (dy * x4 - dx * y4) / d];\n}\nfunction arrow(data, options = {}) {\n  let { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...remainingOptions } = options;\n  [x12, x22] = maybeSameValue(x4, x12, x22);\n  [y12, y22] = maybeSameValue(y4, y12, y22);\n  return new Arrow(data, { ...remainingOptions, x1: x12, x2: x22, y1: y12, y2: y22 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/dot.js\nvar defaults8 = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\nfunction withDefaultSort(options) {\n  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: \"r\", order: \"descending\" }, options) : options;\n}\nvar Dot = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, r, rotate, symbol: symbol2 = circle_default3, frameAnchor } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);\n    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true },\n      rotate: { value: vrotate, optional: true },\n      symbol: { value: vsymbol, scale: \"auto\", optional: true }\n    }, withDefaultSort(options), defaults8);\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    const { channels } = this;\n    const { symbol: symbolChannel } = channels;\n    if (symbolChannel) {\n      const { fill: fillChannel, stroke: strokeChannel } = channels;\n      symbolChannel.hint = {\n        fill: fillChannel ? fillChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.fill,\n        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.stroke\n      };\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, r: R, rotate: A5, symbol: S } = channels;\n    const { r, rotate, symbol: symbol2 } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const circle2 = this.symbol === circle_default3;\n    const size = R ? void 0 : r * r * Math.PI;\n    if (negative(r))\n      index3 = [];\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(circle2 ? \"circle\" : \"path\").call(applyDirectStyles, this).call(circle2 ? (selection2) => {\n      selection2.attr(\"cx\", X3 ? (i) => X3[i] : cx).attr(\"cy\", Y3 ? (i) => Y3[i] : cy).attr(\"r\", R ? (i) => R[i] : r);\n    } : (selection2) => {\n      selection2.attr(\"transform\", template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}`).attr(\"d\", R && S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : R ? (i) => {\n        const p = pathRound();\n        symbol2.draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : S ? (i) => {\n        const p = pathRound();\n        S[i].draw(p, size);\n        return p;\n      } : (() => {\n        const p = pathRound();\n        symbol2.draw(p, size);\n        return p;\n      })());\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction dot(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Dot(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction dotX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidY({ ...remainingOptions, x: x4 }));\n}\nfunction dotY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new Dot(data, maybeIntervalMidX({ ...remainingOptions, y: y4 }));\n}\nfunction circle(data, options) {\n  return dot(data, { ...options, symbol: \"circle\" });\n}\nfunction hexagon(data, options) {\n  return dot(data, { ...options, symbol: \"hexagon\" });\n}\n\n// node_modules/@observablehq/plot/dist/marks/line.js\nvar defaults9 = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Line = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults9);\n    this.z = z;\n    this.curve = PathCurve(curve, tension);\n    markers(this, options);\n  }\n  filter(index3) {\n    return index3;\n  }\n  project(channels, values2, context) {\n    if (this.curve !== curveAuto) {\n      super.project(channels, values2, context);\n    }\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3 } = channels;\n    const { curve } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(groupIndex(index3, [X3, Y3], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels).attr(\"d\", curve === curveAuto && context.projection ? sphereLine(context.projection, X3, Y3) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i]))).node();\n  }\n};\nfunction sphereLine(projection2, X3, Y3) {\n  const path2 = path_default(projection2);\n  X3 = coerceNumbers(X3);\n  Y3 = coerceNumbers(Y3);\n  return (I) => {\n    let line2 = [];\n    const lines = [line2];\n    for (const i of I) {\n      if (i === -1) {\n        line2 = [];\n        lines.push(line2);\n      } else {\n        line2.push([X3[i], Y3[i]]);\n      }\n    }\n    return path2({ type: \"MultiLineString\", coordinates: lines });\n  };\n}\nfunction line(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Line(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction lineX(data, options = {}) {\n  const { x: x4 = identity6, y: y4 = indexOf, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4 }));\n}\nfunction lineY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, ...remainingOptions } = options;\n  return new Line(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4 }));\n}\n\n// node_modules/@observablehq/plot/dist/marks/bar.js\nvar AbstractBar = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    super(data, channels, options, defaults21);\n    const { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", this._x(scales, channels, dimensions)).attr(\"width\", this._width(scales, channels, dimensions)).attr(\"y\", this._y(scales, channels, dimensions)).attr(\"height\", this._height(scales, channels, dimensions)).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n  _x(scales, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _y(scales, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _width({ x: x4 }, { x: X3 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    const bandwidth = X3 && x4 ? x4.bandwidth() : width - marginRight - marginLeft;\n    return Math.max(0, bandwidth - insetLeft - insetRight);\n  }\n  _height({ y: y4 }, { y: Y3 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    const bandwidth = Y3 && y4 ? y4.bandwidth() : height - marginTop - marginBottom;\n    return Math.max(0, bandwidth - insetTop - insetBottom);\n  }\n};\nvar defaults10 = {\n  ariaLabel: \"bar\"\n};\nvar BarX = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x1: x12, x2: x22, y: y4 } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\" },\n      x2: { value: x22, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, 0, 0);\n  }\n  _x({ x: x4 }, { x1: X13, x2: X23 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return isCollapsed(x4) ? marginLeft + insetLeft : (i) => Math.min(X13[i], X23[i]) + insetLeft;\n  }\n  _width({ x: x4 }, { x1: X13, x2: X23 }, { marginRight, marginLeft, width }) {\n    const { insetLeft, insetRight } = this;\n    return isCollapsed(x4) ? width - marginRight - marginLeft - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight);\n  }\n};\nvar BarY = class extends AbstractBar {\n  constructor(data, options = {}) {\n    const { x: x4, y1: y12, y2: y22 } = options;\n    super(data, {\n      y1: { value: y12, scale: \"y\" },\n      y2: { value: y22, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options, defaults10);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, 0);\n  }\n  _y({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop }) {\n    const { insetTop } = this;\n    return isCollapsed(y4) ? marginTop + insetTop : (i) => Math.min(Y13[i], Y23[i]) + insetTop;\n  }\n  _height({ y: y4 }, { y1: Y13, y2: Y23 }, { marginTop, marginBottom, height }) {\n    const { insetTop, insetBottom } = this;\n    return isCollapsed(y4) ? height - marginTop - marginBottom - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y23[i] - Y13[i]) - insetTop - insetBottom);\n  }\n};\nfunction barX(data, options = { y: indexOf, x2: identity6 }) {\n  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));\n}\nfunction barY(data, options = { x: indexOf, y2: identity6 }) {\n  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/rect.js\nvar defaults11 = {\n  ariaLabel: \"rect\"\n};\nvar Rect = class extends Mark {\n  constructor(data, options = {}) {\n    const { x1: x12, y1: y12, x2: x22, y2: y22, inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset, rx, ry } = options;\n    super(data, {\n      x1: { value: x12, scale: \"x\", optional: true },\n      y1: { value: y12, scale: \"y\", optional: true },\n      x2: { value: x22, scale: \"x\", optional: true },\n      y2: { value: y22, scale: \"y\", optional: true }\n    }, options, defaults11);\n    this.insetTop = number5(insetTop);\n    this.insetRight = number5(insetRight);\n    this.insetBottom = number5(insetBottom);\n    this.insetLeft = number5(insetLeft);\n    this.rx = impliedString(rx, \"auto\");\n    this.ry = impliedString(ry, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x1: X13, y1: Y13, x2: X23, y2: Y23 } = channels;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const { projection: projection2 } = context;\n    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X13 && X23 && x4, y: Y13 && Y23 && y4 }, 0, 0).call((g) => g.selectAll().data(index3).enter().append(\"rect\").call(applyDirectStyles, this).attr(\"x\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.min(X13[i], X23[i]) + insetLeft : marginLeft + insetLeft).attr(\"y\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.min(Y13[i], Y23[i]) + insetTop : marginTop + insetTop).attr(\"width\", X13 && X23 && (projection2 || !isCollapsed(x4)) ? (i) => Math.max(0, Math.abs(X23[i] - X13[i]) - insetLeft - insetRight) : width - marginRight - marginLeft - insetRight - insetLeft).attr(\"height\", Y13 && Y23 && (projection2 || !isCollapsed(y4)) ? (i) => Math.max(0, Math.abs(Y13[i] - Y23[i]) - insetTop - insetBottom) : height - marginTop - marginBottom - insetTop - insetBottom).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction rect(data, options) {\n  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));\n}\nfunction rectX(data, options = { y: indexOf, interval: 1, x2: identity6 }) {\n  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));\n}\nfunction rectY(data, options = { x: indexOf, interval: 1, y2: identity6 }) {\n  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));\n}\n\n// node_modules/@observablehq/plot/dist/marks/cell.js\nvar defaults12 = {\n  ariaLabel: \"cell\"\n};\nvar Cell = class extends AbstractBar {\n  constructor(data, { x: x4, y: y4, ...options } = {}) {\n    super(data, {\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options, defaults12);\n  }\n  _transform(selection2, mark) {\n    selection2.call(applyTransform, mark, {}, 0, 0);\n  }\n};\nfunction cell(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Cell(data, { ...remainingOptions, x: x4, y: y4 });\n}\nfunction cellX(data, options = {}) {\n  let { x: x4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, x: x4, fill, stroke });\n}\nfunction cellY(data, options = {}) {\n  let { y: y4 = indexOf, fill, stroke, ...remainingOptions } = options;\n  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)\n    fill = identity6;\n  return new Cell(data, { ...remainingOptions, y: y4, fill, stroke });\n}\n\n// node_modules/@observablehq/plot/dist/marks/auto.js\nfunction autoSpec(data, options) {\n  options = normalizeOptions(options);\n  let {\n    fx,\n    fy,\n    x: { value: xValue, reduce: xReduce, zero: xZero, ...xOptions },\n    y: { value: yValue, reduce: yReduce, zero: yZero, ...yOptions },\n    color: { value: colorValue, color: colorColor, reduce: colorReduce },\n    size: { value: sizeValue, reduce: sizeReduce },\n    // TODO constant radius?\n    mark\n  } = options;\n  const { x: x4, y: y4 } = options;\n  let X3, Y3;\n  if (xReduce === void 0)\n    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === void 0)\n    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n  if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3 ??= materializeValue(data, x4))) && (yValue == null || isOrdinal(Y3 ??= materializeValue(data, y4)))) {\n    sizeReduce = \"count\";\n  }\n  if (xZero === void 0)\n    xZero = isZeroReducer(xReduce) ? true : void 0;\n  if (yZero === void 0)\n    yZero = isZeroReducer(yReduce) ? true : void 0;\n  if (xValue == null && yValue == null)\n    throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null)\n    throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null)\n    throw new Error(\"reducing y requires x\");\n  if (mark === void 0) {\n    mark = sizeValue != null || sizeReduce != null ? \"dot\" : xZero || yZero || colorReduce != null ? \"bar\" : xValue != null && yValue != null ? isOrdinal(X3 ??= materializeValue(data, x4)) || isOrdinal(Y3 ??= materializeValue(data, y4)) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? \"dot\" : \"line\" : xValue != null || yValue != null ? \"rule\" : null;\n  }\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      ...xZero !== void 0 && { zero: xZero },\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      ...yZero !== void 0 && { zero: yZero },\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...colorColor !== void 0 && { color: colorColor }\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark\n  };\n}\nfunction auto(data, options) {\n  options = normalizeOptions(options);\n  const { x: x4, y: y4, color: color3, size } = options;\n  const X3 = materializeValue(data, x4);\n  const Y3 = materializeValue(data, y4);\n  const C3 = materializeValue(data, color3);\n  const S = materializeValue(data, size);\n  let { fx, fy, x: { reduce: xReduce, zero: xZero, ...xOptions }, y: { reduce: yReduce, zero: yZero, ...yOptions }, color: { color: colorColor, reduce: colorReduce }, size: { reduce: sizeReduce }, mark } = autoSpec(data, {\n    ...options,\n    x: { ...x4, value: X3 },\n    y: { ...y4, value: Y3 },\n    color: { ...color3, value: C3 },\n    size: { ...size, value: S }\n  });\n  let Z;\n  let colorMode;\n  if (mark != null) {\n    switch (`${mark}`.toLowerCase()) {\n      case \"dot\":\n        mark = dot;\n        colorMode = \"stroke\";\n        break;\n      case \"line\":\n        mark = X3 && Y3 ? line : X3 ? lineX : lineY;\n        colorMode = \"stroke\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"area\":\n        mark = yZero ? areaY : xZero || Y3 && isMonotonic(Y3) ? areaX : areaY;\n        colorMode = \"fill\";\n        if (isHighCardinality(C3))\n          Z = null;\n        break;\n      case \"rule\":\n        mark = X3 ? ruleX : ruleY;\n        colorMode = \"stroke\";\n        break;\n      case \"bar\":\n        mark = yZero ? isOrdinalReduced(xReduce, X3) ? barY : rectY : xZero ? isOrdinalReduced(yReduce, Y3) ? barX : rectX : isOrdinalReduced(xReduce, X3) && isOrdinalReduced(yReduce, Y3) ? cell : isOrdinalReduced(xReduce, X3) ? barY : isOrdinalReduced(yReduce, Y3) ? barX : rect;\n        colorMode = \"fill\";\n        break;\n      default:\n        throw new Error(`invalid mark: ${mark}`);\n    }\n  }\n  let markOptions = {\n    fx,\n    fy,\n    x: X3 ?? void 0,\n    y: Y3 ?? void 0,\n    [colorMode]: C3 ?? colorColor,\n    z: Z,\n    r: S ?? void 0\n    // treat null size as undefined for default constant radius\n  };\n  let transform2;\n  let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`);\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transform2 = isOrdinal(X3) ? groupX : binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transform2 = isOrdinal(Y3) ? groupY : binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X3 && Y3) {\n      transform2 = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin2;\n    } else if (X3) {\n      transform2 = isOrdinal(X3) ? groupX : binX;\n    } else if (Y3) {\n      transform2 = isOrdinal(Y3) ? groupY : binY;\n    }\n  }\n  if (transform2) {\n    if (transform2 === bin2 || transform2 === binX)\n      markOptions.x = { value: X3, ...xOptions };\n    if (transform2 === bin2 || transform2 === binY)\n      markOptions.y = { value: Y3, ...yOptions };\n    markOptions = transform2(transformOptions, markOptions);\n  }\n  if (xZero === void 0)\n    xZero = transform2 !== binX && (mark === barX || mark === areaX || mark === rectX);\n  if (yZero === void 0)\n    yZero = transform2 !== binY && (mark === barY || mark === areaY || mark === rectY);\n  const frames = fx != null || fy != null ? frame2({ strokeOpacity: 0.1 }) : null;\n  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];\n  mark = mark(data, markOptions);\n  return colorMode === \"stroke\" ? marks(frames, rules, mark) : marks(frames, mark, rules);\n}\nfunction isMonotonic(values2) {\n  let previous;\n  let previousOrder;\n  for (const value of values2) {\n    if (value == null)\n      continue;\n    if (previous === void 0) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign(ascending(previous, value));\n    if (!order)\n      continue;\n    if (previousOrder !== void 0 && order !== previousOrder)\n      return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\nfunction normalizeOptions({ x: x4, y: y4, color: color3, size, fx, fy, mark } = {}) {\n  if (!isOptions(x4))\n    x4 = makeOptions(x4);\n  if (!isOptions(y4))\n    y4 = makeOptions(y4);\n  if (!isOptions(color3))\n    color3 = isColor(color3) ? { color: color3 } : makeOptions(color3);\n  if (!isOptions(size))\n    size = makeOptions(size);\n  if (isOptions(fx))\n    ({ value: fx } = makeOptions(fx));\n  if (isOptions(fy))\n    ({ value: fy } = makeOptions(fy));\n  return { x: x4, y: y4, color: color3, size, fx, fy, mark };\n}\nfunction materializeValue(data, options) {\n  const V = valueof(data, options.value);\n  if (V)\n    V.label = labelof(options.value);\n  return V;\n}\nfunction makeOptions(value) {\n  return isReducer(value) ? { reduce: value } : { value };\n}\nfunction isZeroReducer(reduce2) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce2);\n}\nfunction isSelectReducer(reduce2) {\n  return /^(?:first|last|mode)$/i.test(reduce2);\n}\nfunction isOrdinalReduced(reduce2, value) {\n  return reduce2 != null && !isSelectReducer(reduce2) || !value ? false : isOrdinal(value);\n}\nfunction isReducer(reduce2) {\n  if (typeof reduce2?.reduce === \"function\" && isObject(reduce2))\n    return true;\n  if (/^p\\d{2}$/i.test(reduce2))\n    return true;\n  switch (`${reduce2}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\":\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\":\n    case \"max\":\n    case \"max-index\":\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      return true;\n  }\n  return false;\n}\nfunction isHighCardinality(value) {\n  return value ? new InternSet(value).size > value.length >> 1 : false;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/map.js\nfunction mapX(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"x\", \"x1\", \"x2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction mapY(map6, options = {}) {\n  return mapAlias(Object.fromEntries([\"y\", \"y1\", \"y2\"].filter((key) => options[key] != null).map((key) => [key, map6])), options);\n}\nfunction map5(outputs = {}, options = {}) {\n  const z = maybeZ(options);\n  const channels = Object.entries(outputs).map(([key, map6]) => {\n    const input = maybeInput(key, options);\n    if (input == null)\n      throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = column(input);\n    return { key, input, output, setOutput, map: maybeMap(map6) };\n  });\n  return {\n    ...basic(options, (data, facets) => {\n      const Z = valueof(data, z);\n      const X3 = channels.map(({ input }) => valueof(data, input));\n      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n          channels.forEach(({ map: map6 }, i) => map6.map(I, X3[i], MX[i]));\n        }\n      }\n      return { data, facets };\n    }),\n    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))\n  };\n}\nvar mapAlias = map5;\nfunction maybeMap(map6) {\n  if (map6 && typeof map6.map === \"function\")\n    return map6;\n  if (typeof map6 === \"function\")\n    return mapFunction(map6);\n  switch (`${map6}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction(rank);\n    case \"quantile\":\n      return mapFunction(rankQuantile);\n  }\n  throw new Error(`invalid map: ${map6}`);\n}\nfunction rankQuantile(V) {\n  const n = count(V) - 1;\n  return rank(V).map((r) => r / n);\n}\nfunction mapFunction(f) {\n  return {\n    map(I, S, T) {\n      const M2 = f(take(S, I));\n      if (M2.length !== I.length)\n        throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i)\n        T[I[i]] = M2[i];\n    }\n  };\n}\nvar mapCumsum = {\n  map(I, S, T) {\n    let sum5 = 0;\n    for (const i of I)\n      T[i] = sum5 += S[i];\n  }\n};\n\n// node_modules/@observablehq/plot/dist/marks/tick.js\nvar defaults13 = {\n  ariaLabel: \"tick\",\n  fill: null,\n  stroke: \"currentColor\"\n};\nvar AbstractTick = class extends Mark {\n  constructor(data, channels, options) {\n    super(data, channels, options, defaults13);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call((g) => g.selectAll().data(index3).enter().append(\"line\").call(applyDirectStyles, this).attr(\"x1\", this._x1(scales, channels, dimensions)).attr(\"x2\", this._x2(scales, channels, dimensions)).attr(\"y1\", this._y1(scales, channels, dimensions)).attr(\"y2\", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels)).node();\n  }\n};\nvar TickX = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetTop = inset, insetBottom = inset } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\", type: \"band\", optional: true }\n    }, options);\n    this.insetTop = number5(insetTop);\n    this.insetBottom = number5(insetBottom);\n  }\n  _transform(selection2, mark, { x: x4 }) {\n    selection2.call(applyTransform, mark, { x: x4 }, offset, 0);\n  }\n  _x1(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _x2(scales, { x: X3 }) {\n    return (i) => X3[i];\n  }\n  _y1({ y: y4 }, { y: Y3 }, { marginTop }) {\n    const { insetTop } = this;\n    return Y3 && y4 ? (i) => Y3[i] + insetTop : marginTop + insetTop;\n  }\n  _y2({ y: y4 }, { y: Y3 }, { height, marginBottom }) {\n    const { insetBottom } = this;\n    return Y3 && y4 ? (i) => Y3[i] + y4.bandwidth() - insetBottom : height - marginBottom - insetBottom;\n  }\n};\nvar TickY = class extends AbstractTick {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;\n    super(data, {\n      y: { value: y4, scale: \"y\" },\n      x: { value: x4, scale: \"x\", type: \"band\", optional: true }\n    }, options);\n    this.insetRight = number5(insetRight);\n    this.insetLeft = number5(insetLeft);\n  }\n  _transform(selection2, mark, { y: y4 }) {\n    selection2.call(applyTransform, mark, { y: y4 }, 0, offset);\n  }\n  _x1({ x: x4 }, { x: X3 }, { marginLeft }) {\n    const { insetLeft } = this;\n    return X3 && x4 ? (i) => X3[i] + insetLeft : marginLeft + insetLeft;\n  }\n  _x2({ x: x4 }, { x: X3 }, { width, marginRight }) {\n    const { insetRight } = this;\n    return X3 && x4 ? (i) => X3[i] + x4.bandwidth() - insetRight : width - marginRight - insetRight;\n  }\n  _y1(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n  _y2(scales, { y: Y3 }) {\n    return (i) => Y3[i];\n  }\n};\nfunction tickX(data, options = {}) {\n  const { x: x4 = identity6, ...remainingOptions } = options;\n  return new TickX(data, { ...remainingOptions, x: x4 });\n}\nfunction tickY(data, options = {}) {\n  const { y: y4 = identity6, ...remainingOptions } = options;\n  return new TickY(data, { ...remainingOptions, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/marks/box.js\nfunction boxX(data, options = {}) {\n  const { x: x4 = { transform: (x5) => x5 }, y: y4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = y4 != null ? groupY : groupZ;\n  return marks(ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barX(data, group3({ x1: \"p25\", x2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickX(data, group3({ x: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ x: oqr }, { x: x4, y: y4, z: y4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction boxY(data, options = {}) {\n  const { y: y4 = { transform: (y5) => y5 }, x: x4 = null, fill = \"#ccc\", fillOpacity, stroke = \"currentColor\", strokeOpacity, strokeWidth = 2, sort: sort3, ...remainingOptions } = options;\n  const group3 = x4 != null ? groupX : groupZ;\n  return marks(ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...remainingOptions })), barY(data, group3({ y1: \"p25\", y2: \"p75\" }, { x: x4, y: y4, fill, fillOpacity, ...remainingOptions })), tickY(data, group3({ y: \"p50\" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...remainingOptions })), dot(data, map5({ y: oqr }, { x: x4, y: y4, z: x4, stroke, strokeOpacity, ...remainingOptions })));\n}\nfunction oqr(values2) {\n  const r1 = loqr1(values2);\n  const r2 = hiqr2(values2);\n  return values2.map((v2) => v2 < r1 || v2 > r2 ? v2 : NaN);\n}\nfunction loqr1(values2, value) {\n  const lo = quartile1(values2, value) * 2.5 - quartile3(values2, value) * 1.5;\n  return min(values2, (d) => d >= lo ? d : NaN);\n}\nfunction hiqr2(values2, value) {\n  const hi = quartile3(values2, value) * 2.5 - quartile1(values2, value) * 1.5;\n  return max(values2, (d) => d <= hi ? d : NaN);\n}\nfunction quartile1(values2, value) {\n  return quantile(values2, 0.25, value);\n}\nfunction quartile3(values2, value) {\n  return quantile(values2, 0.75, value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/raster.js\nvar defaults14 = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\nfunction number6(input, name) {\n  const x4 = +input;\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nfunction integer(input, name) {\n  const x4 = Math.floor(input);\n  if (isNaN(x4))\n    throw new Error(`invalid ${name}: ${input}`);\n  return x4;\n}\nvar AbstractRaster = class extends Mark {\n  constructor(data, channels, options = {}, defaults21) {\n    let { width, height, x: x4, y: y4, x1: x12 = x4 == null ? 0 : void 0, y1: y12 = y4 == null ? 0 : void 0, x2: x22 = x4 == null ? width : void 0, y2: y22 = y4 == null ? height : void 0, pixelSize = defaults21.pixelSize, blur: blur3 = 0, interpolate } = options;\n    if (width != null)\n      width = integer(width, \"width\");\n    if (height != null)\n      height = integer(height, \"height\");\n    if (x12 != null)\n      x12 = number6(x12, \"x1\");\n    if (y12 != null)\n      y12 = number6(y12, \"y1\");\n    if (x22 != null)\n      x22 = number6(x22, \"x2\");\n    if (y22 != null)\n      y22 = number6(y22, \"y2\");\n    if (x4 == null && (x12 == null || x22 == null))\n      throw new Error(\"missing x\");\n    if (y4 == null && (y12 == null || y22 == null))\n      throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      if (x4 === void 0 && x12 != null && x22 != null)\n        x4 = denseX(x12, x22, width, height);\n      if (y4 === void 0 && y12 != null && y22 != null)\n        y4 = denseY(y12, y22, width, height);\n    }\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      x1: { value: x12 == null ? null : [x12], scale: \"x\", optional: true, filter: null },\n      y1: { value: y12 == null ? null : [y12], scale: \"y\", optional: true, filter: null },\n      x2: { value: x22 == null ? null : [x22], scale: \"x\", optional: true, filter: null },\n      y2: { value: y22 == null ? null : [y22], scale: \"y\", optional: true, filter: null },\n      ...channels\n    }, options, defaults21);\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number6(pixelSize, \"pixelSize\");\n    this.blur = number6(blur3, \"blur\");\n    this.interpolate = x4 == null || y4 == null ? null : maybeInterpolate(interpolate);\n  }\n};\nvar Raster = class extends AbstractRaster {\n  constructor(data, options = {}) {\n    const { imageRendering } = options;\n    if (data == null) {\n      const { fill, fillOpacity } = options;\n      if (maybeNumberChannel(fillOpacity)[0] !== void 0)\n        options = sampler(\"fillOpacity\", options);\n      if (maybeColorChannel(fill)[0] !== void 0)\n        options = sampler(\"fill\", options);\n    }\n    super(data, void 0, options, defaults14);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, { color: color3, ...scales }, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const color3 = scales.color ?? ((x4) => x4);\n    const { x: X3, y: Y3 } = channels;\n    const { document: document2 } = context;\n    const [x12, y12, x22, y22] = renderBounds(channels, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const n = w * h;\n    let { fill: F, fillOpacity: FO } = channels;\n    let offset2 = 0;\n    if (this.interpolate) {\n      const kx2 = w / dx;\n      const ky2 = h / dy;\n      const IX = map4(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map4(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      if (F)\n        F = this.interpolate(index3, w, h, IX, IY, F);\n      if (FO)\n        FO = this.interpolate(index3, w, h, IX, IY, FO);\n    } else if (this.data == null && index3)\n      offset2 = index3.fi * n;\n    const canvas = document2.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image2 = context2d.createImageData(w, h);\n    const imageData = image2.data;\n    let { r, g, b } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };\n    let a4 = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color3(F[i + offset2]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({ r, g, b } = rgb(fi));\n      }\n      if (FO)\n        a4 = FO[i + offset2] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a4;\n    }\n    if (this.blur > 0)\n      blurImage(image2, this.blur);\n    context2d.putImageData(image2, 0, 0);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g2) => g2.append(\"image\").attr(\"transform\", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr(\"width\", Math.abs(dx)).attr(\"height\", Math.abs(dy)).attr(\"preserveAspectRatio\", \"none\").call(applyAttr, \"image-rendering\", this.imageRendering).call(applyDirectStyles, this).attr(\"xlink:href\", canvas.toDataURL())).node();\n  }\n};\nfunction maybeTuples(k2, data, options) {\n  if (arguments.length < 3)\n    options = data, data = null;\n  let { x: x4, y: y4, [k2]: z, ...rest } = options;\n  if (x4 === void 0 && y4 === void 0 && isTuples(data)) {\n    x4 = first, y4 = second2;\n    if (z === void 0)\n      z = third;\n  }\n  return [data, { ...rest, x: x4, y: y4, [k2]: z }];\n}\nfunction raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(data, data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity6 });\n}\nfunction renderBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, dimensions, { projection: projection2 }) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return [\n    x12 && projection2 == null ? x12[0] : marginLeft,\n    y12 && projection2 == null ? y12[0] : marginTop,\n    x22 && projection2 == null ? x22[0] : width - marginRight,\n    y22 && projection2 == null ? y22[0] : height - marginBottom\n  ];\n}\nfunction rasterBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, scales, dimensions, context) {\n  const channels = {};\n  if (x12)\n    channels.x1 = x12;\n  if (y12)\n    channels.y1 = y12;\n  if (x22)\n    channels.x2 = x22;\n  if (y22)\n    channels.y2 = y22;\n  return renderBounds(valueObject(channels, scales), dimensions, context);\n}\nfunction sampler(name, options = {}) {\n  const { [name]: value } = options;\n  if (typeof value !== \"function\")\n    throw new Error(`invalid ${name}: not a function`);\n  return initializer({ ...options, [name]: void 0 }, function(data, facets, channels, scales, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    if (!x4)\n      throw new Error(\"missing scale: x\");\n    if (!y4)\n      throw new Error(\"missing scale: y\");\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2 } = this;\n    const { width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = options;\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx2 = dx / w;\n    const ky2 = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [void 0]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x4.invert(x12 + xi * kx2), y4.invert(y12 + yi * ky2), facet);\n        }\n      }\n    }\n    return { data: V, facets, channels: { [name]: { value: V, scale: true } } };\n  });\n}\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\")\n    return interpolate;\n  if (interpolate == null)\n    return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\nfunction interpolateNone(index3, width, height, X3, Y3, V) {\n  const W = new Array(width * height);\n  for (const i of index3) {\n    if (X3[i] < 0 || X3[i] >= width || Y3[i] < 0 || Y3[i] >= height)\n      continue;\n    W[Math.floor(Y3[i]) * width + Math.floor(X3[i])] = V[i];\n  }\n  return W;\n}\nfunction interpolatorBarycentric({ random = lcg(42) } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const n = index3.length;\n    const nw = width >> 2;\n    const nh = (height >> 2) - 1;\n    const m3 = n + nw * 2 + nh * 2;\n    const XY2 = new Float64Array(m3 * 2);\n    for (let i2 = 0; i2 < n; ++i2)\n      XY2[i2 * 2] = X3[index3[i2]], XY2[i2 * 2 + 1] = Y3[index3[i2]];\n    let i = n;\n    const addPoint = (x4, y4) => (XY2[i * 2] = x4, XY2[i * 2 + 1] = y4, i++);\n    for (let j = 0; j <= nw; ++j)\n      addPoint(j / nw * width, 0), addPoint(j / nw * width, height);\n    for (let j = 0; j < nh; ++j)\n      addPoint(width, j / nh * height), addPoint(0, j / nh * height);\n    V = take(V, index3);\n    const delaunay = new Delaunay(XY2.subarray(0, n * 2));\n    for (let j = n, ij; j < m3; ++j)\n      V[j] = V[ij = delaunay.find(XY2[j * 2], XY2[j * 2 + 1], ij)];\n    const { points, triangles } = new Delaunay(XY2);\n    const W = new V.constructor(width * height);\n    const mix = mixer(V, random);\n    for (let i2 = 0; i2 < triangles.length; i2 += 3) {\n      const ta = triangles[i2];\n      const tb = triangles[i2 + 1];\n      const tc = triangles[i2 + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x12 = Math.min(Ax, Bx, Cx);\n      const x22 = Math.max(Ax, Bx, Cx);\n      const y12 = Math.min(Ay, By, Cy);\n      const y22 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z)\n        continue;\n      const va = V[ta];\n      const vb = V[tb];\n      const vc = V[tc];\n      for (let x4 = Math.floor(x12); x4 < x22; ++x4) {\n        for (let y4 = Math.floor(y12); y4 < y22; ++y4) {\n          if (x4 < 0 || x4 >= width || y4 < 0 || y4 >= height)\n            continue;\n          const xp = x4 + 0.5;\n          const yp = y4 + 0.5;\n          const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z;\n          if (ga < 0)\n            continue;\n          const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z;\n          if (gb < 0)\n            continue;\n          const gc = 1 - ga - gb;\n          if (gc < 0)\n            continue;\n          W[x4 + width * y4] = mix(va, ga, vb, gb, vc, gc, x4, y4);\n        }\n      }\n    }\n    return W;\n  };\n}\nfunction interpolateNearest(index3, width, height, X3, Y3, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n  let iy, ix;\n  for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n    ix = iy;\n    for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n      ix = delaunay.find(x4, y4, ix);\n      if (x4 === 0.5)\n        iy = ix;\n      W[k2] = V[index3[ix]];\n    }\n  }\n  return W;\n}\nfunction interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {\n  return (index3, width, height, X3, Y3, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = Delaunay.from(index3, (i) => X3[i], (i) => Y3[i]);\n    let iy, ix, iw;\n    for (let y4 = 0.5, k2 = 0; y4 < height; ++y4) {\n      ix = iy;\n      for (let x4 = 0.5; x4 < width; ++x4, ++k2) {\n        let cx = x4;\n        let cy = y4;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x4 === 0.5)\n          iy = ix;\n        let distance;\n        let step = 0;\n        while ((distance = Math.hypot(X3[index3[iw]] - cx, Y3[index3[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle2 = random(x4, y4, step) * 2 * Math.PI;\n          cx += Math.cos(angle2) * distance;\n          cy += Math.sin(angle2) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k2] = V[index3[iw]];\n      }\n    }\n    return W;\n  };\n}\nfunction blend(a4, ca3, b, cb, c6, cc2) {\n  return ca3 * a4 + cb * b + cc2 * c6;\n}\nfunction pick(random) {\n  return (a4, ca3, b, cb, c6, cc2, x4, y4) => {\n    const u4 = random(x4, y4);\n    return u4 < ca3 ? a4 : u4 < ca3 + cb ? b : c6;\n  };\n}\nfunction mixer(F, random) {\n  return isNumeric(F) || isTemporal(F) ? blend : pick(random);\n}\nfunction denseX(x12, x22, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X3 = new Float64Array(n);\n      const kx2 = (x22 - x12) / width;\n      const x06 = x12 + kx2 / 2;\n      for (let i = 0; i < n; ++i)\n        X3[i] = i % width * kx2 + x06;\n      return X3;\n    }\n  };\n}\nfunction denseY(y12, y22, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y3 = new Float64Array(n);\n      const ky2 = (y22 - y12) / height;\n      const y06 = y12 + ky2 / 2;\n      for (let i = 0; i < n; ++i)\n        Y3[i] = Math.floor(i / width) % height * ky2 + y06;\n      return Y3;\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/marks/contour.js\nvar defaults15 = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\nvar Contour = class extends AbstractRaster {\n  constructor(data, { smooth = true, value, ...options } = {}) {\n    const channels = styles({}, options, defaults15);\n    if (value === void 0) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== void 0)\n            throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n    if (value != null) {\n      const v2 = { transform: (D3) => D3.map((d) => d.value), label: labelof(value) };\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v2;\n        }\n      }\n    }\n    if (data == null) {\n      if (value == null)\n        throw new Error(\"missing contour value\");\n      options = sampler(\"value\", { value, ...options });\n      value = null;\n    } else {\n      let { interpolate } = options;\n      if (value === void 0)\n        value = identity6;\n      if (interpolate === void 0)\n        options.interpolate = \"nearest\";\n    }\n    super(data, { value: { value, optional: true } }, contourGeometry(options), defaults15);\n    const contourChannels = { geometry: { value: identity6 } };\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const { scale: scale3 } = channel;\n      if (scale3 === \"x\" || scale3 === \"y\" || key === \"value\")\n        continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index3, { x: x4, y: y4, value, ...channels }, values2) {\n    return super.filter(index3, channels, values2);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G } = channels;\n    const path2 = path_default();\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction contourGeometry({ thresholds, interval: interval2, ...options }) {\n  thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x22 - x12;\n    const dy = y22 - y12;\n    const { pixelSize: k2, width: w = Math.round(Math.abs(dx) / k2), height: h = Math.round(Math.abs(dy) / k2) } = this;\n    const kx2 = w / dx;\n    const ky2 = h / dy;\n    const V = channels.value.value;\n    const VV = [];\n    if (this.interpolate) {\n      const { x: X3, y: Y3 } = Position(channels, scales, context);\n      const IX = map2(X3, (x4) => (x4 - x12) * kx2, Float64Array);\n      const IY = map2(Y3, (y4) => (y4 - y12) * ky2, Float64Array);\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index3 = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index3, w, h, IX, IY, V));\n      }\n    } else if (facets) {\n      const n = w * h;\n      const m3 = facets.length;\n      for (let i = 0; i < m3; ++i)\n        VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n    if (this.blur > 0)\n      for (const V2 of VV)\n        blur2({ data: V2, width: w, height: h }, this.blur);\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null)\n      throw new Error(`unsupported thresholds: ${thresholds}`);\n    const { contour: contour2 } = contours_default().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V2 of VV)\n      contourFacets.push(range(contourData.length, contourData.push(...T.map((t) => contour2(V2, t)))));\n    for (const { coordinates: coordinates2 } of contourData) {\n      for (const rings of coordinates2) {\n        for (const ring of rings) {\n          for (const point6 of ring) {\n            point6[0] = point6[0] / kx2 + x12;\n            point6[1] = point6[1] / ky2 + y12;\n          }\n        }\n      }\n    }\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: Channels(this.contourChannels, contourData)\n    };\n  });\n}\nfunction maybeTicks(thresholds, V, min4, max5) {\n  if (typeof thresholds?.range === \"function\")\n    return thresholds.range(thresholds.floor(min4), max5);\n  if (typeof thresholds === \"function\")\n    thresholds = thresholds(V, min4, max5);\n  if (typeof thresholds !== \"number\")\n    return arrayify2(thresholds, Array);\n  const tz = ticks(...nice(min4, max5, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max5)\n    tz.pop();\n  while (tz[1] < min4)\n    tz.shift();\n  return tz;\n}\nfunction contour() {\n  return new Contour(...maybeTuples(\"value\", ...arguments));\n}\nfunction finiteExtent(VV) {\n  return [min(VV, (V) => min(V, finite3)), max(VV, (V) => max(V, finite3))];\n}\nfunction finite3(x4) {\n  return isFinite(x4) ? x4 : NaN;\n}\n\n// node_modules/@observablehq/plot/dist/marks/delaunay.js\nvar delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\nvar voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nvar DelaunayLink = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, curve, tension } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, delaunayLinkDefaults);\n    this.curve = Curve(curve, tension);\n    markers(this, options);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { curve } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function links(index4) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k2 in channels)\n        newChannels[k2] = [];\n      const X13 = [];\n      const X23 = [];\n      const Y13 = [];\n      const Y23 = [];\n      function link4(ti, tj) {\n        ti = index4[ti];\n        tj = index4[tj];\n        newIndex.push(++i);\n        X13[i] = xi(ti);\n        Y13[i] = yi(ti);\n        X23[i] = xi(tj);\n        Y23[i] = yi(tj);\n        for (const k2 in channels)\n          newChannels[k2].push(channels[k2][tj]);\n      }\n      const { halfedges, hull: hull2, triangles } = Delaunay.from(index4, xi, yi);\n      for (let i2 = 0; i2 < halfedges.length; ++i2) {\n        const j = halfedges[i2];\n        if (j > i2)\n          link4(triangles[i2], triangles[j]);\n      }\n      for (let i2 = 0; i2 < hull2.length; ++i2) {\n        link4(hull2[i2], hull2[(i2 + 1) % hull2.length]);\n      }\n      select_default2(this).selectAll().data(newIndex).join(\"path\").call(applyDirectStyles, mark).attr(\"d\", (i2) => {\n        const p = pathRound();\n        const c6 = curve(p);\n        c6.lineStart();\n        c6.point(X13[i2], Y13[i2]);\n        c6.point(X23[i2], Y23[i2]);\n        c6.lineEnd();\n        return p;\n      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(links) : (g) => g.datum(index3).each(links)).node();\n  }\n};\nvar AbstractDelaunayMark = class extends Mark {\n  constructor(data, options = {}, defaults21, zof = ({ z }) => z) {\n    const { x: x4, y: y4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: zof(options), optional: true }\n    }, options, defaults21);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function mesh(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      select_default2(this).append(\"path\").datum(index4[0]).call(applyDirectStyles, mark).attr(\"d\", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(mesh) : (g) => g.datum(index3).each(mesh)).node();\n  }\n};\nvar DelaunayMesh = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n};\nvar Hull = class extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n};\nvar Voronoi2 = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: z, optional: true }\n    }, options, voronoiDefaults);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, z: Z } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X3 ? (i) => X3[i] : constant2(cx);\n    const yi = Y3 ? (i) => Y3[i] : constant2(cy);\n    const mark = this;\n    function cells(index4) {\n      const delaunay = Delaunay.from(index4, xi, yi);\n      const voronoi2 = voronoiof(delaunay, dimensions);\n      select_default2(this).selectAll().data(index4).enter().append(\"path\").call(applyDirectStyles, mark).attr(\"d\", (_, i) => voronoi2.renderCell(i)).call(applyChannelStyles, mark, channels);\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(Z ? (g) => g.selectAll().data(group(index3, (i) => Z[i]).values()).enter().append(\"g\").each(cells) : (g) => g.datum(index3).each(cells)).node();\n  }\n};\nvar VoronoiMesh = class extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n};\nfunction voronoiof(delaunay, dimensions) {\n  const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\nfunction delaunayMark(DelaunayMark, data, { x: x4, y: y4, ...options } = {}) {\n  [x4, y4] = maybeTuple(x4, y4);\n  return new DelaunayMark(data, { ...options, x: x4, y: y4 });\n}\nfunction delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\nfunction delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\nfunction hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\nfunction voronoi(data, options) {\n  return delaunayMark(Voronoi2, data, options);\n}\nfunction voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}\n\n// node_modules/@observablehq/plot/dist/marks/density.js\nvar defaults16 = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nvar Density = class extends Mark {\n  constructor(data, { x: x4, y: y4, z, weight, fill, stroke, ...options } = {}) {\n    const fillDensity = isDensity(fill) && (fill = \"currentColor\", true);\n    const strokeDensity = isDensity(stroke) && (stroke = \"currentColor\", true);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      z: { value: maybeZ({ z, fill, stroke }), optional: true },\n      weight: { value: weight, optional: true }\n    }, densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity), defaults16);\n    if (fillDensity)\n      this.fill = void 0;\n    if (strokeDensity)\n      this.stroke = void 0;\n    this.z = z;\n  }\n  filter(index3) {\n    return index3;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { contours } = channels;\n    const path2 = path_default();\n    return create_default(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call((g) => g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", (i) => path2(contours[i]))).node();\n  }\n};\nfunction density(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  [x4, y4] = maybeTuple(x4, y4);\n  return new Density(data, { ...remainingOptions, x: x4, y: y4 });\n}\nvar dropChannels = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\", \"weight\"]);\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k2 = 100;\n  let { bandwidth, thresholds } = options;\n  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;\n  thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === \"function\" ? coerceNumbers(thresholds) : +thresholds;\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const { z } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const { width, height } = dimensions;\n    const { x: X3, y: Y3 } = Position(channels, scales, context);\n    const newChannels = Object.fromEntries(Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }]));\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n    const density2 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W ? (i) => W[i] : 1).size([width, height]).bandwidth(bandwidth);\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index3 of Z ? groupZ2(facet, Z, z) : [facet]) {\n        const contour2 = density2.contours(index3);\n        facetContours.push([index3, contour2]);\n      }\n    }\n    let T = thresholds;\n    if (!isTypedArray(T)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour2] of facetContours) {\n          const max5 = contour2.max;\n          if (max5 > maxValue)\n            maxValue = max5;\n        }\n      }\n      T = Float64Array.from({ length: thresholds - 1 }, (_, i) => maxValue * k2 * (i + 1) / thresholds);\n    }\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index3, contour2] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour2(t / k2));\n          if (FD)\n            FD.push(t);\n          if (SD)\n            SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index3[0]]);\n          }\n        }\n      }\n    }\n    if (FD)\n      FD.push(0);\n    if (SD)\n      SD.push(0);\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...FD && { fill: { value: FD, scale: \"color\" } },\n        ...SD && { stroke: { value: SD, scale: \"color\" } },\n        contours: { value: contours }\n      }\n    };\n  });\n}\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n\n// node_modules/@observablehq/plot/dist/marks/geo.js\nvar defaults17 = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar Geo = class extends Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = maybeNumberChannel(options.r, 3);\n    super(data, {\n      geometry: { value: options.geometry },\n      r: { value: vr, scale: \"r\", filter: positive, optional: true }\n    }, withDefaultSort(options), defaults17);\n    this.r = cr;\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { geometry: G, r: R } = channels;\n    const path2 = path_default(context.projection ?? scaleProjection2(scales));\n    const { r } = this;\n    if (negative(r))\n      index3 = [];\n    else if (r !== void 0)\n      path2.pointRadius(r);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => {\n      g.selectAll().data(index3).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", R ? (i) => path2.pointRadius(R[i])(G[i]) : (i) => path2(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n};\nfunction scaleProjection2({ x: X3, y: Y3 }) {\n  if (X3 || Y3) {\n    X3 ??= (x4) => x4;\n    Y3 ??= (y4) => y4;\n    return transform_default({\n      point(x4, y4) {\n        this.stream.point(X3(x4), Y3(y4));\n      }\n    });\n  }\n}\nfunction geo(data, { geometry = identity6, ...options } = {}) {\n  switch (data?.type) {\n    case \"FeatureCollection\":\n      data = data.features;\n      break;\n    case \"GeometryCollection\":\n      data = data.geometries;\n      break;\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      data = [data];\n      break;\n  }\n  return new Geo(data, { geometry, ...options });\n}\nfunction sphere({ strokeWidth = 1.5, ...options } = {}) {\n  return geo({ type: \"Sphere\" }, { strokeWidth, ...options });\n}\nfunction graticule2({ strokeOpacity = 0.1, ...options } = {}) {\n  return geo(graticule10(), { strokeOpacity, ...options });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/hexbin.js\nvar ox = 0.5;\nvar oy = 0;\nfunction hexbin(outputs = { fill: \"count\" }, { binWidth, ...options } = {}) {\n  binWidth = binWidth === void 0 ? 20 : number5(binWidth);\n  outputs = maybeOutputs(outputs, options);\n  const { z, fill, stroke } = options;\n  if (stroke === void 0 && isNoneish(fill) && hasOutput(outputs, \"fill\"))\n    options.stroke = \"none\";\n  if (options.symbol === void 0)\n    options.symbol = \"hexagon\";\n  if (options.r === void 0 && !hasOutput(outputs, \"r\"))\n    options.r = binWidth / 2;\n  return initializer(options, (data, facets, channels, scales, _, context) => {\n    let { x: X3, y: Y3, z: Z, fill: F, stroke: S, symbol: Q } = channels;\n    if (X3 === void 0)\n      throw new Error(\"missing channel: x\");\n    if (Y3 === void 0)\n      throw new Error(\"missing channel: y\");\n    ({ x: X3, y: Y3 } = Position(channels, scales, context));\n    Z = Z ? Z.value : valueof(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n    const G = maybeSubgroup(outputs, { z: Z, fill: F, stroke: S, symbol: Q });\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs)\n      o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs)\n        o.scope(\"facet\", facet);\n      for (const [f, I] of maybeGroup(facet, G)) {\n        for (const bin3 of hbin(I, X3, Y3, binWidth)) {\n          binFacet.push(++i);\n          BX.push(bin3.x);\n          BY.push(bin3.y);\n          if (Z)\n            GZ.push(G === Z ? f : Z[bin3[0]]);\n          if (F)\n            GF.push(G === F ? f : F[bin3[0]]);\n          if (S)\n            GS.push(G === S ? f : S[bin3[0]]);\n          if (Q)\n            GQ.push(G === Q ? f : Q[bin3[0]]);\n          for (const o of outputs)\n            o.reduce(bin3);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n    const binChannels = {\n      x: { value: BX },\n      y: { value: BY },\n      ...Z && { z: { value: GZ } },\n      ...F && { fill: { value: GF, scale: true } },\n      ...S && { stroke: { value: GS, scale: true } },\n      ...Q && { symbol: { value: GQ, scale: true } },\n      ...Object.fromEntries(outputs.map(({ name, output }) => [\n        name,\n        { scale: true, radius: name === \"r\" ? binWidth / 2 : void 0, value: output.transform() }\n      ]))\n    };\n    return { data, facets: binFacets, channels: binChannels };\n  });\n}\nfunction hbin(I, X3, Y3, dx) {\n  const dy = dx * (1.5 / sqrt35);\n  const bins = /* @__PURE__ */ new Map();\n  for (const i of I) {\n    let px = X3[i], py = Y3[i];\n    if (isNaN(px) || isNaN(py))\n      continue;\n    let pj = Math.round(py = (py - oy) / dy), pi7 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi7, pi22 = pi7 + (px < pi7 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)\n        pi7 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n    }\n    const key = `${pi7},${pj}`;\n    let bin3 = bins.get(key);\n    if (bin3 === void 0) {\n      bins.set(key, bin3 = []);\n      bin3.x = (pi7 + (pj & 1) / 2) * dx + ox;\n      bin3.y = pj * dy + oy;\n    }\n    bin3.push(i);\n  }\n  return bins.values();\n}\n\n// node_modules/@observablehq/plot/dist/marks/hexgrid.js\nvar defaults18 = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\nfunction hexgrid(options) {\n  return new Hexgrid(options);\n}\nvar Hexgrid = class extends Mark {\n  constructor({ binWidth = 20, clip = true, ...options } = {}) {\n    super(void 0, void 0, { clip, ...options }, defaults18);\n    this.binWidth = number5(binWidth);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { binWidth } = this;\n    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;\n    const x06 = marginLeft - ox, x12 = width - marginRight - ox, y06 = marginTop - oy, y12 = height - marginBottom - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x06 / wx), i1 = Math.ceil(x12 / wx), j0 = Math.floor((y06 + hy) / wy), j1 = Math.ceil((y12 - hy) / wy) + 1, path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path2;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path2}`;\n      }\n    }\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g) => g.append(\"path\").call(applyDirectStyles, this).attr(\"d\", d)).node();\n  }\n};\nfunction round(x4) {\n  return Math.round(x4 * 1e3) / 1e3;\n}\n\n// node_modules/@observablehq/plot/dist/marks/image.js\nvar defaults19 = {\n  ariaLabel: \"image\",\n  fill: null,\n  stroke: null\n};\nfunction isPath(string2) {\n  return /^\\.*\\//.test(string2);\n}\nfunction isUrl(string2) {\n  return /^(blob|data|file|http|https):/i.test(string2);\n}\nfunction maybePathChannel(value) {\n  return typeof value === \"string\" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];\n}\nvar Image2 = class extends Mark {\n  constructor(data, options = {}) {\n    let { x: x4, y: y4, width, height, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;\n    if (width === void 0 && height !== void 0)\n      width = height;\n    else if (height === void 0 && width !== void 0)\n      height = width;\n    const [vs, cs] = maybePathChannel(src);\n    const [vw, cw] = maybeNumberChannel(width, 16);\n    const [vh, ch] = maybeNumberChannel(height, 16);\n    super(data, {\n      x: { value: x4, scale: \"x\", optional: true },\n      y: { value: y4, scale: \"y\", optional: true },\n      width: { value: vw, filter: positive, optional: true },\n      height: { value: vh, filter: positive, optional: true },\n      src: { value: vs, optional: true }\n    }, options, defaults19);\n    this.src = cs;\n    this.width = cw;\n    this.height = ch;\n    this.preserveAspectRatio = impliedString(preserveAspectRatio, \"xMidYMid\");\n    this.crossOrigin = string(crossOrigin);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: x4, y: y4 } = scales;\n    const { x: X3, y: Y3, width: W, height: H, src: S } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call((g) => g.selectAll().data(index3).enter().append(\"image\").call(applyDirectStyles, this).attr(\"x\", W && X3 ? (i) => X3[i] - W[i] / 2 : W ? (i) => cx - W[i] / 2 : X3 ? (i) => X3[i] - this.width / 2 : cx - this.width / 2).attr(\"y\", H && Y3 ? (i) => Y3[i] - H[i] / 2 : H ? (i) => cy - H[i] / 2 : Y3 ? (i) => Y3[i] - this.height / 2 : cy - this.height / 2).attr(\"width\", W ? (i) => W[i] : this.width).attr(\"height\", H ? (i) => H[i] : this.height).call(applyAttr, \"href\", S ? (i) => S[i] : this.src).call(applyAttr, \"preserveAspectRatio\", this.preserveAspectRatio).call(applyAttr, \"crossorigin\", this.crossOrigin).call(applyAttr, \"image-rendering\", this.imageRendering).call(applyChannelStyles, this, channels)).node();\n  }\n};\nfunction image(data, options = {}) {\n  let { x: x4, y: y4, ...remainingOptions } = options;\n  if (options.frameAnchor === void 0)\n    [x4, y4] = maybeTuple(x4, y4);\n  return new Image2(data, { ...remainingOptions, x: x4, y: y4 });\n}\n\n// node_modules/@observablehq/plot/dist/stats.js\nfunction ibetainv(p, a4, b) {\n  var EPS = 1e-8;\n  var a1 = a4 - 1;\n  var b12 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u4, err, x4, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a4 >= 1 && b >= 1) {\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x4 = -x4;\n    al = (x4 * x4 - 3) / 6;\n    h = 2 / (1 / (2 * a4 - 1) + 1 / (2 * b - 1));\n    w = x4 * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a4 - 1)) * (al + 5 / 6 - 2 / (3 * h));\n    x4 = a4 / (a4 + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a4 / (a4 + b));\n    lnb = Math.log(b / (a4 + b));\n    t = Math.exp(a4 * lna) / a4;\n    u4 = Math.exp(b * lnb) / b;\n    w = t + u4;\n    if (p < t / w)\n      x4 = Math.pow(a4 * w * p, 1 / a4);\n    else\n      x4 = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -gammaln(a4) - gammaln(b) + gammaln(a4 + b);\n  for (; j < 10; j++) {\n    if (x4 === 0 || x4 === 1)\n      return x4;\n    err = ibeta(x4, a4, b) - p;\n    t = Math.exp(a1 * Math.log(x4) + b12 * Math.log(1 - x4) + afac);\n    u4 = err / t;\n    x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b12 / (1 - x4))));\n    if (x4 <= 0)\n      x4 = 0.5 * (x4 + t);\n    if (x4 >= 1)\n      x4 = 0.5 * (x4 + t + 1);\n    if (Math.abs(t) < EPS * x4 && j > 0)\n      break;\n  }\n  return x4;\n}\nfunction ibeta(x4, a4, b) {\n  var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln(a4 + b) - gammaln(a4) - gammaln(b) + a4 * Math.log(x4) + b * Math.log(1 - x4));\n  if (x4 < 0 || x4 > 1)\n    return false;\n  if (x4 < (a4 + 1) / (a4 + b + 2))\n    return bt * betacf(x4, a4, b) / a4;\n  return 1 - bt * betacf(1 - x4, b, a4) / b;\n}\nfunction betacf(x4, a4, b) {\n  var fpmin = 1e-30;\n  var m3 = 1;\n  var qab = a4 + b;\n  var qap = a4 + 1;\n  var qam = a4 - 1;\n  var c6 = 1;\n  var d = 1 - qab * x4 / qap;\n  var m22, aa2, del, h;\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n  for (; m3 <= 100; m3++) {\n    m22 = 2 * m3;\n    aa2 = m3 * (b - m3) * x4 / ((qam + m22) * (a4 + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    h *= d * c6;\n    aa2 = -(a4 + m3) * (qab + m3) * x4 / ((a4 + m22) * (qap + m22));\n    d = 1 + aa2 * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c6 = 1 + aa2 / c6;\n    if (Math.abs(c6) < fpmin)\n      c6 = fpmin;\n    d = 1 / d;\n    del = d * c6;\n    h *= del;\n    if (Math.abs(del - 1) < 3e-7)\n      break;\n  }\n  return h;\n}\nfunction gammaln(x4) {\n  var j = 0;\n  var cof = [\n    76.18009172947146,\n    -86.5053203294167,\n    24.01409824083091,\n    -1.231739572450155,\n    0.001208650973866179,\n    -5395239384953e-18\n  ];\n  var ser = 1.000000000190015;\n  var xx, y4, tmp2;\n  tmp2 = (y4 = xx = x4) + 5.5;\n  tmp2 -= (xx + 0.5) * Math.log(tmp2);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y4;\n  return Math.log(2.506628274631 * ser / xx) - tmp2;\n}\nfunction qt(p, dof) {\n  var x4 = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n  x4 = Math.sqrt(dof * (1 - x4) / x4);\n  return p > 0.5 ? x4 : -x4;\n}\n\n// node_modules/@observablehq/plot/dist/marks/linearRegression.js\nvar defaults20 = {\n  ariaLabel: \"linear-regression\",\n  fill: \"currentColor\",\n  fillOpacity: 0.1,\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nvar LinearRegression = class extends Mark {\n  constructor(data, options = {}) {\n    const { x: x4, y: y4, z, ci = 0.95, precision = 4 } = options;\n    super(data, {\n      x: { value: x4, scale: \"x\" },\n      y: { value: y4, scale: \"y\" },\n      z: { value: maybeZ(options), optional: true }\n    }, options, defaults20);\n    this.z = z;\n    this.ci = +ci;\n    this.precision = +precision;\n    if (!(0 <= this.ci && this.ci < 1))\n      throw new Error(`invalid ci; not in [0, 1): ${ci}`);\n    if (!(this.precision > 0))\n      throw new Error(`invalid precision: ${precision}`);\n  }\n  render(index3, scales, channels, dimensions, context) {\n    const { x: X3, y: Y3, z: Z } = channels;\n    const { ci } = this;\n    return create2(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g) => g.selectAll().data(Z ? groupZ2(index3, Z, this.z) : [index3]).enter().call((enter) => enter.append(\"path\").attr(\"fill\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr(\"d\", (I) => this._renderLine(I, X3, Y3)).call(ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr(\"stroke\", \"none\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {\n      ...channels,\n      stroke: null,\n      strokeOpacity: null,\n      strokeWidth: null\n    }).attr(\"d\", (I) => this._renderBand(I, X3, Y3)) : () => {\n    }))).node();\n  }\n};\nfunction pathBefore() {\n  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, \"path\"), this);\n}\nvar LinearRegressionX = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    const g = confidenceIntervalF(I, Y3, X3, (1 - ci) / 2, f);\n    return area_default5().y((y4) => y4).x0((y4) => g(y4, -1)).x1((y4) => g(y4, 1))(range(y12, y22 - precision / 2, precision).concat(y22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [y12, y22] = extent(I, (i) => Y3[i]);\n    const f = linearRegressionF(I, Y3, X3);\n    return `M${f(y12)},${y12}L${f(y22)},${y22}`;\n  }\n};\nvar LinearRegressionY = class extends LinearRegression {\n  constructor(data, options) {\n    super(data, options);\n  }\n  _renderBand(I, X3, Y3) {\n    const { ci, precision } = this;\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    const g = confidenceIntervalF(I, X3, Y3, (1 - ci) / 2, f);\n    return area_default5().x((x4) => x4).y0((x4) => g(x4, -1)).y1((x4) => g(x4, 1))(range(x12, x22 - precision / 2, precision).concat(x22));\n  }\n  _renderLine(I, X3, Y3) {\n    const [x12, x22] = extent(I, (i) => X3[i]);\n    const f = linearRegressionF(I, X3, Y3);\n    return `M${x12},${f(x12)}L${x22},${f(x22)}`;\n  }\n};\nfunction linearRegressionX(data, options = {}) {\n  const { y: y4 = indexOf, x: x4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionX(data, maybeDenseIntervalY({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionY(data, options = {}) {\n  const { x: x4 = indexOf, y: y4 = identity6, stroke, fill = isNoneish(stroke) ? \"currentColor\" : stroke, ...remainingOptions } = options;\n  return new LinearRegressionY(data, maybeDenseIntervalX({ ...remainingOptions, x: x4, y: y4, fill, stroke }));\n}\nfunction linearRegressionF(I, X3, Y3) {\n  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n  for (const i of I) {\n    const xi = X3[i];\n    const yi = Y3[i];\n    sumX += xi;\n    sumY += yi;\n    sumXY += xi * yi;\n    sumX2 += xi * xi;\n  }\n  const n = I.length;\n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  const intercept = (sumY - slope * sumX) / n;\n  return (x4) => slope * x4 + intercept;\n}\nfunction confidenceIntervalF(I, X3, Y3, p, f) {\n  const mean2 = sum(I, (i) => X3[i]) / I.length;\n  let a4 = 0, b = 0;\n  for (const i of I) {\n    a4 += (X3[i] - mean2) ** 2;\n    b += (Y3[i] - f(X3[i])) ** 2;\n  }\n  const sy = Math.sqrt(b / (I.length - 2));\n  const t = qt(p, I.length - 2);\n  return (x4, k2) => {\n    const Y4 = f(x4);\n    const se = sy * Math.sqrt(1 / I.length + (x4 - mean2) ** 2 / a4);\n    return Y4 + k2 * t * se;\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/tree.js\nfunction treeNode(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    frameAnchor,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (frameAnchor === void 0)\n    frameAnchor = treeAnchor.frameAnchor;\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeNodeValue);\n  const [X3, setX] = column();\n  const [Y3, setY] = column();\n  return {\n    x: X3,\n    y: Y3,\n    frameAnchor,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X4 = setX([]);\n      const Y4 = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const node of root3.descendants()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X4, Y4);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction treeLink(options = {}) {\n  let {\n    path: path2 = identity6,\n    // the delimited path\n    delimiter,\n    // how the path is separated\n    curve = \"bump-x\",\n    stroke = \"#555\",\n    strokeWidth = 1.5,\n    strokeOpacity = 0.5,\n    treeLayout = tree_default,\n    treeSort,\n    treeSeparation,\n    treeAnchor,\n    ...remainingOptions\n  } = options;\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  remainingOptions = { curve, stroke, strokeWidth, strokeOpacity, ...remainingOptions };\n  const normalize4 = normalizer(delimiter);\n  const outputs = treeOutputs(remainingOptions, maybeLinkValue);\n  const [X13, setX1] = column();\n  const [X23, setX2] = column();\n  const [Y13, setY1] = column();\n  const [Y23, setY2] = column();\n  return {\n    x1: X13,\n    x2: X23,\n    y1: Y13,\n    y2: Y23,\n    ...basic(remainingOptions, (data, facets) => {\n      const P = normalize4(valueof(data, path2));\n      const X14 = setX1([]);\n      const X24 = setX2([]);\n      const Y14 = setY1([]);\n      const Y24 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify_default().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize)\n        layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== void 0)\n        layout.separation(treeSeparation ?? one2);\n      for (const o of outputs)\n        o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root3 = rootof(facet.filter((i) => P[i] != null)).each((node) => node.data = data[node.data]);\n        if (treeSort != null)\n          root3.sort(treeSort);\n        layout(root3);\n        for (const { source, target } of root3.links()) {\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X14, Y14);\n          treeAnchor.position(target, treeIndex, X24, Y24);\n          for (const o of outputs)\n            o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return { data: treeData, facets: treeFacets };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nfunction maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\nvar treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = y4;\n    Y3[i] = -x4;\n  }\n};\nvar treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({ x: x4, y: y4 }, i, X3, Y3) {\n    X3[i] = -y4;\n    Y3[i] = -x4;\n  }\n};\nfunction maybeTreeSort(sort3) {\n  return sort3 == null || typeof sort3 === \"function\" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith(\"node:\") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));\n}\nfunction nodeSort(value) {\n  return (a4, b) => ascendingDefined2(value(a4), value(b));\n}\nfunction nodeData(field2) {\n  return (node) => node.data?.[field2];\n}\nfunction normalizer(delimiter = \"/\") {\n  return `${delimiter}` === \"/\" ? (P) => P : (P) => P.map(replaceAll(delimiter, \"/\"));\n}\nfunction replaceAll(search, replace) {\n  search = new RegExp(regexEscape(search), \"g\");\n  return (value) => value == null ? null : `${value}`.replace(search, replace);\n}\nfunction regexEscape(string2) {\n  return `${string2}`.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isNodeValue(option) {\n  return isObject(option) && typeof option.node === \"function\";\n}\nfunction isLinkValue(option) {\n  return isObject(option) && typeof option.link === \"function\";\n}\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\"))\n    return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value))\n    return value.node;\n  if (isLinkValue(value))\n    return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\"))\n    return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\nfunction nodePath(node) {\n  return node.id;\n}\nfunction nodeName(node) {\n  return nameof(node.id);\n}\nfunction nodeDepth(node) {\n  return node.depth;\n}\nfunction nodeHeight(node) {\n  return node.height;\n}\nfunction nodeInternal(node) {\n  return !!node.children;\n}\nfunction parentValue(evaluate) {\n  return (child, parent) => parent == null ? void 0 : evaluate(parent);\n}\nfunction nameof(path2) {\n  let i = path2.length;\n  while (--i > 0)\n    if (slash2(path2, i))\n      break;\n  return path2.slice(i + 1);\n}\nfunction slash2(path2, i) {\n  if (path2[i] === \"/\") {\n    let k2 = 0;\n    while (i > 0 && path2[--i] === \"\\\\\")\n      ++k2;\n    if ((k2 & 1) === 0)\n      return true;\n  }\n  return false;\n}\nvar output_setValues = 2;\nvar output_evaluate = 3;\nvar output_values = 4;\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== void 0) {\n      outputs.push([name, ...column(value), treeValue]);\n    }\n  }\n  return outputs;\n}\n\n// node_modules/@observablehq/plot/dist/marks/tree.js\nfunction tree(data, options = {}) {\n  let { fill, stroke, strokeWidth, strokeOpacity, strokeLinejoin, strokeLinecap, strokeMiterlimit, strokeDasharray, strokeDashoffset, marker, markerStart = marker, markerEnd = marker, dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd), text: textText = \"node:name\", textStroke = \"white\", title = \"node:path\", dx, dy, ...remainingOptions } = options;\n  if (dx === void 0)\n    dx = maybeTreeAnchor(remainingOptions.treeAnchor).dx;\n  return marks(link3(data, treeLink({\n    markerStart,\n    markerEnd,\n    stroke: stroke !== void 0 ? stroke : fill === void 0 ? \"node:internal\" : fill,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    ...remainingOptions\n  })), dotDot ? dot(data, treeNode({ fill: fill === void 0 ? \"node:internal\" : fill, title, ...remainingOptions })) : null, textText != null ? text(data, treeNode({\n    text: textText,\n    fill: fill === void 0 ? \"currentColor\" : fill,\n    stroke: textStroke,\n    dx,\n    dy,\n    title,\n    ...remainingOptions\n  })) : null);\n}\nfunction cluster(data, options) {\n  return tree(data, { ...options, treeLayout: cluster_default });\n}\n\n// node_modules/@observablehq/plot/dist/transforms/centroid.js\nfunction centroid({ geometry = identity6, ...options } = {}) {\n  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, { projection: projection2 }) => {\n    const G = valueof(data, geometry);\n    const n = G.length;\n    const X3 = new Float64Array(n);\n    const Y3 = new Float64Array(n);\n    const path2 = path_default(projection2);\n    for (let i = 0; i < n; ++i)\n      [X3[i], Y3[i]] = path2.centroid(G[i]);\n    return { data, facets, channels: { x: { value: X3 }, y: { value: Y3 } } };\n  });\n}\nfunction geoCentroid({ geometry = identity6, ...options } = {}) {\n  let C3;\n  return {\n    ...options,\n    x: { transform: (data) => Float64Array.from(C3 = valueof(valueof(data, geometry), centroid_default), ([x4]) => x4) },\n    y: { transform: () => Float64Array.from(C3, ([, y4]) => y4) }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/dodge.js\nvar import_interval_tree_1d = __toESM(require_interval_tree(), 1);\nvar anchorXLeft = ({ marginLeft }) => [1, marginLeft];\nvar anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];\nvar anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];\nvar anchorYTop = ({ marginTop }) => [1, marginTop];\nvar anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];\nvar anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];\nfunction maybeAnchor2(anchor) {\n  return typeof anchor === \"string\" ? { anchor } : anchor;\n}\nfunction dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"left\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, number5(padding), options);\n}\nfunction dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1)\n    [dodgeOptions, options] = mergeOptions3(dodgeOptions);\n  let { anchor = \"bottom\", padding = 1 } = maybeAnchor2(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, number5(padding), options);\n}\nfunction mergeOptions3(options) {\n  const { anchor, padding, ...rest } = options;\n  return [{ anchor, padding }, rest];\n}\nfunction dodge(y4, x4, anchor, padding, options) {\n  const { r } = options;\n  if (r != null && typeof r !== \"number\") {\n    const { channels, sort: sort3, reverse: reverse3 } = options;\n    options = { ...options, channels: { r: { value: r, scale: \"r\" }, ...maybeNamed(channels) } };\n    if (sort3 === void 0 && reverse3 === void 0)\n      options.sort = { channel: \"r\", order: \"descending\" };\n  }\n  return initializer(options, function(data, facets, channels, scales, dimensions, context) {\n    let { [x4]: X3, r: R } = channels;\n    if (!channels[x4])\n      throw new Error(`missing channel: ${x4}`);\n    ({ [x4]: X3 } = Position(channels, scales, context));\n    const r2 = R ? void 0 : this.r !== void 0 ? this.r : options.r !== void 0 ? number5(options.r) : 3;\n    if (R)\n      R = coerceNumbers(valueof(R.value, scales[R.scale] || identity6));\n    let [ky2, ty] = anchor(dimensions);\n    const compare = ky2 ? compareAscending : compareSymmetric;\n    const Y3 = new Float64Array(X3.length);\n    const radius2 = R ? (i) => R[i] : () => r2;\n    for (let I of facets) {\n      const tree2 = (0, import_interval_tree_1d.default)();\n      I = I.filter(R ? (i) => finite2(X3[i]) && positive(R[i]) : (i) => finite2(X3[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius2(i);\n        const y06 = ky2 ? ri + padding : 0;\n        const l = X3[i] - ri;\n        const h = X3[i] + ri;\n        let k2 = 2;\n        tree2.queryInterval(l - padding, h + padding, ([, , j]) => {\n          const yj = Y3[j] - y06;\n          const dx = X3[i] - X3[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * r2);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k2++] = yj - dy;\n          intervals[k2++] = yj + dy;\n        });\n        let candidates = intervals.slice(0, k2);\n        if (ky2)\n          candidates = candidates.filter((y5) => y5 >= 0);\n        out:\n          for (const y5 of candidates.sort(compare)) {\n            for (let j = 0; j < k2; j += 2) {\n              if (intervals[j] + 1e-6 < y5 && y5 < intervals[j + 1] - 1e-6) {\n                continue out;\n              }\n            }\n            Y3[i] = y5 + y06;\n            break;\n          }\n        tree2.insert([l, h, i]);\n      }\n    }\n    if (!ky2)\n      ky2 = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y3[i] = Y3[i] * ky2 + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [x4]: { value: X3 },\n        [y4]: { value: Y3 },\n        ...R && { r: { value: R } }\n      }\n    };\n  });\n}\nfunction compareSymmetric(a4, b) {\n  return Math.abs(a4) - Math.abs(b);\n}\nfunction compareAscending(a4, b) {\n  return a4 - b;\n}\n\n// node_modules/@observablehq/plot/dist/transforms/normalize.js\nfunction normalizeX(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapX(normalize3(basis2), options);\n}\nfunction normalizeY(basis2, options) {\n  if (arguments.length === 1)\n    ({ basis: basis2, ...options } = basis2);\n  return mapY(normalize3(basis2), options);\n}\nfunction normalize3(basis2) {\n  if (basis2 === void 0)\n    return normalizeFirst;\n  if (typeof basis2 === \"function\")\n    return normalizeBasis((I, S) => basis2(take(S, I)));\n  if (/^p\\d{2}$/i.test(basis2))\n    return normalizeAccessor(percentile(basis2));\n  switch (`${basis2}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis2}`);\n}\nfunction normalizeBasis(basis2) {\n  return {\n    map(I, S, T) {\n      const b = +basis2(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, (i) => S[i]));\n}\nvar normalizeExtent = {\n  map(I, S, T) {\n    const [s1, s2] = extent(I, (i) => S[i]), d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\nvar normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s2 = S[I[i]];\n    if (defined(s2))\n      return s2;\n  }\n});\nvar normalizeDeviation = {\n  map(I, S, T) {\n    const m3 = mean(I, (i) => S[i]);\n    const d = deviation(I, (i) => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m3) / d : 0;\n    }\n  }\n};\nvar normalizeMax = normalizeAccessor(max);\nvar normalizeMean = normalizeAccessor(mean);\nvar normalizeMedian = normalizeAccessor(median);\nvar normalizeMin = normalizeAccessor(min);\nvar normalizeSum = normalizeAccessor(sum);\n\n// node_modules/@observablehq/plot/dist/transforms/window.js\nfunction windowX(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapX(window2(windowOptions), options);\n}\nfunction windowY(windowOptions = {}, options) {\n  if (arguments.length === 1)\n    options = windowOptions;\n  return mapY(window2(windowOptions), options);\n}\nfunction window2(options = {}) {\n  if (typeof options === \"number\")\n    options = { k: options };\n  let { k: k2, reduce: reduce2, shift, anchor, strict } = options;\n  if (anchor === void 0 && shift !== void 0) {\n    anchor = maybeShift(shift);\n    warn(`Warning: the shift option is deprecated; please use anchor \"${anchor}\" instead.`);\n  }\n  if (!((k2 = Math.floor(k2)) > 0))\n    throw new Error(`invalid k: ${k2}`);\n  return maybeReduce2(reduce2)(k2, maybeAnchor3(anchor, k2), strict);\n}\nfunction maybeAnchor3(anchor = \"middle\", k2) {\n  switch (`${anchor}`.toLowerCase()) {\n    case \"middle\":\n      return k2 - 1 >> 1;\n    case \"start\":\n      return 0;\n    case \"end\":\n      return k2 - 1;\n  }\n  throw new Error(`invalid anchor: ${anchor}`);\n}\nfunction maybeShift(shift) {\n  switch (`${shift}`.toLowerCase()) {\n    case \"centered\":\n      return \"middle\";\n    case \"leading\":\n      return \"start\";\n    case \"trailing\":\n      return \"end\";\n  }\n  throw new Error(`invalid shift: ${shift}`);\n}\nfunction maybeReduce2(reduce2 = \"mean\") {\n  if (typeof reduce2 === \"string\") {\n    if (/^p\\d{2}$/i.test(reduce2))\n      return reduceNumbers(percentile(reduce2));\n    switch (reduce2.toLowerCase()) {\n      case \"deviation\":\n        return reduceNumbers(deviation);\n      case \"max\":\n        return reduceArray(max);\n      case \"mean\":\n        return reduceMean;\n      case \"median\":\n        return reduceNumbers(median);\n      case \"min\":\n        return reduceArray(min);\n      case \"mode\":\n        return reduceArray(mode);\n      case \"sum\":\n        return reduceSum2;\n      case \"variance\":\n        return reduceNumbers(variance);\n      case \"difference\":\n        return reduceDifference;\n      case \"ratio\":\n        return reduceRatio;\n      case \"first\":\n        return reduceFirst2;\n      case \"last\":\n        return reduceLast2;\n    }\n  }\n  if (typeof reduce2 !== \"function\")\n    throw new Error(`invalid reduce: ${reduce2}`);\n  return reduceArray(reduce2);\n}\nfunction slice6(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\nfunction reduceNumbers(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      let nans = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        if (isNaN(C3[i]))\n          ++nans;\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        if (isNaN(C3[i + k2 - 1]))\n          ++nans;\n        T[I[i + s2]] = nans === 0 ? f(C3.subarray(i, i + k2)) : NaN;\n        if (isNaN(C3[i]))\n          --nans;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      const C3 = Float64Array.from(I, (i) => S[i] === null ? NaN : S[i]);\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(C3.subarray(0, i + k2));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(C3.subarray(i, i + k2));\n      }\n    }\n  };\n}\nfunction reduceArray(f) {\n  return (k2, s2, strict) => strict ? {\n    map(I, S, T) {\n      let count3 = 0;\n      for (let i = 0; i < k2 - 1; ++i)\n        count3 += defined(S[I[i]]);\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        count3 += defined(S[I[i + k2 - 1]]);\n        if (count3 === k2)\n          T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n        count3 -= defined(S[I[i]]);\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2; i < 0; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, 0, i + k2)));\n      }\n      for (let i = 0, n = I.length - s2; i < n; ++i) {\n        T[I[i + s2]] = f(take(S, slice6(I, i, i + k2)));\n      }\n    }\n  };\n}\nfunction reduceSum2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      let nans = 0;\n      let sum5 = 0;\n      for (let i = 0; i < k2 - 1; ++i) {\n        const v2 = S[I[i]];\n        if (v2 === null || isNaN(v2))\n          ++nans;\n        else\n          sum5 += +v2;\n      }\n      for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        if (b === null || isNaN(b))\n          ++nans;\n        else\n          sum5 += +b;\n        T[I[i + s2]] = nans === 0 ? sum5 : NaN;\n        if (a4 === null || isNaN(a4))\n          --nans;\n        else\n          sum5 -= +a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      let sum5 = 0;\n      const n = I.length;\n      for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n        sum5 += +S[I[i]] || 0;\n      }\n      for (let i = -s2, j = n - s2; i < j; ++i) {\n        sum5 += +S[I[i + k2 - 1]] || 0;\n        T[I[i + s2]] = sum5;\n        sum5 -= +S[I[i]] || 0;\n      }\n    }\n  };\n}\nfunction reduceMean(k2, s2, strict) {\n  if (strict) {\n    const sum5 = reduceSum2(k2, s2, strict);\n    return {\n      map(I, S, T) {\n        sum5.map(I, S, T);\n        for (let i = 0, n = I.length - k2 + 1; i < n; ++i) {\n          T[I[i + s2]] /= k2;\n        }\n      }\n    };\n  } else {\n    return {\n      map(I, S, T) {\n        let sum5 = 0;\n        let count3 = 0;\n        const n = I.length;\n        for (let i = 0, j = Math.min(n, k2 - s2 - 1); i < j; ++i) {\n          let v2 = S[I[i]];\n          if (v2 !== null && !isNaN(v2 = +v2))\n            sum5 += v2, ++count3;\n        }\n        for (let i = -s2, j = n - s2; i < j; ++i) {\n          let a4 = S[I[i + k2 - 1]];\n          let b = S[I[i]];\n          if (a4 !== null && !isNaN(a4 = +a4))\n            sum5 += a4, ++count3;\n          T[I[i + s2]] = sum5 / count3;\n          if (b !== null && !isNaN(b = +b))\n            sum5 -= b, --count3;\n        }\n      }\n    };\n  }\n}\nfunction firstDefined(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    const v2 = S[I[i]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction lastDefined(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    const v2 = S[I[j]];\n    if (defined(v2))\n      return v2;\n  }\n}\nfunction firstNumber(S, I, i, k2) {\n  for (let j = i + k2; i < j; ++i) {\n    let v2 = S[I[i]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction lastNumber(S, I, i, k2) {\n  for (let j = i + k2 - 1; j >= i; --j) {\n    let v2 = S[I[j]];\n    if (v2 !== null && !isNaN(v2 = +v2))\n      return v2;\n  }\n}\nfunction reduceDifference(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b - a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) - firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceRatio(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        const a4 = S[I[i]];\n        const b = S[I[i + k2 - 1]];\n        T[I[i + s2]] = a4 === null || b === null ? NaN : b / a4;\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastNumber(S, I, i, k2) / firstNumber(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceFirst2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = firstDefined(S, I, i, k2);\n      }\n    }\n  };\n}\nfunction reduceLast2(k2, s2, strict) {\n  return strict ? {\n    map(I, S, T) {\n      for (let i = 0, n = I.length - k2; i < n; ++i) {\n        T[I[i + s2]] = S[I[i + k2 - 1]];\n      }\n    }\n  } : {\n    map(I, S, T) {\n      for (let i = -s2, n = I.length - k2 + s2 + 1; i < n; ++i) {\n        T[I[i + s2]] = lastDefined(S, I, i, k2);\n      }\n    }\n  };\n}\n\n// node_modules/@observablehq/plot/dist/transforms/select.js\nfunction select(selector, options = {}) {\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  let key, value;\n  for (key in selector) {\n    if (value !== void 0)\n      throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === void 0)\n    throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\")\n    return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\nfunction selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\nfunction selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\nfunction selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\nfunction selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\nfunction selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\nfunction selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\nfunction* selectorFirst(I) {\n  yield I[0];\n}\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\nfunction* selectorMin(I, X3) {\n  yield least(I, (i) => X3[i]);\n}\nfunction* selectorMax(I, X3) {\n  yield greatest(I, (i) => X3[i]);\n}\nfunction selectChannel(v2, selector, options) {\n  if (v2 != null) {\n    if (options[v2] == null)\n      throw new Error(`missing channel: ${v2}`);\n    v2 = options[v2];\n  }\n  const z = maybeZ(options);\n  return basic(options, (data, facets) => {\n    const Z = valueof(data, z);\n    const V = valueof(data, v2);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return { data, facets: selectFacets };\n  });\n}\n\n// node_modules/tslib/tslib.es6.js\nfunction __rest(s2, e) {\n  var t = {};\n  for (var p in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)\n      t[p] = s2[p];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))\n        t[p[i]] = s2[p[i]];\n    }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s2 = typeof Symbol === \"function\" && Symbol.iterator, m3 = s2 && o[s2], i = 0;\n  if (m3)\n    return m3.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s2 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v2) {\n  return this instanceof __await ? (this.v = v2, this) : new __await(v2);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v2) {\n        return new Promise(function(a4, b) {\n          q.push([n, v2, a4, b]) > 1 || resume(n, v2);\n        });\n      };\n  }\n  function resume(n, v2) {\n    try {\n      step(g[n](v2));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v2) {\n    if (f(v2), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v2) {\n      return (p = !p) ? { value: __await(o[n](v2)), done: false } : f ? f(v2) : v2;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m3 = o[Symbol.asyncIterator], i;\n  return m3 ? m3.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v2) {\n      return new Promise(function(resolve, reject) {\n        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v2) {\n    Promise.resolve(v2).then(function(v3) {\n      resolve({ value: v3, done: d });\n    }, reject);\n  }\n}\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar buffer_exports = {};\n__export(buffer_exports, {\n  compareArrayLike: () => compareArrayLike,\n  joinUint8Arrays: () => joinUint8Arrays,\n  memcpy: () => memcpy,\n  rebaseValueOffsets: () => rebaseValueOffsets,\n  toArrayBufferView: () => toArrayBufferView,\n  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,\n  toArrayBufferViewIterator: () => toArrayBufferViewIterator,\n  toBigInt64Array: () => toBigInt64Array,\n  toBigUint64Array: () => toBigUint64Array,\n  toFloat32Array: () => toFloat32Array,\n  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,\n  toFloat32ArrayIterator: () => toFloat32ArrayIterator,\n  toFloat64Array: () => toFloat64Array,\n  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,\n  toFloat64ArrayIterator: () => toFloat64ArrayIterator,\n  toInt16Array: () => toInt16Array,\n  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,\n  toInt16ArrayIterator: () => toInt16ArrayIterator,\n  toInt32Array: () => toInt32Array,\n  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,\n  toInt32ArrayIterator: () => toInt32ArrayIterator,\n  toInt8Array: () => toInt8Array,\n  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,\n  toInt8ArrayIterator: () => toInt8ArrayIterator,\n  toUint16Array: () => toUint16Array,\n  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,\n  toUint16ArrayIterator: () => toUint16ArrayIterator,\n  toUint32Array: () => toUint32Array,\n  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,\n  toUint32ArrayIterator: () => toUint32ArrayIterator,\n  toUint8Array: () => toUint8Array,\n  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,\n  toUint8ArrayIterator: () => toUint8ArrayIterator,\n  toUint8ClampedArray: () => toUint8ClampedArray,\n  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,\n  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator\n});\n\n// node_modules/apache-arrow/util/utf8.mjs\nvar decoder = new TextDecoder(\"utf-8\");\nvar decodeUtf8 = (buffer) => decoder.decode(buffer);\nvar encoder = new TextEncoder();\nvar encodeUtf8 = (value) => encoder.encode(value);\n\n// node_modules/apache-arrow/util/compat.mjs\nvar [BigIntCtor, BigIntAvailable] = (() => {\n  const BigIntUnavailableError = () => {\n    throw new Error(\"BigInt is not available in this environment\");\n  };\n  function BigIntUnavailable() {\n    throw BigIntUnavailableError();\n  }\n  BigIntUnavailable.asIntN = () => {\n    throw BigIntUnavailableError();\n  };\n  BigIntUnavailable.asUintN = () => {\n    throw BigIntUnavailableError();\n  };\n  return typeof BigInt !== \"undefined\" ? [BigInt, true] : [BigIntUnavailable, false];\n})();\nvar [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {\n  const BigInt64ArrayUnavailableError = () => {\n    throw new Error(\"BigInt64Array is not available in this environment\");\n  };\n  class BigInt64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigInt64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigInt64ArrayUnavailableError();\n    }\n  }\n  return typeof BigInt64Array !== \"undefined\" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];\n})();\nvar [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {\n  const BigUint64ArrayUnavailableError = () => {\n    throw new Error(\"BigUint64Array is not available in this environment\");\n  };\n  class BigUint64ArrayUnavailable {\n    static get BYTES_PER_ELEMENT() {\n      return 8;\n    }\n    static of() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    static from() {\n      throw BigUint64ArrayUnavailableError();\n    }\n    constructor() {\n      throw BigUint64ArrayUnavailableError();\n    }\n  }\n  return typeof BigUint64Array !== \"undefined\" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];\n})();\nvar isNumber = (x4) => typeof x4 === \"number\";\nvar isBoolean = (x4) => typeof x4 === \"boolean\";\nvar isFunction = (x4) => typeof x4 === \"function\";\nvar isObject2 = (x4) => x4 != null && Object(x4) === x4;\nvar isPromise = (x4) => {\n  return isObject2(x4) && isFunction(x4.then);\n};\nvar isIterable2 = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.iterator]);\n};\nvar isAsyncIterable = (x4) => {\n  return isObject2(x4) && isFunction(x4[Symbol.asyncIterator]);\n};\nvar isArrowJSON = (x4) => {\n  return isObject2(x4) && isObject2(x4[\"schema\"]);\n};\nvar isIteratorResult = (x4) => {\n  return isObject2(x4) && \"done\" in x4 && \"value\" in x4;\n};\nvar isFileHandle = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"stat\"]) && isNumber(x4[\"fd\"]);\n};\nvar isFetchResponse = (x4) => {\n  return isObject2(x4) && isReadableDOMStream(x4[\"body\"]);\n};\nvar isReadableInterop = (x4) => \"_getDOMStream\" in x4 && \"_getNodeStream\" in x4;\nvar isWritableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"abort\"]) && isFunction(x4[\"getWriter\"]) && !isReadableInterop(x4);\n};\nvar isReadableDOMStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"cancel\"]) && isFunction(x4[\"getReader\"]) && !isReadableInterop(x4);\n};\nvar isWritableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"end\"]) && isFunction(x4[\"write\"]) && isBoolean(x4[\"writable\"]) && !isReadableInterop(x4);\n};\nvar isReadableNodeStream = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"read\"]) && isFunction(x4[\"pipe\"]) && isBoolean(x4[\"readable\"]) && !isReadableInterop(x4);\n};\nvar isFlatbuffersByteBuffer = (x4) => {\n  return isObject2(x4) && isFunction(x4[\"clear\"]) && isFunction(x4[\"bytes\"]) && isFunction(x4[\"position\"]) && isFunction(x4[\"setPosition\"]) && isFunction(x4[\"capacity\"]) && isFunction(x4[\"getBufferIdentifier\"]) && isFunction(x4[\"createLong\"]);\n};\n\n// node_modules/apache-arrow/util/buffer.mjs\nvar SharedArrayBuf = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : ArrayBuffer;\nfunction collapseContiguousByteRanges(chunks) {\n  const result = chunks[0] ? [chunks[0]] : [];\n  let xOffset, yOffset, xLen, yLen;\n  for (let x4, y4, i = 0, j = 0, n = chunks.length; ++i < n; ) {\n    x4 = result[j];\n    y4 = chunks[i];\n    if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    ({ byteOffset: xOffset, byteLength: xLen } = x4);\n    ({ byteOffset: yOffset, byteLength: yLen } = y4);\n    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {\n      y4 && (result[++j] = y4);\n      continue;\n    }\n    result[j] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);\n  }\n  return result;\n}\nfunction memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));\n  dst.set(src, targetByteOffset);\n  return target;\n}\nfunction joinUint8Arrays(chunks, size) {\n  const result = collapseContiguousByteRanges(chunks);\n  const byteLength = result.reduce((x4, b) => x4 + b.byteLength, 0);\n  let source, sliced, buffer;\n  let offset2 = 0, index3 = -1;\n  const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);\n  for (const n = result.length; ++index3 < n; ) {\n    source = result[index3];\n    sliced = source.subarray(0, Math.min(source.length, length4 - offset2));\n    if (length4 <= offset2 + sliced.length) {\n      if (sliced.length < source.length) {\n        result[index3] = source.subarray(sliced.length);\n      } else if (sliced.length === source.length) {\n        index3++;\n      }\n      buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;\n      break;\n    }\n    memcpy(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);\n    offset2 += sliced.length;\n  }\n  return [buffer || new Uint8Array(0), result.slice(index3), byteLength - (buffer ? buffer.byteLength : 0)];\n}\nfunction toArrayBufferView(ArrayBufferViewCtor, input) {\n  let value = isIteratorResult(input) ? input.value : input;\n  if (value instanceof ArrayBufferViewCtor) {\n    if (ArrayBufferViewCtor === Uint8Array) {\n      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);\n    }\n    return value;\n  }\n  if (!value) {\n    return new ArrayBufferViewCtor(0);\n  }\n  if (typeof value === \"string\") {\n    value = encodeUtf8(value);\n  }\n  if (value instanceof ArrayBuffer) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (value instanceof SharedArrayBuf) {\n    return new ArrayBufferViewCtor(value);\n  }\n  if (isFlatbuffersByteBuffer(value)) {\n    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());\n  }\n  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);\n}\nvar toInt8Array = (input) => toArrayBufferView(Int8Array, input);\nvar toInt16Array = (input) => toArrayBufferView(Int16Array, input);\nvar toInt32Array = (input) => toArrayBufferView(Int32Array, input);\nvar toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);\nvar toUint8Array = (input) => toArrayBufferView(Uint8Array, input);\nvar toUint16Array = (input) => toArrayBufferView(Uint16Array, input);\nvar toUint32Array = (input) => toArrayBufferView(Uint32Array, input);\nvar toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);\nvar toFloat32Array = (input) => toArrayBufferView(Float32Array, input);\nvar toFloat64Array = (input) => toArrayBufferView(Float64Array, input);\nvar toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);\nvar pump = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* toArrayBufferViewIterator(ArrayCtor, source) {\n  const wrap = function* (x4) {\n    yield x4;\n  };\n  const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;\n  yield* pump(function* (it) {\n    let r = null;\n    do {\n      r = it.next(yield toArrayBufferView(ArrayCtor, r));\n    } while (!r.done);\n  }(buffers[Symbol.iterator]()));\n  return new ArrayCtor();\n}\nvar toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);\nvar toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);\nvar toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);\nvar toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);\nvar toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);\nvar toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);\nvar toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);\nvar toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);\nvar toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);\nfunction toArrayBufferViewAsyncIterator(ArrayCtor, source) {\n  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {\n    if (isPromise(source)) {\n      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));\n    }\n    const wrap = function(x4) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield yield __await(yield __await(x4));\n      });\n    };\n    const emit = function(source2) {\n      return __asyncGenerator(this, arguments, function* () {\n        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {\n          let r = null;\n          do {\n            r = it.next(yield r === null || r === void 0 ? void 0 : r.value);\n          } while (!r.done);\n        }(source2[Symbol.iterator]())))));\n      });\n    };\n    const buffers = typeof source === \"string\" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;\n    yield __await(\n      // otherwise if AsyncIterable, use it\n      yield* __asyncDelegator(__asyncValues(pump(function(it) {\n        return __asyncGenerator(this, arguments, function* () {\n          let r = null;\n          do {\n            r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));\n          } while (!r.done);\n        });\n      }(buffers[Symbol.asyncIterator]()))))\n    );\n    return yield __await(new ArrayCtor());\n  });\n}\nvar toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);\nvar toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);\nvar toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);\nvar toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);\nvar toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);\nvar toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);\nvar toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);\nvar toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);\nvar toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);\nfunction rebaseValueOffsets(offset2, length4, valueOffsets) {\n  if (offset2 !== 0) {\n    valueOffsets = valueOffsets.slice(0, length4 + 1);\n    for (let i = -1; ++i <= length4; ) {\n      valueOffsets[i] += offset2;\n    }\n  }\n  return valueOffsets;\n}\nfunction compareArrayLike(a4, b) {\n  let i = 0;\n  const n = a4.length;\n  if (n !== b.length) {\n    return false;\n  }\n  if (n > 0) {\n    do {\n      if (a4[i] !== b[i]) {\n        return false;\n      }\n    } while (++i < n);\n  }\n  return true;\n}\n\n// node_modules/apache-arrow/io/adapters.mjs\nvar adapters_default = {\n  fromIterable(source) {\n    return pump2(fromIterable(source));\n  },\n  fromAsyncIterable(source) {\n    return pump2(fromAsyncIterable(source));\n  },\n  fromDOMStream(source) {\n    return pump2(fromDOMStream(source));\n  },\n  fromNodeStream(stream) {\n    return pump2(fromNodeStream(stream));\n  },\n  // @ts-ignore\n  toDOMStream(source, options) {\n    throw new Error(`\"toDOMStream\" not available in this environment`);\n  },\n  // @ts-ignore\n  toNodeStream(source, options) {\n    throw new Error(`\"toNodeStream\" not available in this environment`);\n  }\n};\nvar pump2 = (iterator) => {\n  iterator.next();\n  return iterator;\n};\nfunction* fromIterable(source) {\n  let done, threw = false;\n  let buffers = [], buffer;\n  let cmd, size, bufferLength = 0;\n  function byteRange() {\n    if (cmd === \"peek\") {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  }\n  ({ cmd, size } = yield null);\n  const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n  try {\n    do {\n      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      }\n      if (done || size <= bufferLength) {\n        do {\n          ({ cmd, size } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === \"function\" && it.throw(e);\n  } finally {\n    threw === false && typeof it.return === \"function\" && it.return(null);\n  }\n  return null;\n}\nfunction fromAsyncIterable(source) {\n  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n    let done, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && typeof it.throw === \"function\" && (yield __await(it.throw(e)));\n    } finally {\n      threw === false && typeof it.return === \"function\" && (yield __await(it.return(new Uint8Array(0))));\n    }\n    return yield __await(null);\n  });\n}\nfunction fromDOMStream(source) {\n  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n    let done = false, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    const it = new AdaptiveByteReader(source);\n    try {\n      do {\n        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it[\"read\"]()) : yield __await(it[\"read\"](size - bufferLength)));\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(toUint8Array(buffer));\n          bufferLength += buffer.byteLength;\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && (yield __await(it[\"cancel\"](e)));\n    } finally {\n      threw === false ? yield __await(it[\"cancel\"]()) : source[\"locked\"] && it.releaseLock();\n    }\n    return yield __await(null);\n  });\n}\nvar AdaptiveByteReader = class {\n  constructor(source) {\n    this.source = source;\n    this.reader = null;\n    this.reader = this.source[\"getReader\"]();\n    this.reader[\"closed\"].catch(() => {\n    });\n  }\n  get closed() {\n    return this.reader ? this.reader[\"closed\"].catch(() => {\n    }) : Promise.resolve();\n  }\n  releaseLock() {\n    if (this.reader) {\n      this.reader.releaseLock();\n    }\n    this.reader = null;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { reader, source } = this;\n      reader && (yield reader[\"cancel\"](reason).catch(() => {\n      }));\n      source && (source[\"locked\"] && this.releaseLock());\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (size === 0) {\n        return { done: this.reader == null, value: new Uint8Array(0) };\n      }\n      const result = yield this.reader.read();\n      !result.done && (result.value = toUint8Array(result));\n      return result;\n    });\n  }\n};\nvar onEvent = (stream, event) => {\n  const handler = (_) => resolve([event, _]);\n  let resolve;\n  return [event, handler, new Promise((r) => (resolve = r) && stream[\"once\"](event, handler))];\n};\nfunction fromNodeStream(stream) {\n  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n    const events = [];\n    let event = \"error\";\n    let done = false, err = null;\n    let cmd, size, bufferLength = 0;\n    let buffers = [], buffer;\n    function byteRange() {\n      if (cmd === \"peek\") {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    ({ cmd, size } = yield yield __await(null));\n    if (stream[\"isTTY\"]) {\n      yield yield __await(new Uint8Array(0));\n      return yield __await(null);\n    }\n    try {\n      events[0] = onEvent(stream, \"end\");\n      events[1] = onEvent(stream, \"error\");\n      do {\n        events[2] = onEvent(stream, \"readable\");\n        [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));\n        if (event === \"error\") {\n          break;\n        }\n        if (!(done = event === \"end\")) {\n          if (!Number.isFinite(size - bufferLength)) {\n            buffer = toUint8Array(stream[\"read\"]());\n          } else {\n            buffer = toUint8Array(stream[\"read\"](size - bufferLength));\n            if (buffer.byteLength < size - bufferLength) {\n              buffer = toUint8Array(stream[\"read\"]());\n            }\n          }\n          if (buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n        }\n        if (done || size <= bufferLength) {\n          do {\n            ({ cmd, size } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } finally {\n      yield __await(cleanup(events, event === \"error\" ? err : null));\n    }\n    return yield __await(null);\n    function cleanup(events2, err2) {\n      buffer = buffers = null;\n      return new Promise((resolve, reject) => {\n        for (const [evt, fn] of events2) {\n          stream[\"off\"](evt, fn);\n        }\n        try {\n          const destroy = stream[\"destroy\"];\n          destroy && destroy.call(stream, err2);\n          err2 = void 0;\n        } catch (e) {\n          err2 = e || err2;\n        } finally {\n          err2 != null ? reject(err2) : resolve();\n        }\n      });\n    }\n  });\n}\n\n// node_modules/apache-arrow/enum.mjs\nvar MetadataVersion;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion || (MetadataVersion = {}));\nvar UnionMode;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode || (UnionMode = {}));\nvar Precision;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision || (Precision = {}));\nvar DateUnit;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit || (DateUnit = {}));\nvar TimeUnit;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit || (TimeUnit = {}));\nvar IntervalUnit;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit || (IntervalUnit = {}));\nvar MessageHeader;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nvar Type;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"Float\"] = 3] = \"Float\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct\"] = 13] = \"Struct\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type3[Type3[\"Int8\"] = -2] = \"Int8\";\n  Type3[Type3[\"Int16\"] = -3] = \"Int16\";\n  Type3[Type3[\"Int32\"] = -4] = \"Int32\";\n  Type3[Type3[\"Int64\"] = -5] = \"Int64\";\n  Type3[Type3[\"Uint8\"] = -6] = \"Uint8\";\n  Type3[Type3[\"Uint16\"] = -7] = \"Uint16\";\n  Type3[Type3[\"Uint32\"] = -8] = \"Uint32\";\n  Type3[Type3[\"Uint64\"] = -9] = \"Uint64\";\n  Type3[Type3[\"Float16\"] = -10] = \"Float16\";\n  Type3[Type3[\"Float32\"] = -11] = \"Float32\";\n  Type3[Type3[\"Float64\"] = -12] = \"Float64\";\n  Type3[Type3[\"DateDay\"] = -13] = \"DateDay\";\n  Type3[Type3[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type3[Type3[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type3[Type3[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type3[Type3[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type3[Type3[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type3[Type3[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type3[Type3[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type3[Type3[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type3[Type3[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type3[Type3[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type3[Type3[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type3[Type3[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type3[Type3[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\nvar BufferType;\n(function(BufferType2) {\n  BufferType2[BufferType2[\"OFFSET\"] = 0] = \"OFFSET\";\n  BufferType2[BufferType2[\"DATA\"] = 1] = \"DATA\";\n  BufferType2[BufferType2[\"VALIDITY\"] = 2] = \"VALIDITY\";\n  BufferType2[BufferType2[\"TYPE\"] = 3] = \"TYPE\";\n})(BufferType || (BufferType = {}));\n\n// node_modules/apache-arrow/util/vector.mjs\nvar vector_exports = {};\n__export(vector_exports, {\n  clampIndex: () => clampIndex,\n  clampRange: () => clampRange,\n  createElementComparator: () => createElementComparator\n});\n\n// node_modules/apache-arrow/util/pretty.mjs\nvar undf = void 0;\nfunction valueToString(x4) {\n  if (x4 === null) {\n    return \"null\";\n  }\n  if (x4 === undf) {\n    return \"undefined\";\n  }\n  switch (typeof x4) {\n    case \"number\":\n      return `${x4}`;\n    case \"bigint\":\n      return `${x4}`;\n    case \"string\":\n      return `\"${x4}\"`;\n  }\n  if (typeof x4[Symbol.toPrimitive] === \"function\") {\n    return x4[Symbol.toPrimitive](\"string\");\n  }\n  if (ArrayBuffer.isView(x4)) {\n    if (x4 instanceof BigInt64ArrayCtor || x4 instanceof BigUint64ArrayCtor) {\n      return `[${[...x4].map((x5) => valueToString(x5))}]`;\n    }\n    return `[${x4}]`;\n  }\n  return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_, y4) => typeof y4 === \"bigint\" ? `${y4}` : y4);\n}\n\n// node_modules/apache-arrow/util/bn.mjs\nvar bn_exports = {};\n__export(bn_exports, {\n  BN: () => BN,\n  bignumToBigInt: () => bignumToBigInt,\n  bignumToString: () => bignumToString,\n  isArrowBigNumSymbol: () => isArrowBigNumSymbol\n});\nvar isArrowBigNumSymbol = Symbol.for(\"isArrowBigNum\");\nfunction BigNum(x4, ...xs) {\n  if (xs.length === 0) {\n    return Object.setPrototypeOf(toArrayBufferView(this[\"TypedArray\"], x4), this.constructor.prototype);\n  }\n  return Object.setPrototypeOf(new this[\"TypedArray\"](x4, ...xs), this.constructor.prototype);\n}\nBigNum.prototype[isArrowBigNumSymbol] = true;\nBigNum.prototype.toJSON = function() {\n  return `\"${bignumToString(this)}\"`;\n};\nBigNum.prototype.valueOf = function() {\n  return bignumToNumber(this);\n};\nBigNum.prototype.toString = function() {\n  return bignumToString(this);\n};\nBigNum.prototype[Symbol.toPrimitive] = function(hint = \"default\") {\n  switch (hint) {\n    case \"number\":\n      return bignumToNumber(this);\n    case \"string\":\n      return bignumToString(this);\n    case \"default\":\n      return bignumToBigInt(this);\n  }\n  return bignumToString(this);\n};\nfunction SignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction UnsignedBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nfunction DecimalBigNum(...args) {\n  return BigNum.apply(this, args);\n}\nObject.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype, BigNum.prototype, { \"constructor\": SignedBigNum, \"signed\": true, \"TypedArray\": Int32Array, \"BigIntArray\": BigInt64ArrayCtor });\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, { \"constructor\": UnsignedBigNum, \"signed\": false, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nObject.assign(DecimalBigNum.prototype, BigNum.prototype, { \"constructor\": DecimalBigNum, \"signed\": true, \"TypedArray\": Uint32Array, \"BigIntArray\": BigUint64ArrayCtor });\nfunction bignumToNumber(bn) {\n  const { buffer, byteOffset, length: length4, \"signed\": signed } = bn;\n  const words = new BigUint64ArrayCtor(buffer, byteOffset, length4);\n  const negative2 = signed && words[words.length - 1] & BigInt(1) << BigInt(63);\n  let number7 = negative2 ? BigInt(1) : BigInt(0);\n  let i = BigInt(0);\n  if (!negative2) {\n    for (const word of words) {\n      number7 += word * (BigInt(1) << BigInt(32) * i++);\n    }\n  } else {\n    for (const word of words) {\n      number7 += ~word * (BigInt(1) << BigInt(32) * i++);\n    }\n    number7 *= BigInt(-1);\n  }\n  return number7;\n}\nvar bignumToString;\nvar bignumToBigInt;\nif (!BigIntAvailable) {\n  bignumToString = decimalToString;\n  bignumToBigInt = bignumToString;\n} else {\n  bignumToBigInt = (a4) => a4.byteLength === 8 ? new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0] : decimalToString(a4);\n  bignumToString = (a4) => a4.byteLength === 8 ? `${new a4[\"BigIntArray\"](a4.buffer, a4.byteOffset, 1)[0]}` : decimalToString(a4);\n}\nfunction decimalToString(a4) {\n  let digits = \"\";\n  const base64 = new Uint32Array(2);\n  let base32 = new Uint16Array(a4.buffer, a4.byteOffset, a4.byteLength / 2);\n  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n  let i = -1;\n  const n = base32.length - 1;\n  do {\n    for (base64[0] = base32[i = 0]; i < n; ) {\n      base32[i++] = base64[1] = base64[0] / 10;\n      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];\n    }\n    base32[i] = base64[1] = base64[0] / 10;\n    base64[0] = base64[0] - base64[1] * 10;\n    digits = `${base64[0]}${digits}`;\n  } while (checks[0] || checks[1] || checks[2] || checks[3]);\n  return digits !== null && digits !== void 0 ? digits : `0`;\n}\nvar BN = class {\n  /** @nocollapse */\n  static new(num, isSigned) {\n    switch (isSigned) {\n      case true:\n        return new SignedBigNum(num);\n      case false:\n        return new UnsignedBigNum(num);\n    }\n    switch (num.constructor) {\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case BigInt64ArrayCtor:\n        return new SignedBigNum(num);\n    }\n    if (num.byteLength === 16) {\n      return new DecimalBigNum(num);\n    }\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static signed(num) {\n    return new SignedBigNum(num);\n  }\n  /** @nocollapse */\n  static unsigned(num) {\n    return new UnsignedBigNum(num);\n  }\n  /** @nocollapse */\n  static decimal(num) {\n    return new DecimalBigNum(num);\n  }\n  constructor(num, isSigned) {\n    return BN.new(num, isSigned);\n  }\n};\n\n// node_modules/apache-arrow/type.mjs\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\nvar _f;\nvar _g;\nvar _h;\nvar _j;\nvar _k;\nvar _l;\nvar _m;\nvar _o;\nvar _p;\nvar _q;\nvar _r;\nvar _s;\nvar _t;\nvar _u;\nvar DataType = class {\n  /** @nocollapse */\n  static isNull(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Null;\n  }\n  /** @nocollapse */\n  static isInt(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Int;\n  }\n  /** @nocollapse */\n  static isFloat(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Float;\n  }\n  /** @nocollapse */\n  static isBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Binary;\n  }\n  /** @nocollapse */\n  static isUtf8(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Utf8;\n  }\n  /** @nocollapse */\n  static isBool(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Bool;\n  }\n  /** @nocollapse */\n  static isDecimal(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Decimal;\n  }\n  /** @nocollapse */\n  static isDate(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Date;\n  }\n  /** @nocollapse */\n  static isTime(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Time;\n  }\n  /** @nocollapse */\n  static isTimestamp(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Timestamp;\n  }\n  /** @nocollapse */\n  static isInterval(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Interval;\n  }\n  /** @nocollapse */\n  static isList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.List;\n  }\n  /** @nocollapse */\n  static isStruct(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Struct;\n  }\n  /** @nocollapse */\n  static isUnion(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Union;\n  }\n  /** @nocollapse */\n  static isFixedSizeBinary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeBinary;\n  }\n  /** @nocollapse */\n  static isFixedSizeList(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.FixedSizeList;\n  }\n  /** @nocollapse */\n  static isMap(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Map;\n  }\n  /** @nocollapse */\n  static isDictionary(x4) {\n    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type.Dictionary;\n  }\n  /** @nocollapse */\n  static isDenseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Dense;\n  }\n  /** @nocollapse */\n  static isSparseUnion(x4) {\n    return DataType.isUnion(x4) && x4.mode === UnionMode.Sparse;\n  }\n  get typeId() {\n    return Type.NONE;\n  }\n};\n_a = Symbol.toStringTag;\nDataType[_a] = ((proto) => {\n  proto.children = null;\n  proto.ArrayType = Array;\n  return proto[Symbol.toStringTag] = \"DataType\";\n})(DataType.prototype);\nvar Null = class extends DataType {\n  toString() {\n    return `Null`;\n  }\n  get typeId() {\n    return Type.Null;\n  }\n};\n_b = Symbol.toStringTag;\nNull[_b] = ((proto) => proto[Symbol.toStringTag] = \"Null\")(Null.prototype);\nvar Int_ = class extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Int;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 8:\n        return this.isSigned ? Int8Array : Uint8Array;\n      case 16:\n        return this.isSigned ? Int16Array : Uint16Array;\n      case 32:\n        return this.isSigned ? Int32Array : Uint32Array;\n      case 64:\n        return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;\n  }\n};\n_c = Symbol.toStringTag;\nInt_[_c] = ((proto) => {\n  proto.isSigned = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Int\";\n})(Int_.prototype);\nvar Int8 = class extends Int_ {\n  constructor() {\n    super(true, 8);\n  }\n  get ArrayType() {\n    return Int8Array;\n  }\n};\nvar Int16 = class extends Int_ {\n  constructor() {\n    super(true, 16);\n  }\n  get ArrayType() {\n    return Int16Array;\n  }\n};\nvar Int32 = class extends Int_ {\n  constructor() {\n    super(true, 32);\n  }\n  get ArrayType() {\n    return Int32Array;\n  }\n};\nvar Int64 = class extends Int_ {\n  constructor() {\n    super(true, 64);\n  }\n  get ArrayType() {\n    return BigInt64ArrayCtor;\n  }\n};\nvar Uint8 = class extends Int_ {\n  constructor() {\n    super(false, 8);\n  }\n  get ArrayType() {\n    return Uint8Array;\n  }\n};\nvar Uint16 = class extends Int_ {\n  constructor() {\n    super(false, 16);\n  }\n  get ArrayType() {\n    return Uint16Array;\n  }\n};\nvar Uint32 = class extends Int_ {\n  constructor() {\n    super(false, 32);\n  }\n  get ArrayType() {\n    return Uint32Array;\n  }\n};\nvar Uint64 = class extends Int_ {\n  constructor() {\n    super(false, 64);\n  }\n  get ArrayType() {\n    return BigUint64ArrayCtor;\n  }\n};\nObject.defineProperty(Int8.prototype, \"ArrayType\", { value: Int8Array });\nObject.defineProperty(Int16.prototype, \"ArrayType\", { value: Int16Array });\nObject.defineProperty(Int32.prototype, \"ArrayType\", { value: Int32Array });\nObject.defineProperty(Int64.prototype, \"ArrayType\", { value: BigInt64ArrayCtor });\nObject.defineProperty(Uint8.prototype, \"ArrayType\", { value: Uint8Array });\nObject.defineProperty(Uint16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Uint32.prototype, \"ArrayType\", { value: Uint32Array });\nObject.defineProperty(Uint64.prototype, \"ArrayType\", { value: BigUint64ArrayCtor });\nvar Float = class extends DataType {\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId() {\n    return Type.Float;\n  }\n  get ArrayType() {\n    switch (this.precision) {\n      case Precision.HALF:\n        return Uint16Array;\n      case Precision.SINGLE:\n        return Float32Array;\n      case Precision.DOUBLE:\n        return Float64Array;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n  toString() {\n    return `Float${this.precision << 5 || 16}`;\n  }\n};\n_d = Symbol.toStringTag;\nFloat[_d] = ((proto) => {\n  proto.precision = null;\n  return proto[Symbol.toStringTag] = \"Float\";\n})(Float.prototype);\nvar Float16 = class extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n};\nvar Float32 = class extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n};\nvar Float64 = class extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n};\nObject.defineProperty(Float16.prototype, \"ArrayType\", { value: Uint16Array });\nObject.defineProperty(Float32.prototype, \"ArrayType\", { value: Float32Array });\nObject.defineProperty(Float64.prototype, \"ArrayType\", { value: Float64Array });\nvar Binary = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return `Binary`;\n  }\n};\n_e = Symbol.toStringTag;\nBinary[_e] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Binary\";\n})(Binary.prototype);\nvar Utf8 = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Utf8;\n  }\n  toString() {\n    return `Utf8`;\n  }\n};\n_f = Symbol.toStringTag;\nUtf8[_f] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Utf8\";\n})(Utf8.prototype);\nvar Bool = class extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Bool;\n  }\n  toString() {\n    return `Bool`;\n  }\n};\n_g = Symbol.toStringTag;\nBool[_g] = ((proto) => {\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"Bool\";\n})(Bool.prototype);\nvar Decimal = class extends DataType {\n  constructor(scale3, precision, bitWidth = 128) {\n    super();\n    this.scale = scale3;\n    this.precision = precision;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Decimal;\n  }\n  toString() {\n    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;\n  }\n};\n_h = Symbol.toStringTag;\nDecimal[_h] = ((proto) => {\n  proto.scale = null;\n  proto.precision = null;\n  proto.ArrayType = Uint32Array;\n  return proto[Symbol.toStringTag] = \"Decimal\";\n})(Decimal.prototype);\nvar Date_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Date;\n  }\n  toString() {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n};\n_j = Symbol.toStringTag;\nDate_[_j] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Date\";\n})(Date_.prototype);\nvar Time_ = class extends DataType {\n  constructor(unit3, bitWidth) {\n    super();\n    this.unit = unit3;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Time;\n  }\n  toString() {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get ArrayType() {\n    switch (this.bitWidth) {\n      case 32:\n        return Int32Array;\n      case 64:\n        return BigInt64ArrayCtor;\n    }\n    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  }\n};\n_k = Symbol.toStringTag;\nTime_[_k] = ((proto) => {\n  proto.unit = null;\n  proto.bitWidth = null;\n  return proto[Symbol.toStringTag] = \"Time\";\n})(Time_.prototype);\nvar Timestamp_ = class extends DataType {\n  constructor(unit3, timezone) {\n    super();\n    this.unit = unit3;\n    this.timezone = timezone;\n  }\n  get typeId() {\n    return Type.Timestamp;\n  }\n  toString() {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;\n  }\n};\n_l = Symbol.toStringTag;\nTimestamp_[_l] = ((proto) => {\n  proto.unit = null;\n  proto.timezone = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Timestamp\";\n})(Timestamp_.prototype);\nvar Interval_ = class extends DataType {\n  constructor(unit3) {\n    super();\n    this.unit = unit3;\n  }\n  get typeId() {\n    return Type.Interval;\n  }\n  toString() {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n};\n_m = Symbol.toStringTag;\nInterval_[_m] = ((proto) => {\n  proto.unit = null;\n  proto.ArrayType = Int32Array;\n  return proto[Symbol.toStringTag] = \"Interval\";\n})(Interval_.prototype);\nvar List = class extends DataType {\n  constructor(child) {\n    super();\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.List;\n  }\n  toString() {\n    return `List<${this.valueType}>`;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n};\n_o = Symbol.toStringTag;\nList[_o] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"List\";\n})(List.prototype);\nvar Struct = class extends DataType {\n  constructor(children2) {\n    super();\n    this.children = children2;\n  }\n  get typeId() {\n    return Type.Struct;\n  }\n  toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_p = Symbol.toStringTag;\nStruct[_p] = ((proto) => {\n  proto.children = null;\n  return proto[Symbol.toStringTag] = \"Struct\";\n})(Struct.prototype);\nvar Union_ = class extends DataType {\n  constructor(mode2, typeIds, children2) {\n    super();\n    this.mode = mode2;\n    this.children = children2;\n    this.typeIds = typeIds = Int32Array.from(typeIds);\n    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));\n  }\n  get typeId() {\n    return Type.Union;\n  }\n  toString() {\n    return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;\n  }\n};\n_q = Symbol.toStringTag;\nUnion_[_q] = ((proto) => {\n  proto.mode = null;\n  proto.typeIds = null;\n  proto.children = null;\n  proto.typeIdToChildIndex = null;\n  proto.ArrayType = Int8Array;\n  return proto[Symbol.toStringTag] = \"Union\";\n})(Union_.prototype);\nvar FixedSizeBinary = class extends DataType {\n  constructor(byteWidth) {\n    super();\n    this.byteWidth = byteWidth;\n  }\n  get typeId() {\n    return Type.FixedSizeBinary;\n  }\n  toString() {\n    return `FixedSizeBinary[${this.byteWidth}]`;\n  }\n};\n_r = Symbol.toStringTag;\nFixedSizeBinary[_r] = ((proto) => {\n  proto.byteWidth = null;\n  proto.ArrayType = Uint8Array;\n  return proto[Symbol.toStringTag] = \"FixedSizeBinary\";\n})(FixedSizeBinary.prototype);\nvar FixedSizeList = class extends DataType {\n  constructor(listSize, child) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId() {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get ArrayType() {\n    return this.valueType.ArrayType;\n  }\n  toString() {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n};\n_s = Symbol.toStringTag;\nFixedSizeList[_s] = ((proto) => {\n  proto.children = null;\n  proto.listSize = null;\n  return proto[Symbol.toStringTag] = \"FixedSizeList\";\n})(FixedSizeList.prototype);\nvar Map_ = class extends DataType {\n  constructor(child, keysSorted = false) {\n    super();\n    this.children = [child];\n    this.keysSorted = keysSorted;\n  }\n  get typeId() {\n    return Type.Map;\n  }\n  get keyType() {\n    return this.children[0].type.children[0].type;\n  }\n  get valueType() {\n    return this.children[0].type.children[1].type;\n  }\n  get childType() {\n    return this.children[0].type;\n  }\n  toString() {\n    return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;\n  }\n};\n_t = Symbol.toStringTag;\nMap_[_t] = ((proto) => {\n  proto.children = null;\n  proto.keysSorted = null;\n  return proto[Symbol.toStringTag] = \"Map_\";\n})(Map_.prototype);\nvar getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);\nvar Dictionary = class extends DataType {\n  constructor(dictionary, indices, id2, isOrdered2) {\n    super();\n    this.indices = indices;\n    this.dictionary = dictionary;\n    this.isOrdered = isOrdered2 || false;\n    this.id = id2 == null ? getId() : typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get typeId() {\n    return Type.Dictionary;\n  }\n  get children() {\n    return this.dictionary.children;\n  }\n  get valueType() {\n    return this.dictionary;\n  }\n  get ArrayType() {\n    return this.dictionary.ArrayType;\n  }\n  toString() {\n    return `Dictionary<${this.indices}, ${this.dictionary}>`;\n  }\n};\n_u = Symbol.toStringTag;\nDictionary[_u] = ((proto) => {\n  proto.id = null;\n  proto.indices = null;\n  proto.isOrdered = null;\n  proto.dictionary = null;\n  return proto[Symbol.toStringTag] = \"Dictionary\";\n})(Dictionary.prototype);\nfunction strideForType(type2) {\n  const t = type2;\n  switch (type2.typeId) {\n    case Type.Decimal:\n      return type2.bitWidth / 32;\n    case Type.Timestamp:\n      return 2;\n    case Type.Date:\n      return 1 + t.unit;\n    case Type.Interval:\n      return 1 + t.unit;\n    case Type.FixedSizeList:\n      return t.listSize;\n    case Type.FixedSizeBinary:\n      return t.byteWidth;\n    default:\n      return 1;\n  }\n}\n\n// node_modules/apache-arrow/visitor.mjs\nvar Visitor = class {\n  visitMany(nodes, ...args) {\n    return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));\n  }\n  visit(...args) {\n    return this.getVisitFn(args[0], false).apply(this, args);\n  }\n  getVisitFn(node, throwIfNotFound = true) {\n    return getVisitFn(this, node, throwIfNotFound);\n  }\n  getVisitFnByTypeId(typeId, throwIfNotFound = true) {\n    return getVisitFnByTypeId(this, typeId, throwIfNotFound);\n  }\n  visitNull(_node, ..._args) {\n    return null;\n  }\n  visitBool(_node, ..._args) {\n    return null;\n  }\n  visitInt(_node, ..._args) {\n    return null;\n  }\n  visitFloat(_node, ..._args) {\n    return null;\n  }\n  visitUtf8(_node, ..._args) {\n    return null;\n  }\n  visitBinary(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeBinary(_node, ..._args) {\n    return null;\n  }\n  visitDate(_node, ..._args) {\n    return null;\n  }\n  visitTimestamp(_node, ..._args) {\n    return null;\n  }\n  visitTime(_node, ..._args) {\n    return null;\n  }\n  visitDecimal(_node, ..._args) {\n    return null;\n  }\n  visitList(_node, ..._args) {\n    return null;\n  }\n  visitStruct(_node, ..._args) {\n    return null;\n  }\n  visitUnion(_node, ..._args) {\n    return null;\n  }\n  visitDictionary(_node, ..._args) {\n    return null;\n  }\n  visitInterval(_node, ..._args) {\n    return null;\n  }\n  visitFixedSizeList(_node, ..._args) {\n    return null;\n  }\n  visitMap(_node, ..._args) {\n    return null;\n  }\n};\nfunction getVisitFn(visitor, node, throwIfNotFound = true) {\n  if (typeof node === \"number\") {\n    return getVisitFnByTypeId(visitor, node, throwIfNotFound);\n  }\n  if (typeof node === \"string\" && node in Type) {\n    return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);\n  }\n  if (node && node instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);\n  }\n  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {\n    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);\n  }\n  return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);\n}\nfunction getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {\n  let fn = null;\n  switch (dtype) {\n    case Type.Null:\n      fn = visitor.visitNull;\n      break;\n    case Type.Bool:\n      fn = visitor.visitBool;\n      break;\n    case Type.Int:\n      fn = visitor.visitInt;\n      break;\n    case Type.Int8:\n      fn = visitor.visitInt8 || visitor.visitInt;\n      break;\n    case Type.Int16:\n      fn = visitor.visitInt16 || visitor.visitInt;\n      break;\n    case Type.Int32:\n      fn = visitor.visitInt32 || visitor.visitInt;\n      break;\n    case Type.Int64:\n      fn = visitor.visitInt64 || visitor.visitInt;\n      break;\n    case Type.Uint8:\n      fn = visitor.visitUint8 || visitor.visitInt;\n      break;\n    case Type.Uint16:\n      fn = visitor.visitUint16 || visitor.visitInt;\n      break;\n    case Type.Uint32:\n      fn = visitor.visitUint32 || visitor.visitInt;\n      break;\n    case Type.Uint64:\n      fn = visitor.visitUint64 || visitor.visitInt;\n      break;\n    case Type.Float:\n      fn = visitor.visitFloat;\n      break;\n    case Type.Float16:\n      fn = visitor.visitFloat16 || visitor.visitFloat;\n      break;\n    case Type.Float32:\n      fn = visitor.visitFloat32 || visitor.visitFloat;\n      break;\n    case Type.Float64:\n      fn = visitor.visitFloat64 || visitor.visitFloat;\n      break;\n    case Type.Utf8:\n      fn = visitor.visitUtf8;\n      break;\n    case Type.Binary:\n      fn = visitor.visitBinary;\n      break;\n    case Type.FixedSizeBinary:\n      fn = visitor.visitFixedSizeBinary;\n      break;\n    case Type.Date:\n      fn = visitor.visitDate;\n      break;\n    case Type.DateDay:\n      fn = visitor.visitDateDay || visitor.visitDate;\n      break;\n    case Type.DateMillisecond:\n      fn = visitor.visitDateMillisecond || visitor.visitDate;\n      break;\n    case Type.Timestamp:\n      fn = visitor.visitTimestamp;\n      break;\n    case Type.TimestampSecond:\n      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMillisecond:\n      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampMicrosecond:\n      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;\n      break;\n    case Type.TimestampNanosecond:\n      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;\n      break;\n    case Type.Time:\n      fn = visitor.visitTime;\n      break;\n    case Type.TimeSecond:\n      fn = visitor.visitTimeSecond || visitor.visitTime;\n      break;\n    case Type.TimeMillisecond:\n      fn = visitor.visitTimeMillisecond || visitor.visitTime;\n      break;\n    case Type.TimeMicrosecond:\n      fn = visitor.visitTimeMicrosecond || visitor.visitTime;\n      break;\n    case Type.TimeNanosecond:\n      fn = visitor.visitTimeNanosecond || visitor.visitTime;\n      break;\n    case Type.Decimal:\n      fn = visitor.visitDecimal;\n      break;\n    case Type.List:\n      fn = visitor.visitList;\n      break;\n    case Type.Struct:\n      fn = visitor.visitStruct;\n      break;\n    case Type.Union:\n      fn = visitor.visitUnion;\n      break;\n    case Type.DenseUnion:\n      fn = visitor.visitDenseUnion || visitor.visitUnion;\n      break;\n    case Type.SparseUnion:\n      fn = visitor.visitSparseUnion || visitor.visitUnion;\n      break;\n    case Type.Dictionary:\n      fn = visitor.visitDictionary;\n      break;\n    case Type.Interval:\n      fn = visitor.visitInterval;\n      break;\n    case Type.IntervalDayTime:\n      fn = visitor.visitIntervalDayTime || visitor.visitInterval;\n      break;\n    case Type.IntervalYearMonth:\n      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;\n      break;\n    case Type.FixedSizeList:\n      fn = visitor.visitFixedSizeList;\n      break;\n    case Type.Map:\n      fn = visitor.visitMap;\n      break;\n  }\n  if (typeof fn === \"function\")\n    return fn;\n  if (!throwIfNotFound)\n    return () => null;\n  throw new Error(`Unrecognized type '${Type[dtype]}'`);\n}\nfunction inferDType(type2) {\n  switch (type2.typeId) {\n    case Type.Null:\n      return Type.Null;\n    case Type.Int: {\n      const { bitWidth, isSigned } = type2;\n      switch (bitWidth) {\n        case 8:\n          return isSigned ? Type.Int8 : Type.Uint8;\n        case 16:\n          return isSigned ? Type.Int16 : Type.Uint16;\n        case 32:\n          return isSigned ? Type.Int32 : Type.Uint32;\n        case 64:\n          return isSigned ? Type.Int64 : Type.Uint64;\n      }\n      return Type.Int;\n    }\n    case Type.Float:\n      switch (type2.precision) {\n        case Precision.HALF:\n          return Type.Float16;\n        case Precision.SINGLE:\n          return Type.Float32;\n        case Precision.DOUBLE:\n          return Type.Float64;\n      }\n      return Type.Float;\n    case Type.Binary:\n      return Type.Binary;\n    case Type.Utf8:\n      return Type.Utf8;\n    case Type.Bool:\n      return Type.Bool;\n    case Type.Decimal:\n      return Type.Decimal;\n    case Type.Time:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimeSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimeMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimeMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimeNanosecond;\n      }\n      return Type.Time;\n    case Type.Timestamp:\n      switch (type2.unit) {\n        case TimeUnit.SECOND:\n          return Type.TimestampSecond;\n        case TimeUnit.MILLISECOND:\n          return Type.TimestampMillisecond;\n        case TimeUnit.MICROSECOND:\n          return Type.TimestampMicrosecond;\n        case TimeUnit.NANOSECOND:\n          return Type.TimestampNanosecond;\n      }\n      return Type.Timestamp;\n    case Type.Date:\n      switch (type2.unit) {\n        case DateUnit.DAY:\n          return Type.DateDay;\n        case DateUnit.MILLISECOND:\n          return Type.DateMillisecond;\n      }\n      return Type.Date;\n    case Type.Interval:\n      switch (type2.unit) {\n        case IntervalUnit.DAY_TIME:\n          return Type.IntervalDayTime;\n        case IntervalUnit.YEAR_MONTH:\n          return Type.IntervalYearMonth;\n      }\n      return Type.Interval;\n    case Type.Map:\n      return Type.Map;\n    case Type.List:\n      return Type.List;\n    case Type.Struct:\n      return Type.Struct;\n    case Type.Union:\n      switch (type2.mode) {\n        case UnionMode.Dense:\n          return Type.DenseUnion;\n        case UnionMode.Sparse:\n          return Type.SparseUnion;\n      }\n      return Type.Union;\n    case Type.FixedSizeBinary:\n      return Type.FixedSizeBinary;\n    case Type.FixedSizeList:\n      return Type.FixedSizeList;\n    case Type.Dictionary:\n      return Type.Dictionary;\n  }\n  throw new Error(`Unrecognized type '${Type[type2.typeId]}'`);\n}\nVisitor.prototype.visitInt8 = null;\nVisitor.prototype.visitInt16 = null;\nVisitor.prototype.visitInt32 = null;\nVisitor.prototype.visitInt64 = null;\nVisitor.prototype.visitUint8 = null;\nVisitor.prototype.visitUint16 = null;\nVisitor.prototype.visitUint32 = null;\nVisitor.prototype.visitUint64 = null;\nVisitor.prototype.visitFloat16 = null;\nVisitor.prototype.visitFloat32 = null;\nVisitor.prototype.visitFloat64 = null;\nVisitor.prototype.visitDateDay = null;\nVisitor.prototype.visitDateMillisecond = null;\nVisitor.prototype.visitTimestampSecond = null;\nVisitor.prototype.visitTimestampMillisecond = null;\nVisitor.prototype.visitTimestampMicrosecond = null;\nVisitor.prototype.visitTimestampNanosecond = null;\nVisitor.prototype.visitTimeSecond = null;\nVisitor.prototype.visitTimeMillisecond = null;\nVisitor.prototype.visitTimeMicrosecond = null;\nVisitor.prototype.visitTimeNanosecond = null;\nVisitor.prototype.visitDenseUnion = null;\nVisitor.prototype.visitSparseUnion = null;\nVisitor.prototype.visitIntervalDayTime = null;\nVisitor.prototype.visitIntervalYearMonth = null;\n\n// node_modules/apache-arrow/util/math.mjs\nvar math_exports = {};\n__export(math_exports, {\n  float64ToUint16: () => float64ToUint16,\n  uint16ToFloat64: () => uint16ToFloat64\n});\nvar f64 = new Float64Array(1);\nvar u32 = new Uint32Array(f64.buffer);\nfunction uint16ToFloat64(h) {\n  const expo = (h & 31744) >> 10;\n  const sigf = (h & 1023) / 1024;\n  const sign3 = Math.pow(-1, (h & 32768) >> 15);\n  switch (expo) {\n    case 31:\n      return sign3 * (sigf ? Number.NaN : 1 / 0);\n    case 0:\n      return sign3 * (sigf ? 6103515625e-14 * sigf : 0);\n  }\n  return sign3 * Math.pow(2, expo - 15) * (1 + sigf);\n}\nfunction float64ToUint16(d) {\n  if (d !== d) {\n    return 32256;\n  }\n  f64[0] = d;\n  const sign3 = (u32[1] & 2147483648) >> 16 & 65535;\n  let expo = u32[1] & 2146435072, sigf = 0;\n  if (expo >= 1089470464) {\n    if (u32[0] > 0) {\n      expo = 31744;\n    } else {\n      expo = (expo & 2080374784) >> 16;\n      sigf = (u32[1] & 1048575) >> 10;\n    }\n  } else if (expo <= 1056964608) {\n    sigf = 1048576 + (u32[1] & 1048575);\n    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;\n    expo = 0;\n  } else {\n    expo = expo - 1056964608 >> 10;\n    sigf = (u32[1] & 1048575) + 512 >> 10;\n  }\n  return sign3 | expo | sigf & 65535;\n}\n\n// node_modules/apache-arrow/visitor/set.mjs\nvar SetVisitor = class extends Visitor {\n};\nfunction wrapSet(fn) {\n  return (data, _1, _2) => {\n    if (data.setValid(_1, _2 != null)) {\n      return fn(data, _1, _2);\n    }\n  };\n}\nvar setEpochMsToDays = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs / 864e5);\n};\nvar setEpochMsToMillisecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs / 4294967296);\n};\nvar setEpochMsToMicrosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e3 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);\n};\nvar setEpochMsToNanosecondsLong = (data, index3, epochMs) => {\n  data[index3] = Math.trunc(epochMs * 1e6 % 4294967296);\n  data[index3 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);\n};\nvar setVariableWidthBytes = (values2, valueOffsets, index3, value) => {\n  if (index3 + 1 < valueOffsets.length) {\n    const { [index3]: x4, [index3 + 1]: y4 } = valueOffsets;\n    values2.set(value.subarray(0, y4 - x4), x4);\n  }\n};\nvar setBool = ({ offset: offset2, values: values2 }, index3, val) => {\n  const idx = offset2 + index3;\n  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);\n};\nvar setInt = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setFloat16 = ({ values: values2 }, index3, value) => {\n  values2[index3] = float64ToUint16(value);\n};\nvar setAnyFloat = (data, index3, value) => {\n  switch (data.type.precision) {\n    case Precision.HALF:\n      return setFloat16(data, index3, value);\n    case Precision.SINGLE:\n    case Precision.DOUBLE:\n      return setFloat(data, index3, value);\n  }\n};\nvar setDateDay = ({ values: values2 }, index3, value) => {\n  setEpochMsToDays(values2, index3, value.valueOf());\n};\nvar setDateMillisecond = ({ values: values2 }, index3, value) => {\n  setEpochMsToMillisecondsLong(values2, index3 * 2, value.valueOf());\n};\nvar setFixedSizeBinary = ({ stride, values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setBinary = ({ values: values2, valueOffsets }, index3, value) => setVariableWidthBytes(values2, valueOffsets, index3, value);\nvar setUtf8 = ({ values: values2, valueOffsets }, index3, value) => {\n  setVariableWidthBytes(values2, valueOffsets, index3, encodeUtf8(value));\n};\nvar setDate = (data, index3, value) => {\n  data.type.unit === DateUnit.DAY ? setDateDay(data, index3, value) : setDateMillisecond(data, index3, value);\n};\nvar setTimestampSecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value / 1e3);\nvar setTimestampMillisecond = ({ values: values2 }, index3, value) => setEpochMsToMillisecondsLong(values2, index3 * 2, value);\nvar setTimestampMicrosecond = ({ values: values2 }, index3, value) => setEpochMsToMicrosecondsLong(values2, index3 * 2, value);\nvar setTimestampNanosecond = ({ values: values2 }, index3, value) => setEpochMsToNanosecondsLong(values2, index3 * 2, value);\nvar setTimestamp = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimestampSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimestampMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimestampMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimestampNanosecond(data, index3, value);\n  }\n};\nvar setTimeSecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMillisecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeMicrosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTimeNanosecond = ({ values: values2 }, index3, value) => {\n  values2[index3] = value;\n};\nvar setTime = (data, index3, value) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return setTimeSecond(data, index3, value);\n    case TimeUnit.MILLISECOND:\n      return setTimeMillisecond(data, index3, value);\n    case TimeUnit.MICROSECOND:\n      return setTimeMicrosecond(data, index3, value);\n    case TimeUnit.NANOSECOND:\n      return setTimeNanosecond(data, index3, value);\n  }\n};\nvar setDecimal = ({ values: values2, stride }, index3, value) => {\n  values2.set(value.subarray(0, stride), stride * index3);\n};\nvar setList = (data, index3, value) => {\n  const values2 = data.children[0];\n  const valueOffsets = data.valueOffsets;\n  const set4 = instance.getVisitFn(values2);\n  if (Array.isArray(value)) {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value[++idx]);\n    }\n  } else {\n    for (let idx = -1, itr = valueOffsets[index3], end = valueOffsets[index3 + 1]; itr < end; ) {\n      set4(values2, itr++, value.get(++idx));\n    }\n  }\n};\nvar setMap = (data, index3, value) => {\n  const values2 = data.children[0];\n  const { valueOffsets } = data;\n  const set4 = instance.getVisitFn(values2);\n  let { [index3]: idx, [index3 + 1]: end } = valueOffsets;\n  const entries = value instanceof Map ? value.entries() : Object.entries(value);\n  for (const val of entries) {\n    set4(values2, idx, val);\n    if (++idx >= end)\n      break;\n  }\n};\nvar _setStructArrayValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2[i]);\nvar _setStructVectorValue = (o, v2) => (set4, c6, _, i) => c6 && set4(c6, o, v2.get(i));\nvar _setStructMapValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2.get(f.name));\nvar _setStructObjectValue = (o, v2) => (set4, c6, f, _) => c6 && set4(c6, o, v2[f.name]);\nvar setStruct = (data, index3, value) => {\n  const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));\n  const set4 = value instanceof Map ? _setStructMapValue(index3, value) : value instanceof Vector2 ? _setStructVectorValue(index3, value) : Array.isArray(value) ? _setStructArrayValue(index3, value) : _setStructObjectValue(index3, value);\n  data.type.children.forEach((f, i) => set4(childSetters[i], data.children[i], f, i));\n};\nvar setUnion = (data, index3, value) => {\n  data.type.mode === UnionMode.Dense ? setDenseUnion(data, index3, value) : setSparseUnion(data, index3, value);\n};\nvar setDenseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, data.valueOffsets[index3], value);\n};\nvar setSparseUnion = (data, index3, value) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  instance.visit(child, index3, value);\n};\nvar setDictionary = (data, index3, value) => {\n  var _a5;\n  (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index3], value);\n};\nvar setIntervalValue = (data, index3, value) => {\n  data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index3, value) : setIntervalYearMonth(data, index3, value);\n};\nvar setIntervalDayTime = ({ values: values2 }, index3, value) => {\n  values2.set(value.subarray(0, 2), 2 * index3);\n};\nvar setIntervalYearMonth = ({ values: values2 }, index3, value) => {\n  values2[index3] = value[0] * 12 + value[1] % 12;\n};\nvar setFixedSizeList = (data, index3, value) => {\n  const { stride } = data;\n  const child = data.children[0];\n  const set4 = instance.getVisitFn(child);\n  if (Array.isArray(value)) {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value[idx]);\n    }\n  } else {\n    for (let idx = -1, offset2 = index3 * stride; ++idx < stride; ) {\n      set4(child, offset2 + idx, value.get(idx));\n    }\n  }\n};\nSetVisitor.prototype.visitBool = wrapSet(setBool);\nSetVisitor.prototype.visitInt = wrapSet(setInt);\nSetVisitor.prototype.visitInt8 = wrapSet(setInt);\nSetVisitor.prototype.visitInt16 = wrapSet(setInt);\nSetVisitor.prototype.visitInt32 = wrapSet(setInt);\nSetVisitor.prototype.visitInt64 = wrapSet(setInt);\nSetVisitor.prototype.visitUint8 = wrapSet(setInt);\nSetVisitor.prototype.visitUint16 = wrapSet(setInt);\nSetVisitor.prototype.visitUint32 = wrapSet(setInt);\nSetVisitor.prototype.visitUint64 = wrapSet(setInt);\nSetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);\nSetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);\nSetVisitor.prototype.visitFloat32 = wrapSet(setFloat);\nSetVisitor.prototype.visitFloat64 = wrapSet(setFloat);\nSetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);\nSetVisitor.prototype.visitBinary = wrapSet(setBinary);\nSetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);\nSetVisitor.prototype.visitDate = wrapSet(setDate);\nSetVisitor.prototype.visitDateDay = wrapSet(setDateDay);\nSetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);\nSetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);\nSetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);\nSetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);\nSetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);\nSetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);\nSetVisitor.prototype.visitTime = wrapSet(setTime);\nSetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);\nSetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);\nSetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);\nSetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);\nSetVisitor.prototype.visitDecimal = wrapSet(setDecimal);\nSetVisitor.prototype.visitList = wrapSet(setList);\nSetVisitor.prototype.visitStruct = wrapSet(setStruct);\nSetVisitor.prototype.visitUnion = wrapSet(setUnion);\nSetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);\nSetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);\nSetVisitor.prototype.visitDictionary = wrapSet(setDictionary);\nSetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);\nSetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);\nSetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);\nSetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);\nSetVisitor.prototype.visitMap = wrapSet(setMap);\nvar instance = new SetVisitor();\n\n// node_modules/apache-arrow/row/struct.mjs\nvar kParent = Symbol.for(\"parent\");\nvar kRowIndex = Symbol.for(\"rowIndex\");\nvar StructRow = class {\n  constructor(parent, rowIndex) {\n    this[kParent] = parent;\n    this[kRowIndex] = rowIndex;\n    return new Proxy(this, new StructRowProxyHandler());\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const i = this[kRowIndex];\n    const parent = this[kParent];\n    const keys = parent.type.children;\n    const json = {};\n    for (let j = -1, n = keys.length; ++j < n; ) {\n      json[keys[j].name] = instance2.visit(parent.children[j], i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n  [Symbol.iterator]() {\n    return new StructRowIterator(this[kParent], this[kRowIndex]);\n  }\n};\nvar StructRowIterator = class {\n  constructor(data, rowIndex) {\n    this.childIndex = 0;\n    this.children = data.children;\n    this.rowIndex = rowIndex;\n    this.childFields = data.type.children;\n    this.numChildren = this.childFields.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.childIndex;\n    if (i < this.numChildren) {\n      this.childIndex = i + 1;\n      return {\n        done: false,\n        value: [\n          this.childFields[i].name,\n          instance2.visit(this.children[i], this.rowIndex)\n        ]\n      };\n    }\n    return { done: true, value: null };\n  }\n};\nObject.defineProperties(StructRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }\n});\nvar StructRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kParent].type.children.map((f) => f.name);\n  }\n  has(row, key) {\n    return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;\n  }\n  getOwnPropertyDescriptor(row, key) {\n    if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n    if (idx !== -1) {\n      instance.visit(row[kParent].children[idx], row[kRowIndex], val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key) || typeof key === \"symbol\") {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\n\n// node_modules/apache-arrow/visitor/get.mjs\nvar GetVisitor = class extends Visitor {\n};\nfunction wrapGet(fn) {\n  return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;\n}\nvar epochDaysToMs = (data, index3) => 864e5 * data[index3];\nvar epochMillisecondsLongToMs = (data, index3) => 4294967296 * data[index3 + 1] + (data[index3] >>> 0);\nvar epochMicrosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e3) + (data[index3] >>> 0) / 1e3;\nvar epochNanosecondsLongToMs = (data, index3) => 4294967296 * (data[index3 + 1] / 1e6) + (data[index3] >>> 0) / 1e6;\nvar epochMillisecondsToDate = (epochMs) => new Date(epochMs);\nvar epochDaysToDate = (data, index3) => epochMillisecondsToDate(epochDaysToMs(data, index3));\nvar epochMillisecondsLongToDate = (data, index3) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index3));\nvar getNull = (_data, _index) => null;\nvar getVariableWidthBytes = (values2, valueOffsets, index3) => {\n  if (index3 + 1 >= valueOffsets.length) {\n    return null;\n  }\n  const x4 = valueOffsets[index3];\n  const y4 = valueOffsets[index3 + 1];\n  return values2.subarray(x4, y4);\n};\nvar getBool = ({ offset: offset2, values: values2 }, index3) => {\n  const idx = offset2 + index3;\n  const byte = values2[idx >> 3];\n  return (byte & 1 << idx % 8) !== 0;\n};\nvar getDateDay = ({ values: values2 }, index3) => epochDaysToDate(values2, index3);\nvar getDateMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToDate(values2, index3 * 2);\nvar getNumeric = ({ stride, values: values2 }, index3) => values2[stride * index3];\nvar getFloat16 = ({ stride, values: values2 }, index3) => uint16ToFloat64(values2[stride * index3]);\nvar getBigInts = ({ values: values2 }, index3) => values2[index3];\nvar getFixedSizeBinary = ({ stride, values: values2 }, index3) => values2.subarray(stride * index3, stride * (index3 + 1));\nvar getBinary = ({ values: values2, valueOffsets }, index3) => getVariableWidthBytes(values2, valueOffsets, index3);\nvar getUtf8 = ({ values: values2, valueOffsets }, index3) => {\n  const bytes = getVariableWidthBytes(values2, valueOffsets, index3);\n  return bytes !== null ? decodeUtf8(bytes) : null;\n};\nvar getInt = ({ values: values2 }, index3) => values2[index3];\nvar getFloat = ({ type: type2, values: values2 }, index3) => type2.precision !== Precision.HALF ? values2[index3] : uint16ToFloat64(values2[index3]);\nvar getDate = (data, index3) => data.type.unit === DateUnit.DAY ? getDateDay(data, index3) : getDateMillisecond(data, index3);\nvar getTimestampSecond = ({ values: values2 }, index3) => 1e3 * epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMillisecond = ({ values: values2 }, index3) => epochMillisecondsLongToMs(values2, index3 * 2);\nvar getTimestampMicrosecond = ({ values: values2 }, index3) => epochMicrosecondsLongToMs(values2, index3 * 2);\nvar getTimestampNanosecond = ({ values: values2 }, index3) => epochNanosecondsLongToMs(values2, index3 * 2);\nvar getTimestamp = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimestampSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimestampMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimestampMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimestampNanosecond(data, index3);\n  }\n};\nvar getTimeSecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMillisecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeMicrosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTimeNanosecond = ({ values: values2 }, index3) => values2[index3];\nvar getTime = (data, index3) => {\n  switch (data.type.unit) {\n    case TimeUnit.SECOND:\n      return getTimeSecond(data, index3);\n    case TimeUnit.MILLISECOND:\n      return getTimeMillisecond(data, index3);\n    case TimeUnit.MICROSECOND:\n      return getTimeMicrosecond(data, index3);\n    case TimeUnit.NANOSECOND:\n      return getTimeNanosecond(data, index3);\n  }\n};\nvar getDecimal = ({ values: values2, stride }, index3) => BN.decimal(values2.subarray(stride * index3, stride * (index3 + 1)));\nvar getList = (data, index3) => {\n  const { valueOffsets, stride, children: children2 } = data;\n  const { [index3 * stride]: begin, [index3 * stride + 1]: end } = valueOffsets;\n  const child = children2[0];\n  const slice7 = child.slice(begin, end - begin);\n  return new Vector2([slice7]);\n};\nvar getMap = (data, index3) => {\n  const { valueOffsets, children: children2 } = data;\n  const { [index3]: begin, [index3 + 1]: end } = valueOffsets;\n  const child = children2[0];\n  return new MapRow(child.slice(begin, end - begin));\n};\nvar getStruct = (data, index3) => {\n  return new StructRow(data, index3);\n};\nvar getUnion = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index3) : getSparseUnion(data, index3);\n};\nvar getDenseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, data.valueOffsets[index3]);\n};\nvar getSparseUnion = (data, index3) => {\n  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index3]];\n  const child = data.children[childIndex];\n  return instance2.visit(child, index3);\n};\nvar getDictionary = (data, index3) => {\n  var _a5;\n  return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index3]);\n};\nvar getInterval = (data, index3) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index3) : getIntervalYearMonth(data, index3);\nvar getIntervalDayTime = ({ values: values2 }, index3) => values2.subarray(2 * index3, 2 * (index3 + 1));\nvar getIntervalYearMonth = ({ values: values2 }, index3) => {\n  const interval2 = values2[index3];\n  const int32s = new Int32Array(2);\n  int32s[0] = Math.trunc(interval2 / 12);\n  int32s[1] = Math.trunc(interval2 % 12);\n  return int32s;\n};\nvar getFixedSizeList = (data, index3) => {\n  const { stride, children: children2 } = data;\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  return new Vector2([slice7]);\n};\nGetVisitor.prototype.visitNull = wrapGet(getNull);\nGetVisitor.prototype.visitBool = wrapGet(getBool);\nGetVisitor.prototype.visitInt = wrapGet(getInt);\nGetVisitor.prototype.visitInt8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitUint8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitFloat = wrapGet(getFloat);\nGetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);\nGetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);\nGetVisitor.prototype.visitBinary = wrapGet(getBinary);\nGetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);\nGetVisitor.prototype.visitDate = wrapGet(getDate);\nGetVisitor.prototype.visitDateDay = wrapGet(getDateDay);\nGetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);\nGetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);\nGetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);\nGetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);\nGetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);\nGetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);\nGetVisitor.prototype.visitTime = wrapGet(getTime);\nGetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);\nGetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);\nGetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);\nGetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);\nGetVisitor.prototype.visitDecimal = wrapGet(getDecimal);\nGetVisitor.prototype.visitList = wrapGet(getList);\nGetVisitor.prototype.visitStruct = wrapGet(getStruct);\nGetVisitor.prototype.visitUnion = wrapGet(getUnion);\nGetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);\nGetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);\nGetVisitor.prototype.visitDictionary = wrapGet(getDictionary);\nGetVisitor.prototype.visitInterval = wrapGet(getInterval);\nGetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);\nGetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);\nGetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);\nGetVisitor.prototype.visitMap = wrapGet(getMap);\nvar instance2 = new GetVisitor();\n\n// node_modules/apache-arrow/row/map.mjs\nvar kKeys = Symbol.for(\"keys\");\nvar kVals = Symbol.for(\"vals\");\nvar MapRow = class {\n  constructor(slice7) {\n    this[kKeys] = new Vector2([slice7.children[0]]).memoize();\n    this[kVals] = slice7.children[1];\n    return new Proxy(this, new MapRowProxyHandler());\n  }\n  [Symbol.iterator]() {\n    return new MapRowIterator(this[kKeys], this[kVals]);\n  }\n  get size() {\n    return this[kKeys].length;\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const keys = this[kKeys];\n    const vals = this[kVals];\n    const json = {};\n    for (let i = -1, n = keys.length; ++i < n; ) {\n      json[keys.get(i)] = instance2.visit(vals, i);\n    }\n    return json;\n  }\n  toString() {\n    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(\", \")}}`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n};\nvar MapRowIterator = class {\n  constructor(keys, vals) {\n    this.keys = keys;\n    this.vals = vals;\n    this.keyIndex = 0;\n    this.numKeys = keys.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.keyIndex;\n    if (i === this.numKeys) {\n      return { done: true, value: null };\n    }\n    this.keyIndex++;\n    return {\n      done: false,\n      value: [\n        this.keys.get(i),\n        instance2.visit(this.vals, i)\n      ]\n    };\n  }\n};\nvar MapRowProxyHandler = class {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kKeys].toArray().map(String);\n  }\n  has(row, key) {\n    return row[kKeys].includes(key);\n  }\n  getOwnPropertyDescriptor(row, key) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      return { writable: true, enumerable: true, configurable: true };\n    }\n    return;\n  }\n  get(row, key) {\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      const val = instance2.visit(Reflect.get(row, kVals), idx);\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kKeys].indexOf(key);\n    if (idx !== -1) {\n      instance.visit(Reflect.get(row, kVals), idx, val);\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key)) {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n};\nObject.defineProperties(MapRow.prototype, {\n  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: \"Row\" },\n  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },\n  [kVals]: { writable: true, enumerable: false, configurable: false, value: null }\n});\n\n// node_modules/apache-arrow/util/vector.mjs\nfunction clampIndex(source, index3, then) {\n  const length4 = source.length;\n  const adjust = index3 > -1 ? index3 : length4 + index3 % length4;\n  return then ? then(source, adjust) : adjust;\n}\nvar tmp;\nfunction clampRange(source, begin, end, then) {\n  const { length: len = 0 } = source;\n  let lhs = typeof begin !== \"number\" ? 0 : begin;\n  let rhs = typeof end !== \"number\" ? len : end;\n  lhs < 0 && (lhs = (lhs % len + len) % len);\n  rhs < 0 && (rhs = (rhs % len + len) % len);\n  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);\n  rhs > len && (rhs = len);\n  return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\nvar isNaNFast = (value) => value !== value;\nfunction createElementComparator(search) {\n  const typeofSearch = typeof search;\n  if (typeofSearch !== \"object\" || search === null) {\n    if (isNaNFast(search)) {\n      return isNaNFast;\n    }\n    return (value) => value === search;\n  }\n  if (search instanceof Date) {\n    const valueOfSearch = search.valueOf();\n    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;\n  }\n  if (ArrayBuffer.isView(search)) {\n    return (value) => value ? compareArrayLike(search, value) : false;\n  }\n  if (search instanceof Map) {\n    return createMapComparator(search);\n  }\n  if (Array.isArray(search)) {\n    return createArrayLikeComparator(search);\n  }\n  if (search instanceof Vector2) {\n    return createVectorComparator(search);\n  }\n  return createObjectComparator(search, true);\n}\nfunction createArrayLikeComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[i]);\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createMapComparator(lhs) {\n  let i = -1;\n  const comparators = [];\n  for (const v2 of lhs.values())\n    comparators[++i] = createElementComparator(v2);\n  return createSubElementsComparator(comparators);\n}\nfunction createVectorComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs.get(i));\n  }\n  return createSubElementsComparator(comparators);\n}\nfunction createObjectComparator(lhs, allowEmpty = false) {\n  const keys = Object.keys(lhs);\n  if (!allowEmpty && keys.length === 0) {\n    return () => false;\n  }\n  const comparators = [];\n  for (let i = -1, n = keys.length; ++i < n; ) {\n    comparators[i] = createElementComparator(lhs[keys[i]]);\n  }\n  return createSubElementsComparator(comparators, keys);\n}\nfunction createSubElementsComparator(comparators, keys) {\n  return (rhs) => {\n    if (!rhs || typeof rhs !== \"object\") {\n      return false;\n    }\n    switch (rhs.constructor) {\n      case Array:\n        return compareArray(comparators, rhs);\n      case Map:\n        return compareObject(comparators, rhs, rhs.keys());\n      case MapRow:\n      case StructRow:\n      case Object:\n      case void 0:\n        return compareObject(comparators, rhs, keys || Object.keys(rhs));\n    }\n    return rhs instanceof Vector2 ? compareVector(comparators, rhs) : false;\n  };\n}\nfunction compareArray(comparators, arr) {\n  const n = comparators.length;\n  if (arr.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](arr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareVector(comparators, vec2) {\n  const n = comparators.length;\n  if (vec2.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n; ) {\n    if (!comparators[i](vec2.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareObject(comparators, obj, keys) {\n  const lKeyItr = keys[Symbol.iterator]();\n  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n  let i = 0;\n  const n = comparators.length;\n  let rVal = rValItr.next();\n  let lKey = lKeyItr.next();\n  let rKey = rKeyItr.next();\n  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n      break;\n    }\n  }\n  if (i === n && lKey.done && rKey.done && rVal.done) {\n    return true;\n  }\n  lKeyItr.return && lKeyItr.return();\n  rKeyItr.return && rKeyItr.return();\n  rValItr.return && rValItr.return();\n  return false;\n}\n\n// node_modules/apache-arrow/util/bit.mjs\nvar bit_exports = {};\n__export(bit_exports, {\n  BitIterator: () => BitIterator,\n  getBit: () => getBit,\n  getBool: () => getBool2,\n  packBools: () => packBools,\n  popcnt_array: () => popcnt_array,\n  popcnt_bit_range: () => popcnt_bit_range,\n  popcnt_uint32: () => popcnt_uint32,\n  setBool: () => setBool2,\n  truncateBitmap: () => truncateBitmap\n});\nfunction getBool2(_data, _index, byte, bit) {\n  return (byte & 1 << bit) !== 0;\n}\nfunction getBit(_data, _index, byte, bit) {\n  return (byte & 1 << bit) >> bit;\n}\nfunction setBool2(bytes, index3, value) {\n  return value ? !!(bytes[index3 >> 3] |= 1 << index3 % 8) || true : !(bytes[index3 >> 3] &= ~(1 << index3 % 8)) && false;\n}\nfunction truncateBitmap(offset2, length4, bitmap) {\n  const alignedSize = bitmap.byteLength + 7 & ~7;\n  if (offset2 > 0 || bitmap.byteLength < alignedSize) {\n    const bytes = new Uint8Array(alignedSize);\n    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (\n      // Otherwise iterate each bit from the offset and return a new one\n      packBools(new BitIterator(bitmap, offset2, length4, null, getBool2)).subarray(0, alignedSize)\n    ));\n    return bytes;\n  }\n  return bitmap;\n}\nfunction packBools(values2) {\n  const xs = [];\n  let i = 0, bit = 0, byte = 0;\n  for (const value of values2) {\n    value && (byte |= 1 << bit);\n    if (++bit === 8) {\n      xs[i++] = byte;\n      byte = bit = 0;\n    }\n  }\n  if (i === 0 || bit > 0) {\n    xs[i++] = byte;\n  }\n  const b = new Uint8Array(xs.length + 7 & ~7);\n  b.set(xs);\n  return b;\n}\nvar BitIterator = class {\n  constructor(bytes, begin, length4, context, get3) {\n    this.bytes = bytes;\n    this.length = length4;\n    this.context = context;\n    this.get = get3;\n    this.bit = begin % 8;\n    this.byteIndex = begin >> 3;\n    this.byte = bytes[this.byteIndex++];\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.length) {\n      if (this.bit === 8) {\n        this.bit = 0;\n        this.byte = this.bytes[this.byteIndex++];\n      }\n      return {\n        value: this.get(this.context, this.index++, this.byte, this.bit++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction popcnt_bit_range(data, lhs, rhs) {\n  if (rhs - lhs <= 0) {\n    return 0;\n  }\n  if (rhs - lhs < 8) {\n    let sum5 = 0;\n    for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {\n      sum5 += bit;\n    }\n    return sum5;\n  }\n  const rhsInside = rhs >> 3 << 3;\n  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);\n  return (\n    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8\n    popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8\n    popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8\n    popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)\n  );\n}\nfunction popcnt_array(arr, byteOffset, byteLength) {\n  let cnt = 0, pos = Math.trunc(byteOffset);\n  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;\n  while (len - pos >= 4) {\n    cnt += popcnt_uint32(view.getUint32(pos));\n    pos += 4;\n  }\n  while (len - pos >= 2) {\n    cnt += popcnt_uint32(view.getUint16(pos));\n    pos += 2;\n  }\n  while (len - pos >= 1) {\n    cnt += popcnt_uint32(view.getUint8(pos));\n    pos += 1;\n  }\n  return cnt;\n}\nfunction popcnt_uint32(uint32) {\n  let i = Math.trunc(uint32);\n  i = i - (i >>> 1 & 1431655765);\n  i = (i & 858993459) + (i >>> 2 & 858993459);\n  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;\n}\n\n// node_modules/apache-arrow/data.mjs\nvar kUnknownNullCount = -1;\nvar Data = class {\n  constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {\n    this.type = type2;\n    this.children = children2;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset2 || 0, 0));\n    this.length = Math.floor(Math.max(length4 || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    let buffer;\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type2);\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n    this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get buffers() {\n    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n  }\n  get byteLength() {\n    let byteLength = 0;\n    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;\n    valueOffsets && (byteLength += valueOffsets.byteLength);\n    values2 && (byteLength += values2.byteLength);\n    nullBitmap && (byteLength += nullBitmap.byteLength);\n    typeIds && (byteLength += typeIds.byteLength);\n    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);\n  }\n  get nullCount() {\n    let nullCount = this._nullCount;\n    let nullBitmap;\n    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n    }\n    return nullCount;\n  }\n  getValid(index3) {\n    if (this.nullable && this.nullCount > 0) {\n      const pos = this.offset + index3;\n      const val = this.nullBitmap[pos >> 3];\n      return (val & 1 << pos % 8) !== 0;\n    }\n    return true;\n  }\n  setValid(index3, value) {\n    if (!this.nullable) {\n      return value;\n    }\n    if (!this.nullBitmap || this.nullBitmap.byteLength <= index3 >> 3) {\n      const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);\n      Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });\n    }\n    const { nullBitmap, offset: offset2 } = this;\n    const pos = offset2 + index3 >> 3;\n    const bit = (offset2 + index3) % 8;\n    const val = nullBitmap[pos] >> bit & 1;\n    value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);\n    return value;\n  }\n  clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {\n    return new Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);\n  }\n  slice(offset2, length4) {\n    const { stride, typeId, children: children2 } = this;\n    const nullCount = +(this._nullCount === 0) - 1;\n    const childStride = typeId === 16 ? stride : 1;\n    const buffers = this._sliceBuffers(offset2, length4, stride, typeId);\n    return this.clone(\n      this.type,\n      this.offset + offset2,\n      length4,\n      nullCount,\n      buffers,\n      // Don't slice children if we have value offsets (the variable-width types)\n      children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)\n    );\n  }\n  _changeLengthAndBackfillNullBitmap(newLength) {\n    if (this.typeId === Type.Null) {\n      return this.clone(this.type, 0, newLength, 0);\n    }\n    const { length: length4, nullCount } = this;\n    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);\n    bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;\n    if (nullCount > 0) {\n      bitmap.set(truncateBitmap(this.offset, length4, this.nullBitmap), 0);\n    }\n    const buffers = this.buffers;\n    buffers[BufferType.VALIDITY] = bitmap;\n    return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);\n  }\n  _sliceBuffers(offset2, length4, stride, typeId) {\n    let arr;\n    const { buffers } = this;\n    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length4));\n    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));\n    return buffers;\n  }\n  _sliceChildren(children2, offset2, length4) {\n    return children2.map((child) => child.slice(offset2, length4));\n  }\n};\nData.prototype.children = Object.freeze([]);\nvar MakeDataVisitor = class extends Visitor {\n  visit(props) {\n    return this.getVisitFn(props[\"type\"]).call(this, props);\n  }\n  visitNull(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"length\"]: length4 = 0 } = props;\n    return new Data(type2, offset2, length4, 0);\n  }\n  visitBool(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length >> 3, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitInt(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFloat(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitUtf8(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const data = toUint8Array(props[\"data\"]);\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);\n  }\n  visitFixedSizeBinary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDate(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTimestamp(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitTime(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitDecimal(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n  visitStruct(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { length: length4 = children2.reduce((len, { length: length5 }) => Math.max(len, length5), 0), nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);\n  }\n  visitUnion(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"children\"]: children2 = [] } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const typeIds = toArrayBufferView(type2.ArrayType, props[\"typeIds\"]);\n    const { [\"length\"]: length4 = typeIds.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    if (DataType.isSparseUnion(type2)) {\n      return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap, typeIds], children2);\n    }\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children2);\n  }\n  visitDictionary(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.indices.ArrayType, props[\"data\"]);\n    const { [\"dictionary\"]: dictionary = new Vector2([new MakeDataVisitor().visit({ type: type2.dictionary })]) } = props;\n    const { [\"length\"]: length4 = data.length, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);\n  }\n  visitInterval(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0 } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const data = toArrayBufferView(type2.ArrayType, props[\"data\"]);\n    const { [\"length\"]: length4 = data.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);\n  }\n  visitFixedSizeList(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.valueType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const { [\"length\"]: length4 = child.length / strideForType(type2), [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);\n  }\n  visitMap(props) {\n    const { [\"type\"]: type2, [\"offset\"]: offset2 = 0, [\"child\"]: child = new MakeDataVisitor().visit({ type: type2.childType }) } = props;\n    const nullBitmap = toUint8Array(props[\"nullBitmap\"]);\n    const valueOffsets = toInt32Array(props[\"valueOffsets\"]);\n    const { [\"length\"]: length4 = valueOffsets.length - 1, [\"nullCount\"]: nullCount = props[\"nullBitmap\"] ? -1 : 0 } = props;\n    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);\n  }\n};\nfunction makeData(props) {\n  return new MakeDataVisitor().visit(props);\n}\n\n// node_modules/apache-arrow/util/chunk.mjs\nvar ChunkedIterator = class {\n  constructor(numChunks = 0, getChunkIterator) {\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  next() {\n    while (this.chunkIndex < this.numChunks) {\n      const next = this.chunkIterator.next();\n      if (!next.done) {\n        return next;\n      }\n      if (++this.chunkIndex < this.numChunks) {\n        this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n      }\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nfunction computeChunkNullCounts(chunks) {\n  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\nfunction computeChunkOffsets(chunks) {\n  return chunks.reduce((offsets, chunk, index3) => {\n    offsets[index3 + 1] = offsets[index3] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\nfunction sliceChunks(chunks, offsets, begin, end) {\n  const slices = [];\n  for (let i = -1, n = chunks.length; ++i < n; ) {\n    const chunk = chunks[i];\n    const offset2 = offsets[i];\n    const { length: length4 } = chunk;\n    if (offset2 >= end) {\n      break;\n    }\n    if (begin >= offset2 + length4) {\n      continue;\n    }\n    if (offset2 >= begin && offset2 + length4 <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    const from = Math.max(0, begin - offset2);\n    const to = Math.min(end - offset2, length4);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\nfunction binarySearch(chunks, offsets, idx, fn) {\n  let lhs = 0, mid3 = 0, rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid3 = lhs + Math.trunc((rhs - lhs) * 0.5);\n    idx < offsets[mid3] ? rhs = mid3 : lhs = mid3;\n  } while (lhs < rhs);\n}\nfunction isChunkedValid(data, index3) {\n  return data.getValid(index3);\n}\nfunction wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function(index3) {\n    const data = this.data;\n    return binarySearch(data, this._offsets, index3, chunkedFn);\n  };\n}\nfunction wrapChunkedCall2(fn) {\n  let _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function(index3, value) {\n    const data = this.data;\n    _2 = value;\n    const result = binarySearch(data, this._offsets, index3, chunkedFn);\n    _2 = void 0;\n    return result;\n  };\n}\nfunction wrapChunkedIndexOf(indexOf2) {\n  let _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    let begin = fromIndex, index3 = 0, total = 0;\n    for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {\n      const chunk = data[i];\n      if (~(index3 = indexOf2(chunk, _1, begin))) {\n        return total + index3;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function(element, offset2) {\n    _1 = element;\n    const data = this.data;\n    const result = typeof offset2 !== \"number\" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset2, chunkedIndexOf);\n    _1 = void 0;\n    return result;\n  };\n}\n\n// node_modules/apache-arrow/visitor/indexof.mjs\nvar IndexOfVisitor = class extends Visitor {\n};\nfunction nullIndexOf(data, searchElement) {\n  return searchElement === null && data.length > 0 ? 0 : -1;\n}\nfunction indexOfNull(data, fromIndex) {\n  const { nullBitmap } = data;\n  if (!nullBitmap || data.nullCount <= 0) {\n    return -1;\n  }\n  let i = 0;\n  for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {\n    if (!isValid) {\n      return i;\n    }\n    ++i;\n  }\n  return -1;\n}\nfunction indexOfValue(data, searchElement, fromIndex) {\n  if (searchElement === void 0) {\n    return -1;\n  }\n  if (searchElement === null) {\n    return indexOfNull(data, fromIndex);\n  }\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction indexOfUnion(data, searchElement, fromIndex) {\n  const get3 = instance2.getVisitFn(data);\n  const compare = createElementComparator(searchElement);\n  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {\n    if (compare(get3(data, i))) {\n      return i;\n    }\n  }\n  return -1;\n}\nIndexOfVisitor.prototype.visitNull = nullIndexOf;\nIndexOfVisitor.prototype.visitBool = indexOfValue;\nIndexOfVisitor.prototype.visitInt = indexOfValue;\nIndexOfVisitor.prototype.visitInt8 = indexOfValue;\nIndexOfVisitor.prototype.visitInt16 = indexOfValue;\nIndexOfVisitor.prototype.visitInt32 = indexOfValue;\nIndexOfVisitor.prototype.visitInt64 = indexOfValue;\nIndexOfVisitor.prototype.visitUint8 = indexOfValue;\nIndexOfVisitor.prototype.visitUint16 = indexOfValue;\nIndexOfVisitor.prototype.visitUint32 = indexOfValue;\nIndexOfVisitor.prototype.visitUint64 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat = indexOfValue;\nIndexOfVisitor.prototype.visitFloat16 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat32 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat64 = indexOfValue;\nIndexOfVisitor.prototype.visitUtf8 = indexOfValue;\nIndexOfVisitor.prototype.visitBinary = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;\nIndexOfVisitor.prototype.visitDate = indexOfValue;\nIndexOfVisitor.prototype.visitDateDay = indexOfValue;\nIndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestamp = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTime = indexOfValue;\nIndexOfVisitor.prototype.visitTimeSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitDecimal = indexOfValue;\nIndexOfVisitor.prototype.visitList = indexOfValue;\nIndexOfVisitor.prototype.visitStruct = indexOfValue;\nIndexOfVisitor.prototype.visitUnion = indexOfValue;\nIndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitDictionary = indexOfValue;\nIndexOfVisitor.prototype.visitInterval = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;\nIndexOfVisitor.prototype.visitMap = indexOfValue;\nvar instance3 = new IndexOfVisitor();\n\n// node_modules/apache-arrow/visitor/iterator.mjs\nvar IteratorVisitor = class extends Visitor {\n};\nfunction vectorIterator(vector2) {\n  const { type: type2 } = vector2;\n  if (vector2.nullCount === 0 && vector2.stride === 1 && (type2.typeId === Type.Timestamp || type2 instanceof Int_ && type2.bitWidth !== 64 || type2 instanceof Time_ && type2.bitWidth !== 64 || type2 instanceof Float && type2.precision !== Precision.HALF)) {\n    return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n      const data = vector2.data[chunkIndex];\n      return data.values.subarray(0, data.length)[Symbol.iterator]();\n    });\n  }\n  let offset2 = 0;\n  return new ChunkedIterator(vector2.data.length, (chunkIndex) => {\n    const data = vector2.data[chunkIndex];\n    const length4 = data.length;\n    const inner = vector2.slice(offset2, offset2 + length4);\n    offset2 += length4;\n    return new VectorIterator(inner);\n  });\n}\nvar VectorIterator = class {\n  constructor(vector2) {\n    this.vector = vector2;\n    this.index = 0;\n  }\n  next() {\n    if (this.index < this.vector.length) {\n      return {\n        value: this.vector.get(this.index++)\n      };\n    }\n    return { done: true, value: null };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n};\nIteratorVisitor.prototype.visitNull = vectorIterator;\nIteratorVisitor.prototype.visitBool = vectorIterator;\nIteratorVisitor.prototype.visitInt = vectorIterator;\nIteratorVisitor.prototype.visitInt8 = vectorIterator;\nIteratorVisitor.prototype.visitInt16 = vectorIterator;\nIteratorVisitor.prototype.visitInt32 = vectorIterator;\nIteratorVisitor.prototype.visitInt64 = vectorIterator;\nIteratorVisitor.prototype.visitUint8 = vectorIterator;\nIteratorVisitor.prototype.visitUint16 = vectorIterator;\nIteratorVisitor.prototype.visitUint32 = vectorIterator;\nIteratorVisitor.prototype.visitUint64 = vectorIterator;\nIteratorVisitor.prototype.visitFloat = vectorIterator;\nIteratorVisitor.prototype.visitFloat16 = vectorIterator;\nIteratorVisitor.prototype.visitFloat32 = vectorIterator;\nIteratorVisitor.prototype.visitFloat64 = vectorIterator;\nIteratorVisitor.prototype.visitUtf8 = vectorIterator;\nIteratorVisitor.prototype.visitBinary = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;\nIteratorVisitor.prototype.visitDate = vectorIterator;\nIteratorVisitor.prototype.visitDateDay = vectorIterator;\nIteratorVisitor.prototype.visitDateMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestamp = vectorIterator;\nIteratorVisitor.prototype.visitTimestampSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitTime = vectorIterator;\nIteratorVisitor.prototype.visitTimeSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitDecimal = vectorIterator;\nIteratorVisitor.prototype.visitList = vectorIterator;\nIteratorVisitor.prototype.visitStruct = vectorIterator;\nIteratorVisitor.prototype.visitUnion = vectorIterator;\nIteratorVisitor.prototype.visitDenseUnion = vectorIterator;\nIteratorVisitor.prototype.visitSparseUnion = vectorIterator;\nIteratorVisitor.prototype.visitDictionary = vectorIterator;\nIteratorVisitor.prototype.visitInterval = vectorIterator;\nIteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;\nIteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeList = vectorIterator;\nIteratorVisitor.prototype.visitMap = vectorIterator;\nvar instance4 = new IteratorVisitor();\n\n// node_modules/apache-arrow/visitor/bytelength.mjs\nvar sum4 = (x4, y4) => x4 + y4;\nvar GetByteLengthVisitor = class extends Visitor {\n  visitNull(____, _) {\n    return 0;\n  }\n  visitInt(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitFloat(data, _) {\n    return data.type.ArrayType.BYTES_PER_ELEMENT;\n  }\n  visitBool(____, _) {\n    return 1 / 8;\n  }\n  visitDecimal(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitDate(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitTime(data, _) {\n    return data.type.bitWidth / 8;\n  }\n  visitTimestamp(data, _) {\n    return data.type.unit === TimeUnit.SECOND ? 4 : 8;\n  }\n  visitInterval(data, _) {\n    return (data.type.unit + 1) * 4;\n  }\n  visitStruct(data, i) {\n    return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitFixedSizeBinary(data, _) {\n    return data.type.byteWidth;\n  }\n  visitMap(data, i) {\n    return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);\n  }\n  visitDictionary(data, i) {\n    var _a5;\n    return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);\n  }\n};\nvar getUtf8ByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getBinaryByteLength = ({ valueOffsets }, index3) => {\n  return 8 + (valueOffsets[index3 + 1] - valueOffsets[index3]);\n};\nvar getListByteLength = ({ valueOffsets, stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const { [index3 * stride]: start2 } = valueOffsets;\n  const { [index3 * stride + 1]: end } = valueOffsets;\n  const visit = instance5.getVisitFn(child.type);\n  const slice7 = child.slice(start2, end - start2);\n  let size = 8;\n  for (let idx = -1, len = end - start2; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getFixedSizeListByteLength = ({ stride, children: children2 }, index3) => {\n  const child = children2[0];\n  const slice7 = child.slice(index3 * stride, stride);\n  const visit = instance5.getVisitFn(child.type);\n  let size = 0;\n  for (let idx = -1, len = slice7.length; ++idx < len; ) {\n    size += visit(slice7, idx);\n  }\n  return size;\n};\nvar getUnionByteLength = (data, index3) => {\n  return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index3) : getSparseUnionByteLength(data, index3);\n};\nvar getDenseUnionByteLength = ({ type: type2, children: children2, typeIds, valueOffsets }, index3) => {\n  const childIndex = type2.typeIdToChildIndex[typeIds[index3]];\n  return 8 + instance5.visit(children2[childIndex], valueOffsets[index3]);\n};\nvar getSparseUnionByteLength = ({ children: children2 }, index3) => {\n  return 4 + instance5.visitMany(children2, children2.map(() => index3)).reduce(sum4, 0);\n};\nGetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;\nGetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;\nGetByteLengthVisitor.prototype.visitList = getListByteLength;\nGetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;\nGetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;\nGetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;\nGetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;\nvar instance5 = new GetByteLengthVisitor();\n\n// node_modules/apache-arrow/vector.mjs\nvar _a2;\nvar visitorsByTypeId = {};\nvar vectorPrototypesByTypeId = {};\nvar Vector2 = class {\n  constructor(input) {\n    var _b2, _c2, _d2;\n    const data = input[0] instanceof Vector2 ? input.flatMap((x4) => x4.data) : input;\n    if (data.length === 0 || data.some((x4) => !(x4 instanceof Data))) {\n      throw new TypeError(\"Vector constructor expects an Array of Data instances.\");\n    }\n    const type2 = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;\n    switch (data.length) {\n      case 0:\n        this._offsets = [0];\n        break;\n      case 1: {\n        const { get: get3, set: set4, indexOf: indexOf2, byteLength } = visitorsByTypeId[type2.typeId];\n        const unchunkedData = data[0];\n        this.isValid = (index3) => isChunkedValid(unchunkedData, index3);\n        this.get = (index3) => get3(unchunkedData, index3);\n        this.set = (index3, value) => set4(unchunkedData, index3, value);\n        this.indexOf = (index3) => indexOf2(unchunkedData, index3);\n        this.getByteLength = (index3) => byteLength(unchunkedData, index3);\n        this._offsets = [0, unchunkedData.length];\n        break;\n      }\n      default:\n        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type2.typeId]);\n        this._offsets = computeChunkOffsets(data);\n        break;\n    }\n    this.data = data;\n    this.type = type2;\n    this.stride = strideForType(type2);\n    this.numChildren = (_d2 = (_c2 = type2.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;\n    this.length = this._offsets[this._offsets.length - 1];\n  }\n  /**\n   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.\n   */\n  get byteLength() {\n    if (this._byteLength === -1) {\n      this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);\n    }\n    return this._byteLength;\n  }\n  /**\n   * The number of null elements in this Vector.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * The Array or TypedAray constructor used for the JS representation\n   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.\n   */\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  /**\n   * The name that should be printed when the Vector is logged in a message.\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;\n  }\n  /**\n   * The name of this Vector.\n   */\n  get VectorName() {\n    return `${Type[this.type.typeId]}Vector`;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  includes(element, offset2) {\n    return this.indexOf(element, offset2) > 0;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for the Vector's elements.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(this);\n  }\n  /**\n   * Combines two or more Vectors of the same type.\n   * @param others Additional Vectors to add to the end of this Vector.\n   */\n  concat(...others) {\n    return new Vector2(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Vector.\n   * @param start The beginning of the specified portion of the Vector.\n   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    return new Vector2(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));\n  }\n  toJSON() {\n    return [...this];\n  }\n  /**\n   * Return a JavaScript Array or TypedArray of the Vector's elements.\n   *\n   * @note If this Vector contains a single Data chunk and the Vector's type is a\n   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this\n   *  method returns a zero-copy slice of the underlying TypedArray values. If there's\n   *  more than one chunk, the resulting TypedArray will be a copy of the data from each\n   *  chunk's underlying TypedArray values.\n   *\n   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.\n   */\n  toArray() {\n    const { type: type2, data, length: length4, stride, ArrayType } = this;\n    switch (type2.typeId) {\n      case Type.Int:\n      case Type.Float:\n      case Type.Decimal:\n      case Type.Time:\n      case Type.Timestamp:\n        switch (data.length) {\n          case 0:\n            return new ArrayType();\n          case 1:\n            return data[0].values.subarray(0, length4 * stride);\n          default:\n            return data.reduce((memo, { values: values2, length: chunk_length }) => {\n              memo.array.set(values2.subarray(0, chunk_length * stride), memo.offset);\n              memo.offset += chunk_length * stride;\n              return memo;\n            }, { array: new ArrayType(length4 * stride), offset: 0 }).array;\n        }\n    }\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Vector.\n   *\n   * @returns A string representation of the Vector.\n   */\n  toString() {\n    return `[${[...this].join(\",\")}]`;\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.numChildren) {\n      return new Vector2(this.data.map(({ children: children2 }) => children2[index3]));\n    }\n    return null;\n  }\n  get isMemoized() {\n    if (DataType.isDictionary(this.type)) {\n      return this.data[0].dictionary.isMemoized;\n    }\n    return false;\n  }\n  /**\n   * Adds memoization to the Vector's {@link get} method. For dictionary\n   * vectors, this method return a vector that memoizes only the dictionary\n   * values.\n   *\n   * Memoization is very useful when decoding a value is expensive such as\n   * Uft8. The memoization creates a cache of the size of the Vector and\n   * therfore increases memory usage.\n   *\n   * @returns A new vector that memoizes calls to {@link get}.\n   */\n  memoize() {\n    if (DataType.isDictionary(this.type)) {\n      const dictionary = new MemoizedVector(this.data[0].dictionary);\n      const newData = this.data.map((data) => {\n        const cloned = data.clone();\n        cloned.dictionary = dictionary;\n        return cloned;\n      });\n      return new Vector2(newData);\n    }\n    return new MemoizedVector(this);\n  }\n  /**\n   * Returns a vector without memoization of the {@link get} method. If this\n   * vector is not memoized, this method returns this vector.\n   *\n   * @returns A a vector without memoization.\n   */\n  unmemoize() {\n    if (DataType.isDictionary(this.type) && this.isMemoized) {\n      const dictionary = this.data[0].dictionary.unmemoize();\n      const newData = this.data.map((data) => {\n        const newData2 = data.clone();\n        newData2.dictionary = dictionary;\n        return newData2;\n      });\n      return new Vector2(newData);\n    }\n    return this;\n  }\n};\n_a2 = Symbol.toStringTag;\nVector2[_a2] = ((proto) => {\n  proto.type = DataType.prototype;\n  proto.data = [];\n  proto.length = 0;\n  proto.stride = 1;\n  proto.numChildren = 0;\n  proto._nullCount = -1;\n  proto._byteLength = -1;\n  proto._offsets = new Uint32Array([0]);\n  proto[Symbol.isConcatSpreadable] = true;\n  const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === \"number\" && T !== Type.NONE);\n  for (const typeId of typeIds) {\n    const get3 = instance2.getVisitFnByTypeId(typeId);\n    const set4 = instance.getVisitFnByTypeId(typeId);\n    const indexOf2 = instance3.getVisitFnByTypeId(typeId);\n    const byteLength = instance5.getVisitFnByTypeId(typeId);\n    visitorsByTypeId[typeId] = { get: get3, set: set4, indexOf: indexOf2, byteLength };\n    vectorPrototypesByTypeId[typeId] = Object.create(proto, {\n      [\"isValid\"]: { value: wrapChunkedCall1(isChunkedValid) },\n      [\"get\"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },\n      [\"set\"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },\n      [\"indexOf\"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },\n      [\"getByteLength\"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }\n    });\n  }\n  return \"Vector\";\n})(Vector2.prototype);\nvar MemoizedVector = class extends Vector2 {\n  constructor(vector2) {\n    super(vector2.data);\n    const get3 = this.get;\n    const set4 = this.set;\n    const slice7 = this.slice;\n    const cache = new Array(this.length);\n    Object.defineProperty(this, \"get\", {\n      value(index3) {\n        const cachedValue = cache[index3];\n        if (cachedValue !== void 0) {\n          return cachedValue;\n        }\n        const value = get3.call(this, index3);\n        cache[index3] = value;\n        return value;\n      }\n    });\n    Object.defineProperty(this, \"set\", {\n      value(index3, value) {\n        set4.call(this, index3, value);\n        cache[index3] = value;\n      }\n    });\n    Object.defineProperty(this, \"slice\", {\n      value: (begin, end) => new MemoizedVector(slice7.call(this, begin, end))\n    });\n    Object.defineProperty(this, \"isMemoized\", { value: true });\n    Object.defineProperty(this, \"unmemoize\", {\n      value: () => new Vector2(this.data)\n    });\n    Object.defineProperty(this, \"memoize\", {\n      value: () => this\n    });\n  }\n};\n\n// node_modules/apache-arrow/builder/valid.mjs\nfunction createIsValidFunction(nullValues) {\n  if (!nullValues || nullValues.length <= 0) {\n    return function isValid(value) {\n      return true;\n    };\n  }\n  let fnBody = \"\";\n  const noNaNs = nullValues.filter((x4) => x4 === x4);\n  if (noNaNs.length > 0) {\n    fnBody = `\n    switch (x) {${noNaNs.map((x4) => `\n        case ${valueToCase(x4)}:`).join(\"\")}\n            return false;\n    }`;\n  }\n  if (nullValues.length !== noNaNs.length) {\n    fnBody = `if (x !== x) return false;\n${fnBody}`;\n  }\n  return new Function(`x`, `${fnBody}\nreturn true;`);\n}\nfunction valueToCase(x4) {\n  if (typeof x4 !== \"bigint\") {\n    return valueToString(x4);\n  } else if (BigIntAvailable) {\n    return `${valueToString(x4)}n`;\n  }\n  return `\"${valueToString(x4)}\"`;\n}\n\n// node_modules/apache-arrow/builder/buffer.mjs\nvar roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;\nvar sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);\nvar BufferBuilder = class {\n  constructor(buffer, stride = 1) {\n    this.buffer = buffer;\n    this.stride = stride;\n    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;\n    this.ArrayType = buffer.constructor;\n    this._resize(this.length = Math.ceil(buffer.length / stride));\n  }\n  get byteLength() {\n    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;\n  }\n  get reservedLength() {\n    return this.buffer.length / this.stride;\n  }\n  get reservedByteLength() {\n    return this.buffer.byteLength;\n  }\n  // @ts-ignore\n  set(index3, value) {\n    return this;\n  }\n  append(value) {\n    return this.set(this.length, value);\n  }\n  reserve(extra) {\n    if (extra > 0) {\n      this.length += extra;\n      const stride = this.stride;\n      const length4 = this.length * stride;\n      const reserved = this.buffer.length;\n      if (length4 >= reserved) {\n        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length4 * 2, this.BYTES_PER_ELEMENT));\n      }\n    }\n    return this;\n  }\n  flush(length4 = this.length) {\n    length4 = roundLengthUpToNearest64Bytes(length4 * this.stride, this.BYTES_PER_ELEMENT);\n    const array4 = sliceOrExtendArray(this.buffer, length4);\n    this.clear();\n    return array4;\n  }\n  clear() {\n    this.length = 0;\n    this._resize(0);\n    return this;\n  }\n  _resize(newLength) {\n    return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);\n  }\n};\nBufferBuilder.prototype.offset = 0;\nvar DataBufferBuilder = class extends BufferBuilder {\n  last() {\n    return this.get(this.length - 1);\n  }\n  get(index3) {\n    return this.buffer[index3];\n  }\n  set(index3, value) {\n    this.reserve(index3 - this.length + 1);\n    this.buffer[index3 * this.stride] = value;\n    return this;\n  }\n};\nvar BitmapBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Uint8Array(0)) {\n    super(data, 1 / 8);\n    this.numValid = 0;\n  }\n  get numInvalid() {\n    return this.length - this.numValid;\n  }\n  get(idx) {\n    return this.buffer[idx >> 3] >> idx % 8 & 1;\n  }\n  set(idx, val) {\n    const { buffer } = this.reserve(idx - this.length + 1);\n    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;\n    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);\n    return this;\n  }\n  clear() {\n    this.numValid = 0;\n    return super.clear();\n  }\n};\nvar OffsetsBufferBuilder = class extends DataBufferBuilder {\n  constructor(data = new Int32Array(1)) {\n    super(data, 1);\n  }\n  append(value) {\n    return this.set(this.length - 1, value);\n  }\n  set(index3, value) {\n    const offset2 = this.length - 1;\n    const buffer = this.reserve(index3 - offset2 + 1).buffer;\n    if (offset2 < index3++) {\n      buffer.fill(buffer[offset2], offset2, index3);\n    }\n    buffer[index3] = buffer[index3 - 1] + value;\n    return this;\n  }\n  flush(length4 = this.length - 1) {\n    if (length4 > this.length) {\n      this.set(length4 - 1, 0);\n    }\n    return super.flush(length4 + 1);\n  }\n};\n\n// node_modules/apache-arrow/builder.mjs\nvar Builder = class {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  constructor({ \"type\": type2, \"nullValues\": nulls }) {\n    this.length = 0;\n    this.finished = false;\n    this.type = type2;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type2);\n    this._nulls = new BitmapBufferBuilder();\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughDOM(options) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /**\n   * Flush the `Builder` and return a `Vector<T>`.\n   * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n   */\n  toVector() {\n    return new Vector2([this.flush()]);\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get nullCount() {\n    return this._nulls.numInvalid;\n  }\n  get numChildren() {\n    return this.children.length;\n  }\n  /**\n   * @returns The aggregate length (in bytes) of the values that have been written.\n   */\n  get byteLength() {\n    let size = 0;\n    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;\n    _offsets && (size += _offsets.byteLength);\n    _values && (size += _values.byteLength);\n    _nulls && (size += _nulls.byteLength);\n    _typeIds && (size += _typeIds.byteLength);\n    return children2.reduce((size2, child) => size2 + child.byteLength, size);\n  }\n  /**\n   * @returns The aggregate number of rows that have been reserved to write new values.\n   */\n  get reservedLength() {\n    return this._nulls.reservedLength;\n  }\n  /**\n   * @returns The aggregate length (in bytes) that has been reserved to write new values.\n   */\n  get reservedByteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.reservedByteLength);\n    this._values && (size += this._values.reservedByteLength);\n    this._nulls && (size += this._nulls.reservedByteLength);\n    this._typeIds && (size += this._typeIds.reservedByteLength);\n    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);\n  }\n  get valueOffsets() {\n    return this._offsets ? this._offsets.buffer : null;\n  }\n  get values() {\n    return this._values ? this._values.buffer : null;\n  }\n  get nullBitmap() {\n    return this._nulls ? this._nulls.buffer : null;\n  }\n  get typeIds() {\n    return this._typeIds ? this._typeIds.buffer : null;\n  }\n  /**\n   * Appends a value (or null) to this `Builder`.\n   * This is equivalent to `builder.set(builder.length, value)`.\n   * @param {T['TValue'] | TNull } value The value to append.\n   */\n  append(value) {\n    return this.set(this.length, value);\n  }\n  /**\n   * Validates whether a value is valid (true), or null (false)\n   * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n   */\n  isValid(value) {\n    return this._isValid(value);\n  }\n  /**\n   * Write a value (or null-value sentinel) at the supplied index.\n   * If the value matches one of the null-value representations, a 1-bit is\n   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n   * the null `BitmapBufferBuilder`, and the value is passed to\n   * `Builder.prototype.setValue()`.\n   * @param {number} index The index of the value to write.\n   * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n   * @returns {this} The updated `Builder` instance.\n   */\n  set(index3, value) {\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value);\n    }\n    return this;\n  }\n  /**\n   * Write a value to the underlying buffers at the supplied index, bypassing\n   * the null-value check. This is a low-level method that\n   * @param {number} index\n   * @param {T['TValue'] | TNull } value\n   */\n  setValue(index3, value) {\n    this._setValue(this, index3, value);\n  }\n  setValid(index3, valid2) {\n    this.length = this._nulls.set(index3, +valid2).length;\n    return valid2;\n  }\n  // @ts-ignore\n  addChild(child, name = `${this.numChildren}`) {\n    throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n  }\n  /**\n   * Retrieve the child `Builder` at the supplied `index`, or null if no child\n   * exists at that index.\n   * @param {number} index The index of the child `Builder` to retrieve.\n   * @returns {Builder | null} The child Builder at the supplied index or null.\n   */\n  getChildAt(index3) {\n    return this.children[index3] || null;\n  }\n  /**\n   * Commit all the values that have been written to their underlying\n   * ArrayBuffers, including any child Builders if applicable, and reset\n   * the internal `Builder` state.\n   * @returns A `Data<T>` of the buffers and children representing the values written.\n   */\n  flush() {\n    let data;\n    let typeIds;\n    let nullBitmap;\n    let valueOffsets;\n    const { type: type2, length: length4, nullCount, _typeIds, _offsets, _values, _nulls } = this;\n    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {\n      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);\n    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());\n    } else {\n      data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);\n    }\n    if (nullCount > 0) {\n      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);\n    }\n    const children2 = this.children.map((child) => child.flush());\n    this.clear();\n    return makeData({\n      type: type2,\n      length: length4,\n      nullCount,\n      children: children2,\n      \"child\": children2[0],\n      data,\n      typeIds,\n      nullBitmap,\n      valueOffsets\n    });\n  }\n  /**\n   * Finalize this `Builder`, and child builders if applicable.\n   * @returns {this} The finalized `Builder` instance.\n   */\n  finish() {\n    this.finished = true;\n    for (const child of this.children)\n      child.finish();\n    return this;\n  }\n  /**\n   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n   * @returns {this} The cleared `Builder` instance.\n   */\n  clear() {\n    var _a5, _b2, _c2, _d2;\n    this.length = 0;\n    (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();\n    (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();\n    (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();\n    (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();\n    for (const child of this.children)\n      child.clear();\n    return this;\n  }\n};\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\nBuilder.prototype._isValid = () => true;\nvar FixedWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n  }\n  setValue(index3, value) {\n    const values2 = this._values;\n    values2.reserve(index3 - values2.length + 1);\n    return super.setValue(index3, value);\n  }\n};\nvar VariableWidthBuilder = class extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._pendingLength = 0;\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  setValue(index3, value) {\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.length);\n    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;\n    pending.set(index3, value);\n  }\n  setValid(index3, isValid) {\n    if (!super.setValid(index3, isValid)) {\n      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index3, void 0);\n      return false;\n    }\n    return true;\n  }\n  clear() {\n    this._pendingLength = 0;\n    this._pending = void 0;\n    return super.clear();\n  }\n  flush() {\n    this._flush();\n    return super.flush();\n  }\n  finish() {\n    this._flush();\n    return super.finish();\n  }\n  _flush() {\n    const pending = this._pending;\n    const pendingLength = this._pendingLength;\n    this._pendingLength = 0;\n    this._pending = void 0;\n    if (pending && pending.size > 0) {\n      this._flushPending(pending, pendingLength);\n    }\n    return this;\n  }\n};\n\n// node_modules/apache-arrow/fb/block.mjs\nvar Block = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * Index to the start of the RecordBlock (note this is past the Message header)\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * Length of the metadata\n   */\n  metaDataLength() {\n    return this.bb.readInt32(this.bb_pos + 8);\n  }\n  /**\n   * Length of the data (this is aligned so there can be a gap between this and\n   * the metadata).\n   */\n  bodyLength() {\n    return this.bb.readInt64(this.bb_pos + 16);\n  }\n  static sizeOf() {\n    return 24;\n  }\n  static createBlock(builder, offset2, metaDataLength, bodyLength) {\n    builder.prep(8, 24);\n    builder.writeInt64(bodyLength);\n    builder.pad(4);\n    builder.writeInt32(metaDataLength);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/flatbuffers/mjs/constants.js\nvar SIZEOF_SHORT = 2;\nvar SIZEOF_INT = 4;\nvar FILE_IDENTIFIER_LENGTH = 4;\nvar SIZE_PREFIX_LENGTH = 4;\n\n// node_modules/flatbuffers/mjs/utils.js\nvar int32 = new Int32Array(2);\nvar float32 = new Float32Array(int32.buffer);\nvar float64 = new Float64Array(int32.buffer);\nvar isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n// node_modules/flatbuffers/mjs/long.js\nvar Long = class {\n  constructor(low, high) {\n    this.low = low | 0;\n    this.high = high | 0;\n  }\n  static create(low, high) {\n    return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);\n  }\n  toFloat64() {\n    return (this.low >>> 0) + this.high * 4294967296;\n  }\n  equals(other) {\n    return this.low == other.low && this.high == other.high;\n  }\n};\nLong.ZERO = new Long(0, 0);\n\n// node_modules/flatbuffers/mjs/encoding.js\nvar Encoding;\n(function(Encoding2) {\n  Encoding2[Encoding2[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n  Encoding2[Encoding2[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n\n// node_modules/flatbuffers/mjs/byte-buffer.js\nvar ByteBuffer = class {\n  /**\n   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n   */\n  constructor(bytes_) {\n    this.bytes_ = bytes_;\n    this.position_ = 0;\n  }\n  /**\n   * Create and allocate a new ByteBuffer with a given size.\n   */\n  static allocate(byte_size) {\n    return new ByteBuffer(new Uint8Array(byte_size));\n  }\n  clear() {\n    this.position_ = 0;\n  }\n  /**\n   * Get the underlying `Uint8Array`.\n   */\n  bytes() {\n    return this.bytes_;\n  }\n  /**\n   * Get the buffer's position.\n   */\n  position() {\n    return this.position_;\n  }\n  /**\n   * Set the buffer's position.\n   */\n  setPosition(position2) {\n    this.position_ = position2;\n  }\n  /**\n   * Get the buffer's capacity.\n   */\n  capacity() {\n    return this.bytes_.length;\n  }\n  readInt8(offset2) {\n    return this.readUint8(offset2) << 24 >> 24;\n  }\n  readUint8(offset2) {\n    return this.bytes_[offset2];\n  }\n  readInt16(offset2) {\n    return this.readUint16(offset2) << 16 >> 16;\n  }\n  readUint16(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;\n  }\n  readInt32(offset2) {\n    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;\n  }\n  readUint32(offset2) {\n    return this.readInt32(offset2) >>> 0;\n  }\n  readInt64(offset2) {\n    return new Long(this.readInt32(offset2), this.readInt32(offset2 + 4));\n  }\n  readUint64(offset2) {\n    return new Long(this.readUint32(offset2), this.readUint32(offset2 + 4));\n  }\n  readFloat32(offset2) {\n    int32[0] = this.readInt32(offset2);\n    return float32[0];\n  }\n  readFloat64(offset2) {\n    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);\n    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);\n    return float64[0];\n  }\n  writeInt8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeUint8(offset2, value) {\n    this.bytes_[offset2] = value;\n  }\n  writeInt16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeUint16(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n  }\n  writeInt32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeUint32(offset2, value) {\n    this.bytes_[offset2] = value;\n    this.bytes_[offset2 + 1] = value >> 8;\n    this.bytes_[offset2 + 2] = value >> 16;\n    this.bytes_[offset2 + 3] = value >> 24;\n  }\n  writeInt64(offset2, value) {\n    this.writeInt32(offset2, value.low);\n    this.writeInt32(offset2 + 4, value.high);\n  }\n  writeUint64(offset2, value) {\n    this.writeUint32(offset2, value.low);\n    this.writeUint32(offset2 + 4, value.high);\n  }\n  writeFloat32(offset2, value) {\n    float32[0] = value;\n    this.writeInt32(offset2, int32[0]);\n  }\n  writeFloat64(offset2, value) {\n    float64[0] = value;\n    this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);\n    this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);\n  }\n  /**\n   * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n   * schema does not include a file_identifier (likely points at padding or the\n   * start of a the root vtable).\n   */\n  getBufferIdentifier() {\n    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n    }\n    let result = \"\";\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n    }\n    return result;\n  }\n  /**\n   * Look up a field in the vtable, return an offset into the object, or 0 if the\n   * field is not present.\n   */\n  __offset(bb_pos, vtable_offset) {\n    const vtable = bb_pos - this.readInt32(bb_pos);\n    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n  }\n  /**\n   * Initialize any Table-derived type to point to the union at the given offset.\n   */\n  __union(t, offset2) {\n    t.bb_pos = offset2 + this.readInt32(offset2);\n    t.bb = this;\n    return t;\n  }\n  /**\n   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n   * This allocates a new string and converts to wide chars upon each access.\n   *\n   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\n   * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n   * and from UTF-16 when the data will just be packaged back up in another\n   * FlatBuffer later on.\n   *\n   * @param offset\n   * @param opt_encoding Defaults to UTF16_STRING\n   */\n  __string(offset2, opt_encoding) {\n    offset2 += this.readInt32(offset2);\n    const length4 = this.readInt32(offset2);\n    let result = \"\";\n    let i = 0;\n    offset2 += SIZEOF_INT;\n    if (opt_encoding === Encoding.UTF8_BYTES) {\n      return this.bytes_.subarray(offset2, offset2 + length4);\n    }\n    while (i < length4) {\n      let codePoint;\n      const a4 = this.readUint8(offset2 + i++);\n      if (a4 < 192) {\n        codePoint = a4;\n      } else {\n        const b = this.readUint8(offset2 + i++);\n        if (a4 < 224) {\n          codePoint = (a4 & 31) << 6 | b & 63;\n        } else {\n          const c6 = this.readUint8(offset2 + i++);\n          if (a4 < 240) {\n            codePoint = (a4 & 15) << 12 | (b & 63) << 6 | c6 & 63;\n          } else {\n            const d = this.readUint8(offset2 + i++);\n            codePoint = (a4 & 7) << 18 | (b & 63) << 12 | (c6 & 63) << 6 | d & 63;\n          }\n        }\n      }\n      if (codePoint < 65536) {\n        result += String.fromCharCode(codePoint);\n      } else {\n        codePoint -= 65536;\n        result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);\n      }\n    }\n    return result;\n  }\n  /**\n   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n   * if a string then return a new one\n   *\n   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n   * makes the behaviour of __union_with_string different compared to __union\n   */\n  __union_with_string(o, offset2) {\n    if (typeof o === \"string\") {\n      return this.__string(offset2);\n    }\n    return this.__union(o, offset2);\n  }\n  /**\n   * Retrieve the relative offset stored at \"offset\"\n   */\n  __indirect(offset2) {\n    return offset2 + this.readInt32(offset2);\n  }\n  /**\n   * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector(offset2) {\n    return offset2 + this.readInt32(offset2) + SIZEOF_INT;\n  }\n  /**\n   * Get the length of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector_len(offset2) {\n    return this.readInt32(offset2 + this.readInt32(offset2));\n  }\n  __has_identifier(ident) {\n    if (ident.length != FILE_IDENTIFIER_LENGTH) {\n      throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n    }\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function for generating list for obj api\n   */\n  createScalarList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      if (listAccessor(i) !== null) {\n        ret.push(listAccessor(i));\n      }\n    }\n    return ret;\n  }\n  /**\n   * A helper function for generating list for obj api\n   * @param listAccessor function that accepts an index and return data at that index\n   * @param listLength listLength\n   * @param res result list\n   */\n  createObjList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val.unpack());\n      }\n    }\n    return ret;\n  }\n};\n\n// node_modules/flatbuffers/mjs/builder.js\nvar Builder2 = class {\n  /**\n   * Create a FlatBufferBuilder.\n   */\n  constructor(opt_initial_size) {\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n    let initial_size;\n    if (!opt_initial_size) {\n      initial_size = 1024;\n    } else {\n      initial_size = opt_initial_size;\n    }\n    this.bb = ByteBuffer.allocate(initial_size);\n    this.space = initial_size;\n  }\n  clear() {\n    this.bb.clear();\n    this.space = this.bb.capacity();\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n  }\n  /**\n   * In order to save space, fields that are set to their default value\n   * don't get serialized into the buffer. Forcing defaults provides a\n   * way to manually disable this optimization.\n   *\n   * @param forceDefaults true always serializes default values\n   */\n  forceDefaults(forceDefaults) {\n    this.force_defaults = forceDefaults;\n  }\n  /**\n   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n   * called finish(). The actual data starts at the ByteBuffer's current position,\n   * not necessarily at 0.\n   */\n  dataBuffer() {\n    return this.bb;\n  }\n  /**\n   * Get the bytes representing the FlatBuffer. Only call this after you've\n   * called finish().\n   */\n  asUint8Array() {\n    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n  }\n  /**\n   * Prepare to write an element of `size` after `additional_bytes` have been\n   * written, e.g. if you write a string, you need to align such the int length\n   * field is aligned to 4 bytes, and the string data follows it directly. If all\n   * you need to do is alignment, `additional_bytes` will be 0.\n   *\n   * @param size This is the of the new element to write\n   * @param additional_bytes The padding size\n   */\n  prep(size, additional_bytes) {\n    if (size > this.minalign) {\n      this.minalign = size;\n    }\n    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n    while (this.space < align_size + size + additional_bytes) {\n      const old_buf_size = this.bb.capacity();\n      this.bb = Builder2.growByteBuffer(this.bb);\n      this.space += this.bb.capacity() - old_buf_size;\n    }\n    this.pad(align_size);\n  }\n  pad(byte_size) {\n    for (let i = 0; i < byte_size; i++) {\n      this.bb.writeInt8(--this.space, 0);\n    }\n  }\n  writeInt8(value) {\n    this.bb.writeInt8(this.space -= 1, value);\n  }\n  writeInt16(value) {\n    this.bb.writeInt16(this.space -= 2, value);\n  }\n  writeInt32(value) {\n    this.bb.writeInt32(this.space -= 4, value);\n  }\n  writeInt64(value) {\n    this.bb.writeInt64(this.space -= 8, value);\n  }\n  writeFloat32(value) {\n    this.bb.writeFloat32(this.space -= 4, value);\n  }\n  writeFloat64(value) {\n    this.bb.writeFloat64(this.space -= 8, value);\n  }\n  /**\n   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int8` to add the the buffer.\n   */\n  addInt8(value) {\n    this.prep(1, 0);\n    this.writeInt8(value);\n  }\n  /**\n   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int16` to add the the buffer.\n   */\n  addInt16(value) {\n    this.prep(2, 0);\n    this.writeInt16(value);\n  }\n  /**\n   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int32` to add the the buffer.\n   */\n  addInt32(value) {\n    this.prep(4, 0);\n    this.writeInt32(value);\n  }\n  /**\n   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int64` to add the the buffer.\n   */\n  addInt64(value) {\n    this.prep(8, 0);\n    this.writeInt64(value);\n  }\n  /**\n   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float32` to add the the buffer.\n   */\n  addFloat32(value) {\n    this.prep(4, 0);\n    this.writeFloat32(value);\n  }\n  /**\n   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float64` to add the the buffer.\n   */\n  addFloat64(value) {\n    this.prep(8, 0);\n    this.writeFloat64(value);\n  }\n  addFieldInt8(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt8(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt16(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt16(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt64(voffset, value, defaultValue) {\n    if (this.force_defaults || !value.equals(defaultValue)) {\n      this.addInt64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat64(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldOffset(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addOffset(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n   */\n  addFieldStruct(voffset, value, defaultValue) {\n    if (value != defaultValue) {\n      this.nested(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structures are always stored inline, they need to be created right\n   * where they're used.  You'll get this assertion failure if you\n   * created it elsewhere.\n   */\n  nested(obj) {\n    if (obj != this.offset()) {\n      throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n    }\n  }\n  /**\n   * Should not be creating any other object, string or vector\n   * while an object is being constructed\n   */\n  notNested() {\n    if (this.isNested) {\n      throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n    }\n  }\n  /**\n   * Set the current vtable at `voffset` to the current location in the buffer.\n   */\n  slot(voffset) {\n    if (this.vtable !== null)\n      this.vtable[voffset] = this.offset();\n  }\n  /**\n   * @returns Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.bb.capacity() - this.space;\n  }\n  /**\n   * Doubles the size of the backing ByteBuffer and copies the old data towards\n   * the end of the new buffer (since we build the buffer backwards).\n   *\n   * @param bb The current buffer with the existing data\n   * @returns A new byte buffer with the old data copied\n   * to it. The data is located at the end of the buffer.\n   *\n   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n   * it a uint8Array we need to suppress the type check:\n   * @suppress {checkTypes}\n   */\n  static growByteBuffer(bb2) {\n    const old_buf_size = bb2.capacity();\n    if (old_buf_size & 3221225472) {\n      throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n    }\n    const new_buf_size = old_buf_size << 1;\n    const nbb = ByteBuffer.allocate(new_buf_size);\n    nbb.setPosition(new_buf_size - old_buf_size);\n    nbb.bytes().set(bb2.bytes(), new_buf_size - old_buf_size);\n    return nbb;\n  }\n  /**\n   * Adds on offset, relative to where it will be written.\n   *\n   * @param offset The offset to add.\n   */\n  addOffset(offset2) {\n    this.prep(SIZEOF_INT, 0);\n    this.writeInt32(this.offset() - offset2 + SIZEOF_INT);\n  }\n  /**\n   * Start encoding a new object in the buffer.  Users will not usually need to\n   * call this directly. The FlatBuffers compiler will generate helper methods\n   * that call this method internally.\n   */\n  startObject(numfields) {\n    this.notNested();\n    if (this.vtable == null) {\n      this.vtable = [];\n    }\n    this.vtable_in_use = numfields;\n    for (let i = 0; i < numfields; i++) {\n      this.vtable[i] = 0;\n    }\n    this.isNested = true;\n    this.object_start = this.offset();\n  }\n  /**\n   * Finish off writing the object that is under construction.\n   *\n   * @returns The offset to the object inside `dataBuffer`\n   */\n  endObject() {\n    if (this.vtable == null || !this.isNested) {\n      throw new Error(\"FlatBuffers: endObject called without startObject\");\n    }\n    this.addInt32(0);\n    const vtableloc = this.offset();\n    let i = this.vtable_in_use - 1;\n    for (; i >= 0 && this.vtable[i] == 0; i--) {\n    }\n    const trimmed_size = i + 1;\n    for (; i >= 0; i--) {\n      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n    }\n    const standard_fields = 2;\n    this.addInt16(vtableloc - this.object_start);\n    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n    this.addInt16(len);\n    let existing_vtable = 0;\n    const vt1 = this.space;\n    outer_loop:\n      for (i = 0; i < this.vtables.length; i++) {\n        const vt2 = this.bb.capacity() - this.vtables[i];\n        if (len == this.bb.readInt16(vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existing_vtable = this.vtables[i];\n          break;\n        }\n      }\n    if (existing_vtable) {\n      this.space = this.bb.capacity() - vtableloc;\n      this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n    } else {\n      this.vtables.push(this.offset());\n      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n    }\n    this.isNested = false;\n    return vtableloc;\n  }\n  /**\n   * Finalize a buffer, poiting to the given `root_table`.\n   */\n  finish(root_table, opt_file_identifier, opt_size_prefix) {\n    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n    if (opt_file_identifier) {\n      const file_identifier = opt_file_identifier;\n      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n        throw new Error(\"FlatBuffers: file identifier must be length \" + FILE_IDENTIFIER_LENGTH);\n      }\n      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n        this.writeInt8(file_identifier.charCodeAt(i));\n      }\n    }\n    this.prep(this.minalign, SIZEOF_INT + size_prefix);\n    this.addOffset(root_table);\n    if (size_prefix) {\n      this.addInt32(this.bb.capacity() - this.space);\n    }\n    this.bb.setPosition(this.space);\n  }\n  /**\n   * Finalize a size prefixed buffer, pointing to the given `root_table`.\n   */\n  finishSizePrefixed(root_table, opt_file_identifier) {\n    this.finish(root_table, opt_file_identifier, true);\n  }\n  /**\n   * This checks a required field has been set in a given table that has\n   * just been constructed.\n   */\n  requiredField(table, field2) {\n    const table_start = this.bb.capacity() - table;\n    const vtable_start = table_start - this.bb.readInt32(table_start);\n    const ok = this.bb.readInt16(vtable_start + field2) != 0;\n    if (!ok) {\n      throw new Error(\"FlatBuffers: field \" + field2 + \" must be set\");\n    }\n  }\n  /**\n   * Start a new array/vector of objects.  Users usually will not call\n   * this directly. The FlatBuffers compiler will create a start/end\n   * method for vector types in generated code.\n   *\n   * @param elem_size The size of each element in the array\n   * @param num_elems The number of elements in the array\n   * @param alignment The alignment of the array\n   */\n  startVector(elem_size, num_elems, alignment) {\n    this.notNested();\n    this.vector_num_elems = num_elems;\n    this.prep(SIZEOF_INT, elem_size * num_elems);\n    this.prep(alignment, elem_size * num_elems);\n  }\n  /**\n   * Finish off the creation of an array and all its elements. The array must be\n   * created with `startVector`.\n   *\n   * @returns The offset at which the newly created array\n   * starts.\n   */\n  endVector() {\n    this.writeInt32(this.vector_num_elems);\n    return this.offset();\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If the string passed has\n   * already been seen, we return the offset of the already written string\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createSharedString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    if (!this.string_maps) {\n      this.string_maps = /* @__PURE__ */ new Map();\n    }\n    if (this.string_maps.has(s2)) {\n      return this.string_maps.get(s2);\n    }\n    const offset2 = this.createString(s2);\n    this.string_maps.set(s2, offset2);\n    return offset2;\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n   * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createString(s2) {\n    if (!s2) {\n      return 0;\n    }\n    let utf8;\n    if (s2 instanceof Uint8Array) {\n      utf8 = s2;\n    } else {\n      utf8 = [];\n      let i = 0;\n      while (i < s2.length) {\n        let codePoint;\n        const a4 = s2.charCodeAt(i++);\n        if (a4 < 55296 || a4 >= 56320) {\n          codePoint = a4;\n        } else {\n          const b = s2.charCodeAt(i++);\n          codePoint = (a4 << 10) + b + (65536 - (55296 << 10) - 56320);\n        }\n        if (codePoint < 128) {\n          utf8.push(codePoint);\n        } else {\n          if (codePoint < 2048) {\n            utf8.push(codePoint >> 6 & 31 | 192);\n          } else {\n            if (codePoint < 65536) {\n              utf8.push(codePoint >> 12 & 15 | 224);\n            } else {\n              utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);\n            }\n            utf8.push(codePoint >> 6 & 63 | 128);\n          }\n          utf8.push(codePoint & 63 | 128);\n        }\n      }\n    }\n    this.addInt8(0);\n    this.startVector(1, utf8.length, 1);\n    this.bb.setPosition(this.space -= utf8.length);\n    for (let i = 0, offset2 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n      bytes[offset2++] = utf8[i];\n    }\n    return this.endVector();\n  }\n  /**\n   * A helper function to avoid generated code depending on this file directly.\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\n   * A helper function to pack an object\n   *\n   * @returns offset of obj\n   */\n  createObjectOffset(obj) {\n    if (obj === null) {\n      return 0;\n    }\n    if (typeof obj === \"string\") {\n      return this.createString(obj);\n    } else {\n      return obj.pack(this);\n    }\n  }\n  /**\n   * A helper function to pack a list of object\n   *\n   * @returns list of offsets of each non null object\n   */\n  createObjectOffsetList(list) {\n    const ret = [];\n    for (let i = 0; i < list.length; ++i) {\n      const val = list[i];\n      if (val !== null) {\n        ret.push(this.createObjectOffset(val));\n      } else {\n        throw new Error(\"FlatBuffers: Argument for createObjectOffsetList cannot contain null.\");\n      }\n    }\n    return ret;\n  }\n  createStructOffsetList(list, startFunc) {\n    startFunc(this, list.length);\n    this.createObjectOffsetList(list);\n    return this.endVector();\n  }\n};\n\n// node_modules/apache-arrow/fb/key-value.mjs\nvar KeyValue = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsKeyValue(bb2, obj) {\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsKeyValue(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  key(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  value(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startKeyValue(builder) {\n    builder.startObject(2);\n  }\n  static addKey(builder, keyOffset) {\n    builder.addFieldOffset(0, keyOffset, 0);\n  }\n  static addValue(builder, valueOffset) {\n    builder.addFieldOffset(1, valueOffset, 0);\n  }\n  static endKeyValue(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createKeyValue(builder, keyOffset, valueOffset) {\n    KeyValue.startKeyValue(builder);\n    KeyValue.addKey(builder, keyOffset);\n    KeyValue.addValue(builder, valueOffset);\n    return KeyValue.endKeyValue(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/metadata-version.mjs\nvar MetadataVersion2;\n(function(MetadataVersion3) {\n  MetadataVersion3[MetadataVersion3[\"V1\"] = 0] = \"V1\";\n  MetadataVersion3[MetadataVersion3[\"V2\"] = 1] = \"V2\";\n  MetadataVersion3[MetadataVersion3[\"V3\"] = 2] = \"V3\";\n  MetadataVersion3[MetadataVersion3[\"V4\"] = 3] = \"V4\";\n  MetadataVersion3[MetadataVersion3[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion2 || (MetadataVersion2 = {}));\n\n// node_modules/apache-arrow/fb/endianness.mjs\nvar Endianness;\n(function(Endianness2) {\n  Endianness2[Endianness2[\"Little\"] = 0] = \"Little\";\n  Endianness2[Endianness2[\"Big\"] = 1] = \"Big\";\n})(Endianness || (Endianness = {}));\n\n// node_modules/apache-arrow/fb/dictionary-kind.mjs\nvar DictionaryKind;\n(function(DictionaryKind2) {\n  DictionaryKind2[DictionaryKind2[\"DenseArray\"] = 0] = \"DenseArray\";\n})(DictionaryKind || (DictionaryKind = {}));\n\n// node_modules/apache-arrow/fb/int.mjs\nvar Int = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInt(bb2, obj) {\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInt(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  isSigned() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startInt(builder) {\n    builder.startObject(2);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(0, bitWidth, 0);\n  }\n  static addIsSigned(builder, isSigned) {\n    builder.addFieldInt8(1, +isSigned, 0);\n  }\n  static endInt(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInt(builder, bitWidth, isSigned) {\n    Int.startInt(builder);\n    Int.addBitWidth(builder, bitWidth);\n    Int.addIsSigned(builder, isSigned);\n    return Int.endInt(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-encoding.mjs\nvar DictionaryEncoding = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryEncoding(bb2, obj) {\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * The known dictionary id in the application where this data is used. In\n   * the file or streaming formats, the dictionary ids are found in the\n   * DictionaryBatch messages\n   */\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * The dictionary indices are constrained to be non-negative integers. If\n   * this field is null, the indices must be signed int32. To maximize\n   * cross-language compatibility and performance, implementations are\n   * recommended to prefer signed integer types over unsigned integer types\n   * and to avoid uint64 indices unless they are required by an application.\n   */\n  indexType(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * By default, dictionaries are not ordered, or the order does not have\n   * semantic meaning. In some statistical, applications, dictionary-encoding\n   * is used to represent ordered categorical data, and we provide a way to\n   * preserve that metadata here\n   */\n  isOrdered() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  dictionaryKind() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;\n  }\n  static startDictionaryEncoding(builder) {\n    builder.startObject(4);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addIndexType(builder, indexTypeOffset) {\n    builder.addFieldOffset(1, indexTypeOffset, 0);\n  }\n  static addIsOrdered(builder, isOrdered2) {\n    builder.addFieldInt8(2, +isOrdered2, 0);\n  }\n  static addDictionaryKind(builder, dictionaryKind) {\n    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n  }\n  static endDictionaryEncoding(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/binary.mjs\nvar Binary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBinary(bb2, obj) {\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Binary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBinary(builder) {\n    builder.startObject(0);\n  }\n  static endBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBinary(builder) {\n    Binary2.startBinary(builder);\n    return Binary2.endBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/bool.mjs\nvar Bool2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBool(bb2, obj) {\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBool(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Bool2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startBool(builder) {\n    builder.startObject(0);\n  }\n  static endBool(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBool(builder) {\n    Bool2.startBool(builder);\n    return Bool2.endBool(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/date-unit.mjs\nvar DateUnit2;\n(function(DateUnit3) {\n  DateUnit3[DateUnit3[\"DAY\"] = 0] = \"DAY\";\n  DateUnit3[DateUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit2 || (DateUnit2 = {}));\n\n// node_modules/apache-arrow/fb/date.mjs\nvar Date2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDate(bb2, obj) {\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDate(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Date2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit2.MILLISECOND;\n  }\n  static startDate(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, DateUnit2.MILLISECOND);\n  }\n  static endDate(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDate(builder, unit3) {\n    Date2.startDate(builder);\n    Date2.addUnit(builder, unit3);\n    return Date2.endDate(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/decimal.mjs\nvar Decimal2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDecimal(bb2, obj) {\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDecimal(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Decimal2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Total number of decimal digits\n   */\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of digits after the decimal point \".\"\n   */\n  scale() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Number of bits per value. The only accepted widths are 128 and 256.\n   * We use bitWidth for consistency with Int::bitWidth.\n   */\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;\n  }\n  static startDecimal(builder) {\n    builder.startObject(3);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt32(0, precision, 0);\n  }\n  static addScale(builder, scale3) {\n    builder.addFieldInt32(1, scale3, 0);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(2, bitWidth, 128);\n  }\n  static endDecimal(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createDecimal(builder, precision, scale3, bitWidth) {\n    Decimal2.startDecimal(builder);\n    Decimal2.addPrecision(builder, precision);\n    Decimal2.addScale(builder, scale3);\n    Decimal2.addBitWidth(builder, bitWidth);\n    return Decimal2.endDecimal(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time-unit.mjs\nvar TimeUnit2;\n(function(TimeUnit3) {\n  TimeUnit3[TimeUnit3[\"SECOND\"] = 0] = \"SECOND\";\n  TimeUnit3[TimeUnit3[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n  TimeUnit3[TimeUnit3[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n  TimeUnit3[TimeUnit3[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit2 || (TimeUnit2 = {}));\n\n// node_modules/apache-arrow/fb/fixed-size-binary.mjs\nvar FixedSizeBinary2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeBinary(bb2, obj) {\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeBinary2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of bytes per value\n   */\n  byteWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeBinary(builder) {\n    builder.startObject(1);\n  }\n  static addByteWidth(builder, byteWidth) {\n    builder.addFieldInt32(0, byteWidth, 0);\n  }\n  static endFixedSizeBinary(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeBinary(builder, byteWidth) {\n    FixedSizeBinary2.startFixedSizeBinary(builder);\n    FixedSizeBinary2.addByteWidth(builder, byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/fixed-size-list.mjs\nvar FixedSizeList2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFixedSizeList(bb2, obj) {\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFixedSizeList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FixedSizeList2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Number of list items per value\n   */\n  listSize() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;\n  }\n  static startFixedSizeList(builder) {\n    builder.startObject(1);\n  }\n  static addListSize(builder, listSize) {\n    builder.addFieldInt32(0, listSize, 0);\n  }\n  static endFixedSizeList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFixedSizeList(builder, listSize) {\n    FixedSizeList2.startFixedSizeList(builder);\n    FixedSizeList2.addListSize(builder, listSize);\n    return FixedSizeList2.endFixedSizeList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/precision.mjs\nvar Precision2;\n(function(Precision3) {\n  Precision3[Precision3[\"HALF\"] = 0] = \"HALF\";\n  Precision3[Precision3[\"SINGLE\"] = 1] = \"SINGLE\";\n  Precision3[Precision3[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision2 || (Precision2 = {}));\n\n// node_modules/apache-arrow/fb/floating-point.mjs\nvar FloatingPoint = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFloatingPoint(bb2, obj) {\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFloatingPoint(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  precision() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision2.HALF;\n  }\n  static startFloatingPoint(builder) {\n    builder.startObject(1);\n  }\n  static addPrecision(builder, precision) {\n    builder.addFieldInt16(0, precision, Precision2.HALF);\n  }\n  static endFloatingPoint(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createFloatingPoint(builder, precision) {\n    FloatingPoint.startFloatingPoint(builder);\n    FloatingPoint.addPrecision(builder, precision);\n    return FloatingPoint.endFloatingPoint(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/interval-unit.mjs\nvar IntervalUnit2;\n(function(IntervalUnit3) {\n  IntervalUnit3[IntervalUnit3[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n  IntervalUnit3[IntervalUnit3[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n  IntervalUnit3[IntervalUnit3[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit2 || (IntervalUnit2 = {}));\n\n// node_modules/apache-arrow/fb/interval.mjs\nvar Interval = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsInterval(bb2, obj) {\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsInterval(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit2.YEAR_MONTH;\n  }\n  static startInterval(builder) {\n    builder.startObject(1);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, IntervalUnit2.YEAR_MONTH);\n  }\n  static endInterval(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createInterval(builder, unit3) {\n    Interval.startInterval(builder);\n    Interval.addUnit(builder, unit3);\n    return Interval.endInterval(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/list.mjs\nvar List2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsList(bb2, obj) {\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsList(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new List2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startList(builder) {\n    builder.startObject(0);\n  }\n  static endList(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createList(builder) {\n    List2.startList(builder);\n    return List2.endList(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/map.mjs\nvar Map2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMap(bb2, obj) {\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMap(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Map2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Set to true if the keys within each value are sorted\n   */\n  keysSorted() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startMap(builder) {\n    builder.startObject(1);\n  }\n  static addKeysSorted(builder, keysSorted) {\n    builder.addFieldInt8(0, +keysSorted, 0);\n  }\n  static endMap(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createMap(builder, keysSorted) {\n    Map2.startMap(builder);\n    Map2.addKeysSorted(builder, keysSorted);\n    return Map2.endMap(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/null.mjs\nvar Null2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsNull(bb2, obj) {\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsNull(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Null2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startNull(builder) {\n    builder.startObject(0);\n  }\n  static endNull(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createNull(builder) {\n    Null2.startNull(builder);\n    return Null2.endNull(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/struct_.mjs\nvar Struct_ = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsStruct_(bb2, obj) {\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsStruct_(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startStruct_(builder) {\n    builder.startObject(0);\n  }\n  static endStruct_(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createStruct_(builder) {\n    Struct_.startStruct_(builder);\n    return Struct_.endStruct_(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/time.mjs\nvar Time = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTime(bb2, obj) {\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTime(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;\n  }\n  bitWidth() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;\n  }\n  static startTime(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.MILLISECOND);\n  }\n  static addBitWidth(builder, bitWidth) {\n    builder.addFieldInt32(1, bitWidth, 32);\n  }\n  static endTime(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTime(builder, unit3, bitWidth) {\n    Time.startTime(builder);\n    Time.addUnit(builder, unit3);\n    Time.addBitWidth(builder, bitWidth);\n    return Time.endTime(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/timestamp.mjs\nvar Timestamp = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsTimestamp(bb2, obj) {\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsTimestamp(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  unit() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.SECOND;\n  }\n  timezone(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  static startTimestamp(builder) {\n    builder.startObject(2);\n  }\n  static addUnit(builder, unit3) {\n    builder.addFieldInt16(0, unit3, TimeUnit2.SECOND);\n  }\n  static addTimezone(builder, timezoneOffset) {\n    builder.addFieldOffset(1, timezoneOffset, 0);\n  }\n  static endTimestamp(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createTimestamp(builder, unit3, timezoneOffset) {\n    Timestamp.startTimestamp(builder);\n    Timestamp.addUnit(builder, unit3);\n    Timestamp.addTimezone(builder, timezoneOffset);\n    return Timestamp.endTimestamp(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/union-mode.mjs\nvar UnionMode2;\n(function(UnionMode3) {\n  UnionMode3[UnionMode3[\"Sparse\"] = 0] = \"Sparse\";\n  UnionMode3[UnionMode3[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode2 || (UnionMode2 = {}));\n\n// node_modules/apache-arrow/fb/union.mjs\nvar Union = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUnion(bb2, obj) {\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUnion(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  mode() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode2.Sparse;\n  }\n  typeIds(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index3 * 4) : 0;\n  }\n  typeIdsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  typeIdsArray() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;\n  }\n  static startUnion(builder) {\n    builder.startObject(2);\n  }\n  static addMode(builder, mode2) {\n    builder.addFieldInt16(0, mode2, UnionMode2.Sparse);\n  }\n  static addTypeIds(builder, typeIdsOffset) {\n    builder.addFieldOffset(1, typeIdsOffset, 0);\n  }\n  static createTypeIdsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt32(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startTypeIdsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endUnion(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUnion(builder, mode2, typeIdsOffset) {\n    Union.startUnion(builder);\n    Union.addMode(builder, mode2);\n    Union.addTypeIds(builder, typeIdsOffset);\n    return Union.endUnion(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/utf8.mjs\nvar Utf82 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsUtf8(bb2, obj) {\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsUtf8(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Utf82()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static startUtf8(builder) {\n    builder.startObject(0);\n  }\n  static endUtf8(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createUtf8(builder) {\n    Utf82.startUtf8(builder);\n    return Utf82.endUtf8(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/type.mjs\nvar Type2;\n(function(Type3) {\n  Type3[Type3[\"NONE\"] = 0] = \"NONE\";\n  Type3[Type3[\"Null\"] = 1] = \"Null\";\n  Type3[Type3[\"Int\"] = 2] = \"Int\";\n  Type3[Type3[\"FloatingPoint\"] = 3] = \"FloatingPoint\";\n  Type3[Type3[\"Binary\"] = 4] = \"Binary\";\n  Type3[Type3[\"Utf8\"] = 5] = \"Utf8\";\n  Type3[Type3[\"Bool\"] = 6] = \"Bool\";\n  Type3[Type3[\"Decimal\"] = 7] = \"Decimal\";\n  Type3[Type3[\"Date\"] = 8] = \"Date\";\n  Type3[Type3[\"Time\"] = 9] = \"Time\";\n  Type3[Type3[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type3[Type3[\"Interval\"] = 11] = \"Interval\";\n  Type3[Type3[\"List\"] = 12] = \"List\";\n  Type3[Type3[\"Struct_\"] = 13] = \"Struct_\";\n  Type3[Type3[\"Union\"] = 14] = \"Union\";\n  Type3[Type3[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type3[Type3[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type3[Type3[\"Map\"] = 17] = \"Map\";\n  Type3[Type3[\"Duration\"] = 18] = \"Duration\";\n  Type3[Type3[\"LargeBinary\"] = 19] = \"LargeBinary\";\n  Type3[Type3[\"LargeUtf8\"] = 20] = \"LargeUtf8\";\n  Type3[Type3[\"LargeList\"] = 21] = \"LargeList\";\n})(Type2 || (Type2 = {}));\n\n// node_modules/apache-arrow/fb/field.mjs\nvar Field = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsField(bb2, obj) {\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsField(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  name(optionalEncoding) {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;\n  }\n  /**\n   * Whether or not this field can contain nulls. Should be true in general.\n   */\n  nullable() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  typeType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type2.NONE;\n  }\n  /**\n   * This is the type of the decoded value if the field is dictionary encoded.\n   */\n  // @ts-ignore\n  type(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  /**\n   * Present only if the field is dictionary encoded.\n   */\n  dictionary(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * children apply only to nested data types like Struct, List and Union. For\n   * primitive types children will have length 0.\n   */\n  children(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  childrenLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 14);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 16);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startField(builder) {\n    builder.startObject(7);\n  }\n  static addName(builder, nameOffset) {\n    builder.addFieldOffset(0, nameOffset, 0);\n  }\n  static addNullable(builder, nullable) {\n    builder.addFieldInt8(1, +nullable, 0);\n  }\n  static addTypeType(builder, typeType) {\n    builder.addFieldInt8(2, typeType, Type2.NONE);\n  }\n  static addType(builder, typeOffset) {\n    builder.addFieldOffset(3, typeOffset, 0);\n  }\n  static addDictionary(builder, dictionaryOffset) {\n    builder.addFieldOffset(4, dictionaryOffset, 0);\n  }\n  static addChildren(builder, childrenOffset) {\n    builder.addFieldOffset(5, childrenOffset, 0);\n  }\n  static createChildrenVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startChildrenVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(6, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endField(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/schema.mjs\nvar Schema = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsSchema(bb2, obj) {\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsSchema(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * endianness of the buffer\n   * it is Little Endian by default\n   * if endianness doesn't match the underlying system then the vectors need to be converted\n   */\n  endianness() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;\n  }\n  fields(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  fieldsLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Features used in the stream/file.\n   */\n  features(index3) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index3 * 8) : this.bb.createLong(0, 0);\n  }\n  featuresLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startSchema(builder) {\n    builder.startObject(4);\n  }\n  static addEndianness(builder, endianness) {\n    builder.addFieldInt16(0, endianness, Endianness.Little);\n  }\n  static addFields(builder, fieldsOffset) {\n    builder.addFieldOffset(1, fieldsOffset, 0);\n  }\n  static createFieldsVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFieldsVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(2, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addFeatures(builder, featuresOffset) {\n    builder.addFieldOffset(3, featuresOffset, 0);\n  }\n  static createFeaturesVector(builder, data) {\n    builder.startVector(8, data.length, 8);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt64(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startFeaturesVector(builder, numElems) {\n    builder.startVector(8, numElems, 8);\n  }\n  static endSchema(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishSchemaBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedSchemaBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {\n    Schema.startSchema(builder);\n    Schema.addEndianness(builder, endianness);\n    Schema.addFields(builder, fieldsOffset);\n    Schema.addCustomMetadata(builder, customMetadataOffset);\n    Schema.addFeatures(builder, featuresOffset);\n    return Schema.endSchema(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/footer.mjs\nvar Footer = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsFooter(bb2, obj) {\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsFooter(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  schema(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  dictionaries(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  dictionariesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  recordBatches(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 24, this.bb) : null;\n  }\n  recordBatchesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * User-defined metadata\n   */\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startFooter(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addSchema(builder, schemaOffset) {\n    builder.addFieldOffset(1, schemaOffset, 0);\n  }\n  static addDictionaries(builder, dictionariesOffset) {\n    builder.addFieldOffset(2, dictionariesOffset, 0);\n  }\n  static startDictionariesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addRecordBatches(builder, recordBatchesOffset) {\n    builder.addFieldOffset(3, recordBatchesOffset, 0);\n  }\n  static startRecordBatchesVector(builder, numElems) {\n    builder.startVector(24, numElems, 8);\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endFooter(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishFooterBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedFooterBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n};\n\n// node_modules/apache-arrow/schema.mjs\nvar Schema2 = class {\n  constructor(fields = [], metadata, dictionaries) {\n    this.fields = fields || [];\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n    this.dictionaries = dictionaries;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Schema\";\n  }\n  get names() {\n    return this.fields.map((f) => f.name);\n  }\n  toString() {\n    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(\", \")} }>`;\n  }\n  /**\n   * Construct a new Schema containing only specified fields.\n   *\n   * @param fieldNames Names of fields to keep.\n   * @returns A new Schema of fields matching the specified names.\n   */\n  select(fieldNames) {\n    const names = new Set(fieldNames);\n    const fields = this.fields.filter((f) => names.has(f.name));\n    return new Schema2(fields, this.metadata);\n  }\n  /**\n   * Construct a new Schema containing only fields at the specified indices.\n   *\n   * @param fieldIndices Indices of fields to keep.\n   * @returns A new Schema of fields at the specified indices.\n   */\n  selectAt(fieldIndices) {\n    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);\n    return new Schema2(fields, this.metadata);\n  }\n  assign(...args) {\n    const other = args[0] instanceof Schema2 ? args[0] : Array.isArray(args[0]) ? new Schema2(args[0]) : new Schema2(args);\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter((f2) => {\n      const i = curFields.findIndex((f) => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());\n    return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n};\nSchema2.prototype.fields = null;\nSchema2.prototype.metadata = null;\nSchema2.prototype.dictionaries = null;\nvar Field2 = class {\n  constructor(name, type2, nullable = false, metadata) {\n    this.name = name;\n    this.type = type2;\n    this.nullable = nullable;\n    this.metadata = metadata || /* @__PURE__ */ new Map();\n  }\n  /** @nocollapse */\n  static new(...args) {\n    let [name, type2, nullable, metadata] = args;\n    if (args[0] && typeof args[0] === \"object\") {\n      ({ name } = args[0]);\n      type2 === void 0 && (type2 = args[0].type);\n      nullable === void 0 && (nullable = args[0].nullable);\n      metadata === void 0 && (metadata = args[0].metadata);\n    }\n    return new Field2(`${name}`, type2, nullable, metadata);\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Field\";\n  }\n  toString() {\n    return `${this.name}: ${this.type}`;\n  }\n  clone(...args) {\n    let [name, type2, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== \"object\" ? [name = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type: type2 = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];\n    return Field2.new(name, type2, nullable, metadata);\n  }\n};\nField2.prototype.type = null;\nField2.prototype.name = null;\nField2.prototype.nullable = null;\nField2.prototype.metadata = null;\nfunction mergeMaps(m1, m22) {\n  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m22 || /* @__PURE__ */ new Map()]);\n}\nfunction generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        dictionaries.set(type2.id, type2.dictionary);\n      } else if (dictionaries.get(type2.id) !== type2.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      generateDictionaryMap(type2.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n\n// node_modules/apache-arrow/ipc/metadata/file.mjs\nvar Long2 = Long;\nvar Builder3 = Builder2;\nvar ByteBuffer2 = ByteBuffer;\nvar Footer_ = class {\n  constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {\n    this.schema = schema;\n    this.version = version;\n    recordBatches && (this._recordBatches = recordBatches);\n    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer2(toUint8Array(buf));\n    const footer = Footer.getRootAsFooter(buf);\n    const schema = Schema2.decode(footer.schema());\n    return new OffHeapFooter(schema, footer);\n  }\n  /** @nocollapse */\n  static encode(footer) {\n    const b = new Builder3();\n    const schemaOffset = Schema2.encode(b, footer.schema);\n    Footer.startRecordBatchesVector(b, footer.numRecordBatches);\n    for (const rb of [...footer.recordBatches()].slice().reverse()) {\n      FileBlock.encode(b, rb);\n    }\n    const recordBatchesOffset = b.endVector();\n    Footer.startDictionariesVector(b, footer.numDictionaries);\n    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {\n      FileBlock.encode(b, db);\n    }\n    const dictionaryBatchesOffset = b.endVector();\n    Footer.startFooter(b);\n    Footer.addSchema(b, schemaOffset);\n    Footer.addVersion(b, MetadataVersion.V4);\n    Footer.addRecordBatches(b, recordBatchesOffset);\n    Footer.addDictionaries(b, dictionaryBatchesOffset);\n    Footer.finishFooterBuffer(b, Footer.endFooter(b));\n    return b.asUint8Array();\n  }\n  get numRecordBatches() {\n    return this._recordBatches.length;\n  }\n  get numDictionaries() {\n    return this._dictionaryBatches.length;\n  }\n  *recordBatches() {\n    for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {\n      if (block = this.getRecordBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  *dictionaryBatches() {\n    for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {\n      if (block = this.getDictionaryBatch(i)) {\n        yield block;\n      }\n    }\n  }\n  getRecordBatch(index3) {\n    return index3 >= 0 && index3 < this.numRecordBatches && this._recordBatches[index3] || null;\n  }\n  getDictionaryBatch(index3) {\n    return index3 >= 0 && index3 < this.numDictionaries && this._dictionaryBatches[index3] || null;\n  }\n};\nvar OffHeapFooter = class extends Footer_ {\n  constructor(schema, _footer) {\n    super(schema, _footer.version());\n    this._footer = _footer;\n  }\n  get numRecordBatches() {\n    return this._footer.recordBatchesLength();\n  }\n  get numDictionaries() {\n    return this._footer.dictionariesLength();\n  }\n  getRecordBatch(index3) {\n    if (index3 >= 0 && index3 < this.numRecordBatches) {\n      const fileBlock = this._footer.recordBatches(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n  getDictionaryBatch(index3) {\n    if (index3 >= 0 && index3 < this.numDictionaries) {\n      const fileBlock = this._footer.dictionaries(index3);\n      if (fileBlock) {\n        return FileBlock.decode(fileBlock);\n      }\n    }\n    return null;\n  }\n};\nvar FileBlock = class {\n  constructor(metaDataLength, bodyLength, offset2) {\n    this.metaDataLength = metaDataLength;\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static decode(block) {\n    return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());\n  }\n  /** @nocollapse */\n  static encode(b, fileBlock) {\n    const { metaDataLength } = fileBlock;\n    const offset2 = new Long2(fileBlock.offset, 0);\n    const bodyLength = new Long2(fileBlock.bodyLength, 0);\n    return Block.createBlock(b, offset2, metaDataLength, bodyLength);\n  }\n};\n\n// node_modules/apache-arrow/io/interfaces.mjs\nvar ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });\nvar ArrowJSON = class {\n  constructor(_json) {\n    this._json = _json;\n  }\n  get schema() {\n    return this._json[\"schema\"];\n  }\n  get batches() {\n    return this._json[\"batches\"] || [];\n  }\n  get dictionaries() {\n    return this._json[\"dictionaries\"] || [];\n  }\n};\nvar ReadableInterop = class {\n  tee() {\n    return this._getDOMStream().tee();\n  }\n  pipe(writable, options) {\n    return this._getNodeStream().pipe(writable, options);\n  }\n  pipeTo(writable, options) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n  pipeThrough(duplex, options) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n  _getDOMStream() {\n    return this._DOMStream || (this._DOMStream = this.toDOMStream());\n  }\n  _getNodeStream() {\n    return this._nodeStream || (this._nodeStream = this.toNodeStream());\n  }\n};\nvar AsyncQueue = class extends ReadableInterop {\n  constructor() {\n    super();\n    this._values = [];\n    this.resolvers = [];\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  write(value) {\n    if (this._ensureOpen()) {\n      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });\n    }\n  }\n  abort(value) {\n    if (this._closedPromiseResolve) {\n      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });\n    }\n  }\n  close() {\n    if (this._closedPromiseResolve) {\n      const { resolvers } = this;\n      while (resolvers.length > 0) {\n        resolvers.shift().resolve(ITERATOR_DONE);\n      }\n      this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  toDOMStream(options) {\n    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  toNodeStream(options) {\n    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);\n  }\n  throw(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.abort(_);\n      return ITERATOR_DONE;\n    });\n  }\n  return(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return ITERATOR_DONE;\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(..._args) {\n    if (this._values.length > 0) {\n      return Promise.resolve({ done: false, value: this._values.shift() });\n    } else if (this._error) {\n      return Promise.reject({ done: true, value: this._error.error });\n    } else if (!this._closedPromiseResolve) {\n      return Promise.resolve(ITERATOR_DONE);\n    } else {\n      return new Promise((resolve, reject) => {\n        this.resolvers.push({ resolve, reject });\n      });\n    }\n  }\n  _ensureOpen() {\n    if (this._closedPromiseResolve) {\n      return true;\n    }\n    throw new Error(`AsyncQueue is closed`);\n  }\n};\n\n// node_modules/apache-arrow/io/stream.mjs\nvar AsyncByteQueue = class extends AsyncQueue {\n  write(value) {\n    if ((value = toUint8Array(value)).byteLength > 0) {\n      return super.write(value);\n    }\n  }\n  toString(sync = false) {\n    return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);\n  }\n  toUint8Array(sync = false) {\n    return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {\n      var e_1, _a5;\n      const buffers = [];\n      let byteLength = 0;\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const chunk = _c2.value;\n          buffers.push(chunk);\n          byteLength += chunk.byteLength;\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return joinUint8Arrays(buffers, byteLength)[0];\n    }))();\n  }\n};\nvar ByteStream = class {\n  constructor(source) {\n    if (source) {\n      this.source = new ByteStreamSource(adapters_default.fromIterable(source));\n    }\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar AsyncByteStream = class {\n  constructor(source) {\n    if (source instanceof AsyncByteStream) {\n      this.source = source.source;\n    } else if (source instanceof AsyncByteQueue) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isReadableNodeStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));\n    } else if (isReadableDOMStream(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));\n    } else if (isFetchResponse(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));\n    } else if (isIterable2(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));\n    } else if (isPromise(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    } else if (isAsyncIterable(source)) {\n      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next(value) {\n    return this.source.next(value);\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  get closed() {\n    return this.source.closed;\n  }\n  cancel(reason) {\n    return this.source.cancel(reason);\n  }\n  peek(size) {\n    return this.source.peek(size);\n  }\n  read(size) {\n    return this.source.read(size);\n  }\n};\nvar ByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n  }\n  cancel(reason) {\n    this.return(reason);\n  }\n  peek(size) {\n    return this.next(size, \"peek\").value;\n  }\n  read(size) {\n    return this.next(size, \"read\").value;\n  }\n  next(size, cmd = \"read\") {\n    return this.source.next({ cmd, size });\n  }\n  throw(value) {\n    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);\n  }\n  return(value) {\n    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);\n  }\n};\nvar AsyncByteStreamSource = class {\n  constructor(source) {\n    this.source = source;\n    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.return(reason);\n    });\n  }\n  get closed() {\n    return this._closedPromise;\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"read\")).value;\n    });\n  }\n  peek(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.next(size, \"peek\")).value;\n    });\n  }\n  next(size, cmd = \"read\") {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.next({ cmd, size });\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;\n      this._closedPromiseResolve && this._closedPromiseResolve();\n      this._closedPromiseResolve = void 0;\n      return Object.create(result);\n    });\n  }\n};\n\n// node_modules/apache-arrow/io/file.mjs\nvar RandomAccessFile = class extends ByteStream {\n  constructor(buffer, byteLength) {\n    super();\n    this.position = 0;\n    this.buffer = toUint8Array(buffer);\n    this.size = typeof byteLength === \"undefined\" ? this.buffer.byteLength : byteLength;\n  }\n  readInt32(position2) {\n    const { buffer, byteOffset } = this.readAt(position2, 4);\n    return new DataView(buffer, byteOffset).getInt32(0, true);\n  }\n  seek(position2) {\n    this.position = Math.min(position2, this.size);\n    return position2 < this.size;\n  }\n  read(nBytes) {\n    const { buffer, size, position: position2 } = this;\n    if (buffer && position2 < size) {\n      if (typeof nBytes !== \"number\") {\n        nBytes = Number.POSITIVE_INFINITY;\n      }\n      this.position = Math.min(size, position2 + Math.min(size - position2, nBytes));\n      return buffer.subarray(position2, this.position);\n    }\n    return null;\n  }\n  readAt(position2, nBytes) {\n    const buf = this.buffer;\n    const end = Math.min(this.size, position2 + nBytes);\n    return buf ? buf.subarray(position2, end) : new Uint8Array(nBytes);\n  }\n  close() {\n    this.buffer && (this.buffer = null);\n  }\n  throw(value) {\n    this.close();\n    return { done: true, value };\n  }\n  return(value) {\n    this.close();\n    return { done: true, value };\n  }\n};\nvar AsyncRandomAccessFile = class extends AsyncByteStream {\n  constructor(file, byteLength) {\n    super();\n    this.position = 0;\n    this._handle = file;\n    if (typeof byteLength === \"number\") {\n      this.size = byteLength;\n    } else {\n      this._pending = (() => __awaiter(this, void 0, void 0, function* () {\n        this.size = (yield file.stat()).size;\n        delete this._pending;\n      }))();\n    }\n  }\n  readInt32(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { buffer, byteOffset } = yield this.readAt(position2, 4);\n      return new DataView(buffer, byteOffset).getInt32(0, true);\n    });\n  }\n  seek(position2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      this.position = Math.min(position2, this.size);\n      return position2 < this.size;\n    });\n  }\n  read(nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size, position: position2 } = this;\n      if (file && position2 < size) {\n        if (typeof nBytes !== \"number\") {\n          nBytes = Number.POSITIVE_INFINITY;\n        }\n        let pos = position2, offset2 = 0, bytesRead = 0;\n        const end = Math.min(size, pos + Math.min(size - pos, nBytes));\n        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));\n        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {\n          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));\n        }\n        return buffer;\n      }\n      return null;\n    });\n  }\n  readAt(position2, nBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pending && (yield this._pending);\n      const { _handle: file, size } = this;\n      if (file && position2 + nBytes < size) {\n        const end = Math.min(size, position2 + nBytes);\n        const buffer = new Uint8Array(end - position2);\n        return (yield file.read(buffer, 0, nBytes, position2)).buffer;\n      }\n      return new Uint8Array(nBytes);\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const f = this._handle;\n      this._handle = null;\n      f && (yield f.close());\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.close();\n      return { done: true, value };\n    });\n  }\n};\n\n// node_modules/apache-arrow/util/int.mjs\nvar int_exports = {};\n__export(int_exports, {\n  BaseInt64: () => BaseInt64,\n  Int128: () => Int128,\n  Int64: () => Int642,\n  Uint64: () => Uint642\n});\nvar carryBit16 = 1 << 16;\nfunction intAsHex(value) {\n  if (value < 0) {\n    value = 4294967295 + value + 1;\n  }\n  return `0x${value.toString(16)}`;\n}\nvar kInt32DecimalDigits = 8;\nvar kPowersOfTen = [\n  1,\n  10,\n  100,\n  1e3,\n  1e4,\n  1e5,\n  1e6,\n  1e7,\n  1e8\n];\nvar BaseInt64 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return this.buffer[1];\n  }\n  low() {\n    return this.buffer[0];\n  }\n  _times(other) {\n    const L = new Uint32Array([\n      this.buffer[1] >>> 16,\n      this.buffer[1] & 65535,\n      this.buffer[0] >>> 16,\n      this.buffer[0] & 65535\n    ]);\n    const R = new Uint32Array([\n      other.buffer[1] >>> 16,\n      other.buffer[1] & 65535,\n      other.buffer[0] >>> 16,\n      other.buffer[0] & 65535\n    ]);\n    let product = L[3] * R[3];\n    this.buffer[0] = product & 65535;\n    let sum5 = product >>> 16;\n    product = L[2] * R[3];\n    sum5 += product;\n    product = L[3] * R[2] >>> 0;\n    sum5 += product;\n    this.buffer[0] += sum5 << 16;\n    this.buffer[1] = sum5 >>> 0 < product ? carryBit16 : 0;\n    this.buffer[1] += sum5 >>> 16;\n    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;\n    return this;\n  }\n  _plus(other) {\n    const sum5 = this.buffer[0] + other.buffer[0] >>> 0;\n    this.buffer[1] += other.buffer[1];\n    if (sum5 < this.buffer[0] >>> 0) {\n      ++this.buffer[1];\n    }\n    this.buffer[0] = sum5;\n  }\n  lessThan(other) {\n    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];\n  }\n  equals(other) {\n    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n  }\n  greaterThan(other) {\n    return other.lessThan(this);\n  }\n  hex() {\n    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n};\nvar Uint642 = class extends BaseInt64 {\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Uint642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const length4 = str.length;\n    const out = new Uint642(out_buffer);\n    for (let posn = 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Uint642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Uint642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Uint642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int642 = class extends BaseInt64 {\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    return this;\n  }\n  times(other) {\n    this._times(other);\n    return this;\n  }\n  plus(other) {\n    this._plus(other);\n    return this;\n  }\n  lessThan(other) {\n    const this_high = this.buffer[1] << 0;\n    const other_high = other.buffer[1] << 0;\n    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    return Int642.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int642(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));\n      const multiple = new Int642(new Uint32Array([kPowersOfTen[group3], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 2);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int642.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n    return data;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int642(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n};\nvar Int128 = class {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n  high() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n  }\n  low() {\n    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n  }\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    this.buffer[2] = ~this.buffer[2];\n    this.buffer[3] = ~this.buffer[3];\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n    if (this.buffer[1] == 0) {\n      ++this.buffer[2];\n    }\n    if (this.buffer[2] == 0) {\n      ++this.buffer[3];\n    }\n    return this;\n  }\n  times(other) {\n    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));\n    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));\n    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));\n    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));\n    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));\n    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));\n    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));\n    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));\n    let product = Uint642.multiply(L3, R3);\n    this.buffer[0] = product.low();\n    const sum5 = new Uint642(new Uint32Array([product.high(), 0]));\n    product = Uint642.multiply(L2, R3);\n    sum5.plus(product);\n    product = Uint642.multiply(L3, R2);\n    sum5.plus(product);\n    this.buffer[1] = sum5.low();\n    this.buffer[3] = sum5.lessThan(product) ? 1 : 0;\n    this.buffer[2] = sum5.high();\n    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));\n    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();\n    return this;\n  }\n  plus(other) {\n    const sums = new Uint32Array(4);\n    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;\n    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;\n    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;\n    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;\n    if (sums[0] < this.buffer[0] >>> 0) {\n      ++sums[1];\n    }\n    if (sums[1] < this.buffer[1] >>> 0) {\n      ++sums[2];\n    }\n    if (sums[2] < this.buffer[2] >>> 0) {\n      ++sums[3];\n    }\n    this.buffer[3] = sums[3];\n    this.buffer[2] = sums[2];\n    this.buffer[1] = sums[1];\n    this.buffer[0] = sums[0];\n    return this;\n  }\n  hex() {\n    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n  /** @nocollapse */\n  static multiply(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.times(right2);\n  }\n  /** @nocollapse */\n  static add(left2, right2) {\n    const rtrn = new Int128(new Uint32Array(left2.buffer));\n    return rtrn.plus(right2);\n  }\n  /** @nocollapse */\n  static from(val, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(typeof val === \"string\" ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromNumber(num, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n  static fromString(str, out_buffer = new Uint32Array(4)) {\n    const negate2 = str.startsWith(\"-\");\n    const length4 = str.length;\n    const out = new Int128(out_buffer);\n    for (let posn = negate2 ? 1 : 0; posn < length4; ) {\n      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;\n      const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));\n      const multiple = new Int128(new Uint32Array([kPowersOfTen[group3], 0, 0, 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group3;\n    }\n    return negate2 ? out.negate() : out;\n  }\n  /** @nocollapse */\n  static convertArray(values2) {\n    const data = new Uint32Array(values2.length * 4);\n    for (let i = -1, n = values2.length; ++i < n; ) {\n      Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n    }\n    return data;\n  }\n};\n\n// node_modules/apache-arrow/visitor/vectorloader.mjs\nvar VectorLoader = class extends Visitor {\n  constructor(bytes, nodes, buffers, dictionaries) {\n    super();\n    this.nodesIndex = -1;\n    this.buffersIndex = -1;\n    this.bytes = bytes;\n    this.nodes = nodes;\n    this.buffers = buffers;\n    this.dictionaries = dictionaries;\n  }\n  visit(node) {\n    return super.visit(node instanceof Field2 ? node.type : node);\n  }\n  visitNull(type2, { length: length4 } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4 });\n  }\n  visitBool(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitInt(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFloat(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });\n  }\n  visitFixedSizeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDate(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTimestamp(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitTime(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitDecimal(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  visitStruct(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), children: this.visitMany(type2.children) });\n  }\n  visitUnion(type2) {\n    return type2.mode === UnionMode.Sparse ? this.visitSparseUnion(type2) : this.visitDenseUnion(type2);\n  }\n  visitDenseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), valueOffsets: this.readOffsets(type2), children: this.visitMany(type2.children) });\n  }\n  visitSparseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), typeIds: this.readTypeIds(type2), children: this.visitMany(type2.children) });\n  }\n  visitDictionary(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2.indices), dictionary: this.readDictionary(type2) });\n  }\n  visitInterval(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });\n  }\n  visitFixedSizeList(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), \"child\": this.visit(type2.children[0]) });\n  }\n  visitMap(type2, { length: length4, nullCount } = this.nextFieldNode()) {\n    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), \"child\": this.visit(type2.children[0]) });\n  }\n  nextFieldNode() {\n    return this.nodes[++this.nodesIndex];\n  }\n  nextBufferRange() {\n    return this.buffers[++this.buffersIndex];\n  }\n  readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {\n    return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);\n  }\n  readOffsets(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readTypeIds(type2, buffer) {\n    return this.readData(type2, buffer);\n  }\n  readData(_type, { length: length4, offset: offset2 } = this.nextBufferRange()) {\n    return this.bytes.subarray(offset2, offset2 + length4);\n  }\n  readDictionary(type2) {\n    return this.dictionaries.get(type2.id);\n  }\n};\nvar JSONVectorLoader = class extends VectorLoader {\n  constructor(sources, nodes, buffers, dictionaries) {\n    super(new Uint8Array(0), nodes, buffers, dictionaries);\n    this.sources = sources;\n  }\n  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {\n    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);\n  }\n  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset2]));\n  }\n  readTypeIds(type2, { offset: offset2 } = this.nextBufferRange()) {\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, this.sources[offset2]));\n  }\n  readData(type2, { offset: offset2 } = this.nextBufferRange()) {\n    const { sources } = this;\n    if (DataType.isTimestamp(type2)) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if ((DataType.isInt(type2) || DataType.isTime(type2)) && type2.bitWidth === 64) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDate(type2) && type2.unit === DateUnit.MILLISECOND) {\n      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));\n    } else if (DataType.isDecimal(type2)) {\n      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));\n    } else if (DataType.isBinary(type2) || DataType.isFixedSizeBinary(type2)) {\n      return binaryDataFromJSON(sources[offset2]);\n    } else if (DataType.isBool(type2)) {\n      return packBools(sources[offset2]);\n    } else if (DataType.isUtf8(type2)) {\n      return encodeUtf8(sources[offset2].join(\"\"));\n    }\n    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, sources[offset2].map((x4) => +x4)));\n  }\n};\nfunction binaryDataFromJSON(values2) {\n  const joined = values2.join(\"\");\n  const data = new Uint8Array(joined.length / 2);\n  for (let i = 0; i < joined.length; i += 2) {\n    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);\n  }\n  return data;\n}\n\n// node_modules/apache-arrow/builder/binary.mjs\nvar BinaryBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, toUint8Array(value));\n  }\n  _flushPending(pending, pendingLength) {\n    const offsets = this._offsets;\n    const data = this._values.reserve(pendingLength).buffer;\n    let offset2 = 0;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        const length4 = value.length;\n        data.set(value, offset2);\n        offsets.set(index3, length4);\n        offset2 += length4;\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/bool.mjs\nvar BoolBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._values = new BitmapBufferBuilder();\n  }\n  setValue(index3, value) {\n    this._values.set(index3, +value);\n  }\n};\n\n// node_modules/apache-arrow/builder/date.mjs\nvar DateBuilder = class extends FixedWidthBuilder {\n};\nDateBuilder.prototype._setValue = setDate;\nvar DateDayBuilder = class extends DateBuilder {\n};\nDateDayBuilder.prototype._setValue = setDateDay;\nvar DateMillisecondBuilder = class extends DateBuilder {\n};\nDateMillisecondBuilder.prototype._setValue = setDateMillisecond;\n\n// node_modules/apache-arrow/builder/decimal.mjs\nvar DecimalBuilder = class extends FixedWidthBuilder {\n};\nDecimalBuilder.prototype._setValue = setDecimal;\n\n// node_modules/apache-arrow/builder/dictionary.mjs\nvar DictionaryBuilder = class extends Builder {\n  constructor({ \"type\": type2, \"nullValues\": nulls, \"dictionaryHashFunction\": hashFn }) {\n    super({ type: new Dictionary(type2.dictionary, type2.indices, type2.id, type2.isOrdered) });\n    this._nulls = null;\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    this.indices = makeBuilder({ \"type\": this.type.indices, \"nullValues\": nulls });\n    this.dictionary = makeBuilder({ \"type\": this.type.dictionary, \"nullValues\": null });\n    if (typeof hashFn === \"function\") {\n      this.valueToKey = hashFn;\n    }\n  }\n  get values() {\n    return this.indices.values;\n  }\n  get nullCount() {\n    return this.indices.nullCount;\n  }\n  get nullBitmap() {\n    return this.indices.nullBitmap;\n  }\n  get byteLength() {\n    return this.indices.byteLength + this.dictionary.byteLength;\n  }\n  get reservedLength() {\n    return this.indices.reservedLength + this.dictionary.reservedLength;\n  }\n  get reservedByteLength() {\n    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;\n  }\n  isValid(value) {\n    return this.indices.isValid(value);\n  }\n  setValid(index3, valid2) {\n    const indices = this.indices;\n    valid2 = indices.setValid(index3, valid2);\n    this.length = indices.length;\n    return valid2;\n  }\n  setValue(index3, value) {\n    const keysToIndices = this._keysToIndices;\n    const key = this.valueToKey(value);\n    let idx = keysToIndices[key];\n    if (idx === void 0) {\n      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;\n    }\n    return this.indices.setValue(index3, idx);\n  }\n  flush() {\n    const type2 = this.type;\n    const prev = this._dictionary;\n    const curr = this.dictionary.toVector();\n    const data = this.indices.flush().clone(type2);\n    data.dictionary = prev ? prev.concat(curr) : curr;\n    this.finished || (this._dictionaryOffset += curr.length);\n    this._dictionary = data.dictionary;\n    this.clear();\n    return data;\n  }\n  finish() {\n    this.indices.finish();\n    this.dictionary.finish();\n    this._dictionaryOffset = 0;\n    this._keysToIndices = /* @__PURE__ */ Object.create(null);\n    return super.finish();\n  }\n  clear() {\n    this.indices.clear();\n    this.dictionary.clear();\n    return super.clear();\n  }\n  valueToKey(val) {\n    return typeof val === \"string\" ? val : `${val}`;\n  }\n};\n\n// node_modules/apache-arrow/builder/fixedsizebinary.mjs\nvar FixedSizeBinaryBuilder = class extends FixedWidthBuilder {\n};\nFixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;\n\n// node_modules/apache-arrow/builder/fixedsizelist.mjs\nvar FixedSizeListBuilder = class extends Builder {\n  setValue(index3, value) {\n    const [child] = this.children;\n    const start2 = index3 * this.stride;\n    for (let i = -1, n = value.length; ++i < n; ) {\n      child.set(start2 + i, value[i]);\n    }\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"FixedSizeListBuilder can only have one child.\");\n    }\n    const childIndex = this.children.push(child);\n    this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/float.mjs\nvar FloatBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Float16Builder = class extends FloatBuilder {\n  setValue(index3, value) {\n    super.setValue(index3, float64ToUint16(value));\n  }\n};\nvar Float32Builder = class extends FloatBuilder {\n};\nvar Float64Builder = class extends FloatBuilder {\n};\n\n// node_modules/apache-arrow/builder/interval.mjs\nvar IntervalBuilder = class extends FixedWidthBuilder {\n};\nIntervalBuilder.prototype._setValue = setIntervalValue;\nvar IntervalDayTimeBuilder = class extends IntervalBuilder {\n};\nIntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;\nvar IntervalYearMonthBuilder = class extends IntervalBuilder {\n};\nIntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;\n\n// node_modules/apache-arrow/builder/int.mjs\nvar IntBuilder = class extends FixedWidthBuilder {\n  setValue(index3, value) {\n    this._values.set(index3, value);\n  }\n};\nvar Int8Builder = class extends IntBuilder {\n};\nvar Int16Builder = class extends IntBuilder {\n};\nvar Int32Builder = class extends IntBuilder {\n};\nvar Int64Builder = class extends IntBuilder {\n};\nvar Uint8Builder = class extends IntBuilder {\n};\nvar Uint16Builder = class extends IntBuilder {\n};\nvar Uint32Builder = class extends IntBuilder {\n};\nvar Uint64Builder = class extends IntBuilder {\n};\n\n// node_modules/apache-arrow/builder/list.mjs\nvar ListBuilder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._offsets = new OffsetsBufferBuilder();\n  }\n  addChild(child, name = \"0\") {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new List(new Field2(name, child.type, true));\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (typeof value === \"undefined\") {\n        offsets.set(index3, 0);\n      } else {\n        const n = value.length;\n        const start2 = offsets.set(index3, n).buffer[index3];\n        for (let i = -1; ++i < n; ) {\n          child.set(start2 + i, value[i]);\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/map.mjs\nvar MapBuilder = class extends VariableWidthBuilder {\n  set(index3, value) {\n    return super.set(index3, value);\n  }\n  setValue(index3, value) {\n    const row = value instanceof Map ? value : new Map(Object.entries(value));\n    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());\n    const current = pending.get(index3);\n    current && (this._pendingLength -= current.size);\n    this._pendingLength += row.size;\n    pending.set(index3, row);\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    if (this.numChildren > 0) {\n      throw new Error(\"ListBuilder can only have one child.\");\n    }\n    this.children[this.numChildren] = child;\n    this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);\n    return this.numChildren - 1;\n  }\n  _flushPending(pending) {\n    const offsets = this._offsets;\n    const [child] = this.children;\n    for (const [index3, value] of pending) {\n      if (value === void 0) {\n        offsets.set(index3, 0);\n      } else {\n        let { [index3]: idx, [index3 + 1]: end } = offsets.set(index3, value.size).buffer;\n        for (const val of value.entries()) {\n          child.set(idx, val);\n          if (++idx >= end)\n            break;\n        }\n      }\n    }\n  }\n};\n\n// node_modules/apache-arrow/builder/null.mjs\nvar NullBuilder = class extends Builder {\n  // @ts-ignore\n  setValue(index3, value) {\n  }\n  setValid(index3, valid2) {\n    this.length = Math.max(index3 + 1, this.length);\n    return valid2;\n  }\n};\n\n// node_modules/apache-arrow/builder/struct.mjs\nvar StructBuilder = class extends Builder {\n  setValue(index3, value) {\n    const { children: children2, type: type2 } = this;\n    switch (Array.isArray(value) || value.constructor) {\n      case true:\n        return type2.children.forEach((_, i) => children2[i].set(index3, value[i]));\n      case Map:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value.get(f.name)));\n      default:\n        return type2.children.forEach((f, i) => children2[i].set(index3, value[f.name]));\n    }\n  }\n  /** @inheritdoc */\n  setValid(index3, valid2) {\n    if (!super.setValid(index3, valid2)) {\n      this.children.forEach((child) => child.setValid(index3, valid2));\n    }\n    return valid2;\n  }\n  addChild(child, name = `${this.numChildren}`) {\n    const childIndex = this.children.push(child);\n    this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);\n    return childIndex;\n  }\n};\n\n// node_modules/apache-arrow/builder/timestamp.mjs\nvar TimestampBuilder = class extends FixedWidthBuilder {\n};\nTimestampBuilder.prototype._setValue = setTimestamp;\nvar TimestampSecondBuilder = class extends TimestampBuilder {\n};\nTimestampSecondBuilder.prototype._setValue = setTimestampSecond;\nvar TimestampMillisecondBuilder = class extends TimestampBuilder {\n};\nTimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;\nvar TimestampMicrosecondBuilder = class extends TimestampBuilder {\n};\nTimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;\nvar TimestampNanosecondBuilder = class extends TimestampBuilder {\n};\nTimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;\n\n// node_modules/apache-arrow/builder/time.mjs\nvar TimeBuilder = class extends FixedWidthBuilder {\n};\nTimeBuilder.prototype._setValue = setTime;\nvar TimeSecondBuilder = class extends TimeBuilder {\n};\nTimeSecondBuilder.prototype._setValue = setTimeSecond;\nvar TimeMillisecondBuilder = class extends TimeBuilder {\n};\nTimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;\nvar TimeMicrosecondBuilder = class extends TimeBuilder {\n};\nTimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;\nvar TimeNanosecondBuilder = class extends TimeBuilder {\n};\nTimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;\n\n// node_modules/apache-arrow/builder/union.mjs\nvar UnionBuilder = class extends Builder {\n  constructor(options) {\n    super(options);\n    this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);\n    if (typeof options[\"valueToChildTypeId\"] === \"function\") {\n      this._valueToChildTypeId = options[\"valueToChildTypeId\"];\n    }\n  }\n  get typeIdToChildIndex() {\n    return this.type.typeIdToChildIndex;\n  }\n  append(value, childTypeId) {\n    return this.set(this.length, value, childTypeId);\n  }\n  set(index3, value, childTypeId) {\n    if (childTypeId === void 0) {\n      childTypeId = this._valueToChildTypeId(this, value, index3);\n    }\n    if (this.setValid(index3, this.isValid(value))) {\n      this.setValue(index3, value, childTypeId);\n    }\n    return this;\n  }\n  setValue(index3, value, childTypeId) {\n    this._typeIds.set(index3, childTypeId);\n    const childIndex = this.type.typeIdToChildIndex[childTypeId];\n    const child = this.children[childIndex];\n    child === null || child === void 0 ? void 0 : child.set(index3, value);\n  }\n  addChild(child, name = `${this.children.length}`) {\n    const childTypeId = this.children.push(child);\n    const { type: { children: children2, mode: mode2, typeIds } } = this;\n    const fields = [...children2, new Field2(name, child.type)];\n    this.type = new Union_(mode2, [...typeIds, childTypeId], fields);\n    return childTypeId;\n  }\n  /** @ignore */\n  // @ts-ignore\n  _valueToChildTypeId(builder, value, offset2) {\n    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \\`childTypeId\\` as the second argument to unionBuilder.append(), or supply a \\`valueToChildTypeId\\` function as part of the UnionBuilder constructor options.`);\n  }\n};\nvar SparseUnionBuilder = class extends UnionBuilder {\n};\nvar DenseUnionBuilder = class extends UnionBuilder {\n  constructor(options) {\n    super(options);\n    this._offsets = new DataBufferBuilder(new Int32Array(0));\n  }\n  /** @ignore */\n  setValue(index3, value, childTypeId) {\n    const id2 = this._typeIds.set(index3, childTypeId).buffer[index3];\n    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);\n    const denseIndex = this._offsets.set(index3, child.length).buffer[index3];\n    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);\n  }\n};\n\n// node_modules/apache-arrow/builder/utf8.mjs\nvar Utf8Builder = class extends VariableWidthBuilder {\n  constructor(opts) {\n    super(opts);\n    this._values = new BufferBuilder(new Uint8Array(0));\n  }\n  get byteLength() {\n    let size = this._pendingLength + this.length * 4;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    return size;\n  }\n  setValue(index3, value) {\n    return super.setValue(index3, encodeUtf8(value));\n  }\n  // @ts-ignore\n  _flushPending(pending, pendingLength) {\n  }\n};\nUtf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;\n\n// node_modules/apache-arrow/visitor/builderctor.mjs\nvar GetBuilderCtor = class extends Visitor {\n  visitNull() {\n    return NullBuilder;\n  }\n  visitBool() {\n    return BoolBuilder;\n  }\n  visitInt() {\n    return IntBuilder;\n  }\n  visitInt8() {\n    return Int8Builder;\n  }\n  visitInt16() {\n    return Int16Builder;\n  }\n  visitInt32() {\n    return Int32Builder;\n  }\n  visitInt64() {\n    return Int64Builder;\n  }\n  visitUint8() {\n    return Uint8Builder;\n  }\n  visitUint16() {\n    return Uint16Builder;\n  }\n  visitUint32() {\n    return Uint32Builder;\n  }\n  visitUint64() {\n    return Uint64Builder;\n  }\n  visitFloat() {\n    return FloatBuilder;\n  }\n  visitFloat16() {\n    return Float16Builder;\n  }\n  visitFloat32() {\n    return Float32Builder;\n  }\n  visitFloat64() {\n    return Float64Builder;\n  }\n  visitUtf8() {\n    return Utf8Builder;\n  }\n  visitBinary() {\n    return BinaryBuilder;\n  }\n  visitFixedSizeBinary() {\n    return FixedSizeBinaryBuilder;\n  }\n  visitDate() {\n    return DateBuilder;\n  }\n  visitDateDay() {\n    return DateDayBuilder;\n  }\n  visitDateMillisecond() {\n    return DateMillisecondBuilder;\n  }\n  visitTimestamp() {\n    return TimestampBuilder;\n  }\n  visitTimestampSecond() {\n    return TimestampSecondBuilder;\n  }\n  visitTimestampMillisecond() {\n    return TimestampMillisecondBuilder;\n  }\n  visitTimestampMicrosecond() {\n    return TimestampMicrosecondBuilder;\n  }\n  visitTimestampNanosecond() {\n    return TimestampNanosecondBuilder;\n  }\n  visitTime() {\n    return TimeBuilder;\n  }\n  visitTimeSecond() {\n    return TimeSecondBuilder;\n  }\n  visitTimeMillisecond() {\n    return TimeMillisecondBuilder;\n  }\n  visitTimeMicrosecond() {\n    return TimeMicrosecondBuilder;\n  }\n  visitTimeNanosecond() {\n    return TimeNanosecondBuilder;\n  }\n  visitDecimal() {\n    return DecimalBuilder;\n  }\n  visitList() {\n    return ListBuilder;\n  }\n  visitStruct() {\n    return StructBuilder;\n  }\n  visitUnion() {\n    return UnionBuilder;\n  }\n  visitDenseUnion() {\n    return DenseUnionBuilder;\n  }\n  visitSparseUnion() {\n    return SparseUnionBuilder;\n  }\n  visitDictionary() {\n    return DictionaryBuilder;\n  }\n  visitInterval() {\n    return IntervalBuilder;\n  }\n  visitIntervalDayTime() {\n    return IntervalDayTimeBuilder;\n  }\n  visitIntervalYearMonth() {\n    return IntervalYearMonthBuilder;\n  }\n  visitFixedSizeList() {\n    return FixedSizeListBuilder;\n  }\n  visitMap() {\n    return MapBuilder;\n  }\n};\nvar instance6 = new GetBuilderCtor();\n\n// node_modules/apache-arrow/visitor/typecomparator.mjs\nvar TypeComparator = class extends Visitor {\n  compareSchemas(schema, other) {\n    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);\n  }\n  compareManyFields(fields, others) {\n    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));\n  }\n  compareFields(field2, other) {\n    return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);\n  }\n};\nfunction compareConstructor(type2, other) {\n  return other instanceof type2.constructor;\n}\nfunction compareAny(type2, other) {\n  return type2 === other || compareConstructor(type2, other);\n}\nfunction compareInt(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;\n}\nfunction compareFloat(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.precision === other.precision;\n}\nfunction compareFixedSizeBinary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.byteWidth === other.byteWidth;\n}\nfunction compareDate(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareTimestamp(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;\n}\nfunction compareTime(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;\n}\nfunction compareList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareStruct(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareUnion(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareDictionary(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance7.visit(type2.indices, other.indices) && instance7.visit(type2.dictionary, other.dictionary);\n}\nfunction compareInterval(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;\n}\nfunction compareFixedSizeList(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nfunction compareMap(type2, other) {\n  return type2 === other || compareConstructor(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance7.compareManyFields(type2.children, other.children);\n}\nTypeComparator.prototype.visitNull = compareAny;\nTypeComparator.prototype.visitBool = compareAny;\nTypeComparator.prototype.visitInt = compareInt;\nTypeComparator.prototype.visitInt8 = compareInt;\nTypeComparator.prototype.visitInt16 = compareInt;\nTypeComparator.prototype.visitInt32 = compareInt;\nTypeComparator.prototype.visitInt64 = compareInt;\nTypeComparator.prototype.visitUint8 = compareInt;\nTypeComparator.prototype.visitUint16 = compareInt;\nTypeComparator.prototype.visitUint32 = compareInt;\nTypeComparator.prototype.visitUint64 = compareInt;\nTypeComparator.prototype.visitFloat = compareFloat;\nTypeComparator.prototype.visitFloat16 = compareFloat;\nTypeComparator.prototype.visitFloat32 = compareFloat;\nTypeComparator.prototype.visitFloat64 = compareFloat;\nTypeComparator.prototype.visitUtf8 = compareAny;\nTypeComparator.prototype.visitBinary = compareAny;\nTypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;\nTypeComparator.prototype.visitDate = compareDate;\nTypeComparator.prototype.visitDateDay = compareDate;\nTypeComparator.prototype.visitDateMillisecond = compareDate;\nTypeComparator.prototype.visitTimestamp = compareTimestamp;\nTypeComparator.prototype.visitTimestampSecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;\nTypeComparator.prototype.visitTime = compareTime;\nTypeComparator.prototype.visitTimeSecond = compareTime;\nTypeComparator.prototype.visitTimeMillisecond = compareTime;\nTypeComparator.prototype.visitTimeMicrosecond = compareTime;\nTypeComparator.prototype.visitTimeNanosecond = compareTime;\nTypeComparator.prototype.visitDecimal = compareAny;\nTypeComparator.prototype.visitList = compareList;\nTypeComparator.prototype.visitStruct = compareStruct;\nTypeComparator.prototype.visitUnion = compareUnion;\nTypeComparator.prototype.visitDenseUnion = compareUnion;\nTypeComparator.prototype.visitSparseUnion = compareUnion;\nTypeComparator.prototype.visitDictionary = compareDictionary;\nTypeComparator.prototype.visitInterval = compareInterval;\nTypeComparator.prototype.visitIntervalDayTime = compareInterval;\nTypeComparator.prototype.visitIntervalYearMonth = compareInterval;\nTypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;\nTypeComparator.prototype.visitMap = compareMap;\nvar instance7 = new TypeComparator();\nfunction compareSchemas(schema, other) {\n  return instance7.compareSchemas(schema, other);\n}\nfunction compareFields(field2, other) {\n  return instance7.compareFields(field2, other);\n}\nfunction compareTypes(type2, other) {\n  return instance7.visit(type2, other);\n}\n\n// node_modules/apache-arrow/factories.mjs\nfunction makeBuilder(options) {\n  const type2 = options.type;\n  const builder = new (instance6.getVisitFn(type2)())(options);\n  if (type2.children && type2.children.length > 0) {\n    const children2 = options[\"children\"] || [];\n    const defaultOptions = { \"nullValues\": options[\"nullValues\"] };\n    const getChildOptions = Array.isArray(children2) ? (_, i) => children2[i] || defaultOptions : ({ name }) => children2[name] || defaultOptions;\n    for (const [index3, field2] of type2.children.entries()) {\n      const { type: type3 } = field2;\n      const opts = getChildOptions(field2, index3);\n      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type3 })));\n    }\n  }\n  return builder;\n}\n\n// node_modules/apache-arrow/util/recordbatch.mjs\nfunction distributeVectorsIntoRecordBatches(schema, vecs) {\n  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v2) => v2.data.concat()));\n}\nfunction uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {\n  const fields = [...schema.fields];\n  const batches = [];\n  const memo = { numBatches: cols.reduce((n, c6) => Math.max(n, c6.length), 0) };\n  let numBatches = 0, batchLength = 0;\n  let i = -1;\n  const numColumns = cols.length;\n  let child, children2 = [];\n  while (memo.numBatches-- > 0) {\n    for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {\n      children2[i] = child = cols[i].shift();\n      batchLength = Math.min(batchLength, child ? child.length : batchLength);\n    }\n    if (Number.isFinite(batchLength)) {\n      children2 = distributeChildren(fields, batchLength, children2, cols, memo);\n      if (batchLength > 0) {\n        batches[numBatches++] = makeData({\n          type: new Struct(fields),\n          length: batchLength,\n          nullCount: 0,\n          children: children2.slice()\n        });\n      }\n    }\n  }\n  return [\n    schema = schema.assign(fields),\n    batches.map((data) => new RecordBatch(schema, data))\n  ];\n}\nfunction distributeChildren(fields, batchLength, children2, columns, memo) {\n  var _a5;\n  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;\n  for (let i = -1, n = columns.length; ++i < n; ) {\n    const child = children2[i];\n    const length4 = child === null || child === void 0 ? void 0 : child.length;\n    if (length4 >= batchLength) {\n      if (length4 === batchLength) {\n        children2[i] = child;\n      } else {\n        children2[i] = child.slice(0, batchLength);\n        memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));\n      }\n    } else {\n      const field2 = fields[i];\n      fields[i] = field2.clone({ nullable: true });\n      children2[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({\n        type: field2.type,\n        length: batchLength,\n        nullCount: batchLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return children2;\n}\n\n// node_modules/apache-arrow/table.mjs\nvar _a3;\nvar Table = class {\n  constructor(...args) {\n    var _b2, _c2;\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema2([]);\n      this._offsets = [0];\n      return this;\n    }\n    let schema;\n    let offsets;\n    if (args[0] instanceof Schema2) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    const unwrap = (x4) => {\n      if (x4) {\n        if (x4 instanceof RecordBatch) {\n          return [x4];\n        } else if (x4 instanceof Table) {\n          return x4.batches;\n        } else if (x4 instanceof Data) {\n          if (x4.type instanceof Struct) {\n            return [new RecordBatch(new Schema2(x4.type.children), x4)];\n          }\n        } else if (Array.isArray(x4)) {\n          return x4.flatMap((v2) => unwrap(v2));\n        } else if (typeof x4[Symbol.iterator] === \"function\") {\n          return [...x4].flatMap((v2) => unwrap(v2));\n        } else if (typeof x4 === \"object\") {\n          const keys = Object.keys(x4);\n          const vecs = keys.map((k2) => new Vector2([x4[k2]]));\n          const schema2 = new Schema2(keys.map((k2, i) => new Field2(String(k2), vecs[i].type)));\n          const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);\n          return batches2.length === 0 ? [new RecordBatch(x4)] : batches2;\n        }\n      }\n      return [];\n    };\n    const batches = args.flatMap((v2) => unwrap(v2));\n    schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);\n    if (!(schema instanceof Schema2)) {\n      throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n    }\n    for (const batch of batches) {\n      if (!(batch instanceof RecordBatch)) {\n        throw new TypeError(\"Table constructor expects a [Schema, RecordBatch[]] pair.\");\n      }\n      if (!compareSchemas(schema, batch.schema)) {\n        throw new TypeError(\"Table and inner RecordBatch schemas must be equivalent.\");\n      }\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n   */\n  get data() {\n    return this.batches.map(({ data }) => data);\n  }\n  /**\n   * The number of columns in this Table.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this Table.\n   */\n  get numRows() {\n    return this.data.reduce((numRows, data) => numRows + data.length, 0);\n  }\n  /**\n   * The number of null rows in this Table.\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   *\n   * @param index The index at which to read the validity bitmap.\n   */\n  // @ts-ignore\n  isValid(index3) {\n    return false;\n  }\n  /**\n   * Get an element value by position.\n   *\n   * @param index The index of the element to read.\n   */\n  // @ts-ignore\n  get(index3) {\n    return null;\n  }\n  /**\n   * Set an element value by position.\n   *\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  // @ts-ignore\n  set(index3, value) {\n    return;\n  }\n  /**\n   * Retrieve the index of the first occurrence of a value in an Vector.\n   *\n   * @param element The value to locate in the Vector.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  // @ts-ignore\n  indexOf(element, offset2) {\n    return -1;\n  }\n  /**\n   * Get the size in bytes of an element by index.\n   * @param index The index at which to get the byteLength.\n   */\n  // @ts-ignore\n  getByteLength(index3) {\n    return 0;\n  }\n  /**\n   * Iterator for rows in this Table.\n   */\n  [Symbol.iterator]() {\n    if (this.batches.length > 0) {\n      return instance4.visit(new Vector2(this.data));\n    }\n    return new Array(0)[Symbol.iterator]();\n  }\n  /**\n   * Return a JavaScript Array of the Table rows.\n   *\n   * @returns An Array of Table rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Returns a string representation of the Table rows.\n   *\n   * @returns A string representation of the Table rows.\n   */\n  toString() {\n    return `[\n  ${this.toArray().join(\",\\n  \")}\n]`;\n  }\n  /**\n   * Combines two or more Tables of the same schema.\n   *\n   * @param others Additional Tables to add to the end of this Tables.\n   */\n  concat(...others) {\n    const schema = this.schema;\n    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));\n    return new Table(schema, data.map((data2) => new RecordBatch(schema, data2)));\n  }\n  /**\n   * Return a zero-copy sub-section of this Table.\n   *\n   * @param begin The beginning of the specified portion of the Table.\n   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const schema = this.schema;\n    [begin, end] = clampRange({ length: this.numRows }, begin, end);\n    const data = sliceChunks(this.data, this._offsets, begin, end);\n    return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   *\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   *\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      const data = this.data.map((data2) => data2.children[index3]);\n      if (data.length === 0) {\n        const { type: type2 } = this.schema.fields[index3];\n        const empty4 = makeData({ type: type2, length: 0, nullCount: 0 });\n        data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));\n      }\n      return new Vector2(data);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   *\n   * @param name The name of the child to overwrite.\n   * @returns A new Table with the supplied child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let batches = [...this.batches];\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      const children2 = this.schema.fields.map((_, i) => this.getChildAt(i));\n      [fields[index3], children2[index3]] = [field2, child];\n      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);\n    }\n    return new Table(schema, batches);\n  }\n  /**\n   * Construct a new Table containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new Table of columns matching the specified names.\n   */\n  select(columnNames) {\n    const nameToIndex = this.schema.fields.reduce((m3, f, i) => m3.set(f.name, i), /* @__PURE__ */ new Map());\n    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));\n  }\n  /**\n   * Construct a new Table containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new Table of columns at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n    return new Table(schema, data);\n  }\n  assign(other) {\n    const fields = this.schema.fields;\n    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n      const [indices2, oldToNew2] = memo;\n      const i = fields.findIndex((f) => f.name === f2.name);\n      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);\n      return memo;\n    }, [[], []]);\n    const schema = this.schema.assign(other.schema);\n    const columns = [\n      ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),\n      ...indices.map((i) => other.getChildAt(i))\n    ].filter(Boolean);\n    return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n  }\n};\n_a3 = Symbol.toStringTag;\nTable[_a3] = ((proto) => {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto[\"isValid\"] = wrapChunkedCall1(isChunkedValid);\n  proto[\"get\"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));\n  proto[\"set\"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));\n  proto[\"indexOf\"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));\n  proto[\"getByteLength\"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));\n  return \"Table\";\n})(Table.prototype);\n\n// node_modules/apache-arrow/recordbatch.mjs\nvar _a4;\nvar RecordBatch = class {\n  constructor(...args) {\n    switch (args.length) {\n      case 2: {\n        [this.schema] = args;\n        if (!(this.schema instanceof Schema2)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [\n          ,\n          this.data = makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n          })\n        ] = args;\n        if (!(this.data instanceof Data)) {\n          throw new TypeError(\"RecordBatch constructor expects a [Schema, Data] pair.\");\n        }\n        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n        break;\n      }\n      case 1: {\n        const [obj] = args;\n        const { fields, children: children2, length: length4 } = Object.keys(obj).reduce((memo, name, i) => {\n          memo.children[i] = obj[name];\n          memo.length = Math.max(memo.length, obj[name].length);\n          memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });\n          return memo;\n        }, {\n          length: 0,\n          fields: new Array(),\n          children: new Array()\n        });\n        const schema = new Schema2(fields);\n        const data = makeData({ type: new Struct(fields), length: length4, children: children2, nullCount: 0 });\n        [this.schema, this.data] = ensureSameLengthData(schema, data.children, length4);\n        break;\n      }\n      default:\n        throw new TypeError(\"RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.\");\n    }\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n  }\n  /**\n   * The number of columns in this RecordBatch.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this RecordBatch.\n   */\n  get numRows() {\n    return this.data.length;\n  }\n  /**\n   * The number of null rows in this RecordBatch.\n   */\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  isValid(index3) {\n    return this.data.getValid(index3);\n  }\n  /**\n   * Get a row by position.\n   * @param index The index of the element to read.\n   */\n  get(index3) {\n    return instance2.visit(this.data, index3);\n  }\n  /**\n   * Set a row by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  set(index3, value) {\n    return instance.visit(this.data, index3, value);\n  }\n  /**\n   * Retrieve the index of the first occurrence of a row in an RecordBatch.\n   * @param element The row to locate in the RecordBatch.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  indexOf(element, offset2) {\n    return instance3.visit(this.data, element, offset2);\n  }\n  /**\n   * Get the size (in bytes) of a row by index.\n   * @param index The row index for which to compute the byteLength.\n   */\n  getByteLength(index3) {\n    return instance5.visit(this.data, index3);\n  }\n  /**\n   * Iterator for rows in this RecordBatch.\n   */\n  [Symbol.iterator]() {\n    return instance4.visit(new Vector2([this.data]));\n  }\n  /**\n   * Return a JavaScript Array of the RecordBatch rows.\n   * @returns An Array of RecordBatch rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Combines two or more RecordBatch of the same schema.\n   * @param others Additional RecordBatch to add to the end of this RecordBatch.\n   */\n  concat(...others) {\n    return new Table(this.schema, [this, ...others]);\n  }\n  /**\n   * Return a zero-copy sub-section of this RecordBatch.\n   * @param start The beginning of the specified portion of the RecordBatch.\n   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const [slice7] = new Vector2([this.data]).slice(begin, end).data;\n    return new RecordBatch(this.schema, slice7);\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b2;\n    return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index3) {\n    if (index3 > -1 && index3 < this.schema.fields.length) {\n      return new Vector2([this.data.children[index3]]);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   * @param name The name of the child to overwrite.\n   * @returns A new RecordBatch with the new child for the specified name.\n   */\n  setChild(name, child) {\n    var _b2;\n    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);\n  }\n  setChildAt(index3, child) {\n    let schema = this.schema;\n    let data = this.data;\n    if (index3 > -1 && index3 < this.numCols) {\n      if (!child) {\n        child = new Vector2([makeData({ type: new Null(), length: this.numRows })]);\n      }\n      const fields = schema.fields.slice();\n      const children2 = data.children.slice();\n      const field2 = fields[index3].clone({ type: child.type });\n      [fields[index3], children2[index3]] = [field2, child.data[0]];\n      schema = new Schema2(fields, new Map(this.schema.metadata));\n      data = makeData({ type: new Struct(fields), children: children2 });\n    }\n    return new RecordBatch(schema, data);\n  }\n  /**\n   * Construct a new RecordBatch containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new RecordBatch of columns matching the specified names.\n   */\n  select(columnNames) {\n    const schema = this.schema.select(columnNames);\n    const type2 = new Struct(schema.fields);\n    const children2 = [];\n    for (const name of columnNames) {\n      const index3 = this.schema.fields.findIndex((f) => f.name === name);\n      if (~index3) {\n        children2[index3] = this.data.children[index3];\n      }\n    }\n    return new RecordBatch(schema, makeData({ type: type2, length: this.numRows, children: children2 }));\n  }\n  /**\n   * Construct a new RecordBatch containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new RecordBatch of columns matching at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n    const subset2 = makeData({ type: new Struct(schema.fields), length: this.numRows, children: children2 });\n    return new RecordBatch(schema, subset2);\n  }\n};\n_a4 = Symbol.toStringTag;\nRecordBatch[_a4] = ((proto) => {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return \"RecordBatch\";\n})(RecordBatch.prototype);\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max5, col) => Math.max(max5, col.length), 0)) {\n  var _b2;\n  const fields = [...schema.fields];\n  const children2 = [...chunks];\n  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  for (const [idx, field2] of schema.fields.entries()) {\n    const chunk = chunks[idx];\n    if (!chunk || chunk.length !== maxLength) {\n      fields[idx] = field2.clone({ nullable: true });\n      children2[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({\n        type: field2.type,\n        length: maxLength,\n        nullCount: maxLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return [\n    schema.assign(fields),\n    makeData({ type: new Struct(fields), length: maxLength, children: children2 })\n  ];\n}\nfunction collectDictionaries(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {\n  for (let i = -1, n = fields.length; ++i < n; ) {\n    const field2 = fields[i];\n    const type2 = field2.type;\n    const data = children2[i];\n    if (DataType.isDictionary(type2)) {\n      if (!dictionaries.has(type2.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type2.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type2.id) !== data.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type2.children && type2.children.length > 0) {\n      collectDictionaries(type2.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\nvar _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {\n  constructor(schema) {\n    const children2 = schema.fields.map((f) => makeData({ type: f.type }));\n    const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children: children2 });\n    super(schema, data);\n  }\n};\n\n// node_modules/apache-arrow/fb/body-compression-method.mjs\nvar BodyCompressionMethod;\n(function(BodyCompressionMethod2) {\n  BodyCompressionMethod2[BodyCompressionMethod2[\"BUFFER\"] = 0] = \"BUFFER\";\n})(BodyCompressionMethod || (BodyCompressionMethod = {}));\n\n// node_modules/apache-arrow/fb/compression-type.mjs\nvar CompressionType;\n(function(CompressionType2) {\n  CompressionType2[CompressionType2[\"LZ4_FRAME\"] = 0] = \"LZ4_FRAME\";\n  CompressionType2[CompressionType2[\"ZSTD\"] = 1] = \"ZSTD\";\n})(CompressionType || (CompressionType = {}));\n\n// node_modules/apache-arrow/fb/body-compression.mjs\nvar BodyCompression = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsBodyCompression(bb2, obj) {\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsBodyCompression(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * Compressor library.\n   * For LZ4_FRAME, each compressed buffer must consist of a single frame.\n   */\n  codec() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;\n  }\n  /**\n   * Indicates the way the record batch body was compressed\n   */\n  method() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;\n  }\n  static startBodyCompression(builder) {\n    builder.startObject(2);\n  }\n  static addCodec(builder, codec) {\n    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);\n  }\n  static addMethod(builder, method) {\n    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);\n  }\n  static endBodyCompression(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static createBodyCompression(builder, codec, method) {\n    BodyCompression.startBodyCompression(builder);\n    BodyCompression.addCodec(builder, codec);\n    BodyCompression.addMethod(builder, method);\n    return BodyCompression.endBodyCompression(builder);\n  }\n};\n\n// node_modules/apache-arrow/fb/buffer.mjs\nvar Buffer2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The relative offset into the shared memory page where the bytes for this\n   * buffer starts\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The absolute length (in bytes) of the memory buffer. The memory is found\n   * from offset (inclusive) to offset + length (non-inclusive). When building\n   * messages using the encapsulated IPC message, padding bytes may be written\n   * after a buffer, but such padding bytes do not need to be accounted for in\n   * the size here.\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createBuffer(builder, offset2, length4) {\n    builder.prep(8, 16);\n    builder.writeInt64(length4);\n    builder.writeInt64(offset2);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/field-node.mjs\nvar FieldNode = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  /**\n   * The number of value slots in the Arrow array at this level of a nested\n   * tree\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The number of observed nulls. Fields with null_count == 0 may choose not\n   * to write their physical validity bitmap out as a materialized buffer,\n   * instead setting the length of the bitmap buffer to 0.\n   */\n  nullCount() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createFieldNode(builder, length4, null_count) {\n    builder.prep(8, 16);\n    builder.writeInt64(null_count);\n    builder.writeInt64(length4);\n    return builder.offset();\n  }\n};\n\n// node_modules/apache-arrow/fb/record-batch.mjs\nvar RecordBatch2 = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsRecordBatch(bb2, obj) {\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsRecordBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new RecordBatch2()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  /**\n   * number of records / rows. The arrays in the batch should all have this\n   * length\n   */\n  length() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  /**\n   * Nodes correspond to the pre-ordered flattened logical schema\n   */\n  nodes(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  nodesLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Buffers correspond to the pre-ordered flattened buffer tree\n   *\n   * The number of buffers appended to this list depends on the schema. For\n   * example, most primitive arrays will have 2 buffers, 1 for the validity\n   * bitmap and 1 for the values. For struct arrays, there will only be a\n   * single buffer for the validity (nulls) bitmap\n   */\n  buffers(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset2) + index3 * 16, this.bb) : null;\n  }\n  buffersLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  /**\n   * Optional compression of the message body\n   */\n  compression(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  static startRecordBatch(builder) {\n    builder.startObject(4);\n  }\n  static addLength(builder, length4) {\n    builder.addFieldInt64(0, length4, builder.createLong(0, 0));\n  }\n  static addNodes(builder, nodesOffset) {\n    builder.addFieldOffset(1, nodesOffset, 0);\n  }\n  static startNodesVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addBuffers(builder, buffersOffset) {\n    builder.addFieldOffset(2, buffersOffset, 0);\n  }\n  static startBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addCompression(builder, compressionOffset) {\n    builder.addFieldOffset(3, compressionOffset, 0);\n  }\n  static endRecordBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/dictionary-batch.mjs\nvar DictionaryBatch = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsDictionaryBatch(bb2, obj) {\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  id() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  data(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;\n  }\n  /**\n   * If isDelta is true the values in the dictionary are to be appended to a\n   * dictionary with the indicated id. If isDelta is false this dictionary\n   * should replace the existing dictionary.\n   */\n  isDelta() {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;\n  }\n  static startDictionaryBatch(builder) {\n    builder.startObject(3);\n  }\n  static addId(builder, id2) {\n    builder.addFieldInt64(0, id2, builder.createLong(0, 0));\n  }\n  static addData(builder, dataOffset) {\n    builder.addFieldOffset(1, dataOffset, 0);\n  }\n  static addIsDelta(builder, isDelta) {\n    builder.addFieldInt8(2, +isDelta, 0);\n  }\n  static endDictionaryBatch(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n};\n\n// node_modules/apache-arrow/fb/message-header.mjs\nvar MessageHeader2;\n(function(MessageHeader3) {\n  MessageHeader3[MessageHeader3[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader3[MessageHeader3[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader3[MessageHeader3[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader3[MessageHeader3[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader3[MessageHeader3[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader3[MessageHeader3[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader2 || (MessageHeader2 = {}));\n\n// node_modules/apache-arrow/fb/message.mjs\nvar Message = class {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb2) {\n    this.bb_pos = i;\n    this.bb = bb2;\n    return this;\n  }\n  static getRootAsMessage(bb2, obj) {\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  static getSizePrefixedRootAsMessage(bb2, obj) {\n    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);\n    return (obj || new Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);\n  }\n  version() {\n    const offset2 = this.bb.__offset(this.bb_pos, 4);\n    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;\n  }\n  headerType() {\n    const offset2 = this.bb.__offset(this.bb_pos, 6);\n    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader2.NONE;\n  }\n  // @ts-ignore\n  header(obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 8);\n    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;\n  }\n  bodyLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 10);\n    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : this.bb.createLong(0, 0);\n  }\n  customMetadata(index3, obj) {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index3 * 4), this.bb) : null;\n  }\n  customMetadataLength() {\n    const offset2 = this.bb.__offset(this.bb_pos, 12);\n    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;\n  }\n  static startMessage(builder) {\n    builder.startObject(5);\n  }\n  static addVersion(builder, version) {\n    builder.addFieldInt16(0, version, MetadataVersion2.V1);\n  }\n  static addHeaderType(builder, headerType) {\n    builder.addFieldInt8(1, headerType, MessageHeader2.NONE);\n  }\n  static addHeader(builder, headerOffset) {\n    builder.addFieldOffset(2, headerOffset, 0);\n  }\n  static addBodyLength(builder, bodyLength) {\n    builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));\n  }\n  static addCustomMetadata(builder, customMetadataOffset) {\n    builder.addFieldOffset(4, customMetadataOffset, 0);\n  }\n  static createCustomMetadataVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startCustomMetadataVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endMessage(builder) {\n    const offset2 = builder.endObject();\n    return offset2;\n  }\n  static finishMessageBuffer(builder, offset2) {\n    builder.finish(offset2);\n  }\n  static finishSizePrefixedMessageBuffer(builder, offset2) {\n    builder.finish(offset2, void 0, true);\n  }\n  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {\n    Message.startMessage(builder);\n    Message.addVersion(builder, version);\n    Message.addHeaderType(builder, headerType);\n    Message.addHeader(builder, headerOffset);\n    Message.addBodyLength(builder, bodyLength);\n    Message.addCustomMetadata(builder, customMetadataOffset);\n    return Message.endMessage(builder);\n  }\n};\n\n// node_modules/apache-arrow/visitor/typeassembler.mjs\nvar Long3 = Long;\nvar TypeAssembler = class extends Visitor {\n  visit(node, builder) {\n    return node == null || builder == null ? void 0 : super.visit(node, builder);\n  }\n  visitNull(_node, b) {\n    Null2.startNull(b);\n    return Null2.endNull(b);\n  }\n  visitInt(node, b) {\n    Int.startInt(b);\n    Int.addBitWidth(b, node.bitWidth);\n    Int.addIsSigned(b, node.isSigned);\n    return Int.endInt(b);\n  }\n  visitFloat(node, b) {\n    FloatingPoint.startFloatingPoint(b);\n    FloatingPoint.addPrecision(b, node.precision);\n    return FloatingPoint.endFloatingPoint(b);\n  }\n  visitBinary(_node, b) {\n    Binary2.startBinary(b);\n    return Binary2.endBinary(b);\n  }\n  visitBool(_node, b) {\n    Bool2.startBool(b);\n    return Bool2.endBool(b);\n  }\n  visitUtf8(_node, b) {\n    Utf82.startUtf8(b);\n    return Utf82.endUtf8(b);\n  }\n  visitDecimal(node, b) {\n    Decimal2.startDecimal(b);\n    Decimal2.addScale(b, node.scale);\n    Decimal2.addPrecision(b, node.precision);\n    Decimal2.addBitWidth(b, node.bitWidth);\n    return Decimal2.endDecimal(b);\n  }\n  visitDate(node, b) {\n    Date2.startDate(b);\n    Date2.addUnit(b, node.unit);\n    return Date2.endDate(b);\n  }\n  visitTime(node, b) {\n    Time.startTime(b);\n    Time.addUnit(b, node.unit);\n    Time.addBitWidth(b, node.bitWidth);\n    return Time.endTime(b);\n  }\n  visitTimestamp(node, b) {\n    const timezone = node.timezone && b.createString(node.timezone) || void 0;\n    Timestamp.startTimestamp(b);\n    Timestamp.addUnit(b, node.unit);\n    if (timezone !== void 0) {\n      Timestamp.addTimezone(b, timezone);\n    }\n    return Timestamp.endTimestamp(b);\n  }\n  visitInterval(node, b) {\n    Interval.startInterval(b);\n    Interval.addUnit(b, node.unit);\n    return Interval.endInterval(b);\n  }\n  visitList(_node, b) {\n    List2.startList(b);\n    return List2.endList(b);\n  }\n  visitStruct(_node, b) {\n    Struct_.startStruct_(b);\n    return Struct_.endStruct_(b);\n  }\n  visitUnion(node, b) {\n    Union.startTypeIdsVector(b, node.typeIds.length);\n    const typeIds = Union.createTypeIdsVector(b, node.typeIds);\n    Union.startUnion(b);\n    Union.addMode(b, node.mode);\n    Union.addTypeIds(b, typeIds);\n    return Union.endUnion(b);\n  }\n  visitDictionary(node, b) {\n    const indexType = this.visit(node.indices, b);\n    DictionaryEncoding.startDictionaryEncoding(b);\n    DictionaryEncoding.addId(b, new Long3(node.id, 0));\n    DictionaryEncoding.addIsOrdered(b, node.isOrdered);\n    if (indexType !== void 0) {\n      DictionaryEncoding.addIndexType(b, indexType);\n    }\n    return DictionaryEncoding.endDictionaryEncoding(b);\n  }\n  visitFixedSizeBinary(node, b) {\n    FixedSizeBinary2.startFixedSizeBinary(b);\n    FixedSizeBinary2.addByteWidth(b, node.byteWidth);\n    return FixedSizeBinary2.endFixedSizeBinary(b);\n  }\n  visitFixedSizeList(node, b) {\n    FixedSizeList2.startFixedSizeList(b);\n    FixedSizeList2.addListSize(b, node.listSize);\n    return FixedSizeList2.endFixedSizeList(b);\n  }\n  visitMap(node, b) {\n    Map2.startMap(b);\n    Map2.addKeysSorted(b, node.keysSorted);\n    return Map2.endMap(b);\n  }\n};\nvar instance8 = new TypeAssembler();\n\n// node_modules/apache-arrow/ipc/metadata/json.mjs\nfunction schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema[\"customMetadata\"]), dictionaries);\n}\nfunction recordBatchFromJSON(b) {\n  return new RecordBatch3(b[\"count\"], fieldNodesFromJSON(b[\"columns\"]), buffersFromJSON(b[\"columns\"]));\n}\nfunction dictionaryBatchFromJSON(b) {\n  return new DictionaryBatch2(recordBatchFromJSON(b[\"data\"]), b[\"id\"], b[\"isDelta\"]);\n}\nfunction schemaFieldsFromJSON(_schema, dictionaries) {\n  return (_schema[\"fields\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldChildrenFromJSON(_field, dictionaries) {\n  return (_field[\"children\"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));\n}\nfunction fieldNodesFromJSON(xs) {\n  return (xs || []).reduce((fieldNodes, column2) => [\n    ...fieldNodes,\n    new FieldNode2(column2[\"count\"], nullCountFromJSON(column2[\"VALIDITY\"])),\n    ...fieldNodesFromJSON(column2[\"children\"])\n  ], []);\n}\nfunction buffersFromJSON(xs, buffers = []) {\n  for (let i = -1, n = (xs || []).length; ++i < n; ) {\n    const column2 = xs[i];\n    column2[\"VALIDITY\"] && buffers.push(new BufferRegion(buffers.length, column2[\"VALIDITY\"].length));\n    column2[\"TYPE\"] && buffers.push(new BufferRegion(buffers.length, column2[\"TYPE\"].length));\n    column2[\"OFFSET\"] && buffers.push(new BufferRegion(buffers.length, column2[\"OFFSET\"].length));\n    column2[\"DATA\"] && buffers.push(new BufferRegion(buffers.length, column2[\"DATA\"].length));\n    buffers = buffersFromJSON(column2[\"children\"], buffers);\n  }\n  return buffers;\n}\nfunction nullCountFromJSON(validity) {\n  return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);\n}\nfunction fieldFromJSON(_field, dictionaries) {\n  let id2;\n  let keys;\n  let field2;\n  let dictMeta;\n  let type2;\n  let dictType;\n  if (!dictionaries || !(dictMeta = _field[\"dictionary\"])) {\n    type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n    field2 = new Field2(_field[\"name\"], type2, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else if (!dictionaries.has(id2 = dictMeta[\"id\"])) {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictionaries.set(id2, type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  } else {\n    keys = (keys = dictMeta[\"indexType\"]) ? indexTypeFromJSON(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta[\"isOrdered\"]);\n    field2 = new Field2(_field[\"name\"], dictType, _field[\"nullable\"], customMetadataFromJSON(_field[\"customMetadata\"]));\n  }\n  return field2 || null;\n}\nfunction customMetadataFromJSON(_metadata) {\n  return new Map(Object.entries(_metadata || {}));\n}\nfunction indexTypeFromJSON(_type) {\n  return new Int_(_type[\"isSigned\"], _type[\"bitWidth\"]);\n}\nfunction typeFromJSON(f, children2) {\n  const typeId = f[\"type\"][\"name\"];\n  switch (typeId) {\n    case \"NONE\":\n      return new Null();\n    case \"null\":\n      return new Null();\n    case \"binary\":\n      return new Binary();\n    case \"utf8\":\n      return new Utf8();\n    case \"bool\":\n      return new Bool();\n    case \"list\":\n      return new List((children2 || [])[0]);\n    case \"struct\":\n      return new Struct(children2 || []);\n    case \"struct_\":\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case \"int\": {\n      const t = f[\"type\"];\n      return new Int_(t[\"isSigned\"], t[\"bitWidth\"]);\n    }\n    case \"floatingpoint\": {\n      const t = f[\"type\"];\n      return new Float(Precision[t[\"precision\"]]);\n    }\n    case \"decimal\": {\n      const t = f[\"type\"];\n      return new Decimal(t[\"scale\"], t[\"precision\"], t[\"bitWidth\"]);\n    }\n    case \"date\": {\n      const t = f[\"type\"];\n      return new Date_(DateUnit[t[\"unit\"]]);\n    }\n    case \"time\": {\n      const t = f[\"type\"];\n      return new Time_(TimeUnit[t[\"unit\"]], t[\"bitWidth\"]);\n    }\n    case \"timestamp\": {\n      const t = f[\"type\"];\n      return new Timestamp_(TimeUnit[t[\"unit\"]], t[\"timezone\"]);\n    }\n    case \"interval\": {\n      const t = f[\"type\"];\n      return new Interval_(IntervalUnit[t[\"unit\"]]);\n    }\n    case \"union\": {\n      const t = f[\"type\"];\n      return new Union_(UnionMode[t[\"mode\"]], t[\"typeIds\"] || [], children2 || []);\n    }\n    case \"fixedsizebinary\": {\n      const t = f[\"type\"];\n      return new FixedSizeBinary(t[\"byteWidth\"]);\n    }\n    case \"fixedsizelist\": {\n      const t = f[\"type\"];\n      return new FixedSizeList(t[\"listSize\"], (children2 || [])[0]);\n    }\n    case \"map\": {\n      const t = f[\"type\"];\n      return new Map_((children2 || [])[0], t[\"keysSorted\"]);\n    }\n  }\n  throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n\n// node_modules/apache-arrow/ipc/metadata/message.mjs\nvar Long4 = Long;\nvar Builder4 = Builder2;\nvar ByteBuffer3 = ByteBuffer;\nvar Message2 = class {\n  constructor(bodyLength, version, headerType, header) {\n    this._version = version;\n    this._headerType = headerType;\n    this.body = new Uint8Array(0);\n    header && (this._createHeader = () => header);\n    this._bodyLength = typeof bodyLength === \"number\" ? bodyLength : bodyLength.low;\n  }\n  /** @nocollapse */\n  static fromJSON(msg, headerType) {\n    const message = new Message2(0, MetadataVersion.V4, headerType);\n    message._createHeader = messageHeaderFromJSON(msg, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static decode(buf) {\n    buf = new ByteBuffer3(toUint8Array(buf));\n    const _message = Message.getRootAsMessage(buf);\n    const bodyLength = _message.bodyLength();\n    const version = _message.version();\n    const headerType = _message.headerType();\n    const message = new Message2(bodyLength, version, headerType);\n    message._createHeader = decodeMessageHeader(_message, headerType);\n    return message;\n  }\n  /** @nocollapse */\n  static encode(message) {\n    const b = new Builder4();\n    let headerOffset = -1;\n    if (message.isSchema()) {\n      headerOffset = Schema2.encode(b, message.header());\n    } else if (message.isRecordBatch()) {\n      headerOffset = RecordBatch3.encode(b, message.header());\n    } else if (message.isDictionaryBatch()) {\n      headerOffset = DictionaryBatch2.encode(b, message.header());\n    }\n    Message.startMessage(b);\n    Message.addVersion(b, MetadataVersion.V4);\n    Message.addHeader(b, headerOffset);\n    Message.addHeaderType(b, message.headerType);\n    Message.addBodyLength(b, new Long4(message.bodyLength, 0));\n    Message.finishMessageBuffer(b, Message.endMessage(b));\n    return b.asUint8Array();\n  }\n  /** @nocollapse */\n  static from(header, bodyLength = 0) {\n    if (header instanceof Schema2) {\n      return new Message2(0, MetadataVersion.V4, MessageHeader.Schema, header);\n    }\n    if (header instanceof RecordBatch3) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);\n    }\n    if (header instanceof DictionaryBatch2) {\n      return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);\n    }\n    throw new Error(`Unrecognized Message header: ${header}`);\n  }\n  get type() {\n    return this.headerType;\n  }\n  get version() {\n    return this._version;\n  }\n  get headerType() {\n    return this._headerType;\n  }\n  get bodyLength() {\n    return this._bodyLength;\n  }\n  header() {\n    return this._createHeader();\n  }\n  isSchema() {\n    return this.headerType === MessageHeader.Schema;\n  }\n  isRecordBatch() {\n    return this.headerType === MessageHeader.RecordBatch;\n  }\n  isDictionaryBatch() {\n    return this.headerType === MessageHeader.DictionaryBatch;\n  }\n};\nvar RecordBatch3 = class {\n  constructor(length4, nodes, buffers) {\n    this._nodes = nodes;\n    this._buffers = buffers;\n    this._length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get length() {\n    return this._length;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n};\nvar DictionaryBatch2 = class {\n  constructor(data, id2, isDelta = false) {\n    this._data = data;\n    this._isDelta = isDelta;\n    this._id = typeof id2 === \"number\" ? id2 : id2.low;\n  }\n  get id() {\n    return this._id;\n  }\n  get data() {\n    return this._data;\n  }\n  get isDelta() {\n    return this._isDelta;\n  }\n  get length() {\n    return this.data.length;\n  }\n  get nodes() {\n    return this.data.nodes;\n  }\n  get buffers() {\n    return this.data.buffers;\n  }\n};\nvar BufferRegion = class {\n  constructor(offset2, length4) {\n    this.offset = typeof offset2 === \"number\" ? offset2 : offset2.low;\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n  }\n};\nvar FieldNode2 = class {\n  constructor(length4, nullCount) {\n    this.length = typeof length4 === \"number\" ? length4 : length4.low;\n    this.nullCount = typeof nullCount === \"number\" ? nullCount : nullCount.low;\n  }\n};\nfunction messageHeaderFromJSON(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.fromJSON(message);\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.fromJSON(message);\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.fromJSON(message);\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nfunction decodeMessageHeader(message, type2) {\n  return () => {\n    switch (type2) {\n      case MessageHeader.Schema:\n        return Schema2.decode(message.header(new Schema()));\n      case MessageHeader.RecordBatch:\n        return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());\n      case MessageHeader.DictionaryBatch:\n        return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());\n    }\n    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);\n  };\n}\nField2[\"encode\"] = encodeField;\nField2[\"decode\"] = decodeField;\nField2[\"fromJSON\"] = fieldFromJSON;\nSchema2[\"encode\"] = encodeSchema;\nSchema2[\"decode\"] = decodeSchema;\nSchema2[\"fromJSON\"] = schemaFromJSON;\nRecordBatch3[\"encode\"] = encodeRecordBatch;\nRecordBatch3[\"decode\"] = decodeRecordBatch;\nRecordBatch3[\"fromJSON\"] = recordBatchFromJSON;\nDictionaryBatch2[\"encode\"] = encodeDictionaryBatch;\nDictionaryBatch2[\"decode\"] = decodeDictionaryBatch;\nDictionaryBatch2[\"fromJSON\"] = dictionaryBatchFromJSON;\nFieldNode2[\"encode\"] = encodeFieldNode;\nFieldNode2[\"decode\"] = decodeFieldNode;\nBufferRegion[\"encode\"] = encodeBufferRegion;\nBufferRegion[\"decode\"] = decodeBufferRegion;\nfunction decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {\n  const fields = decodeSchemaFields(_schema, dictionaries);\n  return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);\n}\nfunction decodeRecordBatch(batch, version = MetadataVersion.V4) {\n  if (batch.compression() !== null) {\n    throw new Error(\"Record batch compression not implemented\");\n  }\n  return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));\n}\nfunction decodeDictionaryBatch(batch, version = MetadataVersion.V4) {\n  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());\n}\nfunction decodeBufferRegion(b) {\n  return new BufferRegion(b.offset(), b.length());\n}\nfunction decodeFieldNode(f) {\n  return new FieldNode2(f.length(), f.nullCount());\n}\nfunction decodeFieldNodes(batch) {\n  const nodes = [];\n  for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {\n    if (f = batch.nodes(i)) {\n      nodes[++j] = FieldNode2.decode(f);\n    }\n  }\n  return nodes;\n}\nfunction decodeBuffers(batch, version) {\n  const bufferRegions = [];\n  for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {\n    if (b = batch.buffers(i)) {\n      if (version < MetadataVersion.V4) {\n        b.bb_pos += 8 * (i + 1);\n      }\n      bufferRegions[++j] = BufferRegion.decode(b);\n    }\n  }\n  return bufferRegions;\n}\nfunction decodeSchemaFields(schema, dictionaries) {\n  const fields = [];\n  for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {\n    if (f = schema.fields(i)) {\n      fields[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return fields;\n}\nfunction decodeFieldChildren(field2, dictionaries) {\n  const children2 = [];\n  for (let f, i = -1, j = -1, n = field2.childrenLength(); ++i < n; ) {\n    if (f = field2.children(i)) {\n      children2[++j] = Field2.decode(f, dictionaries);\n    }\n  }\n  return children2;\n}\nfunction decodeField(f, dictionaries) {\n  let id2;\n  let field2;\n  let type2;\n  let keys;\n  let dictType;\n  let dictMeta;\n  if (!dictionaries || !(dictMeta = f.dictionary())) {\n    type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries));\n    field2 = new Field2(f.name(), type2, f.nullable(), decodeCustomMetadata(f));\n  } else if (!dictionaries.has(id2 = dictMeta.id().low)) {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictionaries.set(id2, type2 = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));\n    dictType = new Dictionary(type2, keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  } else {\n    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());\n    field2 = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n  }\n  return field2 || null;\n}\nfunction decodeCustomMetadata(parent) {\n  const data = /* @__PURE__ */ new Map();\n  if (parent) {\n    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {\n      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {\n        data.set(key, entry.value());\n      }\n    }\n  }\n  return data;\n}\nfunction decodeIndexType(_type) {\n  return new Int_(_type.isSigned(), _type.bitWidth());\n}\nfunction decodeFieldType(f, children2) {\n  const typeId = f.typeType();\n  switch (typeId) {\n    case Type2[\"NONE\"]:\n      return new Null();\n    case Type2[\"Null\"]:\n      return new Null();\n    case Type2[\"Binary\"]:\n      return new Binary();\n    case Type2[\"Utf8\"]:\n      return new Utf8();\n    case Type2[\"Bool\"]:\n      return new Bool();\n    case Type2[\"List\"]:\n      return new List((children2 || [])[0]);\n    case Type2[\"Struct_\"]:\n      return new Struct(children2 || []);\n  }\n  switch (typeId) {\n    case Type2[\"Int\"]: {\n      const t = f.type(new Int());\n      return new Int_(t.isSigned(), t.bitWidth());\n    }\n    case Type2[\"FloatingPoint\"]: {\n      const t = f.type(new FloatingPoint());\n      return new Float(t.precision());\n    }\n    case Type2[\"Decimal\"]: {\n      const t = f.type(new Decimal2());\n      return new Decimal(t.scale(), t.precision(), t.bitWidth());\n    }\n    case Type2[\"Date\"]: {\n      const t = f.type(new Date2());\n      return new Date_(t.unit());\n    }\n    case Type2[\"Time\"]: {\n      const t = f.type(new Time());\n      return new Time_(t.unit(), t.bitWidth());\n    }\n    case Type2[\"Timestamp\"]: {\n      const t = f.type(new Timestamp());\n      return new Timestamp_(t.unit(), t.timezone());\n    }\n    case Type2[\"Interval\"]: {\n      const t = f.type(new Interval());\n      return new Interval_(t.unit());\n    }\n    case Type2[\"Union\"]: {\n      const t = f.type(new Union());\n      return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);\n    }\n    case Type2[\"FixedSizeBinary\"]: {\n      const t = f.type(new FixedSizeBinary2());\n      return new FixedSizeBinary(t.byteWidth());\n    }\n    case Type2[\"FixedSizeList\"]: {\n      const t = f.type(new FixedSizeList2());\n      return new FixedSizeList(t.listSize(), (children2 || [])[0]);\n    }\n    case Type2[\"Map\"]: {\n      const t = f.type(new Map2());\n      return new Map_((children2 || [])[0], t.keysSorted());\n    }\n  }\n  throw new Error(`Unrecognized type: \"${Type2[typeId]}\" (${typeId})`);\n}\nfunction encodeSchema(b, schema) {\n  const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));\n  Schema.startFieldsVector(b, fieldOffsets.length);\n  const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);\n  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  Schema.startSchema(b);\n  Schema.addFields(b, fieldsVectorOffset);\n  Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);\n  if (metadataOffset !== -1) {\n    Schema.addCustomMetadata(b, metadataOffset);\n  }\n  return Schema.endSchema(b);\n}\nfunction encodeField(b, field2) {\n  let nameOffset = -1;\n  let typeOffset = -1;\n  let dictionaryOffset = -1;\n  const type2 = field2.type;\n  let typeId = field2.typeId;\n  if (!DataType.isDictionary(type2)) {\n    typeOffset = instance8.visit(type2, b);\n  } else {\n    typeId = type2.dictionary.typeId;\n    dictionaryOffset = instance8.visit(type2, b);\n    typeOffset = instance8.visit(type2.dictionary, b);\n  }\n  const childOffsets = (type2.children || []).map((f) => Field2.encode(b, f));\n  const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);\n  const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field2.metadata].map(([k2, v2]) => {\n    const key = b.createString(`${k2}`);\n    const val = b.createString(`${v2}`);\n    KeyValue.startKeyValue(b);\n    KeyValue.addKey(b, key);\n    KeyValue.addValue(b, val);\n    return KeyValue.endKeyValue(b);\n  }));\n  if (field2.name) {\n    nameOffset = b.createString(field2.name);\n  }\n  Field.startField(b);\n  Field.addType(b, typeOffset);\n  Field.addTypeType(b, typeId);\n  Field.addChildren(b, childrenVectorOffset);\n  Field.addNullable(b, !!field2.nullable);\n  if (nameOffset !== -1) {\n    Field.addName(b, nameOffset);\n  }\n  if (dictionaryOffset !== -1) {\n    Field.addDictionary(b, dictionaryOffset);\n  }\n  if (metadataOffset !== -1) {\n    Field.addCustomMetadata(b, metadataOffset);\n  }\n  return Field.endField(b);\n}\nfunction encodeRecordBatch(b, recordBatch) {\n  const nodes = recordBatch.nodes || [];\n  const buffers = recordBatch.buffers || [];\n  RecordBatch2.startNodesVector(b, nodes.length);\n  for (const n of nodes.slice().reverse())\n    FieldNode2.encode(b, n);\n  const nodesVectorOffset = b.endVector();\n  RecordBatch2.startBuffersVector(b, buffers.length);\n  for (const b_ of buffers.slice().reverse())\n    BufferRegion.encode(b, b_);\n  const buffersVectorOffset = b.endVector();\n  RecordBatch2.startRecordBatch(b);\n  RecordBatch2.addLength(b, new Long4(recordBatch.length, 0));\n  RecordBatch2.addNodes(b, nodesVectorOffset);\n  RecordBatch2.addBuffers(b, buffersVectorOffset);\n  return RecordBatch2.endRecordBatch(b);\n}\nfunction encodeDictionaryBatch(b, dictionaryBatch) {\n  const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);\n  DictionaryBatch.startDictionaryBatch(b);\n  DictionaryBatch.addId(b, new Long4(dictionaryBatch.id, 0));\n  DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);\n  DictionaryBatch.addData(b, dataOffset);\n  return DictionaryBatch.endDictionaryBatch(b);\n}\nfunction encodeFieldNode(b, node) {\n  return FieldNode.createFieldNode(b, new Long4(node.length, 0), new Long4(node.nullCount, 0));\n}\nfunction encodeBufferRegion(b, node) {\n  return Buffer2.createBuffer(b, new Long4(node.offset, 0), new Long4(node.length, 0));\n}\nvar platformIsLittleEndian = (() => {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(\n    0,\n    256,\n    true\n    /* littleEndian */\n  );\n  return new Int16Array(buffer)[0] === 256;\n})();\n\n// node_modules/apache-arrow/ipc/message.mjs\nvar invalidMessageType = (type2) => `Expected ${MessageHeader[type2]} Message in stream, but was null or length 0.`;\nvar nullMessage = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader[type2]} Message is null or length 0.`;\nvar invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\nvar invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\nvar MessageReader = class {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    let r;\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    return (\n      /* 1. */\n      buf.byteOffset % 8 === 0 && /* 2. */\n      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n  readSchema(throwIfNull = false) {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb2 = buf && new ByteBuffer(buf);\n    const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n    return { done: len === 0, value: len };\n  }\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return { done: false, value: Message2.decode(buf) };\n  }\n};\nvar AsyncMessageReader = class {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {\n        return ITERATOR_DONE;\n      }\n      if ((r = yield this.readMetadata(r.value)).done) {\n        return ITERATOR_DONE;\n      }\n      return r;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.throw(value);\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.source.return(value);\n    });\n  }\n  readMessage(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r;\n      if ((r = yield this.next()).done) {\n        return null;\n      }\n      if (type2 != null && r.value.headerType !== type2) {\n        throw new Error(invalidMessageType(type2));\n      }\n      return r.value;\n    });\n  }\n  readMessageBody(bodyLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (bodyLength <= 0) {\n        return new Uint8Array(0);\n      }\n      const buf = toUint8Array(yield this.source.read(bodyLength));\n      if (buf.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n      }\n      return (\n        /* 1. */\n        buf.byteOffset % 8 === 0 && /* 2. */\n        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n      );\n    });\n  }\n  readSchema(throwIfNull = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type2 = MessageHeader.Schema;\n      const message = yield this.readMessage(type2);\n      const schema = message === null || message === void 0 ? void 0 : message.header();\n      if (throwIfNull && !schema) {\n        throw new Error(nullMessage(type2));\n      }\n      return schema;\n    });\n  }\n  readMetadataLength() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(PADDING);\n      const bb2 = buf && new ByteBuffer(buf);\n      const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;\n      return { done: len === 0, value: len };\n    });\n  }\n  readMetadata(metadataLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buf = yield this.source.read(metadataLength);\n      if (!buf) {\n        return ITERATOR_DONE;\n      }\n      if (buf.byteLength < metadataLength) {\n        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n      }\n      return { done: false, value: Message2.decode(buf) };\n    });\n  }\n};\nvar JSONMessageReader = class extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n  next() {\n    const { _json } = this;\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);\n      return { done: false, value: message };\n    }\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch[\"data\"][\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return { done: false, value: message };\n    }\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch[\"columns\"];\n      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);\n      return { done: false, value: message };\n    }\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column2) => [\n        ...buffers,\n        ...column2[\"VALIDITY\"] && [column2[\"VALIDITY\"]] || [],\n        ...column2[\"TYPE\"] && [column2[\"TYPE\"]] || [],\n        ...column2[\"OFFSET\"] && [column2[\"OFFSET\"]] || [],\n        ...column2[\"DATA\"] && [column2[\"DATA\"]] || [],\n        ...flattenDataSources(column2[\"children\"])\n      ], []);\n    }\n  }\n  readMessage(type2) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type2 != null && r.value.headerType !== type2) {\n      throw new Error(invalidMessageType(type2));\n    }\n    return r.value;\n  }\n  readSchema() {\n    const type2 = MessageHeader.Schema;\n    const message = this.readMessage(type2);\n    const schema = message === null || message === void 0 ? void 0 : message.header();\n    if (!message || !schema) {\n      throw new Error(nullMessage(type2));\n    }\n    return schema;\n  }\n};\nvar PADDING = 4;\nvar MAGIC_STR = \"ARROW1\";\nvar MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1) {\n  MAGIC[i] = MAGIC_STR.codePointAt(i);\n}\nfunction checkForMagicArrowString(buffer, index3 = 0) {\n  for (let i = -1, n = MAGIC.length; ++i < n; ) {\n    if (MAGIC[i] !== buffer[index3 + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nvar magicLength = MAGIC.length;\nvar magicAndPadding = magicLength + PADDING;\nvar magicX2AndPadding = magicLength * 2 + PADDING;\n\n// node_modules/apache-arrow/ipc/reader.mjs\nvar RecordBatchReader = class extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n  get closed() {\n    return this._impl.closed;\n  }\n  get schema() {\n    return this._impl.schema;\n  }\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n  isSync() {\n    return this._impl.isSync();\n  }\n  isAsync() {\n    return this._impl.isAsync();\n  }\n  isFile() {\n    return this._impl.isFile();\n  }\n  isStream() {\n    return this._impl.isStream();\n  }\n  next() {\n    return this._impl.next();\n  }\n  throw(value) {\n    return this._impl.throw(value);\n  }\n  return(value) {\n    return this._impl.return(value);\n  }\n  cancel() {\n    return this._impl.cancel();\n  }\n  reset(schema) {\n    this._impl.reset(schema);\n    this._DOMStream = void 0;\n    this._nodeStream = void 0;\n    return this;\n  }\n  open(options) {\n    const opening = this._impl.open(options);\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n  readRecordBatch(index3) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index3) : null;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n  toDOMStream() {\n    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });\n  }\n  toNodeStream() {\n    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (() => __awaiter(this, void 0, void 0, function* () {\n        return yield RecordBatchReader.from(yield source);\n      }))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n    return readAllAsync(source);\n  }\n};\nvar RecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    return [...this];\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return __asyncGenerator(this, arguments, function* _a5() {\n      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));\n    });\n  }\n};\nvar AsyncRecordBatchStreamReader = class extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    var e_1, _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const batches = new Array();\n      try {\n        for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {\n          const batch = _c2.value;\n          batches.push(batch);\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c2 && !_c2.done && (_a5 = _b2.return))\n            yield _a5.call(_b2);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      return batches;\n    });\n  }\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n};\nvar RecordBatchFileReader = class extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n};\nvar RecordBatchReaderImpl = class {\n  constructor(dictionaries = /* @__PURE__ */ new Map()) {\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n  isSync() {\n    return false;\n  }\n  isAsync() {\n    return false;\n  }\n  isFile() {\n    return false;\n  }\n  isStream() {\n    return false;\n  }\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = /* @__PURE__ */ new Map();\n    return this;\n  }\n  _loadRecordBatch(header, body) {\n    const children2 = this._loadVectors(header, body, this.schema.fields);\n    const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children: children2 });\n    return new RecordBatch(this.schema, data);\n  }\n  _loadDictionaryBatch(header, body) {\n    const { id: id2, isDelta } = header;\n    const { dictionaries, schema } = this;\n    const dictionary = dictionaries.get(id2);\n    if (isDelta || !dictionary) {\n      const type2 = schema.dictionaries.get(id2);\n      const data = this._loadVectors(header.data, body, [type2]);\n      return (dictionary && isDelta ? dictionary.concat(new Vector2(data)) : new Vector2(data)).memoize();\n    }\n    return dictionary.memoize();\n  }\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nvar RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n  isSync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n    return this;\n  }\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message;\n    const { _reader: reader } = this;\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return { done: false, value: recordBatch };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n    }\n    return this.return();\n  }\n  _readNextMessageAndValidate(type2) {\n    return this._reader.readMessage(type2);\n  }\n};\nvar AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n  isAsync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && (this.closed = true)) {\n        yield this.reset()._reader.return();\n        this._reader = null;\n        this.dictionaries = null;\n      }\n    });\n  }\n  open(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed) {\n        this.autoDestroy = shouldAutoDestroy(this, options);\n        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {\n          yield this.cancel();\n        }\n      }\n      return this;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.throw(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.return(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return ITERATOR_DONE;\n      }\n      let message;\n      const { _reader: reader } = this;\n      while (message = yield this._readNextMessageAndValidate()) {\n        if (message.isSchema()) {\n          yield this.reset(message.header());\n        } else if (message.isRecordBatch()) {\n          this._recordBatchIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return { done: false, value: recordBatch };\n        } else if (message.isDictionaryBatch()) {\n          this._dictionaryIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n      if (this.schema && this._recordBatchIndex === 0) {\n        this._recordBatchIndex++;\n        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n      }\n      return yield this.return();\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this._reader.readMessage(type2);\n    });\n  }\n};\nvar RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isSync() {\n    return true;\n  }\n  isFile() {\n    return true;\n  }\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n    return super.open(options);\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      this.open();\n    }\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const vector2 = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector2);\n      }\n    }\n  }\n  _readFooter() {\n    const { _handle } = this;\n    const offset2 = _handle.size - magicAndPadding;\n    const length4 = _handle.readInt32(offset2);\n    const buffer = _handle.readAt(offset2 - length4, length4);\n    return Footer_.decode(buffer);\n  }\n  _readNextMessageAndValidate(type2) {\n    var _a5;\n    if (!this._footer) {\n      this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type2);\n      }\n    }\n    return null;\n  }\n};\nvar AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source, ...rest) {\n    const byteLength = typeof rest[0] !== \"number\" ? rest.shift() : void 0;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isFile() {\n    return true;\n  }\n  isAsync() {\n    return true;\n  }\n  open(options) {\n    const _super = Object.create(null, {\n      open: { get: () => super.open }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && !this._footer) {\n        this.schema = (this._footer = yield this._readFooter()).schema;\n        for (const block of this._footer.dictionaryBatches()) {\n          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));\n        }\n      }\n      return yield _super.open.call(this, options);\n    });\n  }\n  readRecordBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return null;\n      }\n      if (!this._footer) {\n        yield this.open();\n      }\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);\n        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return recordBatch;\n        }\n      }\n      return null;\n    });\n  }\n  _readDictionaryBatch(index3) {\n    var _a5;\n    return __awaiter(this, void 0, void 0, function* () {\n      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index3);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);\n        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const vector2 = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector2);\n        }\n      }\n    });\n  }\n  _readFooter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const { _handle } = this;\n      _handle._pending && (yield _handle._pending);\n      const offset2 = _handle.size - magicAndPadding;\n      const length4 = yield _handle.readInt32(offset2);\n      const buffer = yield _handle.readAt(offset2 - length4, length4);\n      return Footer_.decode(buffer);\n    });\n  }\n  _readNextMessageAndValidate(type2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._footer) {\n        yield this.open();\n      }\n      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n        const block = this._footer.getRecordBatch(this._recordBatchIndex);\n        if (block && (yield this._handle.seek(block.offset))) {\n          return yield this._reader.readMessage(type2);\n        }\n      }\n      return null;\n    });\n  }\n};\nvar RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n};\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options[\"autoDestroy\"] === \"boolean\" ? options[\"autoDestroy\"] : self[\"autoDestroy\"];\n}\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n  try {\n    if (!reader.open({ autoDestroy: false }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\nfunction readAllAsync(source) {\n  return __asyncGenerator(this, arguments, function* readAllAsync_1() {\n    const reader = yield __await(RecordBatchReader.from(source));\n    try {\n      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {\n        do {\n          yield yield __await(reader);\n        } while (!(yield __await(reader.reset().open())).closed);\n      }\n    } finally {\n      yield __await(reader.cancel());\n    }\n  });\n}\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {\n  }()));\n}\nfunction fromAsyncByteStream(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const bytes = yield source.peek(magicLength + 7 & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {\n      return __asyncGenerator(this, arguments, function* () {\n      });\n    }()));\n  });\n}\nfunction fromFileHandle(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const { size } = yield source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n  });\n}\n\n// node_modules/apache-arrow/visitor/vectorassembler.mjs\nvar VectorAssembler = class extends Visitor {\n  constructor() {\n    super();\n    this._byteLength = 0;\n    this._nodes = [];\n    this._buffers = [];\n    this._bufferRegions = [];\n  }\n  /** @nocollapse */\n  static assemble(...args) {\n    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);\n    const assembler = new VectorAssembler();\n    assembler.visitMany(unwrap(args));\n    return assembler;\n  }\n  visit(data) {\n    if (data instanceof Vector2) {\n      this.visitMany(data.data);\n      return this;\n    }\n    const { type: type2 } = data;\n    if (!DataType.isDictionary(type2)) {\n      const { length: length4, nullCount } = data;\n      if (length4 > 2147483647) {\n        throw new RangeError(\"Cannot write arrays larger than 2^31 - 1 in length\");\n      }\n      if (!DataType.isNull(type2)) {\n        addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length4, data.nullBitmap));\n      }\n      this.nodes.push(new FieldNode2(length4, nullCount));\n    }\n    return super.visit(data);\n  }\n  visitNull(_null) {\n    return this;\n  }\n  visitDictionary(data) {\n    return this.visit(data.clone(data.type.indices));\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferRegions() {\n    return this._bufferRegions;\n  }\n};\nfunction addBuffer(values2) {\n  const byteLength = values2.byteLength + 7 & ~7;\n  this.buffers.push(values2);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\nfunction assembleUnion(data) {\n  const { type: type2, length: length4, typeIds, valueOffsets } = data;\n  addBuffer.call(this, typeIds);\n  if (type2.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, data);\n  } else if (type2.mode === UnionMode.Dense) {\n    if (data.offset <= 0) {\n      addBuffer.call(this, valueOffsets);\n      return assembleNestedVector.call(this, data);\n    } else {\n      const maxChildTypeId = typeIds.reduce((x4, y4) => Math.max(x4, y4), typeIds[0]);\n      const childLengths = new Int32Array(maxChildTypeId + 1);\n      const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      const shiftedOffsets = new Int32Array(length4);\n      const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets);\n      for (let typeId, shift, index3 = -1; ++index3 < length4; ) {\n        if ((shift = childOffsets[typeId = typeIds[index3]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index3] = unshiftedOffsets[index3] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      for (let child, childIndex = -1, numChildren = type2.children.length; ++childIndex < numChildren; ) {\n        if (child = data.children[childIndex]) {\n          const typeId = type2.typeIds[childIndex];\n          const childLength = Math.min(length4, childLengths[typeId]);\n          this.visit(child.slice(childOffsets[typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\nfunction assembleBoolVector(data) {\n  let values2;\n  if (data.nullCount >= data.length) {\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values2 = data.values) instanceof Uint8Array) {\n    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values2));\n  }\n  return addBuffer.call(this, packBools(data.values));\n}\nfunction assembleFlatVector(data) {\n  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\nfunction assembleFlatListVector(data) {\n  const { length: length4, values: values2, valueOffsets } = data;\n  const firstOffset = valueOffsets[0];\n  const lastOffset = valueOffsets[length4];\n  const byteLength = Math.min(lastOffset - firstOffset, values2.byteLength - firstOffset);\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length4, valueOffsets));\n  addBuffer.call(this, values2.subarray(firstOffset, firstOffset + byteLength));\n  return this;\n}\nfunction assembleListVector(data) {\n  const { length: length4, valueOffsets } = data;\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length4, valueOffsets));\n  }\n  return this.visit(data.children[0]);\n}\nfunction assembleNestedVector(data) {\n  return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n\n// node_modules/apache-arrow/ipc/writer.mjs\nvar RecordBatchWriter = class extends ReadableInterop {\n  constructor(options) {\n    super();\n    this._position = 0;\n    this._started = false;\n    this._sink = new AsyncByteQueue();\n    this._schema = null;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    isObject2(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });\n    this._autoDestroy = typeof options.autoDestroy === \"boolean\" ? options.autoDestroy : true;\n    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === \"boolean\" ? options.writeLegacyIpcFormat : false;\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(writableStrategy, readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  toString(sync = false) {\n    return this._sink.toString(sync);\n  }\n  toUint8Array(sync = false) {\n    return this._sink.toUint8Array(sync);\n  }\n  writeAll(input) {\n    if (isPromise(input)) {\n      return input.then((x4) => this.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(this, input);\n    }\n    return writeAll(this, input);\n  }\n  get closed() {\n    return this._sink.closed;\n  }\n  [Symbol.asyncIterator]() {\n    return this._sink[Symbol.asyncIterator]();\n  }\n  toDOMStream(options) {\n    return this._sink.toDOMStream(options);\n  }\n  toNodeStream(options) {\n    return this._sink.toNodeStream(options);\n  }\n  close() {\n    return this.reset()._sink.close();\n  }\n  abort(reason) {\n    return this.reset()._sink.abort(reason);\n  }\n  finish() {\n    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);\n    return this;\n  }\n  reset(sink = this._sink, schema = null) {\n    if (sink === this._sink || sink instanceof AsyncByteQueue) {\n      this._sink = sink;\n    } else {\n      this._sink = new AsyncByteQueue();\n      if (sink && isWritableDOMStream(sink)) {\n        this.toDOMStream({ type: \"bytes\" }).pipeTo(sink);\n      } else if (sink && isWritableNodeStream(sink)) {\n        this.toNodeStream({ objectMode: false }).pipe(sink);\n      }\n    }\n    if (this._started && this._schema) {\n      this._writeFooter(this._schema);\n    }\n    this._started = false;\n    this._dictionaryBlocks = [];\n    this._recordBatchBlocks = [];\n    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();\n    if (!schema || !compareSchemas(schema, this._schema)) {\n      if (schema == null) {\n        this._position = 0;\n        this._schema = null;\n      } else {\n        this._started = true;\n        this._schema = schema;\n        this._writeSchema(schema);\n      }\n    }\n    return this;\n  }\n  write(payload) {\n    let schema = null;\n    if (!this._sink) {\n      throw new Error(`RecordBatchWriter is closed`);\n    } else if (payload == null) {\n      return this.finish() && void 0;\n    } else if (payload instanceof Table && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {\n      return this.finish() && void 0;\n    }\n    if (schema && !compareSchemas(schema, this._schema)) {\n      if (this._started && this._autoDestroy) {\n        return this.close();\n      }\n      this.reset(this._sink, schema);\n    }\n    if (payload instanceof RecordBatch) {\n      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {\n        this._writeRecordBatch(payload);\n      }\n    } else if (payload instanceof Table) {\n      this.writeAll(payload.batches);\n    } else if (isIterable2(payload)) {\n      this.writeAll(payload);\n    }\n  }\n  _writeMessage(message, alignment = 8) {\n    const a4 = alignment - 1;\n    const buffer = Message2.encode(message);\n    const flatbufferSize = buffer.byteLength;\n    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;\n    const alignedSize = flatbufferSize + prefixSize + a4 & ~a4;\n    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;\n    if (message.headerType === MessageHeader.RecordBatch) {\n      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    } else if (message.headerType === MessageHeader.DictionaryBatch) {\n      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n    }\n    if (!this._writeLegacyIpcFormat) {\n      this._write(Int32Array.of(-1));\n    }\n    this._write(Int32Array.of(alignedSize - prefixSize));\n    if (flatbufferSize > 0) {\n      this._write(buffer);\n    }\n    return this._writePadding(nPaddingBytes);\n  }\n  _write(chunk) {\n    if (this._started) {\n      const buffer = toUint8Array(chunk);\n      if (buffer && buffer.byteLength > 0) {\n        this._sink.write(buffer);\n        this._position += buffer.byteLength;\n      }\n    }\n    return this;\n  }\n  _writeSchema(schema) {\n    return this._writeMessage(Message2.from(schema));\n  }\n  // @ts-ignore\n  _writeFooter(schema) {\n    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));\n  }\n  _writeMagic() {\n    return this._write(MAGIC);\n  }\n  _writePadding(nBytes) {\n    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;\n  }\n  _writeRecordBatch(batch) {\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);\n    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);\n    const message = Message2.from(recordBatch, byteLength);\n    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeDictionaryBatch(dictionary, id2, isDelta = false) {\n    this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));\n    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector2([dictionary]));\n    const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);\n    const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);\n    const message = Message2.from(dictionaryBatch, byteLength);\n    return this._writeMessage(message)._writeBodyBuffers(buffers);\n  }\n  _writeBodyBuffers(buffers) {\n    let buffer;\n    let size, padding;\n    for (let i = -1, n = buffers.length; ++i < n; ) {\n      if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {\n        this._write(buffer);\n        if ((padding = (size + 7 & ~7) - size) > 0) {\n          this._writePadding(padding);\n        }\n      }\n    }\n    return this;\n  }\n  _writeDictionaries(batch) {\n    for (let [id2, dictionary] of batch.dictionaries) {\n      let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;\n      if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {\n        for (const data of dictionary.data) {\n          this._writeDictionaryBatch(data, id2, offset2 > 0);\n          offset2 += data.length;\n        }\n      }\n    }\n    return this;\n  }\n};\nvar RecordBatchStreamWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input, options) {\n    const writer = new RecordBatchStreamWriter(options);\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n};\nvar RecordBatchFileWriter = class extends RecordBatchWriter {\n  /** @nocollapse */\n  static writeAll(input) {\n    const writer = new RecordBatchFileWriter();\n    if (isPromise(input)) {\n      return input.then((x4) => writer.writeAll(x4));\n    } else if (isAsyncIterable(input)) {\n      return writeAllAsync(writer, input);\n    }\n    return writeAll(writer, input);\n  }\n  constructor() {\n    super();\n    this._autoDestroy = true;\n  }\n  // @ts-ignore\n  _writeSchema(schema) {\n    return this._writeMagic()._writePadding(2);\n  }\n  _writeFooter(schema) {\n    const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));\n    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();\n  }\n};\nfunction writeAll(writer, input) {\n  let chunks = input;\n  if (input instanceof Table) {\n    chunks = input.batches;\n    writer.reset(void 0, input.schema);\n  }\n  for (const batch of chunks) {\n    writer.write(batch);\n  }\n  return writer.finish();\n}\nfunction writeAllAsync(writer, batches) {\n  var batches_1, batches_1_1;\n  var e_1, _a5;\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      for (batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done; ) {\n        const batch = batches_1_1.value;\n        writer.write(batch);\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (batches_1_1 && !batches_1_1.done && (_a5 = batches_1.return))\n          yield _a5.call(batches_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    return writer.finish();\n  });\n}\n\n// node_modules/apache-arrow/io/whatwg/iterable.mjs\nfunction toDOMStream(source, options) {\n  if (isAsyncIterable(source)) {\n    return asyncIterableAsReadableDOMStream(source, options);\n  }\n  if (isIterable2(source)) {\n    return iterableAsReadableDOMStream(source, options);\n  }\n  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);\n}\nfunction iterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      next(controller, it || (it = source[Symbol.iterator]()));\n    },\n    pull(controller) {\n      it ? next(controller, it) : controller.close();\n    },\n    cancel() {\n      ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    let buf;\n    let r = null;\n    let size = controller.desiredSize || null;\n    while (!(r = it2.next(bm ? size : null)).done) {\n      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n        size != null && bm && (size = size - buf.byteLength + 1);\n        r.value = buf;\n      }\n      controller.enqueue(r.value);\n      if (size != null && --size <= 0) {\n        return;\n      }\n    }\n    controller.close();\n  }\n}\nfunction asyncIterableAsReadableDOMStream(source, options) {\n  let it = null;\n  const bm = (options === null || options === void 0 ? void 0 : options.type) === \"bytes\" || false;\n  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);\n  return new ReadableStream(Object.assign(Object.assign({}, options), {\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, it || (it = source[Symbol.asyncIterator]()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        it ? yield next(controller, it) : controller.close();\n      });\n    },\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);\n      });\n    }\n  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));\n  function next(controller, it2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf;\n      let r = null;\n      let size = controller.desiredSize || null;\n      while (!(r = yield it2.next(bm ? size : null)).done) {\n        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {\n          size != null && bm && (size = size - buf.byteLength + 1);\n          r.value = buf;\n        }\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/builder.mjs\nfunction builderThroughDOMStream(options) {\n  return new BuilderTransform(options);\n}\nvar BuilderTransform = class {\n  constructor(options) {\n    this._numChunks = 0;\n    this._finished = false;\n    this._bufferedSize = 0;\n    const { [\"readableStrategy\"]: readableStrategy, [\"writableStrategy\"]: writableStrategy, [\"queueingStrategy\"]: queueingStrategy = \"count\" } = options, builderOptions = __rest(options, [\"readableStrategy\", \"writableStrategy\", \"queueingStrategy\"]);\n    this._controller = null;\n    this._builder = makeBuilder(builderOptions);\n    this._getSize = queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength;\n    const { [\"highWaterMark\"]: readableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);\n    const { [\"highWaterMark\"]: writableHighWaterMark = queueingStrategy === \"bytes\" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);\n    this[\"readable\"] = new ReadableStream({\n      [\"cancel\"]: () => {\n        this._builder.clear();\n      },\n      [\"pull\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      },\n      [\"start\"]: (c6) => {\n        this._maybeFlush(this._builder, this._controller = c6);\n      }\n    }, {\n      \"highWaterMark\": readableHighWaterMark,\n      \"size\": queueingStrategy !== \"bytes\" ? chunkLength : chunkByteLength\n    });\n    this[\"writable\"] = new WritableStream({\n      [\"abort\"]: () => {\n        this._builder.clear();\n      },\n      [\"write\"]: () => {\n        this._maybeFlush(this._builder, this._controller);\n      },\n      [\"close\"]: () => {\n        this._maybeFlush(this._builder.finish(), this._controller);\n      }\n    }, {\n      \"highWaterMark\": writableHighWaterMark,\n      \"size\": (value) => this._writeValueAndReturnChunkSize(value)\n    });\n  }\n  _writeValueAndReturnChunkSize(value) {\n    const bufferedSize = this._bufferedSize;\n    this._bufferedSize = this._getSize(this._builder.append(value));\n    return this._bufferedSize - bufferedSize;\n  }\n  _maybeFlush(builder, controller) {\n    if (controller == null) {\n      return;\n    }\n    if (this._bufferedSize >= controller.desiredSize) {\n      ++this._numChunks && this._enqueue(controller, builder.toVector());\n    }\n    if (builder.finished) {\n      if (builder.length > 0 || this._numChunks === 0) {\n        ++this._numChunks && this._enqueue(controller, builder.toVector());\n      }\n      if (!this._finished && (this._finished = true)) {\n        this._enqueue(controller, null);\n      }\n    }\n  }\n  _enqueue(controller, chunk) {\n    this._bufferedSize = 0;\n    this._controller = null;\n    chunk == null ? controller.close() : controller.enqueue(chunk);\n  }\n};\nvar chunkLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;\n};\nvar chunkByteLength = (chunk) => {\n  var _a5;\n  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;\n};\n\n// node_modules/apache-arrow/io/whatwg/reader.mjs\nfunction recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {\n  const queue = new AsyncByteQueue();\n  let reader = null;\n  const readable = new ReadableStream({\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield queue.close();\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller, reader || (reader = yield open()));\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        reader ? yield next(controller, reader) : controller.close();\n      });\n    }\n  });\n  return { writable: new WritableStream(queue, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, writableStrategy)), readable };\n  function open() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);\n    });\n  }\n  function next(controller, reader2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let size = controller.desiredSize;\n      let r = null;\n      while (!(r = yield reader2.next()).done) {\n        controller.enqueue(r.value);\n        if (size != null && --size <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/io/whatwg/writer.mjs\nfunction recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {\n  const writer = new this(writableStrategy);\n  const reader = new AsyncByteStream(writer);\n  const readable = new ReadableStream({\n    // type: 'bytes',\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield reader.cancel();\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    }\n  }, Object.assign({ \"highWaterMark\": Math.pow(2, 14) }, readableStrategy));\n  return { writable: new WritableStream(writer, writableStrategy), readable };\n  function next(controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf = null;\n      let size = controller.desiredSize;\n      while (buf = yield reader.read(size || null)) {\n        controller.enqueue(buf);\n        if (size != null && (size -= buf.byteLength) <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}\n\n// node_modules/apache-arrow/ipc/serialization.mjs\nfunction tableFromIPC(input) {\n  const reader = RecordBatchReader.from(input);\n  if (isPromise(reader)) {\n    return reader.then((reader2) => tableFromIPC(reader2));\n  }\n  if (reader.isAsync()) {\n    return reader.readAll().then((xs) => new Table(xs));\n  }\n  return new Table(reader.readAll());\n}\n\n// node_modules/apache-arrow/Arrow.mjs\nvar util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {\n  compareSchemas,\n  compareFields,\n  compareTypes\n});\n\n// node_modules/apache-arrow/Arrow.dom.mjs\nadapters_default.toDOMStream = toDOMStream;\nBuilder[\"throughDOM\"] = builderThroughDOMStream;\nRecordBatchReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchFileReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchStreamReader[\"throughDOM\"] = recordBatchReaderThroughDOMStream;\nRecordBatchWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchFileWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\nRecordBatchStreamWriter[\"throughDOM\"] = recordBatchWriterThroughDOMStream;\n\n// js/parsing.js\nfunction parse_spec(code, data) {\n  if (code === null) {\n    return null;\n  }\n  if (Array.isArray(code)) {\n    return code.map((d) => parse_spec(d, data));\n  }\n  if (typeof code === \"string\" || code instanceof String) {\n    return code;\n  }\n  if (Object.entries(code).length == 0) {\n    return code;\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame\") {\n    return tableFromIPC(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"DataFrame-ref\") {\n    return tableFromIPC(data[code[\"value\"]]);\n  }\n  if (code[\"pyobsplot-type\"] == \"function\") {\n    let fun = get_fun(code[\"module\"], code[\"method\"]);\n    return fun.call(null, ...parse_spec(code[\"args\"], data));\n  }\n  if (code[\"pyobsplot-type\"] == \"function-object\") {\n    return get_fun(code[\"module\"], code[\"method\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"js\") {\n    let indirect_eval = eval;\n    return indirect_eval(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"datetime\") {\n    return new Date(code[\"value\"]);\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson\") {\n    return code[\"value\"];\n  }\n  if (code[\"pyobsplot-type\"] == \"GeoJson-ref\") {\n    return data[code[\"value\"]];\n  }\n  let ret = {};\n  for (const [key, value] of Object.entries(code)) {\n    ret[key] = parse_spec(value, data);\n  }\n  return ret;\n}\nfunction get_fun(mod, method) {\n  let fun;\n  switch (mod) {\n    case \"Plot\":\n      fun = dist_exports[method];\n      break;\n    case \"d3\":\n      fun = src_exports[method];\n      break;\n    case \"Math\":\n      fun = Math[method];\n      break;\n    default:\n      throw new Error(`Invalid module: ${mod}`);\n  }\n  if (fun === void 0) {\n    throw new Error(`${mod}.${method} is not defined`);\n  }\n  return fun;\n}\n\n// js/index.js\nfunction render(view) {\n  let spec = () => view.model.get(\"spec\");\n  view.el.appendChild(generate_plot(spec()));\n  view.model.on(\"change:spec\", () => _onValueChanged(view, view.el));\n}\nfunction generate_plot(spec) {\n  let plot2 = document.createElement(\"div\");\n  plot2.classList.add(\"pyobsplot-plot\");\n  let out;\n  try {\n    out = parse_spec(spec[\"code\"], spec[\"data\"]);\n    if (spec[\"code\"][\"pyobsplot-type\"] == \"function\") {\n      if (!(out instanceof Element)) {\n        out = out.plot();\n      }\n    } else {\n      out = plot(out);\n    }\n  } catch (error) {\n    out = document.createElement(\"pre\");\n    out.classList.add(\"pyobsplot-error\");\n    out.textContent = error;\n  }\n  plot2.appendChild(out);\n  return plot2;\n}\nfunction _onValueChanged(view, el) {\n  let plot2 = el.querySelector(\".pyobsplot-plot\");\n  el.removeChild(plot2);\n  let spec = () => view.model.get(\"spec\");\n  el.appendChild(generate_plot(spec()));\n}\nexport {\n  render\n};\n","_model_module":"anywidget","_model_module_version":"0.2.0","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"0.2.0","_view_name":"AnyView","layout":"IPY_MODEL_6054fd49907944938fa8b10e2a74a9c9","spec":{"code":{"grid":true,"marks":[{"args":[{"pyobsplot-type":"DataFrame-ref","value":0},{"fill":"type","r":5,"x":"x","y":"y"}],"method":"dot","module":"Plot","pyobsplot-type":"function"}]},"data":[null]},"tabbable":null,"tooltip":null}},"c296008f5ec44c789ffab6488a81c437":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>